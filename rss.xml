<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>STEMHA&#39;s Blog</title>
  
  <subtitle>People have dream!</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="https://stemha.github.io/"/>
  <updated>2020-05-08T13:36:30.296Z</updated>
  <id>https://stemha.github.io/</id>
  
  <author>
    <name>STEMHA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++特性及优缺点</title>
    <link href="https://stemha.github.io/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>https://stemha.github.io/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</id>
    <published>2020-05-08T13:03:43.000Z</published>
    <updated>2020-05-08T13:36:30.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-语言优缺点"><a href="#C-语言优缺点" class="headerlink" title="C++语言优缺点"></a><strong>C++语言优缺点</strong></h2><a id="more"></a><p><strong>优点</strong></p><ul><li>兼容性好，C++在保持了C语言简洁高效的特点的同时，还对C的类型系统进行改革性扩充，相比C语言，C++更安全，其编译系统也能检查出更多错误类型。</li><li>面向对象编程能力，可复用性好，可以让团队衍化出自己的的类库。</li><li>性能优势，程序效率高。</li></ul><p><strong>缺点</strong></p><ul><li>C++ 是 C 语言的一个超集，既有指针又有对象使它成为最复杂的语言，学习难度大。过分的精细和复杂了。C++的复杂度，超过了C和OO（面向对象）的复杂度之和</li><li>没有垃圾回收机制。</li></ul><p>C++本质上说是提前编译的，Fortran也是。C#和Java大多时候是编译成字节码，运行的时候再 即使编译。Python和Ruby通常是解释型。这就产生了一个性能的分级：C++和Fortran比Java和C#快，Java和C#又比Python 和Ruby快。<br><a href="http://www.ruanyifeng.com/blog/2010/03/programming_language_evaluations_revised.html">几种计算机语言的评价（修订版）</a><br><a href="https://www.kawabangga.com/posts/582">为什么一些语言会比别的快？</a></p><h2 id="C-特性"><a href="#C-特性" class="headerlink" title="C++特性"></a><strong>C++特性</strong></h2><p>C++面向对象的三个基本特征：封装、继承、多态。它们的目的都是为了——<strong>代码重用</strong>。而多态则是为了实现另一个目的——<strong>接口重用</strong><br>在 C++ 中，用类进行封装（数据抽象），用类派生从一个类继承另一个：派生类继承基类的成员。<br>多态（动态绑定）使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数<br>继承和多态（动态绑定）在两个方面简化了我们的程序：能够容易地定义与其他类相似但又不相同的新类，能够更容易地编写忽略这些相似类型之间区别的程序。</p><h3 id="封装（encapsulation）"><a href="#封装（encapsulation）" class="headerlink" title="封装（encapsulation）"></a><strong>封装（encapsulation）</strong></h3><p><code>封装</code>是一项低层次的元素组合起来的形成新的、高层次实体的技术。</p><ul><li><code>函数</code>是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。</li><li><code>类</code>也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。</li></ul><p>目的：</p><ul><li>将抽象得到的数据和行为相结合，形成一个有机的整体（结合性）</li><li>将对象的使用者和设计者分开，以提高软件的可维护性和可修改性</li><li>实现代码重用</li></ul><h3 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a><strong>继承（inheritance）</strong></h3><p>继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><ul><li>通过继承关联起来的类型都共享共同的接口。当一个类继承另一个类时，这两个类通常可以使用相同的操作。更确切地说，如果两种类型存在继承关系，则可以说一个类“继承”了其父类的行为——接口。</li><li>C++ 中所提及的父类称为<code>基类（base class）</code>，而继承而来的类则称为<code>派生类（derived class）</code>。</li></ul><h3 id="多态（polymorphism）"><a href="#多态（polymorphism）" class="headerlink" title="多态（polymorphism）"></a><strong>多态（polymorphism）</strong></h3><p>多态：多态的基础是继承。多态下，子类重写父类的方法，实际使用过程中，用父类引用变量指向子类对象，此时父类引用调用的是子类重写后的方法，由于是父类引用变量，所有无法调用子类特有的方法。如果想调用子类特有的方法，必须强制类型转换到子类。<br>多态性派生于一个希腊单词，意思是“许多形态”。之所以称<u>通过继承而相关联的类型为</u><code>多态类型</code>，是因为在许多情况下可以互换地使用派生类型或基类型的“许多形态”。在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。<br>多态性：指的是<strong>基于引用或指针的动态类型获得类型明确的行为的能力</strong>。</p><ul><li>在C++中的主要表现是动态多态（动态绑定）</li><li>动态多态（动态绑定）：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。</li><li>在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。</li><li>引用和指针的静态类型与动态类型可以不同，这是 C++ 用以支持多态性的基石。</li></ul><h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a><strong>静态多态（编译期/早绑定）</strong></h4><p><code>template（模板）</code>：静态多态（编译时完成，效率高，适配性高，松耦合性），隐形接口<br><code>overload（重载）</code>：静态多态</p><ol><li>同名函数，不同参数/函数返回值</li><li>相同范围，同一个类中</li></ol><p><code>overwrite（重写）</code>：静态多态，子类屏蔽父类的同名基函数</p><ol><li>同名同参，无virtual</li><li>同名不同参</li></ol><h4 id="动态多态（运行期-晚绑定）"><a href="#动态多态（运行期-晚绑定）" class="headerlink" title="动态多态（运行期/晚绑定）"></a><strong>动态多态（运行期/晚绑定）</strong></h4><p><code>override（覆盖重写）</code>：动态多态（运行时完成，接口重用，编译器无法优化）</p><ol><li>不同类中</li><li>同名，同参</li><li>基类函数有virtual</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>[1]C++ primer 第四版<br>[2]<a href="http://www.ruanyifeng.com/blog/2010/03/programming_language_evaluations_revised.html">几种计算机语言的评价（修订版）</a><br>[3]<a href="https://www.kawabangga.com/posts/582">为什么一些语言会比别的快？</a><br>[4]<a href="https://blog.csdn.net/Chuwei_xu/article/details/89321191">C++ 特性及类（面试复习整理）</a><br>[5]<a href="https://www.runoob.com/cplusplus/cpp-polymorphism.html">C++ 多态-菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-语言优缺点&quot;&gt;&lt;a href=&quot;#C-语言优缺点&quot; class=&quot;headerlink&quot; title=&quot;C++语言优缺点&quot;&gt;&lt;/a&gt;&lt;strong&gt;C++语言优缺点&lt;/strong&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://stemha.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://stemha.github.io/tags/C/"/>
    
      <category term="封装" scheme="https://stemha.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="继承" scheme="https://stemha.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="多态" scheme="https://stemha.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="静态多态" scheme="https://stemha.github.io/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"/>
    
      <category term="动态多态" scheme="https://stemha.github.io/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>C++内存分配与内存划分</title>
    <link href="https://stemha.github.io/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <id>https://stemha.github.io/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</id>
    <published>2020-05-07T17:46:47.000Z</published>
    <updated>2020-05-08T07:12:29.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-内存使用划分"><a href="#C-C-内存使用划分" class="headerlink" title="C/C++内存使用划分"></a><strong>C/C++内存使用划分</strong></h2><p>C/C++编译过的程序使用的内存划分：</p><a id="more"></a><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a><strong>栈区</strong></h3><ul><li>是连续的内存区域。</li><li>由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。</li><li>栈区的变量通常是局部变量、函数参数等。 </li><li>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>每次程序运行都会分配一个栈，<strong>main函数就在栈底</strong>，然后通过不同函数的调用顺序，依次进栈出栈。<br><a href="https://zhidao.baidu.com/question/397221561.html">c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗</a><h3 id="堆区（动态内存分配）"><a href="#堆区（动态内存分配）" class="headerlink" title="堆区（动态内存分配）"></a><strong>堆区（动态内存分配）</strong></h3></li><li>是不连续的内存区域。</li></ul><p><code>自由存储区或堆</code>：每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。<br>C 语言程序使用一对标准库函数malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和delete 表达式实现相同的功能。可以手动释放或者程序结束自动释放存储空间。<br><strong>优点</strong>：动态内存的生存期人为决定，使用灵活。<br><strong>缺点</strong>：是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。<br>若程序员不释放，程序结束时可能由OS（操作系统）回收。<br>注意它与数据结构中的堆是两回事，分配方式类似于链表。</p><h3 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a><strong>全局/静态存储区</strong></h3><p>全局变量和静态变量的存储是放在一起。C语言中，全局变量又分为初始化的和未初始化的。C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统释放。</p><h3 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a><strong>常量存储区</strong></h3><p>这是一个比较特殊的存储区，里面存放的是常量，不允许修改。程序结束后由系统释放。</p><h3 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a><strong>程序代码区</strong></h3><p>存放函数的二进制代码。</p><h2 id="堆存储-栈存储"><a href="#堆存储-栈存储" class="headerlink" title="堆存储/栈存储"></a><strong>堆存储/栈存储</strong></h2><h3 id="对象是存放在堆中还是栈中"><a href="#对象是存放在堆中还是栈中" class="headerlink" title="对象是存放在堆中还是栈中"></a><strong>对象是存放在堆中还是栈中</strong></h3><p>要看怎么去构造这个对象：</p><ul><li>如果用new来生成的对象,是放在堆中的。</li><li>直接定义的局部变量内都是放在栈中的，全局和静态的对象（包括类的静态数据成员）是放在数据段的静态存储区</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Test；</span><br><span class="line">Test p;            <span class="comment">//栈上分配内存</span></span><br><span class="line">Test* tTest；      <span class="comment">//指针在栈中</span></span><br><span class="line">tTest = <span class="keyword">new</span> Test;，<span class="comment">//new的在堆中</span></span><br></pre></td></tr></table></figure><h3 id="堆存储"><a href="#堆存储" class="headerlink" title="堆存储"></a><strong>堆存储</strong></h3><ul><li>因为没有专门的系统支持，效率很低；</li><li>可能引发用户态和核心态的切换，内存的申请代价变得更加昂贵。</li><li>操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序</li><li>大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。</li><li>因为找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul><h3 id="栈存储"><a href="#栈存储" class="headerlink" title="栈存储"></a><strong>栈存储</strong></h3><ul><li>用于存储占用空间小，生命周期短的数据（局部变量/参数变量等）</li><li>若栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出</li></ul><p>出现<code>栈内存溢出</code>的常见原因有2个：</p><ol><li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li><li>局部变量体积太大。</li></ol><h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a><strong>地址分配</strong></h3><ul><li>堆，往下增长，向内存地址增加的方向增长</li><li>栈，往上增长，向内存地址减小的方向增长（对于小端存储，高位字节在高端地址、低位字节在低位地址，因此在压栈时先压高字节后压低字节）</li><li>可能会发生堆栈冲突(从堆中分配内存失败或者爆栈)</li><li>大端存储：数据高位在内存低位，低位在内存高位（如Freescale的PowerPC处理器）</li><li>小端存储：数据高位在内存高位，低位在内存低位（Intel的芯片一般是小端存储）</li></ul><h3 id="分配效率"><a href="#分配效率" class="headerlink" title="分配效率"></a><strong>分配效率</strong></h3><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</p><p>堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p><a href="https://www.cnblogs.com/yunlambert/p/10053800.html">堆、栈与大小端存储</a></p><h2 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a><strong>数据存放</strong></h2><p>基本数据类型：</p><ul><li>直接存储在<strong>栈(stack)</strong>中的数据。（字符串、布尔值、未定义、数字、null）</li><li>null只是一个空指针对象，没有数据。</li></ul><p>引用类型：</p><ul><li>将该对象引用地址存储在<strong>栈(stack)</strong>中，然后对象里面的数据存放在<strong>堆</strong>中。（数组、对象、函数）</li><li>存储的是该对象在栈中的引用，真实的数据存放在堆内存里</li><li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a><strong>深拷贝与浅拷贝</strong></h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h3><p><strong>既复制对象空间又复制资源</strong><br>在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。<br>当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值，然后同步复拷贝开辟空间的值。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><p><strong>只复制对象空间而不复制资源</strong> </p><ul><li>如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。<code>default memberwise copy</code>即称为<code>浅拷贝</code>。</li><li>即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)</li><li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</li><li>如果属性是基本类型，拷贝的就是基本类型的值；</li><li>如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</li></ul><h2 id="C-C-内存分配的三种方式"><a href="#C-C-内存分配的三种方式" class="headerlink" title="C/C++内存分配的三种方式"></a><strong>C/C++内存分配的三种方式</strong></h2><ol><li>静态存储区分配<br>内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。</li><li>栈上分配<br>在函数执行时，函数内的局部变量的存储单元在栈上创建，由操作系统自动分配，函数调用结束时内存也随之析构<br>栈内存分配运算内置于处理器的指令集中，效率高，但栈容量小。</li><li>堆上分配<br>堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放,在整个程序运行周期内都存在。</li></ol><p><strong>tips:</strong></p><ul><li>申请内存后立即判断指针是否为NULL确定内存是否分配成功，如果为NULL则立即用return终止此函数，或者用exit（1）终止整个程序的运行，为new和malloc设置异常处理函数；</li><li><strong>为申请的内存赋初值</strong>，分配的是一段连续的内存空间的话，要防止指针下标越界；</li><li>sizeof是操作符，不能用sizeof得到内存空间的大小，<strong>只能在申请时候记住申请的空间大小</strong>；</li><li>在内存使用结束后必须用free或delete释放内存，注意在内存使用中如果存在指针加1或减1 的操作应特别注意，释放的内存要和申请的内存一致，放置内存泄漏，<strong>释放内存后，应该立即将指针置为NULL，不要存在野指针</strong>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]<a href="https://segmentfault.com/a/1190000018874254">浅拷贝与深拷贝的区别</a><br>[2]<a href="https://blog.csdn.net/nyist_zxp/article/details/80257760">C++中数据存储的位置</a><br>[3]<a href="https://blog.csdn.net/lq18811566072/article/details/80331793">C++经典面试之 内存分配的三种方式</a><br>[4]<a href="https://www.cnblogs.com/yunlambert/p/10053800.html">堆、栈与大小端存储</a><br>[5]<a href="https://zhidao.baidu.com/question/397221561.html">c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-C-内存使用划分&quot;&gt;&lt;a href=&quot;#C-C-内存使用划分&quot; class=&quot;headerlink&quot; title=&quot;C/C++内存使用划分&quot;&gt;&lt;/a&gt;&lt;strong&gt;C/C++内存使用划分&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;C/C++编译过的程序使用的内存划分：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://stemha.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://stemha.github.io/tags/C/"/>
    
      <category term="内存分配" scheme="https://stemha.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="内存分区" scheme="https://stemha.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    
      <category term="深拷贝" scheme="https://stemha.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="https://stemha.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>文件系统（1）</title>
    <link href="https://stemha.github.io/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/"/>
    <id>https://stemha.github.io/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/</id>
    <published>2020-05-01T15:00:41.000Z</published>
    <updated>2020-05-01T16:00:41.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><code>文件系统</code>：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容</p><a id="more"></a><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件可以有多种构造方式。</p><ul><li>字节序列（Windows，UNIX都采用这种文件模型）</li><li>记录序列（以前大型计算机系统中的常见模式，现在没多少了）</li><li>树（处理商业数据的大型计算机中获得广泛使用）<ul><li>文件在这种结构中由一棵记录树构成，每个记录并不具有同样长度，记录的固定位置有一个键。树按键排序，从而对特定的键进行快速查找</li></ul></li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Linux中分为    </p><ol><li>普通文件（regular）：存在于外部存储器中，用于存储普通文件。</li><li>目录文件（directory）：用于存放目录项，是文件系统管理的重要文件类型。</li><li>管道文件（pipe）：一种用于进程间通信的特殊文件，也称为命名管道FIFO。</li><li>套接字文件（socket）：一种用于网络间通信的特殊文件。</li><li>链接文件（link）；用于间接访问另外一个目标文件，相当于widows快捷方式。</li><li>字符设备文件（character）:字符设备在应用层的访问结构。</li><li>块设备文件（block）：块设备在应用层的访问接口。</li></ol><h3 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h3><ul><li>顺序存取文件（sequential access）：进程可以从头到尾顺序读取文件的全部字节或者记录，但不能跳过某一些内容，也不能不按顺序读取。可以返回到起点的。</li><li>随机存取文件（random access）：以任何次序读取其中字节或记录的文件。对很多应用程序来说是必不可少的，比如数据库系统</li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>操作系统常用的文件属性</p><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><table><thead><tr><th align="left">属性</th><th align="left">含义</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">保护</td><td align="left">谁可以存取文件，以什么方式</td><td align="left"></td></tr><tr><td align="left">口令</td><td align="left">存取文件需要的口令</td><td align="left">有一些系统中，用户必须给出口令才能存取文件</td></tr><tr><td align="left">创建者</td><td align="left">创建文件者ID</td><td align="left"></td></tr><tr><td align="left">所有者</td><td align="left">当前所有者</td><td align="left"></td></tr></tbody></table><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><table><thead><tr><th align="left">属性</th><th align="left">含义</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">只读标志</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">隐藏标志</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">系统标志</td><td align="left">0表普通文件，1表示系统文件</td><td align="left"></td></tr><tr><td align="left">存档标志</td><td align="left">0表示已经备份，1表示需要备份</td><td align="left"></td></tr><tr><td align="left">ASCII/二进制标志</td><td align="left">0表示ASCII文件，1表示二进制文件</td><td align="left"></td></tr><tr><td align="left">随机存取标志</td><td align="left">0表示只允许顺序存取，1表示随机存取</td><td align="left"></td></tr><tr><td align="left">临时标志</td><td align="left">0表示正常，1表示进程退出时删除文件</td><td align="left"></td></tr><tr><td align="left">加锁标志</td><td align="left">0表示未加锁，非零表示加锁</td><td align="left"></td></tr></tbody></table><h4 id="查找读写相关"><a href="#查找读写相关" class="headerlink" title="查找读写相关"></a>查找读写相关</h4><table><thead><tr><th align="left">属性</th><th align="left">含义</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">记录长度</td><td align="left">一个记录中的字节数</td><td align="left"></td></tr><tr><td align="left">键的位置</td><td align="left">每个记录中键的偏移量</td><td align="left"></td></tr><tr><td align="left">键的长度</td><td align="left">键字段的字节数</td><td align="left"></td></tr><tr><td align="left">当前大小</td><td align="left">文件字节数</td><td align="left"></td></tr><tr><td align="left">最大长度</td><td align="left">文件可能增长到的字节数</td><td align="left"></td></tr></tbody></table><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><table><thead><tr><th align="left">属性</th><th align="left">含义</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">创建时间</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">最后一次存取时间</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">最后一次修改时间</td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>最常用的一些系统调用（不限制系统的总结）</p><ol><li>create</li><li>delete</li><li>open</li><li>close</li><li>read</li><li>write</li><li>append：write的限制形式，智能在文件末尾读取数据</li><li>seek：对于随机存取文件，通常需要指定从何处读取数据，通常使用seek系统调用把当前位置指针指向文件中的特定位置。seek调用结束后，就可以从该位置开始读了。</li><li>get attributes</li><li>set attributes</li><li>rename</li></ol><p>Linux文件IO函数，通常包括 open,read,write,lseek,close这五个函数。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li>create</li><li>delete</li><li>opendir</li><li>closedir</li><li>readdir</li><li>rename</li><li>link</li><li>ulink</li></ol><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p><code>文件系统存放</code>：文件系统存放在外存上。多数磁盘划分为一个或者多个分区，每个而分区有一个独立的文件系统。<br><code>主引导记录（master boot record，MBR）</code>：磁盘的0号扇区称为主引导记录，用来引导计算机，MBR之后挨着的是<code>分区表</code>,该表给出了每一个分区的起始和结束地址。</p><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><h4 id="在内存中采用表的链表分配"><a href="#在内存中采用表的链表分配" class="headerlink" title="在内存中采用表的链表分配"></a>在内存中采用表的链表分配</h4><h4 id="i节点分配"><a href="#i节点分配" class="headerlink" title="i节点分配"></a>i节点分配</h4><p>i节点（index-node）：每个文件都赋予了一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。</p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>每个目录项只引用i节点的目录</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>硬连接和软连接</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>现代操作系统</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;文件系统&lt;/code&gt;：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://stemha.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="软连接" scheme="https://stemha.github.io/tags/%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="硬连接" scheme="https://stemha.github.io/tags/%E7%A1%AC%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="文件与目录" scheme="https://stemha.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>软件工程简述</title>
    <link href="https://stemha.github.io/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>https://stemha.github.io/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2020-04-29T12:47:07.000Z</published>
    <updated>2020-04-29T12:53:33.080Z</updated>
    
    <content type="html"><![CDATA[<p>为了写大型程序，程序员们使用了各种工具和方法，形成了<code>软件工程</code>这门学科。<br>软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言：</p><blockquote><p>这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。</p></blockquote><a id="more"></a><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>尽管可以将大项目分解为小函数，每个人同时工作，不用关心整个项目，只关心自己的函数高效和正确就好啦，然而把代码打包成函数还是远远不够的。<br>比如微软Office软件有近4000万行代码，打包成函数也还有几十万个，也还是也有点多。<br>解决办法是，把函数再次打包成为层级，把相关的代码都放到一起，打包成<code>对象（objects）</code>。</p><h2 id="面向对象编程（object-oriented-programming）"><a href="#面向对象编程（object-oriented-programming）" class="headerlink" title="面向对象编程（object oriented programming）"></a>面向对象编程（object oriented programming）</h2><p>把函数打包成为对象的思想叫做<code>“面向对象编程”</code>。<br>对象可以包含对象，函数，变量。子对象也是同样的，所以会出现<u>沿着对象层级一层层找执行函数</u>的做法。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>软件工程的比喻</code>：<br>就像建造摩天大一样，有管道工配置管道，电工装电线，油漆工涂油漆，还有成败上千人做其他的事情。<br>所以一个大团队中有许多小团队，不同小团队之间负责不同的功能，所以不同团队之间需要文档，才能帮助理解代码都在做什么，还需要定义好的程序编程接口（API）<br>API帮助不同程序员合作，不需要直到细节，只要直到怎么使用就好了。</p><p>然后<code>private与public</code>提供不同的权限，哪些不让外部访问，哪些仅供内部访问。</p><p><code>面向对象的核心</code>：</p><ul><li>隐藏复杂度</li><li>选择性公布功能</li></ul><h2 id="IDE与调试（debugging）"><a href="#IDE与调试（debugging）" class="headerlink" title="IDE与调试（debugging）"></a>IDE与调试（debugging）</h2><p>代码在编译之前只是文字，可以用任何文本处理程序写代码，但是一般来时，还是会用专门的工具来写比较好。<br>IDE提供了许多有用功能，因为集成了所有的东西，所以叫IDE。</p><ul><li>代码帮助，提示，整理，编译，测试</li></ul><h2 id="文档和注释（readme-comment）"><a href="#文档和注释（readme-comment）" class="headerlink" title="文档和注释（readme/comment）"></a>文档和注释（readme/comment）</h2><p>程序员另一项重要工作是给代码写文档<br>文档一般放在readme中<br>文档也可以写成注释，放在源代码中<br>好的文档的作用：</p><ul><li>能帮助开发者几个月后理解自己和他人的代码</li><li>还能提升复用性，与其让程序员一遍遍写已经有的东西，不如直接用别人写好的来解决问题。</li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>源代码管理，帮助团队协作，也叫版本控制。弄懂git原理即可。</p><h2 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h2><p>写代码与测试代码密不可分。<br>测试也称为<code>质量保证测试（QA，quality assurance testing）</code>。<br>严格测试软件的方方面面，看软件会不会出错，也就是找Bug。</p><h2 id="Beta-Alpha"><a href="#Beta-Alpha" class="headerlink" title="Beta Alpha"></a>Beta Alpha</h2><p><code>beta版软件（beta software）</code>：意思是软件接近完成，但不是百分之一百通过测试过，公司有时会向公众发布beta版本，以帮助发现问题。<br><code>alpha版软件（alpha version software）</code>：一般很粗糙，错误多，只在公司内部测试。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Crash Course Computer Science</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了写大型程序，程序员们使用了各种工具和方法，形成了&lt;code&gt;软件工程&lt;/code&gt;这门学科。&lt;br&gt;软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://stemha.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="面向对象" scheme="https://stemha.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="版本控制" scheme="https://stemha.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="文档和注释" scheme="https://stemha.github.io/tags/%E6%96%87%E6%A1%A3%E5%92%8C%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构简述</title>
    <link href="https://stemha.github.io/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"/>
    <id>https://stemha.github.io/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/</id>
    <published>2020-04-28T17:37:34.000Z</published>
    <updated>2020-04-28T17:42:08.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算法处理的数据在内存中的格式是什么？<br>我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构</p></blockquote><a id="more"></a><h2 id="数组array"><a href="#数组array" class="headerlink" title="数组array"></a>数组array</h2><p>几乎所有的编程语言都自带了许多函数来处理数组，比如数组的排序</p><h2 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h2><p>是数组的亲戚<br>i = “love”<br>虽然长得不像数组，但的确是数组，在计算机幕后的确是这样的<br>字符放在内存中以/0结尾，不是”字符0“而是”二进制0“，这叫字符“null”，表示字符串结尾。</p><ul><li>这个字符非常重要，如果调用print函数，会从开始位置逐个显示到屏幕，但是得直到什么时候停下来!否则会把内存中的所有内容输出。</li></ul><h2 id="矩阵matrix"><a href="#矩阵matrix" class="headerlink" title="矩阵matrix"></a>矩阵matrix</h2><p>数组的数组</p><h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h2><p>多个变量打包在一起，在内存中会自动组织到一起的</p><h2 id="节点node与指针"><a href="#节点node与指针" class="headerlink" title="节点node与指针"></a>节点node与指针</h2><p>struct可以构建复杂的数据结构，比如node</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">listnode * next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表linked-list"><a href="#链表linked-list" class="headerlink" title="链表linked list"></a>链表linked list</h2><p>使用node来构建链表<br>灵活性是通过每个节点指向下一个节点实现的<br><code>循环链表（circular list）</code>：尾部的next指向开头<br><code>非循环链表</code>：尾部节点指针值是null<br>链表使用的时候很少看具体地址么，而是经常使用链表的抽象模型</p><p>链表的优点</p><ul><li>容易重新排序，两端缩减，分割，倒序等</li><li>因为灵活很多数据结果可以用链表实现，比如队列和栈</li></ul><h2 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h2><p>FIFO<br>队列的链表实现<br>比方1-&gt;2-&gt;3-&gt;4-&gt;5<br>可以让队列头指向1，队列尾部指向5 （也就是链表的节点连接是反向的）<br>入队（enqueuing）出队（dequeuing）</p><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><p>LIFO<br>入栈（push onto the stack）和出栈（pop from the stack） </p><h2 id="树tree"><a href="#树tree" class="headerlink" title="树tree"></a>树tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">listnode * nextleft;</span><br><span class="line">listnode * nextright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最重要的性质：树到根是单向的</p><h2 id="二叉树-binary-tree"><a href="#二叉树-binary-tree" class="headerlink" title="二叉树 binary tree"></a>二叉树 binary tree</h2><p>每个节点至多两个孩子</p><h2 id="图graph"><a href="#图graph" class="headerlink" title="图graph"></a>图graph</h2><p>顶点多对多</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Crash Course Computer Science</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;算法处理的数据在内存中的格式是什么？&lt;br&gt;我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://stemha.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="简述" scheme="https://stemha.github.io/tags/%E7%AE%80%E8%BF%B0/"/>
    
      <category term="数据结构" scheme="https://stemha.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>操作系统与文件系统简述</title>
    <link href="https://stemha.github.io/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/"/>
    <id>https://stemha.github.io/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/</id>
    <published>2020-04-28T16:34:41.000Z</published>
    <updated>2020-04-28T16:44:52.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><a id="more"></a><p>1940s，1950s的年代，计算机慢，一次只能运行一个程序，<br>程序员在打孔纸上写程序，拿到一个计算机房间，交给操作员。<br>操作员等计算机空下来后，将程序放入，然后运行，输出结果，停机。</p><p>计算机变快之后，放程序的时间比程序运行时间还长，我们需要计算机以一种方式自动运作——&gt;操作系统</p><p>到1950年代尾声，计算机已经变得非常快了，处理器经常闲着，等待慢的设备（比如打印机，读卡器等），也就是程序阻塞在I/O上</p><p>50年代后期，曼彻斯特大学研发了世界上第一台超级计算机，Atlas，想法设法最大限度利用它，1962年设计了atlas supervisor程序，能够在一个CPU上运行多个程序（这种能力也叫<code>多任务处理</code>）<br>Atlas是世界上第一台同时支持虚拟内存和内存保护的电脑</p><p>同时运行多个程序会有一些问题</p><ul><li>每个程序都会占一些内存，切换程序的时候不能丢失数据</li><li>解决办法是给每一个程序配置专属内存块</li></ul><p>分配专属内存块到物理地址时候，可能物理地址不连续的，为了隐藏这种复杂性，把内存地址虚拟化，也就是<code>虚拟内存机制</code></p><p>这种机制可以使程序内存大小灵活增减，也叫<code>动态内存分配</code></p><p><code>内存保护</code>：程序只能捣乱自己的内存，不会影响到其他的程序。</p><p>分时操作系统<br>Multics  首次在设计时候考虑了安全机制，但是导致系统过于臃肿。</p><p>Dennis 和 Thompson 联手打造了Unix，将os分为两部分</p><ol><li>操作系统的核心功能，比如内存管理，多任务和输入输出管理，称之为内核</li><li>一堆有用的工具，比如程序和运行库</li></ol><p>Unix中并没有向multics这么多的错误处理代码<br>-如果有错误产生，就让<code>内核恐慌（kernel panic）</code></p><ul><li>内核崩溃是没有办法恢复的，所以调用了一个pannic的函数，起初只是打印pannic一词，然后无限循环<br>Unix成为1970-1980年代最流行的操作系统之一</li></ul><p>1980年代，计算机降价到普通人买得起，这时候叫个人电脑。<br>起初微软的操作系统没有内存保护，经常蓝屏,后来微软都加上了</p><p>我们现在用的ios，安卓，windows，macos基本上都有了<code>内存保护</code>，<code>虚拟内存</code>，<code>多任务</code>了；</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件格式：随机排列文件当然没有问题，但是随机排列会更好的</p><p>最简单的文件格式</p><ul><li>文本文件（.txt）</li></ul><p>元数据（meta data）：关于数据的数据<br>元数据存在于文件开头，在实际的数据前面，因此也叫<code>文件头（header）</code></p><p>早期计算机只做一件事，比如火炮射程表，这时候整个存储器就像一个文件（数据从头到尾直到占用满）</p><p>后期计算和存储能力的提升，可以存多个文件了，这时候最简单的方式是把文件连续存储，一个个在内存中连续存放<br>但是存储器没有文件概念，只存储大量位，我们怎么直到文件的开头和结尾在哪呢？<br>所以我们需要一个特殊文件，来记录其他文件存储的位置<br>这个特殊文件有很多名字，这里泛称为<code>“目录文件”</code>,这个文件经常是存放在开头的</p><p>目录文件存放</p><ul><li>其他文件的名字”文件名+”.“+扩展名“</li><li>文件的元数据，比如创建时间(created)，最后修改时间(last modified)，文件所有者，是否能读写，最重要的是<code>文件的起始位置和长度</code></li></ul><p>就像书的目录意义，更改了书里面的内容，就需要更改对应的目录</p><p>目录文件和对目录文件的管理是一个非常简单的文件系统的例子</p><p>上面的例子是<code>”平面文件系统“</code>：文件都在同一个层次<br>平面文件系统存在的问题：如果给某个文件加数据，会覆盖掉后面文件的一部分</p><p>所以现代的文件系统会做两件事</p><ol><li>把空间预先分为一块块，并留一些“预留空间”可以方便改动和管理 （用这样的方案目录文件需要记录文件存放在哪些块里面）</li><li>拆分文件，存放在多个块里面，这样文件可以轻松增大和缩小（目录文件会记录不只一个块）//有点像虚拟内存</li></ol><p>删除文件只需要在目录文件上删除那条记录即可。</p><p><code>碎片</code>：文件存储在多个块里面，块之间是分开的，顺序也是乱的。//是增删改文件导致的，不可避免的</p><p>对很多存储技术来说，碎片是坏事，现实生活中大文件可能存放在数百个块里面，导致打开文件特别慢。<br>如何解决？碎片整理！<br>计算机把数据来回移动，排成正确的顺序</p><p><code>分层文件系统</code><br>树状目录的形式</p><ul><li>目录文件（根目录）不仅要指向文件，还要指向目录（is directory字段）//相对于平面文件系统的变化</li><li>无线深度的文件夹</li><li>可以轻松移动文件，只需要改动两个目录文件（一个删去一条记录，一个加一条记录）</li></ul><h2 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h2><p>如今存储技术正朝向固态前进，没有机械活动部件，里面是集成电路，不用像磁盘那样磁头等待磁盘旋转，ssd访问时间低于1/1000秒，但是仍然比RAM慢很多倍，所以现代计算机仍然用层次存储结构。<br>第一个RAM出现于1972年，成本每比特一美分</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Crash Course Computer Science</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://stemha.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://stemha.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件系统" scheme="https://stemha.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux概述</title>
    <link href="https://stemha.github.io/2020/04/20/Linux%E6%A6%82%E8%BF%B0/"/>
    <id>https://stemha.github.io/2020/04/20/Linux%E6%A6%82%E8%BF%B0/</id>
    <published>2020-04-20T13:50:16.000Z</published>
    <updated>2020-04-20T14:47:10.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux设计目标"><a href="#Linux设计目标" class="headerlink" title="Linux设计目标"></a>Linux设计目标</h2><p>Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。</p><a id="more"></a><p>设计Linux的基本方针：</p><ul><li>每个程序只做一件事并且做好。</li></ul><h3 id="好的程序员追求的系统"><a href="#好的程序员追求的系统" class="headerlink" title="好的程序员追求的系统"></a>好的程序员追求的系统</h3><ul><li>简单，优雅，</li><li>一致性 （<code>最小惊讶原理</code>）</li><li>较强的功能性与灵活性<ul><li>意味着系统有较小的一组基本元素，产生多种多样的组合来满足各种应用需要。</li></ul></li></ul><h2 id="Linux的接口"><a href="#Linux的接口" class="headerlink" title="Linux的接口"></a>Linux的接口</h2><p><img src="/2020/04/20/Linux%E6%A6%82%E8%BF%B0/Linux%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" alt></p><center>Linux系统层次结构 </center><p>所有版本的Linux必须提供大量的标准程序，其中一些是POSIX标准指定的，其他的根据Linux的版本而有所不同。它们包括：</p><ul><li>命令处理器（shell）</li><li>编译器</li><li>编辑器</li><li>文本处理程序</li><li>文件操作工具等</li></ul><h3 id="Linux具有三种不同的接口"><a href="#Linux具有三种不同的接口" class="headerlink" title="Linux具有三种不同的接口"></a>Linux具有三种不同的接口</h3><ol><li>真正的系统调用接口</li><li>库函数接口</li><li>由标准应用程序构成的接口</li></ol><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell中，后台运行一个程序的语法是在原本命令后加“&amp;”。</p><p>shell脚本：包含shell命令的文件。</p><ul><li>可以包含参数，同时使用if、for、while和case等结构。</li><li>可以给变量赋值，然后过一段时间再读取这些变量。</li></ul><h2 id="linux应用程序"><a href="#linux应用程序" class="headerlink" title="linux应用程序"></a>linux应用程序</h2><h3 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h3><p>Linux的命令行用户界面包含大量的标准应用程序。大致分为6类：</p><ol><li>文件和目录操作命令</li><li>过滤器</li><li>程序设计工具，如编辑器和编译器</li><li>文档处理</li><li>系统管理</li><li>其他</li></ol><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器有：</p><ul><li>grep、sort、head、tail</li><li>cut和paste（文档剪切与粘贴）</li><li>od：将输入（通常是二进制，也包括八，十和十六进制）转化为ASCII文档。</li><li>pr：打印机格式化输出</li><li>tr：字符大小写转换</li></ul><h3 id="编译器和程序设计工具"><a href="#编译器和程序设计工具" class="headerlink" title="编译器和程序设计工具"></a>编译器和程序设计工具</h3><p>编译器和程序设计工具：</p><ul><li>gcc</li><li>ar：将库函数收集到存档文件中</li><li>make：维护程序，跟踪哪些头文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。 </li></ul><h2 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h2><p><img src="/2020/04/20/Linux%E6%A6%82%E8%BF%B0/Linux%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.jpg" alt></p><center>Linux内核结构 </center><p>内核最底层，负责中断处理程序，这是它们与设备交互的主要方式，以及底层的分派机制。分派在中断时发生。</p><ul><li>底层的代码中止正在运行的进程，将其状态存储在内核进程结构中，然后启动相应的驱动程序。</li><li>进程分派，在内核完成某些操作并且需要再次启动一个用户进程时，发生。进程分派的代码是汇编代码，并且和进程调度的代码有很大不同。</li></ul><p>内核子系统的三个主要部件</p><ul><li>I/O部件<ul><li>包含所有负责与设备交互以及实现联网和存储的I/O功能的内核部件</li></ul></li><li>内存管理部件<ul><li>维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法。并根据需要把需要的数据和代码页读入内存中。</li></ul></li><li>进程管理部件<ul><li>主要是进程的创建和中止。还有CPU调度和信号处理。</li></ul></li></ul><p>内核最顶层，是内核的系统调用接口。所有的调用都来自这里，其导致一个陷阱，将系统从用户态切换到受保护的内核态，继而将控制权交给上述的内核部件之一。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>现代操作系统</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux设计目标&quot;&gt;&lt;a href=&quot;#Linux设计目标&quot; class=&quot;headerlink&quot; title=&quot;Linux设计目标&quot;&gt;&lt;/a&gt;Linux设计目标&lt;/h2&gt;&lt;p&gt;Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://stemha.github.io/categories/Linux/"/>
    
    
      <category term="Linux概述" scheme="https://stemha.github.io/tags/Linux%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令整理（2）</title>
    <link href="https://stemha.github.io/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/"/>
    <id>https://stemha.github.io/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/</id>
    <published>2020-04-19T12:47:44.000Z</published>
    <updated>2020-04-19T16:31:26.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计与过滤"><a href="#统计与过滤" class="headerlink" title="统计与过滤"></a>统计与过滤</h2><a id="more"></a><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>用于过滤/搜索的特定字符,可用正则表达式能多种命令配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-option] pattern file</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-grep.html">Linux grep 命令</a></p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>统计指定文件中的行数、字数、字节数，并将统计结果显示输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-option] 文件…</span><br></pre></td></tr></table></figure><p>该命令统计指定文件中的行数、字数、字节数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc testfile           <span class="comment"># testfile文件的统计信息  </span></span><br><span class="line">5 100 600 testfile      <span class="comment"># testfile文件的行数为5、单词数100、字节数600</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-wc.html">Linux wc命令</a></p><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -stop PID &#x2F;&#x2F;将进程挂起（redhat）</span><br></pre></td></tr></table></figure><p>需要重新执行当前被挂起的任务时，使用 bg %num 即可将挂起的 job 的状态由 stopped 改为 running，仍在后台执行。需要改为在前台执行时，执行fg %num 即可。<br>也可以使用[ctrl]+[z]</p><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pstree -p    &#x2F;&#x2F;可以显示进程树</span><br><span class="line">pstree -apnh &#x2F;&#x2F;显示进程间的关系</span><br><span class="line">pstree -u    &#x2F;&#x2F;显示用户名称</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-pstree.html">Linux pstree命令</a></p><h3 id="lsof-（lists-openfiles）"><a href="#lsof-（lists-openfiles）" class="headerlink" title="lsof （lists openfiles）"></a>lsof （lists openfiles）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [参数][文件]  &#x2F;&#x2F;需要root执行（因为要访问核心内存和各种文件）</span><br></pre></td></tr></table></figure><p>功能： 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。<br>找回/恢复删除的文件。</p><ul><li>好用的系统监视工具（神器）。</li><li>有着最多开关的Linux/Unix命令之一</li></ul><p>lsof打开的文件可以是：<br>1.普通文件<br>2.目录<br>3.网络文件系统的文件<br>4.字符或设备文件<br>5.(函数)共享库<br>6.管道，命名管道<br>7.符号链接<br>8.网络文件（例如：NFS file、网络socket，unix域名socket）<br>9.还有其它类型的文件，等等<br><a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">lsof 菜鸟教程</a><br><a href="https://www.jianshu.com/p/a3aa6b01b2e1">Linux 命令神器：lsof</a></p><h3 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process status)"></a>ps(process status)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options] [--help]  &#x2F;&#x2F;用来显示当前进程的状态</span><br></pre></td></tr></table></figure><p>ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。<br>如果想要动态的显示进程信息，就可以使用top命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">13777 pts&#x2F;1    00:00:00 bash</span><br><span class="line">14564 pts&#x2F;1    00:00:00 ps</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-ps.html">Linux ps命令</a></p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs[选项][参数] &#x2F;&#x2F;用于显示Linux中的任务列表及任务状态，包括后台运行的任务。</span><br><span class="line">&#x2F;&#x2F;jobs 的状态可以是 running, stopped, Terminated</span><br></pre></td></tr></table></figure><p>该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# jobs  </span><br><span class="line">&#x2F;&#x2F;后台没有进程，所以jobs命令的输出是空</span><br><span class="line">root@ubuntu:~# ping 192.168.0.1</span><br><span class="line">PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 ping 192.168.0.1</span><br><span class="line">root@ubuntu:~# jobs</span><br><span class="line">[1]+  Stopped                 ping 192.168.0.1</span><br><span class="line">root@ubuntu:~# jobs -l  &#x2F;&#x2F;-l：显示进程号；</span><br><span class="line">[1]+ 14661 Stopped                 ping 192.168.0.1</span><br></pre></td></tr></table></figure><p><a href="https://ipcmen.com/jobs">jobs命令</a></p><blockquote><p>fg、bg、jobs、&amp;、ctrl + z都是与系统任务有关的常用命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command&amp; 或者 ctrl + z 让进程在后台运行 </span><br><span class="line">jobs     查看后台运行的进程 </span><br><span class="line">fg %jobnumber    让后台的进程jobnumber到前台到前台 </span><br><span class="line">bg %jobnumber    让进程jobnumber到后台去 </span><br><span class="line">&#x2F;&#x2F;%jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid)</span><br></pre></td></tr></table></figure><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill[参数][进程号]</span><br></pre></td></tr></table></figure><p>功能： 发送指定的信号到相应进程。不指定信号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过 jobs 命令查看 job 号（假设为 jobnumber）</span><br><span class="line">kill %jobnumber</span><br><span class="line">通过 ps 命令查看 job 的进程号（PID，假设为 pid）</span><br><span class="line">&#x2F;&#x2F;kill pid</span><br></pre></td></tr></table></figure><h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall[参数][进程名] &#x2F;&#x2F;用来结束同名的的所有进程（kill processes by name）</span><br></pre></td></tr></table></figure><p>killall命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。</p><h2 id="系统监测"><a href="#系统监测" class="headerlink" title="系统监测"></a>系统监测</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure><p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [参数]</span><br></pre></td></tr></table></figure><p>功能： free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:        1009176      136644      172116         628      700416      687996</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><h3 id="vmstat-virtual-memory-statistics"><a href="#vmstat-virtual-memory-statistics" class="headerlink" title="vmstat (virtual memory statistics)"></a>vmstat (virtual memory statistics)</h3><p>功能： 用来显示虚拟内存的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 172200 145008 555428    0    0     0     6   16   15  0  0 100  0  0</span><br></pre></td></tr></table></figure><p>虚拟内存的原理：<br>在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。<br>在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。<br>分页(Page)写入磁盘的过程被称作<code>Page-Out</code>，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。<br>当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作<code>thrashing(颠簸)</code>。</p><h3 id="iostat-I-O-statistics"><a href="#iostat-I-O-statistics" class="headerlink" title="iostat (I/O statistics)"></a>iostat (I/O statistics)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat[参数][时间][次数]</span><br></pre></td></tr></table></figure><p>功能： 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p><p>Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch[参数][命令]</span><br></pre></td></tr></table></figure><p>可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令（也就是说定个具体时间或者隔一段时间执行一次）<br><a href="https://ipcmen.com/watch">watch命令</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 -d <span class="string">'pstree|grep http'</span> <span class="comment"># 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。</span></span><br></pre></td></tr></table></figure><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at[参数][时间]</span><br></pre></td></tr></table></figure><p>功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on）</p><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p><p><a href="https://www.cnblogs.com/ftl1012/p/crontab.html">Linux crontab命令详解</a></p><p>##文件传输</p><h3 id="rcp-remote-file-copy"><a href="#rcp-remote-file-copy" class="headerlink" title="rcp (remote file copy)"></a>rcp (remote file copy)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp [参数] [源文件] [目标文件]</span><br></pre></td></tr></table></figure><p>功能：rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。</p><p>rcp（远程文件拷贝）命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。</p><h3 id="scp-secure-copy"><a href="#scp-secure-copy" class="headerlink" title="scp (secure copy)"></a>scp (secure copy)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [源路径] [目标路径]</span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</li><li>linux的scp命令可以在linux服务器之间复制文件和目录。</li></ul><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br></pre></td></tr></table></figure><p>用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。</p><ul><li>支持断点下传功能</li><li>同时支持FTP和HTTP下载方式</li><li>支持代理服务器</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ipcmen.com/">Linux命令大全（手册）</a><br><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全（菜鸟教程）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;统计与过滤&quot;&gt;&lt;a href=&quot;#统计与过滤&quot; class=&quot;headerlink&quot; title=&quot;统计与过滤&quot;&gt;&lt;/a&gt;统计与过滤&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://stemha.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stemha.github.io/tags/Linux/"/>
    
      <category term="命令" scheme="https://stemha.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令整理（1）</title>
    <link href="https://stemha.github.io/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/"/>
    <id>https://stemha.github.io/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/</id>
    <published>2020-04-19T09:35:55.000Z</published>
    <updated>2020-04-19T15:44:09.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux命令基础知识"><a href="#Linux命令基础知识" class="headerlink" title="Linux命令基础知识"></a>Linux命令基础知识</h2><a id="more"></a>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> [-options] parameter1 parameter2 ... </span><br><span class="line">命令     选项      参数(1)    参数(2) </span><br><span class="line">说明： </span><br><span class="line">1. 任何命令中第一个输入的部分绝对是『命令(<span class="built_in">command</span>)』或者『可运行文件』 </span><br><span class="line">2. <span class="built_in">command</span> 命令的名称 </span><br><span class="line">3. [-options] 选项并不存在于实际的命令中，而加入选项配置时，通常选项前会带 - 号（比如-h）。有时候会使用选项的完整全名，此时带有 -- 符号（比如--<span class="built_in">help</span>） </span><br><span class="line">4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 <span class="built_in">command</span> 的参数；  </span><br><span class="line">5. 命令, 选项, 参数等以空格来区分，但是不论空几格 ，shell 都同一视为一格；  </span><br><span class="line">6. [Enter]按键代表着一行命令的开始启动。 </span><br><span class="line">7. 命令太长的时候，可以使用反斜杠 (\) 来跳脱[Enter]符号，使命令连续到下一行。反斜杠后需要立刻接特殊字符才行。</span><br><span class="line">8. 在 Linux 中，区分大小写。</span><br></pre></td></tr></table></figure><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><h3 id="查询所支持的语言"><a href="#查询所支持的语言" class="headerlink" title="查询所支持的语言"></a>查询所支持的语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$LANG</span> </span><br><span class="line">zh_TW.UTF-8</span><br><span class="line"><span class="comment">#修改为英文语系 </span></span><br><span class="line">$ LANG=en_US</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$LANG</span> </span><br><span class="line">en_US</span><br></pre></td></tr></table></figure><h3 id="时间日历与计算器"><a href="#时间日历与计算器" class="headerlink" title="时间日历与计算器"></a>时间日历与计算器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ date &#x2F;&#x2F;date 时间</span><br><span class="line">$ cal  &#x2F;&#x2F;cal 日历</span><br><span class="line">$ bc   &#x2F;&#x2F;计算器</span><br></pre></td></tr></table></figure><h3 id="版本信息查询"><a href="#版本信息查询" class="headerlink" title="版本信息查询"></a>版本信息查询</h3><h4 id="uname-－a"><a href="#uname-－a" class="headerlink" title="uname －a"></a>uname －a</h4><p>查看版本当前操作系统内核信息</p><h4 id="cat-proc-version"><a href="#cat-proc-version" class="headerlink" title="cat /proc/version"></a>cat /proc/version</h4><p>查看当前操作系统版本信息</p><h4 id="cat-etc-issue-或-cat-etc-redhat-release"><a href="#cat-etc-issue-或-cat-etc-redhat-release" class="headerlink" title="cat /etc/issue 或 cat /etc/redhat-release"></a>cat /etc/issue 或 cat /etc/redhat-release</h4><p>查看版本当前操作系统发行版信息</p><h4 id="cat-proc-cpuinfo"><a href="#cat-proc-cpuinfo" class="headerlink" title="cat /proc/cpuinfo"></a>cat /proc/cpuinfo</h4><p>Linux查看cpu相关信息，包括型号、主频、内核信息等</p><h4 id="getconf-LONG-BIT"><a href="#getconf-LONG-BIT" class="headerlink" title="getconf LONG_BIT"></a>getconf LONG_BIT</h4><p>Linux查看版本多少位</p><h4 id="lsb-release-a"><a href="#lsb-release-a" class="headerlink" title="lsb_release -a"></a>lsb_release -a</h4><p>CentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用</p><h2 id="命令信息查询"><a href="#命令信息查询" class="headerlink" title="命令信息查询"></a>命令信息查询</h2><h3 id="命令总数：-Tab-Tab"><a href="#命令总数：-Tab-Tab" class="headerlink" title="命令总数：[Tab][Tab]"></a>命令总数：[Tab][Tab]</h3><p>按下两个[Tab]按键，查看共有多少命令可以让用户使用用。</p><h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>有时忘记了命令全称，也可以根据不完整的名称查出来，系统有哪些跟这个名词有关的说明文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -f 查询以keyword开头所有相关帮助信息列表，只会找数据中的左边那个命令(或文件)的完整名称。</span><br><span class="line">$ man -f keyword</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -k 将说明文件里面只要含有keyword的都列出来。</span><br><span class="line">$ man -k keyword</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ whatis  [命令或者是数据]   相当于 man -f [命令或者是数据] </span><br><span class="line">$ apropos [命令或者是数据]   相当于 man -k [命令或者是数据] </span><br><span class="line">两个特殊命令要能使用，必须要有创建 whatis 数据库才行！这个数据库的创建需要以 root 的身份下达如下的命令：</span><br><span class="line">[root@ ~]<span class="comment"># makewhatis</span></span><br></pre></td></tr></table></figure><h2 id="关机-重新启动命令"><a href="#关机-重新启动命令" class="headerlink" title="关机/重新启动命令"></a>关机/重新启动命令</h2><h3 id="数据同步写入硬盘中：-sync"><a href="#数据同步写入硬盘中：-sync" class="headerlink" title="数据同步写入硬盘中： sync"></a>数据同步写入硬盘中： sync</h3><h3 id="惯用的关机命令：-shutdown"><a href="#惯用的关机命令：-shutdown" class="headerlink" title="惯用的关机命令： shutdown"></a>惯用的关机命令： shutdown</h3><h3 id="重新启动，关机：-reboot-halt-poweroff"><a href="#重新启动，关机：-reboot-halt-poweroff" class="headerlink" title="重新启动，关机： reboot, halt, poweroff"></a>重新启动，关机： reboot, halt, poweroff</h3><p>在默认的情况下， 这几个命令都会完成一样的工作！(因为halt会先呼叫shutdown，而shutdown最后会呼叫halt！)。 不过，shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt却能够在不理会目前系统状况下， 进行硬件关机的特殊功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# reboot </span><br><span class="line">[root@ ~]# shutdown -h now </span><br><span class="line">[root@ ~]# poweroff -f</span><br></pre></td></tr></table></figure><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。<br>使用权限：系统管理者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]# halt</span><br></pre></td></tr></table></figure><h4 id="切换运行等级：init"><a href="#切换运行等级：init" class="headerlink" title="切换运行等级：init"></a>切换运行等级：init</h4><p>Linux共有七种运行等级<br>run level 0：关机<br>run level 3：纯文本模式<br>run level 5：含有图形接口模式<br>run level 6：重新启动<br>可以使用init来关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@~]# init 0</span><br></pre></td></tr></table></figure><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="目录相关：ls、pwd、mkdir、rmdir"><a href="#目录相关：ls、pwd、mkdir、rmdir" class="headerlink" title="目录相关：ls、pwd、mkdir、rmdir"></a>目录相关：ls、pwd、mkdir、rmdir</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l  &#x2F;&#x2F;列出当前目录下的文件详细信息</span><br><span class="line">pwd [-options] &#x2F;&#x2F;查看”当前工作目录“的完整路径</span><br><span class="line">mkdir [-options] 目录名 &#x2F;&#x2F;创建目录 </span><br><span class="line">rmdir [-options] 目录名   &#x2F;&#x2F;删除空目录。</span><br></pre></td></tr></table></figure><h3 id="文件复制移动：touch、mv、cp、rm"><a href="#文件复制移动：touch、mv、cp、rm" class="headerlink" title="文件复制移动：touch、mv、cp、rm"></a>文件复制移动：touch、mv、cp、rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br><span class="line">//mv命令将文件重命名或将其移至一个新的目录中</span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">```bash</span><br><span class="line">cp [选项]… [-T] 源 目的</span><br><span class="line">//cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch [选项]… 文件…</span><br><span class="line">//touch命令可更改文档或目录的日期时间，包括存取时间和更改时间。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件…</span><br><span class="line">rm命令删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。</span><br></pre></td></tr></table></figure><h3 id="取得路径的文件名与目录名：basename，dirname"><a href="#取得路径的文件名与目录名：basename，dirname" class="headerlink" title="取得路径的文件名与目录名：basename，dirname"></a>取得路径的文件名与目录名：basename，dirname</h3><h3 id="查看文件内容：more、less、head、tail、cat、tac、nl、diff"><a href="#查看文件内容：more、less、head、tail、cat、tac、nl、diff" class="headerlink" title="查看文件内容：more、less、head、tail、cat、tac、nl、diff"></a>查看文件内容：more、less、head、tail、cat、tac、nl、diff</h3><p>more：一页一页显示文件内容<br>less：less与more类似，但是可以向前翻页<br>head：查看文件时，只显示头几行<br>tail：查看文件时，只显示尾几行【-f 循环读取文件，不断刷新】<br>tac：从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]…</span><br><span class="line">主要的三大功能：</span><br><span class="line">1.一次显示整个文件:cat filename</span><br><span class="line">2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.</span><br><span class="line">3.将几个文件合并为一个文件:cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nl [选项]… [文件]…</span><br><span class="line">\\可以用来显示文件</span><br><span class="line">\\nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！</span><br><span class="line">\\其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff[参数][文件1或目录1][文件2或目录2]</span><br><span class="line">\\diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span><br><span class="line">root@ubuntu:~# diff &#x2F;snap&#x2F; &#x2F;usr&#x2F;</span><br><span class="line">Only in &#x2F;snap&#x2F;: README</span><br><span class="line">Only in &#x2F;usr&#x2F;: bin</span><br><span class="line">Only in &#x2F;usr&#x2F;: games</span><br><span class="line">Only in &#x2F;usr&#x2F;: include</span><br><span class="line">Only in &#x2F;usr&#x2F;: lib</span><br><span class="line">Only in &#x2F;usr&#x2F;: local</span><br><span class="line">Only in &#x2F;usr&#x2F;: sbin</span><br><span class="line">Only in &#x2F;usr&#x2F;: share</span><br><span class="line">Only in &#x2F;usr&#x2F;: src</span><br></pre></td></tr></table></figure><h3 id="创建文件链接：-ln"><a href="#创建文件链接：-ln" class="headerlink" title="创建文件链接： ln"></a>创建文件链接： ln</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ln (link)</span><br><span class="line">ln -s source dist        # 建立软连接</span><br><span class="line">ln source dist           # 建立硬连接</span><br></pre></td></tr></table></figure><p><code>软链接(symbolic link)</code>：软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。<br><code>硬链接(hard link)</code>：硬链接是已存在文件的另一个名字。【不允许给目录创建硬链接；只有在同一文件系统中的文件之间才能创建硬链接。】</p><p>硬链接：指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Number)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件,以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。<br>软链接：文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><h3 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h3><p>umask 档案预设权限<br>chattr 配置文件档案隐藏属性<br>lsattr 显示档案隐藏属性<br>file    观察文件类型：</p><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>改变所属群组, /etc/group里面可查询群组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@~]# chgrp users code.log</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>功能： 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。<br>格式： chown [选项]… [所有者][:[组]] 文件…</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。<br>格式： chmod [-cfvR] [–help] [–version] mode file<br>数字与字符对应关系如下：<br>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=7。</p><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>压缩文件和读取压缩文件：tar，gzip，zcat</p><h3 id="磁盘占用与挂载"><a href="#磁盘占用与挂载" class="headerlink" title="磁盘占用与挂载"></a>磁盘占用与挂载</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>df命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# df </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">udev              491848       0    491848   0% &#x2F;dev</span><br><span class="line">tmpfs             100920     628    100292   1% &#x2F;run</span><br></pre></td></tr></table></figure><h4 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du (disk usage)"></a>du (disk usage)</h4><p>du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。该命令的功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出指定目录，则对当前目录进行统计。</p><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p>在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等</p><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which 可执行文件名称   &#x2F;&#x2F;查找路径：PATH所含目录</span><br><span class="line">&#x2F;&#x2F;which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</span><br></pre></td></tr></table></figure><p>适用场合：查找命令/可执行文件所在的路径。有时候可能在多个路径下存在相同的命令，该命令可用于查找当前所执行的命令到底是哪一个位置处的命令。 </p><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] [BMS 目录名 -f ] 文件名 &#x2F;&#x2F;查找路径：索引数据库所含目录</span><br><span class="line">&#x2F;&#x2F;whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于源文件，二进制文件，或是帮助文件。</span><br><span class="line">&#x2F;&#x2F;whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。</span><br></pre></td></tr></table></figure><p>原理：首先会去掉文件名中的前缀空格和以.开头的任何字符，然后在数据库（var/lib/slocate/slocate.db）中查找与经过处理后的文件名相匹配的源文件，二进制文件，或是帮助文件。<br>使用之前可以使用updatedb命令手动更新数据库。<br>适用场合：定位可执行文件、源代码文件、帮助文件在文件系统中的位置</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate [选择参数] [样式]  &#x2F;&#x2F;查找路径：索引数据库所含目录</span><br><span class="line">locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。</span><br></pre></td></tr></table></figure><p>原理：默认情况下(文件名中不包含通配符<em>时)，locate会给出所有与</em>filename*相匹配的文件的路径。<br>适用场合：没有文件类型性质的模糊查找</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find pathname -options [-print -exec -ok …]  &#x2F;&#x2F;查找路径：当前目录&#x2F;指定目录</span><br></pre></td></tr></table></figure><p>适用场合：能用which、whereis和locate的时候尽量不要用find.<br>功能： 用于在文件树种查找文件，并作出相应的处理<br>原理：遍历当前工作目录及其子目录<br>参数：</p><p>1.使用name选项，可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。<br>2.按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。<br>3.如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。<br>4.使用type选项,根据不同的文件类型进行查找，如d(目录)、l(链接)</p><p>find命令之exec<br>-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。例如：find . -type f -exec ls -l {} ;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。<br>find命令之xargs<br>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><p><a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">Linux 查看端口占用情况</a></p><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip [-option] [动作] [命令]</span><br></pre></td></tr></table></figure><p>option ：设定的参数，主要有-s显示出该设备的统计数据(statistics)，例如总接受封包数等；<br>动作：就是是可以针对哪些网络参数进行动作，包括有：</p><p>link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等<br>addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；<br>route ：与路由有关的相关设定</p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br></pre></td></tr></table></figure><p>ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。</p><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>dig命令是一个功能强大的DNS查询命令。</p><p>一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig [@global-server] [domain] [q-type] [q-class] &#123;q-opt&#125; &#123;d-opt&#125;</span><br></pre></td></tr></table></figure><p>参数说明：<br>global-server：默认是以/etc/resolv.conf作为DNS查询的主机，这里可以填入其它DNS主机IP。<br>domain：要查询的域名。<br>q-type：查询记录的类型，例如a、any、mx、ns、soa、hinfo、axfr、txt等，默认查询a。<br>q-class：查询的类别，相当于nslookup中的set class。默认值为in（Internet）。<br>q-opt：查询选项，可以有好几种方式，比如：-f file为通过批处理文件解析多个地址；-p port指定另一个端口（缺省的DNS端口为53），等等。<br>d-opt：dig特有的选项。使用时要在参数前加上一个“+”号。</p><p>d-opt常用选项：<br>+vc：使用TCP协议查询。<br>+time=###：设置超时时间。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure><p>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，<strong>接口状态 (Interface Statistics)</strong>，masquerade 连接，多播成员 (Multicast Memberships) 等等。<br><a href="https://www.runoob.com/linux/linux-comm-netstat.html">netstat命令(菜鸟教程)</a></p><h3 id="ss-Socket-Statistics"><a href="#ss-Socket-Statistics" class="headerlink" title="ss(Socket Statistics)"></a>ss(Socket Statistics)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss [参数]</span><br><span class="line">ss [参数] [过滤]</span><br></pre></td></tr></table></figure><p>功能： ss命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。<br><a href="https://blog.csdn.net/jiajiren11/article/details/80887528">ss命令的参数及使用详解</a></p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br></pre></td></tr></table></figure><p>ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。<br>ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。</p><h3 id="tracertroute"><a href="#tracertroute" class="headerlink" title="tracertroute"></a>tracertroute</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">traceroute[参数][主机]</span><br><span class="line">&#x2F;&#x2F;具体参数格式：</span><br><span class="line">traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</span><br></pre></td></tr></table></figure><p>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]</span><br></pre></td></tr></table></figure><p>功能： Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。</p><p>Linux系统的route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。<br>在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html">理解 Linux 的硬链接与软链接</a><br>鸟哥的linux私房菜<br><a href="https://blog.csdn.net/u010625000/article/details/44455023">Linux下4个查找命令which、whereis、locate、find的总结</a><br><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux命令基础知识&quot;&gt;&lt;a href=&quot;#Linux命令基础知识&quot; class=&quot;headerlink&quot; title=&quot;Linux命令基础知识&quot;&gt;&lt;/a&gt;Linux命令基础知识&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://stemha.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stemha.github.io/tags/Linux/"/>
    
      <category term="命令" scheme="https://stemha.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>《别闹了费曼先生》读书笔记</title>
    <link href="https://stemha.github.io/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://stemha.github.io/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-18T12:48:23.000Z</published>
    <updated>2020-04-18T13:11:18.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当科学大师碰上菜鸟"><a href="#当科学大师碰上菜鸟" class="headerlink" title="当科学大师碰上菜鸟"></a>当科学大师碰上菜鸟</h2><a id="more"></a><blockquote><p>报告时间终于到了。我面前坐了这些科学大师，全在等我开口讲话！我生平第一次学术报告，却碰上这样的听众！我的意思是说，他们会问很多难题，我将会大大地出丑了！我还清楚记得，从牛皮纸袋抽出讲稿时，双手不住地发抖。<br>但奇迹出现了——事实上我很幸运，类似的奇迹在我一生中一再发生——只要我开始思考物理、必须全神贯注于要说明的问题上，我的脑袋中就再没有其他杂念，完全不会紧张。因此当我开始报告以后，我根本不知道听众是谁了；我只不过在说明这些物理概念。事情就那么简单！</p></blockquote><h2 id="向数学家挑战"><a href="#向数学家挑战" class="headerlink" title="向数学家挑战"></a>向数学家挑战</h2><blockquote><p>我向他们挑战：“我跟你们打赌，随便你提出一个定理——只要你用我听得懂的方式告诉我，它假设些什么、定理是什么等等——我立刻可以告诉你，它是对的还是错的！”</p></blockquote><blockquote><p>其实，我也并不是随便乱猜的。我有一套方法，甚至到了今天，当别人对我说明一些什么，而我努力要弄明白时，我还在用这些方法：不断地举实例。<br>譬如说，那些念数学的提出一个听起来很了不得的定理，大家都非常兴奋。当他们告诉我这个定理的各项条件时，我便一边构思符合这些条件的情况。当他们说到数学上的“集”时，我便想到一个球，两个不相容的集便是两个球。然后视情况而定，球可能具有不同的颜色、长出头发或发生其他千奇百怪的状况。最后，当他们提出那宝贝定理时，我只要想到那跟我长满头发的绿球不吻合时，便宣布：“不对！”</p></blockquote><blockquote><p>看怎样用些有趣、近代的数学观念来教数学。原先的目的，是要使那些觉得数学枯燥无味的学生提高兴趣。</p></blockquote><h2 id="费曼教授"><a href="#费曼教授" class="headerlink" title="费曼教授"></a>费曼教授</h2><blockquote><p>20 世纪40 年代，我待在普林斯顿的期间，亲眼看到高等研究院内那些卓越心灵的下场。他们都具备了聪明绝顶的头脑，因此特别被选中，来到坐落在森林旁边的漂亮房子里，整天悠哉游哉地闲坐——不用教书，没有任何约束或负担。但等过了一段日子，他们想不出什么新东西来，每个人心里一定开始感到内疚或沮丧，更加担心提不出新想法。可是一切还是如旧，仍然没有灵感。<br>会发生这种情况，完全是因为那里缺乏真正的活动和挑战：他们没有跟做实验的学者接触，也不必思索如何回答学生提出的问题，什么都没有！</p></blockquote><blockquote><p>在任何思考过程中，当一切进行顺利、灵感源源不绝时，教书确实是一种妨碍，十分讨厌。但有更多的时候是脑袋空空的，如果既想不出什么、又没做什么，那真会教人疯狂！你甚至不能说：“我在教书呀！”。</p></blockquote><h2 id="不敢面对问题到弄明白"><a href="#不敢面对问题到弄明白" class="headerlink" title="不敢面对问题到弄明白"></a>不敢面对问题到弄明白</h2><blockquote><p>在罗彻斯特举行了一个会议——一年一度的罗彻斯特研讨会（Rochester Conference）。我还是事事落于人后，而李政道已在发表关于宇称不守恒的论文。他和杨振宁作出宇称并不守恒的结论，现在他正提出解释这现象的理论。<br>会议期间，我住在我位于西瑞桥斯（Syracuse）的妹妹家。我把论文带回家跟她说：“我搞不懂李政道和杨振宁说的东西，这全都那么复杂！”“不，”她说，“你的意思并不是说你无法弄懂它，而是你没有发明它。你没有用你的方法，从听到线索开始做起，把它推演出来。你应该做的是想象自己重新在当学生，把这篇论文带到楼上去，逐字逐句地读，检查每一条方程式。然后你就什么都弄懂了。”<br>我接受了她的建议，把那东西从头看到尾，发现它真的很明显简单。我只是一直害怕去读它，总觉得它太深奥。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;当科学大师碰上菜鸟&quot;&gt;&lt;a href=&quot;#当科学大师碰上菜鸟&quot; class=&quot;headerlink&quot; title=&quot;当科学大师碰上菜鸟&quot;&gt;&lt;/a&gt;当科学大师碰上菜鸟&lt;/h2&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://stemha.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="费曼" scheme="https://stemha.github.io/tags/%E8%B4%B9%E6%9B%BC/"/>
    
      <category term="诺贝尔奖" scheme="https://stemha.github.io/tags/%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96/"/>
    
      <category term="传记" scheme="https://stemha.github.io/tags/%E4%BC%A0%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>哈希表（散列表）详解</title>
    <link href="https://stemha.github.io/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
    <id>https://stemha.github.io/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-14T14:34:02.000Z</published>
    <updated>2020-04-15T09:53:01.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p><code>散列方法（hashing）</code>：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在<u>词条的关键码与向量单元的秩之间建立起映射关系</u>。<br><code>散列表（hashtable）</code>：逻辑上由一些列可存放词条（或者其引用）的单元（称作<code>桶（bucket）</code>或<code>桶单元</code>）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作<code>桶数组（bucket array）</code><br><code>地址空间（address space）</code>：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。</p><a id="more"></a><p><code>散列函数（hash function）</code>：用来描述散列方法，是从关键码空间到桶数组地址空间的函数。比如下面的hash()：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>() : key -&gt; <span class="built_in">hash</span>(key)</span><br></pre></td></tr></table></figure><p><code>key的散列地址（hashing address）</code>：也就是上面的hash(key) 。</p><p><code>完美散列（perfect hashing）</code>：在时间和空间性能方面均达到最优的散列，也就是没有空余，没有重复的散列。</p><p><code>装填因子（load factor）</code>：散列表中非空桶的数目与桶单元总数的比值。是散列表的空间利用率度量方法。</p><p><code>散列冲突（collision）</code>：关键码不同的词条映射到同一个散列地址的情况。</p><p><code>词条的聚集（clustering）</code>：词条集中到散列表内少数若干桶中（或附近）的现象。</p><p>综上散列表的基本构思概括为：</p><blockquote><p>开辟物理地址连续的桶数组hba[],借助散列函数hash(),将词条关键码key映射为桶地址hash(key),从而快速确定待操作的词条的位置。</p></blockquote><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><strong>散列函数</strong></h2><p>好的散列函数应该具备的条件：</p><ul><li>确定性 ：也就是说词条E的映射地址hash(E.key)必须完全取决于E.key。</li><li>简单性 ：映射过程不能过于复杂</li><li>所有关键码经过映射后应该尽量覆盖整个地址空间。也就是说hash()最好是满射。</li><li>均匀性 ：最重要的原则，关键码映射到各个桶的概率是同等的，应该尽量为1/R ，R为散列表长度或容量。</li></ul><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a><strong>直接定址法</strong></h3><p>直接定址法：关键码就可以直接用作为散列地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(key)=key</span><br></pre></td></tr></table></figure><h3 id="除余法（devision-method）"><a href="#除余法（devision-method）" class="headerlink" title="除余法（devision method）"></a><strong>除余法（devision method）</strong></h3><p>除余法：选择一个适当的正整数R,用R去除关键码去除关键码,余数作为 散列地址.这个方法的关键是选取适当的R。一般R为素数，采用素数表长是是降低聚集发生概率的捷径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(key)=key mod R  //R为散列表长度或容量。一般R为素数。</span><br></pre></td></tr></table></figure><p>缺点：残留有某种连续性，比如相邻关键码所对应的散列的地址，总是彼此相邻。</p><h3 id="MAD法（multiply-add-divide-method）乘加除法"><a href="#MAD法（multiply-add-divide-method）乘加除法" class="headerlink" title="MAD法（multiply-add-divide method）乘加除法"></a><strong>MAD法（multiply-add-divide method）乘加除法</strong></h3><p>乘加除法：需要依次执行乘法，加法，和除法运算得名。<br>解决的问题：用来克服除余法的连续性缺陷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(key)=(a * key + b)mod R  //a&gt;0，b&gt;0，且(a mod R) !=0</span><br><span class="line">//R为散列表长度或容量。一般R为素数。</span><br></pre></td></tr></table></figure><h3 id="数字分析法（selecting-digits）"><a href="#数字分析法（selecting-digits）" class="headerlink" title="数字分析法（selecting digits）"></a><strong>数字分析法（selecting digits）</strong></h3><p>数字分析法：从关键码key中特定进制的展开中抽出特定的若干位，构成一个整型地址。对关键码的各位进行分析（多种方法），丢下分布不均匀的位，留下均匀的位作为地址。<br>数字分析法举例：</p><ul><li>平方取中法（mid-square）</li><li>折叠法（folding）<ul><li>一般折叠</li><li>往复折返式折叠</li></ul></li><li>异或法（xor）<ul><li>一般异或</li><li>往复折返式异或</li></ul></li></ul><h3 id="伪随机数法"><a href="#伪随机数法" class="headerlink" title="伪随机数法"></a><strong>伪随机数法</strong></h3><p>越是随机，越是没有规律的就是好的散列函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(key)=rand(key) mod R  //R为散列表长度或容量。</span><br></pre></td></tr></table></figure><h2 id="冲突及其排解"><a href="#冲突及其排解" class="headerlink" title="冲突及其排解"></a><strong>冲突及其排解</strong></h2><h3 id="开散列策略-封闭定址"><a href="#开散列策略-封闭定址" class="headerlink" title="开散列策略/封闭定址"></a><strong>开散列策略/封闭定址</strong></h3><p>开散列（open hashing）或封闭定址（closed addressing）：</p><ul><li>开放基本的散列表结构，引入次级关联结构。</li><li>散列表中的地址只对特定的词条开放（每个桶可以只能能存放特定的一组词条）。</li></ul><h4 id="多槽位法（multiple-slots）"><a href="#多槽位法（multiple-slots）" class="headerlink" title="多槽位法（multiple slots）"></a><strong>多槽位法（multiple slots）</strong></h4><p>多槽位法：将每个桶细分为更小的称作<code>槽位（slot）</code>的若干单元，每一组槽位可以组织为向量或列表。//类似于二维数组</p><h4 id="独立链法（separate-chaining-（拉链法）"><a href="#独立链法（separate-chaining-（拉链法）" class="headerlink" title="独立链法（separate chaining)（拉链法）"></a><strong>独立链法（separate chaining)（拉链法）</strong></h4><p>拉链法：某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。//引入链表<br>先计算哈希地址，然后搜索该地址的单链表。</p><h4 id="公共溢出区法（overflow）"><a href="#公共溢出区法（overflow）" class="headerlink" title="公共溢出区法（overflow）"></a><strong>公共溢出区法（overflow）</strong></h4><p>在原有散列表hashA之外再设置一个公共溢出区（散列表hashB），如果抽入词条发生冲突，就将该词条转存至公共溢出区（散列表hashB）中。 //引入新的散列表<br>可以说是一种递归形式的散列表。</p><h3 id="闭散列策略-开放定址"><a href="#闭散列策略-开放定址" class="headerlink" title="闭散列策略/开放定址"></a><strong>闭散列策略/开放定址</strong></h3><p>闭散列（open hashing）或开放定址（closed addressing）：</p><ul><li>仅仅依靠基本的散列表结构，就地排解冲突。</li><li>散列表中的地址对所有的词条开放（每个桶可以都有可能存放任一词条）。</li><li>一个桶冲突了，只允许在散列表内部为其寻找另一空桶。</li></ul><h4 id="线性试探法（linear-probing）"><a href="#线性试探法（linear-probing）" class="headerlink" title="线性试探法（linear probing）"></a><strong>线性试探法（linear probing）</strong></h4><p>线性试探法：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。<br>被尝试的桶依次为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="built_in">hash</span>(key) + i)mod R ] ,i=1,2,3,...</span><br></pre></td></tr></table></figure><h4 id="平法试探法（二次探测法）"><a href="#平法试探法（二次探测法）" class="headerlink" title="平法试探法（二次探测法）"></a><strong>平法试探法（二次探测法）</strong></h4><p>被尝试的桶依次为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="built_in">hash</span>(key) + i^2)mod R ] ,i=1,2,3,...</span><br></pre></td></tr></table></figure><h4 id="伪随机试探法"><a href="#伪随机试探法" class="headerlink" title="伪随机试探法"></a><strong>伪随机试探法</strong></h4><p>被尝试的桶依次为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rand(i)mod R ] ,rand(i)为系统定义的第i个随机数。</span><br></pre></td></tr></table></figure><h4 id="再散列法（rehashing）"><a href="#再散列法（rehashing）" class="headerlink" title="再散列法（rehashing）"></a><strong>再散列法（rehashing）</strong></h4><p>再散列法：使用哈希函数去散列一个输入的时候，如果输出是同一个散列地址就再次散列，直至不发生冲突为止。<br>缺点：每次冲突都要重新散列，计算时间增加。<br>被尝试的桶依次为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//hash2为二级散列函数</span><br><span class="line">[(<span class="built_in">hash</span>(key) + i*hash2(key) ] ,i=1,2,3,...</span><br></pre></td></tr></table></figure><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;散列方法（hashing）&lt;/code&gt;：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在&lt;u&gt;词条的关键码与向量单元的秩之间建立起映射关系&lt;/u&gt;。&lt;br&gt;&lt;code&gt;散列表（hashtable）&lt;/code&gt;：逻辑上由一些列可存放词条（或者其引用）的单元（称作&lt;code&gt;桶（bucket）&lt;/code&gt;或&lt;code&gt;桶单元&lt;/code&gt;）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作&lt;code&gt;桶数组（bucket array）&lt;/code&gt;&lt;br&gt;&lt;code&gt;地址空间（address space）&lt;/code&gt;：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://stemha.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="散列表" scheme="https://stemha.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统目录结构</title>
    <link href="https://stemha.github.io/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>https://stemha.github.io/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2020-04-13T16:04:52.000Z</published>
    <updated>2020-04-13T16:38:08.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bin-binary"><a href="#bin-binary" class="headerlink" title="/bin (binary)"></a>/bin (binary)</h2><p>目录存放着最经常使用的命令</p><a id="more"></a><h2 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h2><p>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><p>包括Linux内核文件，以及开机菜单与开机所需的配置文件</p><p>linux kernel常用的文件名为vmlinux</p><h2 id="dev-device"><a href="#dev-device" class="headerlink" title="/dev (device)"></a>/dev (device)</h2><p>该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p><h2 id="etc-Editable-Text-Configuration"><a href="#etc-Editable-Text-Configuration" class="headerlink" title="/etc (Editable Text Configuration)"></a>/etc (Editable Text Configuration)</h2><p>可配置文件<br>存放所有的系统管理所需要的配置文件和子目录。</p><h3 id="etc-init-d"><a href="#etc-init-d" class="headerlink" title="/etc/init.d"></a>/etc/init.d</h3><p>所有服务的默认启动脚本都是放置在这个目录内</p><h3 id="etc-xinetd-d"><a href="#etc-xinetd-d" class="headerlink" title="/etc/xinetd.d"></a>/etc/xinetd.d</h3><p>所谓的super daemon管理的各项服务的配置文件目录</p><h3 id="etc-X11"><a href="#etc-X11" class="headerlink" title="/etc/X11"></a>/etc/X11</h3><p>与X Windows有关的各种配置文件都在这里</p><h3 id="etc-securetty"><a href="#etc-securetty" class="headerlink" title="/etc/securetty"></a>/etc/securetty</h3><p>只有/etc/securetty中登记的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录</p><p>这个终端指tty1之类的</p><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>保存的就是系统中所有的用户和用户的主要信息</p><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。</p><h2 id="home-home-directory"><a href="#home-home-directory" class="headerlink" title="/home (home directory)"></a>/home (home directory)</h2><p>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p><p>系统默认的用户主文件夹</p><p>比较重要的是 主文件夹有两者代号</p><ul><li><p>~ 代表目前这个用户的主文件夹</p></li><li><p>~dmtsai 代表dmtsai的主文件夹</p></li></ul><h2 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h2><p>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p><p>放置的是开机会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库而已</p><p>尤其重要的是/lib/modules/这个目录</p><p>放置内核相关的模块（驱动程序）</p><h2 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h2><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>这个目录是使用标准的ext2/ext3文件系统格式才会产生的目录</p><h2 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h2><p>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p><p>包括软盘，光盘，DVD等设备都暂时挂载于此</p><h2 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h2><p>系统提供该目录是为了让用户临时挂载别的文件系统的，或者说是额外的设备</p><p>比较早的时候，这个目录的用途与/media相同。只是有了/media之后这个目录就暂时用来挂载用了</p><h2 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h2><p> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><p>给第三方软件放置的目录</p><h2 id="proc-process"><a href="#proc-process" class="headerlink" title="/proc (process)"></a>/proc (process)</h2><p>这个目录本身是一个虚拟的文件系统，放置的数据都是在内存中:例如，系统内核，进程，外部设备的状态及网络状态等</p><p>目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</p><p>这个目录的内容不在硬盘上而是在内存里，本身不占用任何硬盘空间，我们也可以直接修改里面的某些文件</p><h2 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h2><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p><h2 id="run"><a href="#run" class="headerlink" title="/run"></a>/run</h2><p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><h2 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h2><p>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><h2 id="selinux"><a href="#selinux" class="headerlink" title="/selinux"></a>/selinux</h2><p>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><p>这个目录的内容数据也是在内存中的信息，同样不会占用任何的硬盘容量</p><p>Secure Enhance Linux的执行目录</p><h2 id="srv-service"><a href="#srv-service" class="headerlink" title="/srv (service)"></a>/srv (service)</h2><p> 该目录存放一些服务启动之后需要提取的数据。</p><p>一些网络服务启动之后，这些服务所取用的数据目录</p><p>存放服务启动后需要提取的数据（不用服务器就是空）</p><h2 id="sys"><a href="#sys" class="headerlink" title="/sys"></a>/sys</h2><p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。<br>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><p>这个目录与/proc目录类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。包括目前已经加载的内核模块与内核检测到的硬件设备信息等。</p><p>这个目录同样不占用硬盘容量。</p><h2 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h2><p>这个目录是用来存放一些临时文件的。</p><h2 id="usr-UNIX-Software-Resource-而不是user"><a href="#usr-UNIX-Software-Resource-而不是user" class="headerlink" title="/usr (UNIX Software Resource,而不是user)"></a>/usr (UNIX Software Resource,而不是user)</h2><p>是UNIX 操作系统软件资源所放置的目录，而不是用户的数据.<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<br>注意事项：FHS建议所有软件开发者将他们的数据合理地放置到这个目录下的子目录，而不要自行新建软件自己独立的目录<br>有点像windows系统中C:\Windows\和C:\Program files\这两个目录的综合体</p><h3 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h3><p>系统用户使用的应用程序。</p><h3 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h3><p>超级用户使用的比较高级的管理程序和系统守护程序</p><h3 id="usr-src"><a href="#usr-src" class="headerlink" title="/usr/src"></a>/usr/src</h3><p>内核源代码默认的放置目录。</p><h2 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h2><p>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>上面这些目录比较完备了</p><p>我主要是根据菜鸟教程，鸟哥的私房菜进行整理的</p><p>关于/run这个目录稍微特殊一点点，有的系统是二级目录，如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p>可以用ls -l / 命令查看目录树</p><h3 id="关于挂载"><a href="#关于挂载" class="headerlink" title="关于挂载"></a>关于挂载</h3><p>开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为</p><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;bin-binary&quot;&gt;&lt;a href=&quot;#bin-binary&quot; class=&quot;headerlink&quot; title=&quot;/bin (binary)&quot;&gt;&lt;/a&gt;/bin (binary)&lt;/h2&gt;&lt;p&gt;目录存放着最经常使用的命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://stemha.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stemha.github.io/tags/Linux/"/>
    
      <category term="目录结构" scheme="https://stemha.github.io/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>linux 性能分析，测试与调优工具</title>
    <link href="https://stemha.github.io/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>https://stemha.github.io/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-09T06:44:46.000Z</published>
    <updated>2020-04-09T07:10:43.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态性能分析工具-static-performance-analysis-tools"><a href="#静态性能分析工具-static-performance-analysis-tools" class="headerlink" title="静态性能分析工具(static performance analysis tools)"></a>静态性能分析工具(static performance analysis tools)</h3><ul><li><strong>dmesg</strong> 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。</li><li><strong>blockdev</strong>  工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。</li><li><strong>ldd</strong> （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。<a id="more"></a></li><li><strong>lsblk</strong> (list block)即用于列出所有可用块设备的信息,而且还能显示他们之间的依赖关系,但是它不会列出RAM盘的信息</li><li><strong>lsscsi</strong>  可以看到Raid卡信息和所有虚拟磁盘以及光驱的信息，如果没有硬件SCSI控制器，那就不会返回信息。</li><li><strong>lspci</strong> 显示有关pci总线的信息以及连接到它们的设备。</li><li><strong>lscpu</strong> (list cpu)显示CPU的详细信息，比如CPU的制造商、架构、CPU数量、型号、主频、缓存及支持的虚拟化技术等信息。</li><li><strong>lstopo</strong> (list topology of the system)显示可视化的方式组成 CPU、缓存、内存和I/O设备的拓扑结构。这个命令用来识别处理器结构和系统的NUMA拓扑结构。</li><li><strong>likwid</strong> (Like I Knew What I’m Doing) 是一个用来测量、配置并显示硬件相关特性的命令行收集工具。其中的likwid拓扑结构能显示CPU硬件(线程/缓存/NUMA)的拓扑结构信息，还能识别处理器家族(比如：Intel Core 2, AMD Shanghai)。</li><li><strong>smartctl</strong>  查看硬盘的SMART信息。</li><li><strong>fdisk</strong> 创建和维护分区表的程序(兼容DOS类型的分区表、BSD或SUN的磁盘列表）</li><li><strong>schedtool</strong> (scheduling tool)查询或设置CPU状态的工具。通过不同的参数可以查看或设置不同的属性。</li><li><strong>numactl</strong> (Control NUMA policy)用于控制 进程与共享存储的 NUMA 技术机制。</li><li><strong>cpuid</strong> 获取CPU的信息。该命令的底层是CPUID指令。它获取的内容比/proc/cpuinfo要详细很多。</li><li><strong>MegaCli</strong> 管理维护硬件RAID的软件</li><li><strong>App Config</strong></li></ul><h3 id="观测工具-Observability-Tools"><a href="#观测工具-Observability-Tools" class="headerlink" title="观测工具(Observability Tools)"></a>观测工具(Observability Tools)</h3><ul><li><strong>iostat</strong>  (input/output statistics)报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息。</li><li><strong>vmstat</strong>  (VirtualMeomoryStatistics,虚拟内存统计) 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。</li><li><strong>dstat</strong> 用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具,是一个全能系统信息统计工具。</li><li><strong>pidstat</strong> 是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。</li><li><strong>mpstat</strong>  (multiprocessor statistics)查看多核心的cpu中每个计算核心的统计数据。类似工具vmstat只能查看系统的整体cpu情况</li><li><strong>netstat</strong> ( network statistics)显示当前的网络状态，包括传输控制协议层的连线状况、路由表、网络接口状态和网络协议的统计信息等。</li><li><strong>iotop</strong> 用来监视磁盘I/O使用状况的top类工具</li><li><strong>top</strong> (display Linux processes)实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。</li><li><strong>htop</strong>  top命令的升级版。交互式的进程浏览器，可以用来替换Linux下的top命令</li><li><strong>gtop</strong>  JavaScript 编写的开源系统资源监控实用程序,它是 Linux 系统自带 top 工具的替代品</li><li><strong>tiptop</strong>  通过读取CPU硬件计数器的信息（比如cahche miss，executed instructions per cycle等等）了解程序执行效率</li><li><strong>strace</strong> 可跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。</li><li><strong>uptime</strong> 可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息</li><li><strong>lsof</strong>  (list open files)列出当前系统打开的文件，注意linux中设备也是文件</li><li><strong>perf</strong>  性能分析工具，能够进行函数级与指令级的热点查找。</li><li><strong>Flame Graphs</strong> 性能分析的利器,通过它可以快速定位性能瓶颈点。</li></ul><h3 id="测试工具-Benchmarking-Tools"><a href="#测试工具-Benchmarking-Tools" class="headerlink" title="测试工具(Benchmarking Tools)"></a>测试工具(Benchmarking Tools)</h3><ul><li><strong>fio</strong> 开源的I/O压力测试工具，主要是用来测试磁盘/SSD的IO性能，也可测试cpu，nic的IO性能。</li><li><strong>hdparm</strong> (hard disk parameters)用于显示与设定硬盘的参数</li><li><strong>dd</strong>  用于读取、转换并输出数据。可从标准输入或文件中读取数据,根据指定的格式来转换数据,再输出到文件、设备或标准输出。  </li><li><strong>perf_events</strong> 网上很多叫法如perf_events , perf profiler , Performance Counters for Linux。叫法不同，都指perf</li><li><strong>perf-tools</strong>  基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集，能够收集ftrace和perf_events中乱七八糟的参数。</li><li><strong>ktap</strong>  Linux的基于脚本的动态跟踪工具 允许用户跟踪Linux内核动态。</li><li><strong>sysbench</strong>  一个开源的、模块化的、跨平台的多线程性能测试工具,可以用来进行CPU、内存、磁盘I/O、线程、数据库的性能测试。</li><li><strong>ab</strong> (apachebench) ab命令会创建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。</li><li><strong>wrk</strong> 针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。</li><li><strong>jmeter</strong>  Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试。</li><li><strong>openssl</strong> 加解密能力也是CPU性能测试的一部分。</li><li><strong>UnixBench</strong> 类unix系(Unix,BSD,Linux)统下的性能测试工具</li><li><strong>lmbench</strong> 多平台软件，因此能够对同级别的系统进行比较测试，反映不同系统的优劣势，可用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能.</li><li><strong>perfbench</strong> perf下的工具 测试系统性能</li><li><strong>hping3</strong>  面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。</li><li><strong>iperf</strong> 网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。</li><li><strong>ping</strong>  向特定的目的主机发送 ICMP（Iternet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</li><li><strong>ttcp</strong>  传统的测试TCP性能的工具,它主要测试两个机器之间TCP的吞吐量(在应用层模拟消息传递的过程)</li><li><strong>traceroute</strong>  利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。</li><li><strong>mtr</strong> 网络连通性判断工具，它结合了ping, traceroute,nslookup 的相关特性</li><li><strong>pchar</strong> 沿Internet路径执行网络测量</li></ul><h3 id="调优工具-Tuning-Tools"><a href="#调优工具-Tuning-Tools" class="headerlink" title="调优工具(Tuning Tools)"></a>调优工具(Tuning Tools)</h3><ul><li><strong>sysctl</strong>  (System Administration)用来配置与显示在/proc/sys目录中的内核参数</li><li><strong>swapon</strong>  用于激活Linux中的交换空间，Linux的内存管理必须使用交换区来建立虚拟内存。</li><li><strong>env</strong> gnu的coreutils包内的一个软件，用来显示系统中已存在的环境变量,以及在定义的环境中执行指令。</li><li><strong>tune2fs</strong> 允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。</li><li><strong>ionice</strong>  获取或设置程序的IO调度与优先级。PRI(new)=PRI(default)+nice</li><li><strong>nice</strong>  调整程序运行的优先级，当前程序运行优先级基础之上调整指定值得到新的程序运行优先级。</li><li><strong>renice</strong>  重新指定一个或多个进程的优先级</li><li><strong>taskset</strong> 将某个进程与某个CPU核心绑定。</li><li><strong>ulimit</strong>  为shell内建指令，可用来控制shell执行程序的资源</li><li><strong>chcpu</strong>   修改cpu的状态,启用和关闭cpu，扫描新的CPU,改变底层虚拟机监控程序的CPU调度模式,并请求CPU的系统管理程序(配置)或返回CPU hypervisor</li><li><strong>numactl</strong> 用于控制进程与共享存储的 NUMA 技术机制。</li><li><strong>sysctl</strong>  用于运行时配置内核参数,这些参数位于/proc/sys目录下。</li><li><strong>ethtool</strong> 用于查询及设置网卡参数</li><li><strong>stap</strong> (SystemTap) 内核开发者必须要掌握的一个工具,用于内核监控和跟踪，以及诊断性能或功能问题。</li><li><strong>kpatch</strong>  给Linux内核动态打补丁但是不必重启系统</li></ul><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;静态性能分析工具-static-performance-analysis-tools&quot;&gt;&lt;a href=&quot;#静态性能分析工具-static-performance-analysis-tools&quot; class=&quot;headerlink&quot; title=&quot;静态性能分析工具(static performance analysis tools)&quot;&gt;&lt;/a&gt;静态性能分析工具(static performance analysis tools)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dmesg&lt;/strong&gt; 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;blockdev&lt;/strong&gt;  工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ldd&lt;/strong&gt; （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://stemha.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stemha.github.io/tags/Linux/"/>
    
      <category term="工具" scheme="https://stemha.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="性能分析" scheme="https://stemha.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《练习的心态》读书笔记</title>
    <link href="https://stemha.github.io/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://stemha.github.io/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-08T09:12:52.000Z</published>
    <updated>2020-04-09T07:04:13.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言-人生就是漫长的练习"><a href="#引言-人生就是漫长的练习" class="headerlink" title="引言　人生就是漫长的练习"></a>引言　人生就是漫长的练习</h2><h2 id="第1章-学习开始"><a href="#第1章-学习开始" class="headerlink" title="第1章　学习开始"></a>第1章　学习开始</h2><p>当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种<strong>没有压力的愉快与平和的体验</strong>，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。</p><a id="more"></a><p><strong>压力与焦虑主要来源于我们自己对目标的依恋。</strong><br>练习的心态这也是一种技能：尽可能迅速，最少的付出来发展任何一项技能的能力，以及在这个过程体验内心平和与愉悦的能力。</p><p>在不感到失败和焦虑的情况下去努力实现目标。<br>学习的渴望仅仅是第一步，需要正确理解技术性细节与努力，否则会耗尽的</p><p>当今的文化是多任务的，比如开车时第一件事会习惯性打开收音机。   而<code>滑冰</code>正相反，滑冰时候不会注意边上嘈杂的声音！<br>由于习惯于一心多用，我们大脑躁动不安，且具有极大惯性，没法安静下来。</p><p>练习的心态是安静的<br>意识是第一位的：没法控制自己的思维，不管设立什么样的目标，都没有用。我们对自己要去的方向就像<code>乘坐马车</code>，必须要拉紧思维的缰绳才行啊！<br>填补空虚是一个循环往复的过程</p><p><code>学会走路</code>的过程并不会在心里让你压力倍增。我们要意识并掌控这个过程，学会从中享受！</p><h2 id="第2章-以过程为导向，不以结果为导向"><a href="#第2章-以过程为导向，不以结果为导向" class="headerlink" title="第2章　以过程为导向，不以结果为导向"></a>第2章　以过程为导向，不以结果为导向</h2><p> 人生的悖论：耐心与自律的问题是，要培养它们中的任何一个，需要同时具备它们两个。</p><ul><li>简单法则</li><li>以过程为导向</li><li>重点关注当前</li><li>将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。</li></ul><p>对自己想要做的事情刻意训练，带着意图训练，并且自始至终清醒的知道那种意图</p><h2 id="第3章-关键是视角"><a href="#第3章-关键是视角" class="headerlink" title="第3章　关键是视角"></a>第3章　关键是视角</h2><p>当我们试图理解自己以及我们对人生中各种努力的痛苦挣扎时，可以通过观察一朵鲜花来找到平和。问你自己：一朵鲜花的生命，从撒下种子到完全盛开，在什么时候可以达到完美？</p><p>然后呢？ 达成目标之后，然后呢？然后又能干什么呢？？？？<br><code>初学者心态</code><br><code>鲜花的生命</code>，自始至终都是完美的</p><p><strong>他了解到，假如将自己的思绪集中在当前，并只专注了他在这一刻正在做的事情的过程，那便可以喜欢上他正在做的任何事情。</strong></p><h2 id="第4章-培养期望的习惯"><a href="#第4章-培养期望的习惯" class="headerlink" title="第4章　培养期望的习惯"></a>第4章　培养期望的习惯</h2><p>习惯是学来的。明智地选择它们。自己创造想要的习惯，不带情绪和判断的采取哪些行为，之后坚持下去。</p><blockquote><p>   就像一名优秀的老师，对待学生的错误不会情绪化，那种情绪化来源于自我期望，与结果和产物关联，如果你体验到这些情绪，就证明你没有专注于当前过程！！！</p></blockquote><p>怎么样阻止旧的习惯，采用一种例行行为来阻止，比如<code>击球前例动作</code></p><h2 id="第5章-感知变化，创造耐心！"><a href="#第5章-感知变化，创造耐心！" class="headerlink" title="第5章　感知变化，创造耐心！"></a>第5章　感知变化，创造耐心！</h2><p>你需要的所有耐心，都已经处在你的内心了。<br>知道什么时候内心疯狂奔走<br>接受什么事情不会尽善尽美</p><blockquote><p>放弃某种幸福和乐趣就在某个地方的徒劳想法</p></blockquote><p>在探索的道路上，除了去追求，没有别的可以达到的目标了//我们20岁的目标肯定与18岁的不同，参照对象也是不一样的，不要指望能达到你的目标。探索本身就是一种目标。</p><p>对于没有费力得到的东西，那种兴奋感在得到东西早已烟消云散。</p><p><code>得到目标</code>和<code>实现目标</code>是两种完全不同的概念<br>真正的愉悦 </p><h2 id="第6章-4“S”方法"><a href="#第6章-4“S”方法" class="headerlink" title="第6章　4“S”方法"></a>第6章　4“S”方法</h2><p>力求简化，将征服大多数复杂的任务。</p><ul><li>简化 </li><li>细分 </li><li>缩短 </li><li>放慢</li></ul><h2 id="第7章-平静与DOC方法"><a href="#第7章-平静与DOC方法" class="headerlink" title="第7章　平静与DOC方法"></a>第7章　平静与DOC方法</h2><p>客观是通往宁静心灵之路！</p><p>主观判断需要一个评估和对比的过程，这要求有一个相对的点，即理想状况<br>判断有一个不利的地方，它不会以一种超然的方式运行，常常会包含着某些情绪，有趣的是，对事情我们感觉到的重要性越多，我们带的情绪越多<br>将自我与观察者合并  。就像我们安慰他人时候带着的超然智慧一样。  怎么合并呢 冥想！</p><p>do observe correct<br>就像射箭运动员一样，安静，不复杂完全没有心理的杂乱</p><h2 id="第8章-教孩子，也从孩子身上学习"><a href="#第8章-教孩子，也从孩子身上学习" class="headerlink" title="第8章　教孩子，也从孩子身上学习"></a>第8章　教孩子，也从孩子身上学习</h2><p>智慧并不是年龄的副产物。从你身边所有的人身上学习，同时也用自己的行为影响身边的人。</p><h2 id="第9章-你的技能在成长"><a href="#第9章-你的技能在成长" class="headerlink" title="第9章　你的技能在成长"></a>第9章　你的技能在成长</h2><p>有了刻意的和反复的努力，进步便水到渠成。</p><blockquote><p>   如果说各种软件上的信息不能使你知识变得丰富，那么你就不需要它们</p></blockquote><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言-人生就是漫长的练习&quot;&gt;&lt;a href=&quot;#引言-人生就是漫长的练习&quot; class=&quot;headerlink&quot; title=&quot;引言　人生就是漫长的练习&quot;&gt;&lt;/a&gt;引言　人生就是漫长的练习&lt;/h2&gt;&lt;h2 id=&quot;第1章-学习开始&quot;&gt;&lt;a href=&quot;#第1章-学习开始&quot; class=&quot;headerlink&quot; title=&quot;第1章　学习开始&quot;&gt;&lt;/a&gt;第1章　学习开始&lt;/h2&gt;&lt;p&gt;当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种&lt;strong&gt;没有压力的愉快与平和的体验&lt;/strong&gt;，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://stemha.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="练习" scheme="https://stemha.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
      <category term="心态" scheme="https://stemha.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>成为一个不惑、不忧、不惧的人</title>
    <link href="https://stemha.github.io/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/"/>
    <id>https://stemha.github.io/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/</id>
    <published>2020-03-29T11:48:51.000Z</published>
    <updated>2020-03-29T12:28:26.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。</p></blockquote><a id="more"></a>     <h2 id="演讲全文"><a href="#演讲全文" class="headerlink" title="演讲全文"></a>演讲全文</h2><p>诸君!我在南京讲学将近三个月了，这边苏州学界里，有好几回写信邀我，可惜我在南京是天天有功课的，不能分身前来。今天到这里，能够和全城各校诸君聚在一堂，令我感激的很，但有一件，还要请诸君原谅：因为我一个月以来，都带着些病，勉强支持，今天不能作很长的讲演，恐怕有负诸君期望哩。</p><p>问诸君“为什么进学校?”</p><p>我想人人都会众口一词的答道：“为的是求学问”。再问：“你为什么要求学问?”“你想学些什么?”恐怕各人的答案就很不相同，或者竟自答不出来了。诸君啊!我替你们回答一句罢：“为的是学做人。”你在学校里头学的什么数学、几何、物理、化学、生理、心理、历史、地理、国文、英语，乃至什么哲学、文学、科学、政治、法律、经济、教育、农业、工业、商业等等，不过是做人所需的一种手段，不能说专靠这些便达到做人的目的，任凭你把这些件件学的精通，你能够成个人不成个人还是个问题。</p><p>人类心理，有知、情、意三部分。这三部分圆满发达的状态，我们先哲名为三达德——智、仁、勇。为什么叫做“达德”呢?因为这三件事是人类普通道德的标准，总要三个具备，才能成一个人。三件的完成状态怎么样呢?孔子说：<strong>“知者不惑，仁者不忧，勇者不惧。”</strong>所以教育应分为知育、情育、意育三方面，——现在讲的智育、德育、体育不对，德育范围太笼统，体育范围太狭隘——<strong>知育要教到人不惑，情育要教到人不忧，意育到教到人不惧。</strong>教育家教育学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。</p><h3 id="1-怎么样才能不惑呢"><a href="#1-怎么样才能不惑呢" class="headerlink" title="1. 怎么样才能不惑呢?"></a>1. 怎么样才能不惑呢?</h3><p><strong>最要紧的是养成我们的判断力</strong>。<u>想要养成判断力，第一步，最少须有相当的常识，进一步，对于自己要做的事须有专门智识，再进一步，还要有遇事能断的智慧。</u></p><p>假如一个人连常识都没有，听见打雷，说是雷公发威，看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，碰到一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。学校里小学中学所教，就是要人有了许多基本的知识，免得凡事都暗中摸索。</p><p>但仅仅有点常识还不够，我们做人，总要各有一件专门职业。这门职业，也并不是我一人破天荒去做，从前已经许多人做过，他们积累了无数经验，发现出好些原理原则，这就是<code>专门学识</code>。<u>我打算做这项职业，就应该有这项专门的学识。</u>例如我想做农吗，怎么的改良土壤，怎么的改良种子，怎么的防御水旱病虫，等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。做工、做商等等都各有他的专门学识，也是如此。我想做财政家吗，何种租税可以生出何样结果，何种公债可以生出何样结果等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。教育家、军事家等等，都各有他的专门学说，也是如此。</p><p>我们在高等以上学校所求的知识，就是这一类。但专靠这种常识和学识就够吗?还不能。宇宙和人生是活的不是呆的，我们每日碰见的事理是复杂的变化的，不是单纯的刻板的，倘若我们只是学过这一件，才懂这一件，那么，碰着一件没有学过的事来到跟前，便手忙脚乱了。</p><p>所以还要<strong>养成总体的智慧，才能有根本的判断力</strong>。这种<code>总的智慧如何才能养成呢?</code><u>第一件，要把我们向来粗浮的脑筋着实磨炼他，叫他变成细密而且踏实。那么，无论遇着如何繁难的事，我都可以彻头彻尾想清楚他的条理，自然不至于惑了。</u></p><p>第二件，要把我们向来浑浊的脑筋，着实将养他，叫他变成清明。那么，一件事理到跟前，我才能很从容很莹澈的去判断他，自然不至于惑了。以上所说常识学识和总体的智慧，都是<code>知育</code>的要件，目的是教人做到<code>“知者不惑”</code>。</p><h3 id="2-怎么样才能不忧呢"><a href="#2-怎么样才能不忧呢" class="headerlink" title="2. 怎么样才能不忧呢?"></a>2. 怎么样才能不忧呢?</h3><p>为什么仁者便会不忧呢?想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么?很难用言语说明，勉强下个解释，可以说是：“普遍人格之实现。”孔子说：“仁者人也。”意思是说<code>人格完成就叫做“仁”</code>。</p><p>但我们要知道，人格不是单独一个人可以表现的，要从人和人的关系上来看。所以仁字从二人，郑康成解他做“相人偶”。<strong>总而言之，要彼此交感互发，成为一体，然后我的人格才能实现。</strong>所以我们若不讲人格主义，那便无话可说;讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我们的人格，和宇宙无二区别，体验得这个道理，就叫做“仁者”。然则这种仁者为什么就会不忧呢?<strong>大凡忧之所从来，不外两端，一曰忧成败，二曰忧得失。</strong>我们得着“仁”的人生观，就不会忧成败。为什么呢?因为我们知道宇宙和人生是永远不会圆满的，所以《易经》六十四卦，始“乾”而终“未济”。正为在这永远不会圆满的宇宙中，才永远容得我们创造进化。</p><p><strong>我们所做的事，不过在宇宙进化几万万里的长途中，往前挪一寸，两寸，那里配说成功呢?然则不做怎么样呢?不做便连这一寸都不往前挪，那可真是失败了。</strong></p><p>“仁者”看透这种道理，信得过只有不做事才算失败，肯做事便不会失败。所以《易经》说：“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的几万万里路挪了一两寸，算成功吗?所以《论语》：<strong>“知其不可而为之。”你想，有这种人生观的人，还有什么成败可忧呢?</strong></p><p>再者，我们得着“仁”的人生观，便不会忧得失。为什么呢?因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则哪里有东西可以为我们所得?既已没有东西为我所得，当然也没有东西为我所失。</p><p>我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等做手段来达某种目的——可以为我们“所得”得。所以老子说：“生而不有，为而不恃。”“既以为人已愈有，既以与人已愈多。”你想，有这种人生观的人，还有什么得失可忧呢?总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无人而不自得”。他的生活，纯然是趣味化艺术化。这是最高的情感教育，目的教人做到“仁者不忧”。</p><h3 id="3-怎么样才能不惧呢"><a href="#3-怎么样才能不惧呢" class="headerlink" title="3. 怎么样才能不惧呢?"></a>3. 怎么样才能不惧呢?</h3><p>有了不惑不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便会有丰富的智识，临时也会用不着，便有优美的情操，临时也会变了卦。然则意志怎么会才坚强呢?头一件须要心地光明，孟子说：“浩然之气，至大至刚。行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不惴焉;自反而缩，虽千万人，吾往矣。”</p><p>俗话说得好：“生平不作亏心事，夜半敲门心不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一着。第二件要不为劣等欲望之所牵制。</p><p>《论语》记：子曰：“吾未见刚者。”或对曰伸枨。子曰：“枨也欲，焉刚。”一被物质上无聊得嗜欲东拉西扯，那么百炼成刚也会变成绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。</p><p>自己作不起自己的主，还有什么事可做?受别人压制，做别人奴隶，自己只要肯奋斗，终必能恢复自由。自己的意志做了自己情欲的奴隶，那么，真是万劫沉沦，永无恢复自由的余地，终身畏首畏尾，成了个可怜人了。</p><p>孔子说：“和而不流，强哉矫;中立而不倚，强哉矫。国有道，不变塞焉，强哉矫;国无道，至死不变，强哉矫。”我老实告诉诸君说罢，做人不做到如此，决不会成一个人。但做到如此真是不容易，非时时刻刻做磨炼意志的功夫不可，<strong>意志磨炼得到家，自然是看着自己应做得事，一点不迟疑，扛起来便做，“虽千万人吾往矣。”这样才算顶天立地做一世人，绝不会有藏头躲尾左支右绌的丑态。这便是<code>意育</code>的目的，要教人做到“勇者不惧”</strong>。</p><p>我们拿这三件事作做人的标准，请诸君想想，我自己现时做到哪一件——哪一件稍微有一点把握。倘若连一件都不能做到，连一点把握都没有，嗳哟!那可真危险了，你将来做人恐怕做不成。讲到学校里的教育吗，第二层的情育，第三层的意育，可以说完全没有，剩下的只有第一层的知育。就算知育罢，又只有所谓常识和学识，至于我所讲的总体智慧靠来养成根本判断力的，却是一点儿也没有。</p><p>这种“贩卖知识杂货店”的育，把他前途想下去，真令人不寒而栗!现在这种教育，一时又改革不来，我们可爱的青年，除了他更没有可以受教育的地方。诸君啊!你到底还要做人不要?你要知道危险呀，非你自己抖擞精神方法自救，没有人救你呀!</p><p>诸君啊!你千万别要以为得些断片的智识，就算是有学问呀。我老实不客气告诉你罢;你如果做成一个人，知识自然是越多越好：你如果做不成一个人，知识却是越多越坏。你不信吗?试想想全国人所唾骂的卖国贼某人某人，是有智识的呀，还是没有智识的呢?试想想全国人所痛恨的官僚政客——专门助军阀作恶鱼肉良民的人，是有智识的呀，还是没有智识的呢?诸君须知道啊，这些人当十几年前在学校的时代，意气横历，天真烂漫，何尝不和诸君一样?为什么就会堕落到这样的田地呀?</p><p>屈原说：“何昔日之芳草兮，今直为此萧艾也!岂其有他故兮，莫好修之害也。”天下最伤心的事，莫过于看着一群好好的青年，一步一步的往坏路上走。诸君猛醒啊!现在你所厌所恨的人，就是你前车之鉴了。</p><p>诸君啊!你现在怀疑吗?沉闷吗?悲哀痛苦吗?觉得外边的压迫你不能抵抗吗?我告诉你：你怀疑和沉闷，便是你因不知才会惑;你悲哀痛苦，便是你因不仁才会忧;你觉得你不能抵抗外界的压迫，便是你因不勇才有惧。这都是你的知、情、意未经过修养磨炼，所以还未成个人。我盼望你有痛切的自觉啊!有了自觉，自然会成功。那么，学校之外，当然有许多学问，读一卷经，翻一不史，到处都可以发现诸君的良师呀!</p><p>诸君啊，醒醒罢!养足你的根本智慧，体验出你的人格人生观，保护好你的自由意志。你成人不成人，就看这几年哩!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="醒世通言" scheme="https://stemha.github.io/categories/%E9%86%92%E4%B8%96%E9%80%9A%E8%A8%80/"/>
    
    
      <category term="演讲" scheme="https://stemha.github.io/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="人生" scheme="https://stemha.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>学术论文的基本结构</title>
    <link href="https://stemha.github.io/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>https://stemha.github.io/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-29T10:14:24.000Z</published>
    <updated>2020-04-09T07:12:32.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ol><li><strong>标题</strong><ul><li>真实反应论文内容 </li><li>简短明了 </li><li>吸引人</li><li>大背景 </li><li>小背景</li><li>技术特色<a id="more"></a>    </li></ul></li></ol><ol start="2"><li><strong>摘要</strong></li></ol><ul><li>概括你的研究</li><li>假设或要研究的问题</li><li>研究方法 </li><li>主要成果</li></ul><ol start="3"><li><strong>引言</strong></li></ol><ul><li><p>说明选题的背景，目的，意义</p></li><li><p>陈述研究的主要内容和论文的假说或研究问题</p></li><li><p>文章的研究方法与章节编排</p></li></ul><ol start="4"><li><strong>文献综述</strong></li></ol><ul><li>阐述前人的研究，展示文献批判能力，说明你对研究问题的掌握程度，表明你研究的创新之处。</li></ul><ol start="5"><li><strong>研究方法</strong></li></ol><ul><li>详细介绍相关信息，便于读者采取同样的方法能够重复此项研究。</li><li>研究性质</li><li>对象</li><li>步骤</li><li>工具</li><li>条件</li><li>…</li></ul><ol start="6"><li><strong>研究结果</strong></li></ol><ul><li>用文字和/或图表真实报告你获得的数据或结果。</li></ul><ol start="7"><li><strong>讨论</strong></li></ol><ul><li>基于你获得的数据论述对于研究问题可能得到的结论。</li></ul><ol start="8"><li><strong>结论</strong></li></ol><ul><li>简明总结所得到的数据，得出的结论及意义。</li><li>说明研究的价值，不足或局限性。</li></ul><ol start="9"><li><strong>致谢</strong></li></ol><ol start="10"><li><strong>参考文献</strong></li></ol><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;真实反应论文内容 &lt;/li&gt;
&lt;li&gt;简短明了 &lt;/li&gt;
&lt;li&gt;吸引人&lt;/li&gt;
&lt;li&gt;大背景 &lt;/li&gt;
&lt;li&gt;小背景&lt;/li&gt;
&lt;li&gt;技术特色&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学术论文" scheme="https://stemha.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="学术论文" scheme="https://stemha.github.io/tags/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
      <category term="基本结构" scheme="https://stemha.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>好用的chrome插件</title>
    <link href="https://stemha.github.io/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/"/>
    <id>https://stemha.github.io/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/</id>
    <published>2020-03-29T09:29:48.000Z</published>
    <updated>2020-04-09T07:12:51.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。</p></blockquote><h2 id="Awesome-Autocomplete-for-GitHub"><a href="#Awesome-Autocomplete-for-GitHub" class="headerlink" title="Awesome Autocomplete for GitHub"></a>Awesome Autocomplete for GitHub</h2><p>增强github的搜索功能</p><a id="more"></a>     <h2 id="Git-History-Browser-Extension"><a href="#Git-History-Browser-Extension" class="headerlink" title="Git History Browser Extension"></a>Git History Browser Extension</h2><p>查看github的历史更新记录，超级好用，可以对比不同人对代码做的更新；</p><h2 id="octotree"><a href="#octotree" class="headerlink" title="octotree"></a>octotree</h2><p>可以查看github的目录结构，并且下载单个的文件；</p><h2 id="Sourcegraph"><a href="#Sourcegraph" class="headerlink" title="Sourcegraph"></a>Sourcegraph</h2><p>可以查看相关的代码，搜索代码，查找代码定义的地方</p><h2 id="The-Great-Suspender"><a href="#The-Great-Suspender" class="headerlink" title="The Great Suspender"></a>The Great Suspender</h2><p>休眠chrome不必要的标签页</p><h2 id="Tab-Resize-split-screen-layouts"><a href="#Tab-Resize-split-screen-layouts" class="headerlink" title="Tab Resize - split screen layouts"></a>Tab Resize - split screen layouts</h2><p>浏览器分屏</p><p><img src="/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/chrome-plug-in-components.png" alt="avatar"></p><h2 id="本文许可证"><a href="#本文许可证" class="headerlink" title="本文许可证"></a>本文许可证</h2><p>本文遵循 <a href="https://github.com/huihut/interview/blob/master/LICENSE">CC BY-NC-SA 4.0</a>（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。<br><a href="LICENSE"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmNyZWF0aXZlY29tbW9ucy5vcmcvbC9ieS1uYy1zYS80LjAvODh4MzEucG5n?x-oss-process=image/format,png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Awesome-Autocomplete-for-GitHub&quot;&gt;&lt;a href=&quot;#Awesome-Autocomplete-for-GitHub&quot; class=&quot;headerlink&quot; title=&quot;Awesome Autocomplete for GitHub&quot;&gt;&lt;/a&gt;Awesome Autocomplete for GitHub&lt;/h2&gt;&lt;p&gt;增强github的搜索功能&lt;/p&gt;
    
    </summary>
    
    
      <category term="效率工具" scheme="https://stemha.github.io/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="生产力" scheme="https://stemha.github.io/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="插件" scheme="https://stemha.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="chrome" scheme="https://stemha.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>《苏菲的世界》读书笔记</title>
    <link href="https://stemha.github.io/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://stemha.github.io/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-28T16:40:11.000Z</published>
    <updated>2020-04-13T15:44:43.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伊甸园-在某个时刻事物必然从无到有"><a href="#伊甸园-在某个时刻事物必然从无到有" class="headerlink" title="伊甸园　在某个时刻事物必然从无到有"></a>伊甸园　在某个时刻事物必然从无到有</h2><p>你是谁？<br>世界从何处来？<br>    要么一直存在<br>    要么从无到有<br>        比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。</p><p>生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。</p><a id="more"></a><h2 id="魔术师的礼帽-要成为一个优秀的哲学家只有一个条件：要有好奇心"><a href="#魔术师的礼帽-要成为一个优秀的哲学家只有一个条件：要有好奇心" class="headerlink" title="魔术师的礼帽　要成为一个优秀的哲学家只有一个条件：要有好奇心"></a>魔术师的礼帽　要成为一个优秀的哲学家只有一个条件：要有好奇心</h2><p>哲学是什么？<br>天底下有没有一种东西是所有人都感兴趣的呢？有的！当人的基本需求（比如衣食住行，亲情爱情，爱与关怀等）满足之后，还有一些东西是人人都需要的，那就是明白我们是谁，我们为何在这里。宇宙，地球与生命是如何产生的？</p><p><u>探讨哲学的最好方式就是问一些哲学性的问题，如：这世界是如何创造出来的？其背后是否有某种一直或者意义？人死后还有生命吗？我们如何能够解答这些问题呢？最重要的是，我们应该如何生活？</u><br>我们无法从百科全书上得到这些答案，不过读一读别人的意见倒可以帮助我们建立自己对于生命的看法。</p><p>哲学家追求真理的过程很想一步侦探小说，对于案件，警方有时候可以侦破，但也有可能永远无法查出真相（虽然在某个地方一定有一个破案的办法）。因此，即使要回答一个问题很不容易，但无论如何总会有一个（且仅此一个）正确答案的。比如人死后要么就是透过某种形式存在，要不就是根本不在存在。</p><p>作者很好的比喻：许多人对于这个世界的种种也同样有种不可置信的感觉，就像我们看到魔术师突然从一顶原本空空如也的帽子里拉出一只小兔子一般。实际上我们就生活在这个世界上，是这个世界的一部分。形象的比喻一下，我们就是那只从礼帽里面变出的小兔子的一部分，小兔子可以比作是是整个宇宙，而我们则是寄居在小兔子身上的小小生物，但是我们和兔子不同的是，小兔子可不知道自己参与了一场魔术表演，而我们知道自己是某种神秘事物的一部分，我们想了解其中的奥秘；哲学家们总是试图沿着兔子的细毛往上爬，以便将魔术师的看个清楚；</p><h2 id="神话-善与恶之间脆弱的平衡"><a href="#神话-善与恶之间脆弱的平衡" class="headerlink" title="神话　善与恶之间脆弱的平衡"></a>神话　善与恶之间脆弱的平衡</h2><p>神话的世界观<br>    北欧<br>            （挪威）索尔和铁锤   北欧人相信人类居住的这部分是一部分岛屿，名为米德加德(Midgard)，也就是”中央王国“的意思，在这个中央王国内，有一个地方名叫阿斯加德（Asgard），乃是诸神的领地。中央王国之外，有一个叫乌特加德（Utgard），是狡猾的巨人居住的地方。<br>                象征肥沃多产的额女神芙瑞雅<br>                侍童洛奇<br>                《史莱慕之诗》  巨人之王史莱慕<br>希腊  公元前700左右，有一大部分希腊神话被荷马与赫西俄德（赫西俄德Hesiod以长诗《工作与时日》《神谱》闻名于后世，被称为“希腊训谕诗之父”。）记录下来。</p><p><code>赞诺芬尼司(Xnphans)</code>,古希腊哲学家。是早期批评荷马的神话的哲学家之一。 赞诺芬尼斯_百度百科  他指出人类按照自己的形象创造出这些天神。</p><p>随后这段期间，希腊人在希腊本土与意大利南部，小亚细亚等希腊殖民地建立了许多城市。在这些城市中，所有劳力工作由奴隶担任，因此市民有充分的闲暇，可以将所有的时间投注在政治与文化上；这时候的人们思考方式与以前大不相同，无需借助神话而提出一些哲学性的问题；<br>我们称这样的现象为“从神话的思考模式发展到以经验与理性为基础的思考模式”</p><h2 id="自然派哲学家-没有一件事物可以来自空无"><a href="#自然派哲学家-没有一件事物可以来自空无" class="headerlink" title="自然派哲学家　没有一件事物可以来自空无"></a>自然派哲学家　没有一件事物可以来自空无</h2><p>万事万物是否有一种基本的物质组成？<br>哲学家的课题：每个人关注和质疑的事项是什么？<br>了解了每一位哲学家的课题之后，我们就比较容易了解他的思想脉络，因为没有任何一位哲学家会企图探讨哲学的所有领域。</p><p>自然派哲学家<br>关注的课题是“大自然与它的循环和变化”<br>最重要的是，他们想要透过对大自然本身的研究来了解实际的变化过程，而不是借助神话来解释。<br>这样，哲学逐渐脱离了宗教的范畴。自然派哲学家朝科学推理的方向迈出了第一步，成为后来科学的先驱。</p><p>米雷特斯的三位哲学家<br>泰利斯<br>安娜克西曼德<br>安那西梅尼斯</p><p>没有任何事物会来自于虚无<br>帕梅尼德斯（约公元前540年~公元前480年）<br>他认为：</p><ol><li>没有任何事物会改变。</li><li>因此我们的感官认知是不可靠的</li></ol><p>理性主义：坚决相信人的理智的态度<br>理性主义者：百分百相信人类的理智是时间所有知识源泉的人</p><p>所有的事物都是流动的<br>赫拉克里德斯（约公元前540年~公元前480年）<br>他认为：</p><ol><li>万物都会改变（”一切事物都是流动的“）</li><li>我们的感官认知是可靠的</li></ol><p>恩培窦克里斯（西西里）<br>恩培窦克里斯认为帕梅尼德斯与赫拉克里德斯各有一点是对的，也各有一点是错的，造成这个根本性差异的原因是之前的两人都认定世间只有一种元素存在。<br>恩培窦克里斯认为：</p><ol><li>没有任何事物会改变。</li><li>我们的感官认知是可靠的</li></ol><p>恩培窦克里斯的结论是：大自然不可能只有一种元素构成。</p><p>安纳萨格拉斯（约公元前500年~公元前428年）</p><h2 id="德谟克里特斯-世界上最巧妙的玩具"><a href="#德谟克里特斯-世界上最巧妙的玩具" class="headerlink" title="德谟克里特斯　世界上最巧妙的玩具"></a>德谟克里特斯　世界上最巧妙的玩具</h2><blockquote><p>   积木为何是世界上最巧妙的玩具？</p></blockquote><p>原子理论<br>德谟克里特斯（约公元前460年~公元前370年，来自爱琴海北部海岸的阿布拉德小镇）</p><p><code>唯物论者</code>：只相信物质的东西。</p><h2 id="命运-算命者试图预测某些事实上极不可测的事物"><a href="#命运-算命者试图预测某些事实上极不可测的事物" class="headerlink" title="命运　算命者试图预测某些事实上极不可测的事物"></a>命运　算命者试图预测某些事实上极不可测的事物</h2><p>古希腊的德尔菲（Delphi）神论与宿命论 现在看来都是迷信</p><p>历史与医学<br>历史上最早的一批历史学家开始为历史事件寻求合理的解释。<br>贺若多陀斯（约公元前484年~公元前424年）与修西德底斯（约公元前460年~公元前400年）</p><p>在希腊哲学、历史学发展的同时，希腊医学兴起，其目的是为了疾病与健康寻求合乎自然的解释。<br>希波克拉底（约公元前460~公元前377年，生于寇斯岛，希腊医学始祖）<br>比较出名的是希波克拉底誓言：</p><blockquote><p>我将依照自身的能力与判断，采用对病人有利的疗法与处方，绝不施以有害或有毒之物。无论应何人之请，我也绝不给与致命药物或做此类之建议，也绝不协助妇女堕胎。进入病家访视时，我将以病人的福祉为念，不做任何贪渎害人之事，不受男女奴仆之引诱。我在执业时之所见所闻，反不应泄露者，我将严予保密。若我遵行此一誓言，不懈不怠，愿上苍使我乐享生命、精进医事并受世人敬重。若我违反誓言，愿我遭相反之命运。</p></blockquote><h2 id="苏格拉底-最聪明的是明白自己无知的人"><a href="#苏格拉底-最聪明的是明白自己无知的人" class="headerlink" title="苏格拉底　最聪明的是明白自己无知的人"></a>苏格拉底　最聪明的是明白自己无知的人</h2><blockquote><p>是否有人天生就很害羞呢？<br>最聪明的是明白自己无知的人。<br>真正的智慧来自内心。<br>明白是非者必能够进退合宜。</p></blockquote><p>雅典的哲学<br>以人为中心<br>苏格拉底是谁？<br>谈话的艺术</p><p>“苏格拉底式的反讽”<br>神圣的声音<br>雅典的小丑<br>正确的见解导致正确的行动</p><h2 id="雅典-废墟中升起了几栋高楼"><a href="#雅典-废墟中升起了几栋高楼" class="headerlink" title="雅典　废墟中升起了几栋高楼"></a>雅典　废墟中升起了几栋高楼</h2><h2 id="柏拉图-回归灵魂世界的渴望"><a href="#柏拉图-回归灵魂世界的渴望" class="headerlink" title="柏拉图　回归灵魂世界的渴望"></a>柏拉图　回归灵魂世界的渴望</h2><p>柏拉图学院<br>永远的真善美<br>理型的世界<br>真正的知识<br>不朽的灵魂<br>走出黑暗的洞穴（洞穴神话）<br>哲学之国（理想国）</p><h2 id="少校的小木屋-镜中的女孩双眼眨了一眨"><a href="#少校的小木屋-镜中的女孩双眼眨了一眨" class="headerlink" title="少校的小木屋　镜中的女孩双眼眨了一眨"></a>少校的小木屋　镜中的女孩双眼眨了一眨</h2><h2 id="亚力士多德-一位希望澄清我们观念的严谨的逻辑学家"><a href="#亚力士多德-一位希望澄清我们观念的严谨的逻辑学家" class="headerlink" title="亚力士多德　一位希望澄清我们观念的严谨的逻辑学家"></a>亚力士多德　一位希望澄清我们观念的严谨的逻辑学家</h2><p>逻辑<br>亚里士多德创立了逻辑学这门学科，他以实例显示我们在得出合乎逻辑的结论或证明时，必须遵循若干法则。</p><h2 id="希腊文化-一丝火花"><a href="#希腊文化-一丝火花" class="headerlink" title="希腊文化　一丝火花"></a>希腊文化　一丝火花</h2><p>生命与容忍的哲学<br>宗教，哲学与科学</p><p>犬儒学派</p><p>斯多葛学派</p><p>伊比鸠鲁学派</p><p>新柏拉图派哲学<br>神秘主义</p><h2 id="明信片-我对自己实施严格的检查制度"><a href="#明信片-我对自己实施严格的检查制度" class="headerlink" title="明信片　我对自己实施严格的检查制度"></a>明信片　我对自己实施严格的检查制度</h2><h2 id="两种文化-避免在真空中飘浮的唯一方式"><a href="#两种文化-避免在真空中飘浮的唯一方式" class="headerlink" title="两种文化　避免在真空中飘浮的唯一方式"></a>两种文化　避免在真空中飘浮的唯一方式</h2><p>印欧文化</p><p>闪族文化</p><h2 id="中世纪-对了一部分并不等于错"><a href="#中世纪-对了一部分并不等于错" class="headerlink" title="中世纪　对了一部分并不等于错"></a>中世纪　对了一部分并不等于错</h2><h2 id="文艺复兴-啊！藏在凡俗身躯里的神明子孙哪"><a href="#文艺复兴-啊！藏在凡俗身躯里的神明子孙哪" class="headerlink" title="文艺复兴　啊！藏在凡俗身躯里的神明子孙哪"></a>文艺复兴　啊！藏在凡俗身躯里的神明子孙哪</h2><p>实证法：以亲身的经验，而不是以古人的著作或凭空想象来作为知识的基础。</p><h2 id="巴洛克时期-宛如梦中的事物"><a href="#巴洛克时期-宛如梦中的事物" class="headerlink" title="巴洛克时期　宛如梦中的事物"></a>巴洛克时期　宛如梦中的事物</h2><h2 id="笛卡尔-他希望清除工地上所有的瓦砾"><a href="#笛卡尔-他希望清除工地上所有的瓦砾" class="headerlink" title="笛卡尔　他希望清除工地上所有的瓦砾"></a>笛卡尔　他希望清除工地上所有的瓦砾</h2><h2 id="斯宾诺莎-上帝不是一个傀儡戏师傅"><a href="#斯宾诺莎-上帝不是一个傀儡戏师傅" class="headerlink" title="斯宾诺莎　上帝不是一个傀儡戏师傅"></a>斯宾诺莎　上帝不是一个傀儡戏师傅</h2><h2 id="洛克-赤裸、空虚一如教师来到教室前的黑板"><a href="#洛克-赤裸、空虚一如教师来到教室前的黑板" class="headerlink" title="洛克　赤裸、空虚一如教师来到教室前的黑板"></a>洛克　赤裸、空虚一如教师来到教室前的黑板</h2><h2 id="休姆-将它付之一炬"><a href="#休姆-将它付之一炬" class="headerlink" title="休姆　将它付之一炬"></a>休姆　将它付之一炬</h2><p>如果我们手里有一本书，我们应该问：书里是否有包含任何与数量和数目有关的抽象思考？如果答案是没有，那么我们应该再问：书里是否包含任何与事实有关的经验性思考？如果答案是没有，那么我们还是将它付之一炬吧，因为这样的书纯粹是诡辩和幻想。</p><p>印象<br>观念</p><p>不可知论者：不持肯定或否定的态度，持怀疑态度。</p><h2 id="柏克莱-宛如燃烧的恒星旁一颗晕眩的行星"><a href="#柏克莱-宛如燃烧的恒星旁一颗晕眩的行星" class="headerlink" title="柏克莱　宛如燃烧的恒星旁一颗晕眩的行星"></a>柏克莱　宛如燃烧的恒星旁一颗晕眩的行星</h2><h2 id="柏客来-曾祖母向一名吉普赛妇人买的一面古老魔镜"><a href="#柏客来-曾祖母向一名吉普赛妇人买的一面古老魔镜" class="headerlink" title="柏客来　曾祖母向一名吉普赛妇人买的一面古老魔镜"></a>柏客来　曾祖母向一名吉普赛妇人买的一面古老魔镜</h2><h2 id="启蒙-从制针的技术到铸造大炮的方法"><a href="#启蒙-从制针的技术到铸造大炮的方法" class="headerlink" title="启蒙　从制针的技术到铸造大炮的方法"></a>启蒙　从制针的技术到铸造大炮的方法</h2><h2 id="康德-头上闪烁的星空与心中的道德规范"><a href="#康德-头上闪烁的星空与心中的道德规范" class="headerlink" title="康德　头上闪烁的星空与心中的道德规范"></a>康德　头上闪烁的星空与心中的道德规范</h2><h2 id="浪漫主义-神秘之路通向内心"><a href="#浪漫主义-神秘之路通向内心" class="headerlink" title="浪漫主义　神秘之路通向内心"></a>浪漫主义　神秘之路通向内心</h2><h2 id="黑格尔-可以站得住脚的就是有道理的"><a href="#黑格尔-可以站得住脚的就是有道理的" class="headerlink" title="黑格尔　可以站得住脚的就是有道理的"></a>黑格尔　可以站得住脚的就是有道理的</h2><h2 id="祁克果-欧洲正迈向破产的地步"><a href="#祁克果-欧洲正迈向破产的地步" class="headerlink" title="祁克果　欧洲正迈向破产的地步"></a>祁克果　欧洲正迈向破产的地步</h2><p>主观的真理<br>可以测算的真理<br>我信因为荒谬<br>个体主义者</p><h2 id="马克思-在欧洲游荡的幽灵"><a href="#马克思-在欧洲游荡的幽灵" class="headerlink" title="马克思　在欧洲游荡的幽灵"></a>马克思　在欧洲游荡的幽灵</h2><h2 id="达尔文-满载基因航行过生命的一艘小船"><a href="#达尔文-满载基因航行过生命的一艘小船" class="headerlink" title="达尔文　满载基因航行过生命的一艘小船"></a>达尔文　满载基因航行过生命的一艘小船</h2><h2 id="弗洛伊德-他内心出现那股令人讨厌的自大的冲动"><a href="#弗洛伊德-他内心出现那股令人讨厌的自大的冲动" class="headerlink" title="弗洛伊德　他内心出现那股令人讨厌的自大的冲动"></a>弗洛伊德　他内心出现那股令人讨厌的自大的冲动</h2><p>弗洛伊德发展了所谓的深度心理学或精神分析<br>弗洛依德主张人和他的环境之间不断有一种紧张关系存在。这种紧张关系（也就是冲突）尤其存在于他的驱策力，需要和社会之间。<br>基本需求可能会被伪装和升华；<br>快乐原则/本我<br>现实原则/自我<br>这世界的道德规范已经成为我们内心的一部分/成为超我<br>潜意识:我们并不一定能够意识到我们曾经有过的各种经验。但那些只要我们“用心想便可以记起来的想法或经验”通常是指被压抑的想法或经验。<br>不错的比喻：演讲厅说话<br>演讲厅称为”意识“，演讲厅之外称为“潜意识”；<br>大声喧哗者被”压抑“，椅子堵住门口作为”防御“</p><p>我们的感觉和行为会受到“潜意识的鼓动”<br>这类机制有好几种：比如<br>“说溜了嘴”<br>“合理化”我们自己也不愿意承认，也不愿意告诉别人我们做一件事的真正动机，因为这个动机是让人无法接受的。–&gt;”两面式沟通“的经验<br>“投射”把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较。<br>如何对抗不愉快的经历呢？弗洛伊德发展出一个”自由联想“的技巧。<br>梦的解析<br>显梦 mainfest dream     潜梦意念<br>把潜梦意念转换成显梦面向的工作，他称之为“梦的运作”<br>超现实主义</p><p>灵感：潜意识的盖子被打开了，好像我们突然所想的东西是来自某种外部的源泉似的。<br>创作的过程是想象与理性细密交织的时刻</p><p>想象力也许可以创造新的事物，但是却不能加以挑选，这时候理智就发挥作用了！</p><h2 id="我们这个时代-人是注定要受自由之苦的"><a href="#我们这个时代-人是注定要受自由之苦的" class="headerlink" title="我们这个时代　人是注定要受自由之苦的"></a>我们这个时代　人是注定要受自由之苦的</h2><h2 id="花园宴会-一只白色的乌鸦"><a href="#花园宴会-一只白色的乌鸦" class="headerlink" title="花园宴会　一只白色的乌鸦"></a>花园宴会　一只白色的乌鸦</h2><h2 id="对位法-两首或多首旋律齐响"><a href="#对位法-两首或多首旋律齐响" class="headerlink" title="对位法　两首或多首旋律齐响"></a>对位法　两首或多首旋律齐响</h2><h2 id="那轰然一响-我们也是星尘"><a href="#那轰然一响-我们也是星尘" class="headerlink" title="那轰然一响　我们也是星尘"></a>那轰然一响　我们也是星尘</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;伊甸园-在某个时刻事物必然从无到有&quot;&gt;&lt;a href=&quot;#伊甸园-在某个时刻事物必然从无到有&quot; class=&quot;headerlink&quot; title=&quot;伊甸园　在某个时刻事物必然从无到有&quot;&gt;&lt;/a&gt;伊甸园　在某个时刻事物必然从无到有&lt;/h2&gt;&lt;p&gt;你是谁？&lt;br&gt;世界从何处来？&lt;br&gt;    要么一直存在&lt;br&gt;    要么从无到有&lt;br&gt;        比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。&lt;/p&gt;
&lt;p&gt;生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://stemha.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://stemha.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="名著" scheme="https://stemha.github.io/tags/%E5%90%8D%E8%91%97/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://stemha.github.io/2020/03/28/hello-world/"/>
    <id>https://stemha.github.io/2020/03/28/hello-world/</id>
    <published>2020-03-27T17:12:36.485Z</published>
    <updated>2020-03-28T18:54:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><a id="more"></a><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客维护" scheme="https://stemha.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="hexo" scheme="https://stemha.github.io/tags/hexo/"/>
    
      <category term="教程" scheme="https://stemha.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
