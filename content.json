{"pages":[{"title":"关于","text":"关于博主博主是目前是一名在在校的计算机研究生（master student）,为未来而学习着，成长着。专业是计算机系统结构。目标是能够怀着求知与探索的品质，能够对社会有所贡献，在信息化浪潮中搏一番自己的精彩。 在此奉上牛顿的名言： 我好像是一个海边玩耍的孩子,不时为拾到比通常更光滑的石子或更美丽的贝壳而欢欣鼓舞,而展现在我面前的是完全未探明的真理之海。 关于博客博主搭建了这个博客主要是为了记录一些思考、经验、收藏和笔记。博客的内容可能倾向于记录博主的日常所学所思，当然也会有一些技术文章（技术文章博主主要写在CSDN上，这里放的少一些） 在此奉上查理芒格的名言： 如果要变得聪明，不停地问：为什么为什么为什么。 在此奉上高德纳（Donald Knuth，现代计算机鼻祖，《计算机程序设计艺术》作者）的名言： “让我们改变一下对构建程序的态度：不要把我们的主要工作想象为教计算机怎么做，相反，让我们集中精力向人们解释我们想让机器做什么。” 联系博主博客搭建了评论系统，直接用github授权评论即可，博主隔一段时间会看一下。","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/28/hello-world/"},{"title":"成为一个不惑、不忧、不惧的人","text":"说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。 演讲全文诸君!我在南京讲学将近三个月了，这边苏州学界里，有好几回写信邀我，可惜我在南京是天天有功课的，不能分身前来。今天到这里，能够和全城各校诸君聚在一堂，令我感激的很，但有一件，还要请诸君原谅：因为我一个月以来，都带着些病，勉强支持，今天不能作很长的讲演，恐怕有负诸君期望哩。 问诸君“为什么进学校?” 我想人人都会众口一词的答道：“为的是求学问”。再问：“你为什么要求学问?”“你想学些什么?”恐怕各人的答案就很不相同，或者竟自答不出来了。诸君啊!我替你们回答一句罢：“为的是学做人。”你在学校里头学的什么数学、几何、物理、化学、生理、心理、历史、地理、国文、英语，乃至什么哲学、文学、科学、政治、法律、经济、教育、农业、工业、商业等等，不过是做人所需的一种手段，不能说专靠这些便达到做人的目的，任凭你把这些件件学的精通，你能够成个人不成个人还是个问题。 人类心理，有知、情、意三部分。这三部分圆满发达的状态，我们先哲名为三达德——智、仁、勇。为什么叫做“达德”呢?因为这三件事是人类普通道德的标准，总要三个具备，才能成一个人。三件的完成状态怎么样呢?孔子说：“知者不惑，仁者不忧，勇者不惧。”所以教育应分为知育、情育、意育三方面，——现在讲的智育、德育、体育不对，德育范围太笼统，体育范围太狭隘——知育要教到人不惑，情育要教到人不忧，意育到教到人不惧。教育家教育学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。 1. 怎么样才能不惑呢?最要紧的是养成我们的判断力。想要养成判断力，第一步，最少须有相当的常识，进一步，对于自己要做的事须有专门智识，再进一步，还要有遇事能断的智慧。 假如一个人连常识都没有，听见打雷，说是雷公发威，看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，碰到一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。学校里小学中学所教，就是要人有了许多基本的知识，免得凡事都暗中摸索。 但仅仅有点常识还不够，我们做人，总要各有一件专门职业。这门职业，也并不是我一人破天荒去做，从前已经许多人做过，他们积累了无数经验，发现出好些原理原则，这就是专门学识。我打算做这项职业，就应该有这项专门的学识。例如我想做农吗，怎么的改良土壤，怎么的改良种子，怎么的防御水旱病虫，等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。做工、做商等等都各有他的专门学识，也是如此。我想做财政家吗，何种租税可以生出何样结果，何种公债可以生出何样结果等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。教育家、军事家等等，都各有他的专门学说，也是如此。 我们在高等以上学校所求的知识，就是这一类。但专靠这种常识和学识就够吗?还不能。宇宙和人生是活的不是呆的，我们每日碰见的事理是复杂的变化的，不是单纯的刻板的，倘若我们只是学过这一件，才懂这一件，那么，碰着一件没有学过的事来到跟前，便手忙脚乱了。 所以还要养成总体的智慧，才能有根本的判断力。这种总的智慧如何才能养成呢?第一件，要把我们向来粗浮的脑筋着实磨炼他，叫他变成细密而且踏实。那么，无论遇着如何繁难的事，我都可以彻头彻尾想清楚他的条理，自然不至于惑了。 第二件，要把我们向来浑浊的脑筋，着实将养他，叫他变成清明。那么，一件事理到跟前，我才能很从容很莹澈的去判断他，自然不至于惑了。以上所说常识学识和总体的智慧，都是知育的要件，目的是教人做到“知者不惑”。 2. 怎么样才能不忧呢?为什么仁者便会不忧呢?想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么?很难用言语说明，勉强下个解释，可以说是：“普遍人格之实现。”孔子说：“仁者人也。”意思是说人格完成就叫做“仁”。 但我们要知道，人格不是单独一个人可以表现的，要从人和人的关系上来看。所以仁字从二人，郑康成解他做“相人偶”。总而言之，要彼此交感互发，成为一体，然后我的人格才能实现。所以我们若不讲人格主义，那便无话可说;讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我们的人格，和宇宙无二区别，体验得这个道理，就叫做“仁者”。然则这种仁者为什么就会不忧呢?大凡忧之所从来，不外两端，一曰忧成败，二曰忧得失。我们得着“仁”的人生观，就不会忧成败。为什么呢?因为我们知道宇宙和人生是永远不会圆满的，所以《易经》六十四卦，始“乾”而终“未济”。正为在这永远不会圆满的宇宙中，才永远容得我们创造进化。 我们所做的事，不过在宇宙进化几万万里的长途中，往前挪一寸，两寸，那里配说成功呢?然则不做怎么样呢?不做便连这一寸都不往前挪，那可真是失败了。 “仁者”看透这种道理，信得过只有不做事才算失败，肯做事便不会失败。所以《易经》说：“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的几万万里路挪了一两寸，算成功吗?所以《论语》：“知其不可而为之。”你想，有这种人生观的人，还有什么成败可忧呢? 再者，我们得着“仁”的人生观，便不会忧得失。为什么呢?因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则哪里有东西可以为我们所得?既已没有东西为我所得，当然也没有东西为我所失。 我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等做手段来达某种目的——可以为我们“所得”得。所以老子说：“生而不有，为而不恃。”“既以为人已愈有，既以与人已愈多。”你想，有这种人生观的人，还有什么得失可忧呢?总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无人而不自得”。他的生活，纯然是趣味化艺术化。这是最高的情感教育，目的教人做到“仁者不忧”。 3. 怎么样才能不惧呢?有了不惑不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便会有丰富的智识，临时也会用不着，便有优美的情操，临时也会变了卦。然则意志怎么会才坚强呢?头一件须要心地光明，孟子说：“浩然之气，至大至刚。行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不惴焉;自反而缩，虽千万人，吾往矣。” 俗话说得好：“生平不作亏心事，夜半敲门心不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一着。第二件要不为劣等欲望之所牵制。 《论语》记：子曰：“吾未见刚者。”或对曰伸枨。子曰：“枨也欲，焉刚。”一被物质上无聊得嗜欲东拉西扯，那么百炼成刚也会变成绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。 自己作不起自己的主，还有什么事可做?受别人压制，做别人奴隶，自己只要肯奋斗，终必能恢复自由。自己的意志做了自己情欲的奴隶，那么，真是万劫沉沦，永无恢复自由的余地，终身畏首畏尾，成了个可怜人了。 孔子说：“和而不流，强哉矫;中立而不倚，强哉矫。国有道，不变塞焉，强哉矫;国无道，至死不变，强哉矫。”我老实告诉诸君说罢，做人不做到如此，决不会成一个人。但做到如此真是不容易，非时时刻刻做磨炼意志的功夫不可，意志磨炼得到家，自然是看着自己应做得事，一点不迟疑，扛起来便做，“虽千万人吾往矣。”这样才算顶天立地做一世人，绝不会有藏头躲尾左支右绌的丑态。这便是意育的目的，要教人做到“勇者不惧”。 我们拿这三件事作做人的标准，请诸君想想，我自己现时做到哪一件——哪一件稍微有一点把握。倘若连一件都不能做到，连一点把握都没有，嗳哟!那可真危险了，你将来做人恐怕做不成。讲到学校里的教育吗，第二层的情育，第三层的意育，可以说完全没有，剩下的只有第一层的知育。就算知育罢，又只有所谓常识和学识，至于我所讲的总体智慧靠来养成根本判断力的，却是一点儿也没有。 这种“贩卖知识杂货店”的育，把他前途想下去，真令人不寒而栗!现在这种教育，一时又改革不来，我们可爱的青年，除了他更没有可以受教育的地方。诸君啊!你到底还要做人不要?你要知道危险呀，非你自己抖擞精神方法自救，没有人救你呀! 诸君啊!你千万别要以为得些断片的智识，就算是有学问呀。我老实不客气告诉你罢;你如果做成一个人，知识自然是越多越好：你如果做不成一个人，知识却是越多越坏。你不信吗?试想想全国人所唾骂的卖国贼某人某人，是有智识的呀，还是没有智识的呢?试想想全国人所痛恨的官僚政客——专门助军阀作恶鱼肉良民的人，是有智识的呀，还是没有智识的呢?诸君须知道啊，这些人当十几年前在学校的时代，意气横历，天真烂漫，何尝不和诸君一样?为什么就会堕落到这样的田地呀? 屈原说：“何昔日之芳草兮，今直为此萧艾也!岂其有他故兮，莫好修之害也。”天下最伤心的事，莫过于看着一群好好的青年，一步一步的往坏路上走。诸君猛醒啊!现在你所厌所恨的人，就是你前车之鉴了。 诸君啊!你现在怀疑吗?沉闷吗?悲哀痛苦吗?觉得外边的压迫你不能抵抗吗?我告诉你：你怀疑和沉闷，便是你因不知才会惑;你悲哀痛苦，便是你因不仁才会忧;你觉得你不能抵抗外界的压迫，便是你因不勇才有惧。这都是你的知、情、意未经过修养磨炼，所以还未成个人。我盼望你有痛切的自觉啊!有了自觉，自然会成功。那么，学校之外，当然有许多学问，读一卷经，翻一不史，到处都可以发现诸君的良师呀! 诸君啊，醒醒罢!养足你的根本智慧，体验出你的人格人生观，保护好你的自由意志。你成人不成人，就看这几年哩!","link":"/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/"},{"title":"《苏菲的世界》读书笔记","text":"伊甸园 在某个时刻事物必然从无到有你是谁？世界从何处来？ 要么一直存在 要么从无到有 比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。 生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。 魔术师的礼帽 要成为一个优秀的哲学家只有一个条件：要有好奇心哲学是什么？天底下有没有一种东西是所有人都感兴趣的呢？有的！当人的基本需求（比如衣食住行，亲情爱情，爱与关怀等）满足之后，还有一些东西是人人都需要的，那就是明白我们是谁，我们为何在这里。宇宙，地球与生命是如何产生的？ 探讨哲学的最好方式就是问一些哲学性的问题，如：这世界是如何创造出来的？其背后是否有某种一直或者意义？人死后还有生命吗？我们如何能够解答这些问题呢？最重要的是，我们应该如何生活？我们无法从百科全书上得到这些答案，不过读一读别人的意见倒可以帮助我们建立自己对于生命的看法。 哲学家追求真理的过程很想一步侦探小说，对于案件，警方有时候可以侦破，但也有可能永远无法查出真相（虽然在某个地方一定有一个破案的办法）。因此，即使要回答一个问题很不容易，但无论如何总会有一个（且仅此一个）正确答案的。比如人死后要么就是透过某种形式存在，要不就是根本不在存在。 作者很好的比喻：许多人对于这个世界的种种也同样有种不可置信的感觉，就像我们看到魔术师突然从一顶原本空空如也的帽子里拉出一只小兔子一般。实际上我们就生活在这个世界上，是这个世界的一部分。形象的比喻一下，我们就是那只从礼帽里面变出的小兔子的一部分，小兔子可以比作是是整个宇宙，而我们则是寄居在小兔子身上的小小生物，但是我们和兔子不同的是，小兔子可不知道自己参与了一场魔术表演，而我们知道自己是某种神秘事物的一部分，我们想了解其中的奥秘；哲学家们总是试图沿着兔子的细毛往上爬，以便将魔术师的看个清楚； 神话 善与恶之间脆弱的平衡神话的世界观 北欧 （挪威）索尔和铁锤 北欧人相信人类居住的这部分是一部分岛屿，名为米德加德(Midgard)，也就是”中央王国“的意思，在这个中央王国内，有一个地方名叫阿斯加德（Asgard），乃是诸神的领地。中央王国之外，有一个叫乌特加德（Utgard），是狡猾的巨人居住的地方。 象征肥沃多产的额女神芙瑞雅 侍童洛奇 《史莱慕之诗》 巨人之王史莱慕希腊 公元前700左右，有一大部分希腊神话被荷马与赫西俄德（赫西俄德Hesiod以长诗《工作与时日》《神谱》闻名于后世，被称为“希腊训谕诗之父”。）记录下来。 赞诺芬尼司(Xnphans),古希腊哲学家。是早期批评荷马的神话的哲学家之一。 赞诺芬尼斯_百度百科 他指出人类按照自己的形象创造出这些天神。 随后这段期间，希腊人在希腊本土与意大利南部，小亚细亚等希腊殖民地建立了许多城市。在这些城市中，所有劳力工作由奴隶担任，因此市民有充分的闲暇，可以将所有的时间投注在政治与文化上；这时候的人们思考方式与以前大不相同，无需借助神话而提出一些哲学性的问题；我们称这样的现象为“从神话的思考模式发展到以经验与理性为基础的思考模式” 自然派哲学家 没有一件事物可以来自空无万事万物是否有一种基本的物质组成？哲学家的课题：每个人关注和质疑的事项是什么？了解了每一位哲学家的课题之后，我们就比较容易了解他的思想脉络，因为没有任何一位哲学家会企图探讨哲学的所有领域。 自然派哲学家关注的课题是“大自然与它的循环和变化”最重要的是，他们想要透过对大自然本身的研究来了解实际的变化过程，而不是借助神话来解释。这样，哲学逐渐脱离了宗教的范畴。自然派哲学家朝科学推理的方向迈出了第一步，成为后来科学的先驱。 米雷特斯的三位哲学家泰利斯安娜克西曼德安那西梅尼斯 没有任何事物会来自于虚无帕梅尼德斯（约公元前540年~公元前480年）他认为： 没有任何事物会改变。 因此我们的感官认知是不可靠的 理性主义：坚决相信人的理智的态度理性主义者：百分百相信人类的理智是时间所有知识源泉的人 所有的事物都是流动的赫拉克里德斯（约公元前540年~公元前480年）他认为： 万物都会改变（”一切事物都是流动的“） 我们的感官认知是可靠的 恩培窦克里斯（西西里）恩培窦克里斯认为帕梅尼德斯与赫拉克里德斯各有一点是对的，也各有一点是错的，造成这个根本性差异的原因是之前的两人都认定世间只有一种元素存在。恩培窦克里斯认为： 没有任何事物会改变。 我们的感官认知是可靠的 恩培窦克里斯的结论是：大自然不可能只有一种元素构成。 安纳萨格拉斯（约公元前500年~公元前428年） 德谟克里特斯 世界上最巧妙的玩具 积木为何是世界上最巧妙的玩具？ 原子理论德谟克里特斯（约公元前460年~公元前370年，来自爱琴海北部海岸的阿布拉德小镇） 唯物论者：只相信物质的东西。 命运 算命者试图预测某些事实上极不可测的事物古希腊的德尔菲（Delphi）神论与宿命论 现在看来都是迷信 历史与医学历史上最早的一批历史学家开始为历史事件寻求合理的解释。贺若多陀斯（约公元前484年~公元前424年）与修西德底斯（约公元前460年~公元前400年） 在希腊哲学、历史学发展的同时，希腊医学兴起，其目的是为了疾病与健康寻求合乎自然的解释。希波克拉底（约公元前460~公元前377年，生于寇斯岛，希腊医学始祖）比较出名的是希波克拉底誓言： 我将依照自身的能力与判断，采用对病人有利的疗法与处方，绝不施以有害或有毒之物。无论应何人之请，我也绝不给与致命药物或做此类之建议，也绝不协助妇女堕胎。进入病家访视时，我将以病人的福祉为念，不做任何贪渎害人之事，不受男女奴仆之引诱。我在执业时之所见所闻，反不应泄露者，我将严予保密。若我遵行此一誓言，不懈不怠，愿上苍使我乐享生命、精进医事并受世人敬重。若我违反誓言，愿我遭相反之命运。 苏格拉底 最聪明的是明白自己无知的人 是否有人天生就很害羞呢？最聪明的是明白自己无知的人。真正的智慧来自内心。明白是非者必能够进退合宜。 雅典的哲学以人为中心苏格拉底是谁？谈话的艺术 “苏格拉底式的反讽”神圣的声音雅典的小丑正确的见解导致正确的行动 雅典 废墟中升起了几栋高楼柏拉图 回归灵魂世界的渴望柏拉图学院永远的真善美理型的世界真正的知识不朽的灵魂走出黑暗的洞穴（洞穴神话）哲学之国（理想国） 少校的小木屋 镜中的女孩双眼眨了一眨亚力士多德 一位希望澄清我们观念的严谨的逻辑学家逻辑亚里士多德创立了逻辑学这门学科，他以实例显示我们在得出合乎逻辑的结论或证明时，必须遵循若干法则。 希腊文化 一丝火花生命与容忍的哲学宗教，哲学与科学 犬儒学派 斯多葛学派 伊比鸠鲁学派 新柏拉图派哲学神秘主义 明信片 我对自己实施严格的检查制度两种文化 避免在真空中飘浮的唯一方式印欧文化 闪族文化 中世纪 对了一部分并不等于错文艺复兴 啊！藏在凡俗身躯里的神明子孙哪实证法：以亲身的经验，而不是以古人的著作或凭空想象来作为知识的基础。 巴洛克时期 宛如梦中的事物笛卡尔 他希望清除工地上所有的瓦砾斯宾诺莎 上帝不是一个傀儡戏师傅洛克 赤裸、空虚一如教师来到教室前的黑板休姆 将它付之一炬如果我们手里有一本书，我们应该问：书里是否有包含任何与数量和数目有关的抽象思考？如果答案是没有，那么我们应该再问：书里是否包含任何与事实有关的经验性思考？如果答案是没有，那么我们还是将它付之一炬吧，因为这样的书纯粹是诡辩和幻想。 印象观念 不可知论者：不持肯定或否定的态度，持怀疑态度。 柏克莱 宛如燃烧的恒星旁一颗晕眩的行星柏客来 曾祖母向一名吉普赛妇人买的一面古老魔镜启蒙 从制针的技术到铸造大炮的方法康德 头上闪烁的星空与心中的道德规范浪漫主义 神秘之路通向内心黑格尔 可以站得住脚的就是有道理的祁克果 欧洲正迈向破产的地步主观的真理可以测算的真理我信因为荒谬个体主义者 马克思 在欧洲游荡的幽灵达尔文 满载基因航行过生命的一艘小船弗洛伊德 他内心出现那股令人讨厌的自大的冲动弗洛伊德发展了所谓的深度心理学或精神分析弗洛依德主张人和他的环境之间不断有一种紧张关系存在。这种紧张关系（也就是冲突）尤其存在于他的驱策力，需要和社会之间。基本需求可能会被伪装和升华；快乐原则/本我现实原则/自我这世界的道德规范已经成为我们内心的一部分/成为超我潜意识:我们并不一定能够意识到我们曾经有过的各种经验。但那些只要我们“用心想便可以记起来的想法或经验”通常是指被压抑的想法或经验。不错的比喻：演讲厅说话演讲厅称为”意识“，演讲厅之外称为“潜意识”；大声喧哗者被”压抑“，椅子堵住门口作为”防御“ 我们的感觉和行为会受到“潜意识的鼓动”这类机制有好几种：比如“说溜了嘴”“合理化”我们自己也不愿意承认，也不愿意告诉别人我们做一件事的真正动机，因为这个动机是让人无法接受的。–&gt;”两面式沟通“的经验“投射”把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较。如何对抗不愉快的经历呢？弗洛伊德发展出一个”自由联想“的技巧。梦的解析显梦 mainfest dream 潜梦意念把潜梦意念转换成显梦面向的工作，他称之为“梦的运作”超现实主义 灵感：潜意识的盖子被打开了，好像我们突然所想的东西是来自某种外部的源泉似的。创作的过程是想象与理性细密交织的时刻 想象力也许可以创造新的事物，但是却不能加以挑选，这时候理智就发挥作用了！ 我们这个时代 人是注定要受自由之苦的花园宴会 一只白色的乌鸦对位法 两首或多首旋律齐响那轰然一响 我们也是星尘","link":"/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"好用的chrome插件","text":"深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。 Awesome Autocomplete for GitHub增强github的搜索功能 Git History Browser Extension查看github的历史更新记录，超级好用，可以对比不同人对代码做的更新； octotree可以查看github的目录结构，并且下载单个的文件； Sourcegraph可以查看相关的代码，搜索代码，查找代码定义的地方 The Great Suspender休眠chrome不必要的标签页 Tab Resize - split screen layouts浏览器分屏 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/"},{"title":"学术论文的基本结构","text":"基本结构 标题 真实反应论文内容 简短明了 吸引人 大背景 小背景 技术特色 摘要 概括你的研究 假设或要研究的问题 研究方法 主要成果 引言 说明选题的背景，目的，意义 陈述研究的主要内容和论文的假说或研究问题 文章的研究方法与章节编排 文献综述 阐述前人的研究，展示文献批判能力，说明你对研究问题的掌握程度，表明你研究的创新之处。 研究方法 详细介绍相关信息，便于读者采取同样的方法能够重复此项研究。 研究性质 对象 步骤 工具 条件 … 研究结果 用文字和/或图表真实报告你获得的数据或结果。 讨论 基于你获得的数据论述对于研究问题可能得到的结论。 结论 简明总结所得到的数据，得出的结论及意义。 说明研究的价值，不足或局限性。 致谢 参考文献 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"title":"《练习的心态》读书笔记","text":"引言 人生就是漫长的练习第1章 学习开始当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种没有压力的愉快与平和的体验，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。 压力与焦虑主要来源于我们自己对目标的依恋。练习的心态这也是一种技能：尽可能迅速，最少的付出来发展任何一项技能的能力，以及在这个过程体验内心平和与愉悦的能力。 在不感到失败和焦虑的情况下去努力实现目标。学习的渴望仅仅是第一步，需要正确理解技术性细节与努力，否则会耗尽的 当今的文化是多任务的，比如开车时第一件事会习惯性打开收音机。 而滑冰正相反，滑冰时候不会注意边上嘈杂的声音！由于习惯于一心多用，我们大脑躁动不安，且具有极大惯性，没法安静下来。 练习的心态是安静的意识是第一位的：没法控制自己的思维，不管设立什么样的目标，都没有用。我们对自己要去的方向就像乘坐马车，必须要拉紧思维的缰绳才行啊！填补空虚是一个循环往复的过程 学会走路的过程并不会在心里让你压力倍增。我们要意识并掌控这个过程，学会从中享受！ 第2章 以过程为导向，不以结果为导向 人生的悖论：耐心与自律的问题是，要培养它们中的任何一个，需要同时具备它们两个。 简单法则 以过程为导向 重点关注当前 将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。 对自己想要做的事情刻意训练，带着意图训练，并且自始至终清醒的知道那种意图 第3章 关键是视角当我们试图理解自己以及我们对人生中各种努力的痛苦挣扎时，可以通过观察一朵鲜花来找到平和。问你自己：一朵鲜花的生命，从撒下种子到完全盛开，在什么时候可以达到完美？ 然后呢？ 达成目标之后，然后呢？然后又能干什么呢？？？？初学者心态鲜花的生命，自始至终都是完美的 他了解到，假如将自己的思绪集中在当前，并只专注了他在这一刻正在做的事情的过程，那便可以喜欢上他正在做的任何事情。 第4章 培养期望的习惯习惯是学来的。明智地选择它们。自己创造想要的习惯，不带情绪和判断的采取哪些行为，之后坚持下去。 就像一名优秀的老师，对待学生的错误不会情绪化，那种情绪化来源于自我期望，与结果和产物关联，如果你体验到这些情绪，就证明你没有专注于当前过程！！！ 怎么样阻止旧的习惯，采用一种例行行为来阻止，比如击球前例动作 第5章 感知变化，创造耐心！你需要的所有耐心，都已经处在你的内心了。知道什么时候内心疯狂奔走接受什么事情不会尽善尽美 放弃某种幸福和乐趣就在某个地方的徒劳想法 在探索的道路上，除了去追求，没有别的可以达到的目标了//我们20岁的目标肯定与18岁的不同，参照对象也是不一样的，不要指望能达到你的目标。探索本身就是一种目标。 对于没有费力得到的东西，那种兴奋感在得到东西早已烟消云散。 得到目标和实现目标是两种完全不同的概念真正的愉悦 第6章 4“S”方法力求简化，将征服大多数复杂的任务。 简化 细分 缩短 放慢 第7章 平静与DOC方法客观是通往宁静心灵之路！ 主观判断需要一个评估和对比的过程，这要求有一个相对的点，即理想状况判断有一个不利的地方，它不会以一种超然的方式运行，常常会包含着某些情绪，有趣的是，对事情我们感觉到的重要性越多，我们带的情绪越多将自我与观察者合并 。就像我们安慰他人时候带着的超然智慧一样。 怎么合并呢 冥想！ do observe correct就像射箭运动员一样，安静，不复杂完全没有心理的杂乱 第8章 教孩子，也从孩子身上学习智慧并不是年龄的副产物。从你身边所有的人身上学习，同时也用自己的行为影响身边的人。 第9章 你的技能在成长有了刻意的和反复的努力，进步便水到渠成。 如果说各种软件上的信息不能使你知识变得丰富，那么你就不需要它们 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"linux 性能分析，测试与调优工具","text":"静态性能分析工具(static performance analysis tools) dmesg 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。 blockdev 工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。 ldd （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。 lsblk (list block)即用于列出所有可用块设备的信息,而且还能显示他们之间的依赖关系,但是它不会列出RAM盘的信息 lsscsi 可以看到Raid卡信息和所有虚拟磁盘以及光驱的信息，如果没有硬件SCSI控制器，那就不会返回信息。 lspci 显示有关pci总线的信息以及连接到它们的设备。 lscpu (list cpu)显示CPU的详细信息，比如CPU的制造商、架构、CPU数量、型号、主频、缓存及支持的虚拟化技术等信息。 lstopo (list topology of the system)显示可视化的方式组成 CPU、缓存、内存和I/O设备的拓扑结构。这个命令用来识别处理器结构和系统的NUMA拓扑结构。 likwid (Like I Knew What I’m Doing) 是一个用来测量、配置并显示硬件相关特性的命令行收集工具。其中的likwid拓扑结构能显示CPU硬件(线程/缓存/NUMA)的拓扑结构信息，还能识别处理器家族(比如：Intel Core 2, AMD Shanghai)。 smartctl 查看硬盘的SMART信息。 fdisk 创建和维护分区表的程序(兼容DOS类型的分区表、BSD或SUN的磁盘列表） schedtool (scheduling tool)查询或设置CPU状态的工具。通过不同的参数可以查看或设置不同的属性。 numactl (Control NUMA policy)用于控制 进程与共享存储的 NUMA 技术机制。 cpuid 获取CPU的信息。该命令的底层是CPUID指令。它获取的内容比/proc/cpuinfo要详细很多。 MegaCli 管理维护硬件RAID的软件 App Config 观测工具(Observability Tools) iostat (input/output statistics)报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息。 vmstat (VirtualMeomoryStatistics,虚拟内存统计) 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。 dstat 用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具,是一个全能系统信息统计工具。 pidstat 是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。 mpstat (multiprocessor statistics)查看多核心的cpu中每个计算核心的统计数据。类似工具vmstat只能查看系统的整体cpu情况 netstat ( network statistics)显示当前的网络状态，包括传输控制协议层的连线状况、路由表、网络接口状态和网络协议的统计信息等。 iotop 用来监视磁盘I/O使用状况的top类工具 top (display Linux processes)实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。 htop top命令的升级版。交互式的进程浏览器，可以用来替换Linux下的top命令 gtop JavaScript 编写的开源系统资源监控实用程序,它是 Linux 系统自带 top 工具的替代品 tiptop 通过读取CPU硬件计数器的信息（比如cahche miss，executed instructions per cycle等等）了解程序执行效率 strace 可跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。 uptime 可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息 lsof (list open files)列出当前系统打开的文件，注意linux中设备也是文件 perf 性能分析工具，能够进行函数级与指令级的热点查找。 Flame Graphs 性能分析的利器,通过它可以快速定位性能瓶颈点。 测试工具(Benchmarking Tools) fio 开源的I/O压力测试工具，主要是用来测试磁盘/SSD的IO性能，也可测试cpu，nic的IO性能。 hdparm (hard disk parameters)用于显示与设定硬盘的参数 dd 用于读取、转换并输出数据。可从标准输入或文件中读取数据,根据指定的格式来转换数据,再输出到文件、设备或标准输出。 perf_events 网上很多叫法如perf_events , perf profiler , Performance Counters for Linux。叫法不同，都指perf perf-tools 基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集，能够收集ftrace和perf_events中乱七八糟的参数。 ktap Linux的基于脚本的动态跟踪工具 允许用户跟踪Linux内核动态。 sysbench 一个开源的、模块化的、跨平台的多线程性能测试工具,可以用来进行CPU、内存、磁盘I/O、线程、数据库的性能测试。 ab (apachebench) ab命令会创建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。 wrk 针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 jmeter Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试。 openssl 加解密能力也是CPU性能测试的一部分。 UnixBench 类unix系(Unix,BSD,Linux)统下的性能测试工具 lmbench 多平台软件，因此能够对同级别的系统进行比较测试，反映不同系统的优劣势，可用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能. perfbench perf下的工具 测试系统性能 hping3 面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。 iperf 网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 ping 向特定的目的主机发送 ICMP（Iternet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。 ttcp 传统的测试TCP性能的工具,它主要测试两个机器之间TCP的吞吐量(在应用层模拟消息传递的过程) traceroute 利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。 mtr 网络连通性判断工具，它结合了ping, traceroute,nslookup 的相关特性 pchar 沿Internet路径执行网络测量 调优工具(Tuning Tools) sysctl (System Administration)用来配置与显示在/proc/sys目录中的内核参数 swapon 用于激活Linux中的交换空间，Linux的内存管理必须使用交换区来建立虚拟内存。 env gnu的coreutils包内的一个软件，用来显示系统中已存在的环境变量,以及在定义的环境中执行指令。 tune2fs 允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。 ionice 获取或设置程序的IO调度与优先级。PRI(new)=PRI(default)+nice nice 调整程序运行的优先级，当前程序运行优先级基础之上调整指定值得到新的程序运行优先级。 renice 重新指定一个或多个进程的优先级 taskset 将某个进程与某个CPU核心绑定。 ulimit 为shell内建指令，可用来控制shell执行程序的资源 chcpu 修改cpu的状态,启用和关闭cpu，扫描新的CPU,改变底层虚拟机监控程序的CPU调度模式,并请求CPU的系统管理程序(配置)或返回CPU hypervisor numactl 用于控制进程与共享存储的 NUMA 技术机制。 sysctl 用于运行时配置内核参数,这些参数位于/proc/sys目录下。 ethtool 用于查询及设置网卡参数 stap (SystemTap) 内核开发者必须要掌握的一个工具,用于内核监控和跟踪，以及诊断性能或功能问题。 kpatch 给Linux内核动态打补丁但是不必重启系统 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"},{"title":"Linux系统目录结构","text":"/bin (binary)目录存放着最经常使用的命令 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 包括Linux内核文件，以及开机菜单与开机所需的配置文件 linux kernel常用的文件名为vmlinux /dev (device)该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc (Editable Text Configuration)可配置文件存放所有的系统管理所需要的配置文件和子目录。 /etc/init.d所有服务的默认启动脚本都是放置在这个目录内 /etc/xinetd.d所谓的super daemon管理的各项服务的配置文件目录 /etc/X11与X Windows有关的各种配置文件都在这里 /etc/securetty只有/etc/securetty中登记的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录 这个终端指tty1之类的 /etc/passwd保存的就是系统中所有的用户和用户的主要信息 /etc/shadow/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。 /home (home directory)用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 系统默认的用户主文件夹 比较重要的是 主文件夹有两者代号 ~ 代表目前这个用户的主文件夹 ~dmtsai 代表dmtsai的主文件夹 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 放置的是开机会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库而已 尤其重要的是/lib/modules/这个目录 放置内核相关的模块（驱动程序） /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 这个目录是使用标准的ext2/ext3文件系统格式才会产生的目录 /medialinux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 包括软盘，光盘，DVD等设备都暂时挂载于此 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，或者说是额外的设备 比较早的时候，这个目录的用途与/media相同。只是有了/media之后这个目录就暂时用来挂载用了 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 给第三方软件放置的目录 /proc (process)这个目录本身是一个虚拟的文件系统，放置的数据都是在内存中:例如，系统内核，进程，外部设备的状态及网络状态等 目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息 这个目录的内容不在硬盘上而是在内存里，本身不占用任何硬盘空间，我们也可以直接修改里面的某些文件 /root该目录为系统管理员，也称作超级权限者的用户主目录。 /run是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 这个目录的内容数据也是在内存中的信息，同样不会占用任何的硬盘容量 Secure Enhance Linux的执行目录 /srv (service) 该目录存放一些服务启动之后需要提取的数据。 一些网络服务启动之后，这些服务所取用的数据目录 存放服务启动后需要提取的数据（不用服务器就是空） /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 这个目录与/proc目录类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。包括目前已经加载的内核模块与内核检测到的硬件设备信息等。 这个目录同样不占用硬盘容量。 /tmp这个目录是用来存放一些临时文件的。 /usr (UNIX Software Resource,而不是user)是UNIX 操作系统软件资源所放置的目录，而不是用户的数据.这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。注意事项：FHS建议所有软件开发者将他们的数据合理地放置到这个目录下的子目录，而不要自行新建软件自己独立的目录有点像windows系统中C:\\Windows\\和C:\\Program files\\这两个目录的综合体 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 附注上面这些目录比较完备了 我主要是根据菜鸟教程，鸟哥的私房菜进行整理的 关于/run这个目录稍微特殊一点点，有的系统是二级目录，如果你的系统上有 /var/run 目录，应该让它指向 run。 可以用ls -l / 命令查看目录树 关于挂载开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"哈希表（散列表）详解","text":"基本概念散列方法（hashing）：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立起映射关系。散列表（hashtable）：逻辑上由一些列可存放词条（或者其引用）的单元（称作桶（bucket）或桶单元）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作桶数组（bucket array）地址空间（address space）：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。 散列函数（hash function）：用来描述散列方法，是从关键码空间到桶数组地址空间的函数。比如下面的hash()： 1hash() : key -&gt; hash(key) key的散列地址（hashing address）：也就是上面的hash(key) 。 完美散列（perfect hashing）：在时间和空间性能方面均达到最优的散列，也就是没有空余，没有重复的散列。 装填因子（load factor）：散列表中非空桶的数目与桶单元总数的比值。是散列表的空间利用率度量方法。 散列冲突（collision）：关键码不同的词条映射到同一个散列地址的情况。 词条的聚集（clustering）：词条集中到散列表内少数若干桶中（或附近）的现象。 综上散列表的基本构思概括为： 开辟物理地址连续的桶数组hba[],借助散列函数hash(),将词条关键码key映射为桶地址hash(key),从而快速确定待操作的词条的位置。 散列函数好的散列函数应该具备的条件： 确定性 ：也就是说词条E的映射地址hash(E.key)必须完全取决于E.key。 简单性 ：映射过程不能过于复杂 所有关键码经过映射后应该尽量覆盖整个地址空间。也就是说hash()最好是满射。 均匀性 ：最重要的原则，关键码映射到各个桶的概率是同等的，应该尽量为1/R ，R为散列表长度或容量。 直接定址法直接定址法：关键码就可以直接用作为散列地址 1hash(key)=key 除余法（devision method）除余法：选择一个适当的正整数R,用R去除关键码去除关键码,余数作为 散列地址.这个方法的关键是选取适当的R。一般R为素数，采用素数表长是是降低聚集发生概率的捷径。 1hash(key)=key mod R //R为散列表长度或容量。一般R为素数。 缺点：残留有某种连续性，比如相邻关键码所对应的散列的地址，总是彼此相邻。 MAD法（multiply-add-divide method）乘加除法乘加除法：需要依次执行乘法，加法，和除法运算得名。解决的问题：用来克服除余法的连续性缺陷。 12hash(key)=(a * key + b)mod R //a&gt;0，b&gt;0，且(a mod R) !=0//R为散列表长度或容量。一般R为素数。 数字分析法（selecting digits）数字分析法：从关键码key中特定进制的展开中抽出特定的若干位，构成一个整型地址。对关键码的各位进行分析（多种方法），丢下分布不均匀的位，留下均匀的位作为地址。数字分析法举例： 平方取中法（mid-square） 折叠法（folding） 一般折叠 往复折返式折叠 异或法（xor） 一般异或 往复折返式异或 伪随机数法越是随机，越是没有规律的就是好的散列函数。 1hash(key)=rand(key) mod R //R为散列表长度或容量。 冲突及其排解开散列策略/封闭定址开散列（open hashing）或封闭定址（closed addressing）： 开放基本的散列表结构，引入次级关联结构。 散列表中的地址只对特定的词条开放（每个桶可以只能能存放特定的一组词条）。 多槽位法（multiple slots）多槽位法：将每个桶细分为更小的称作槽位（slot）的若干单元，每一组槽位可以组织为向量或列表。//类似于二维数组 独立链法（separate chaining)（拉链法）拉链法：某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。//引入链表先计算哈希地址，然后搜索该地址的单链表。 公共溢出区法（overflow）在原有散列表hashA之外再设置一个公共溢出区（散列表hashB），如果抽入词条发生冲突，就将该词条转存至公共溢出区（散列表hashB）中。 //引入新的散列表可以说是一种递归形式的散列表。 闭散列策略/开放定址闭散列（open hashing）或开放定址（closed addressing）： 仅仅依靠基本的散列表结构，就地排解冲突。 散列表中的地址对所有的词条开放（每个桶可以都有可能存放任一词条）。 一个桶冲突了，只允许在散列表内部为其寻找另一空桶。 线性试探法（linear probing）线性试探法：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。被尝试的桶依次为： 1[(hash(key) + i)mod R ] ,i=1,2,3,... 平法试探法（二次探测法）被尝试的桶依次为： 1[(hash(key) + i^2)mod R ] ,i=1,2,3,... 伪随机试探法被尝试的桶依次为： 1[rand(i)mod R ] ,rand(i)为系统定义的第i个随机数。 再散列法（rehashing）再散列法：使用哈希函数去散列一个输入的时候，如果输出是同一个散列地址就再次散列，直至不发生冲突为止。缺点：每次冲突都要重新散列，计算时间增加。被尝试的桶依次为： 12//hash2为二级散列函数[(hash(key) + i*hash2(key) ] ,i=1,2,3,... 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"},{"title":"《别闹了费曼先生》读书笔记","text":"当科学大师碰上菜鸟 报告时间终于到了。我面前坐了这些科学大师，全在等我开口讲话！我生平第一次学术报告，却碰上这样的听众！我的意思是说，他们会问很多难题，我将会大大地出丑了！我还清楚记得，从牛皮纸袋抽出讲稿时，双手不住地发抖。但奇迹出现了——事实上我很幸运，类似的奇迹在我一生中一再发生——只要我开始思考物理、必须全神贯注于要说明的问题上，我的脑袋中就再没有其他杂念，完全不会紧张。因此当我开始报告以后，我根本不知道听众是谁了；我只不过在说明这些物理概念。事情就那么简单！ 向数学家挑战 我向他们挑战：“我跟你们打赌，随便你提出一个定理——只要你用我听得懂的方式告诉我，它假设些什么、定理是什么等等——我立刻可以告诉你，它是对的还是错的！” 其实，我也并不是随便乱猜的。我有一套方法，甚至到了今天，当别人对我说明一些什么，而我努力要弄明白时，我还在用这些方法：不断地举实例。譬如说，那些念数学的提出一个听起来很了不得的定理，大家都非常兴奋。当他们告诉我这个定理的各项条件时，我便一边构思符合这些条件的情况。当他们说到数学上的“集”时，我便想到一个球，两个不相容的集便是两个球。然后视情况而定，球可能具有不同的颜色、长出头发或发生其他千奇百怪的状况。最后，当他们提出那宝贝定理时，我只要想到那跟我长满头发的绿球不吻合时，便宣布：“不对！” 看怎样用些有趣、近代的数学观念来教数学。原先的目的，是要使那些觉得数学枯燥无味的学生提高兴趣。 费曼教授 20 世纪40 年代，我待在普林斯顿的期间，亲眼看到高等研究院内那些卓越心灵的下场。他们都具备了聪明绝顶的头脑，因此特别被选中，来到坐落在森林旁边的漂亮房子里，整天悠哉游哉地闲坐——不用教书，没有任何约束或负担。但等过了一段日子，他们想不出什么新东西来，每个人心里一定开始感到内疚或沮丧，更加担心提不出新想法。可是一切还是如旧，仍然没有灵感。会发生这种情况，完全是因为那里缺乏真正的活动和挑战：他们没有跟做实验的学者接触，也不必思索如何回答学生提出的问题，什么都没有！ 在任何思考过程中，当一切进行顺利、灵感源源不绝时，教书确实是一种妨碍，十分讨厌。但有更多的时候是脑袋空空的，如果既想不出什么、又没做什么，那真会教人疯狂！你甚至不能说：“我在教书呀！”。 不敢面对问题到弄明白 在罗彻斯特举行了一个会议——一年一度的罗彻斯特研讨会（Rochester Conference）。我还是事事落于人后，而李政道已在发表关于宇称不守恒的论文。他和杨振宁作出宇称并不守恒的结论，现在他正提出解释这现象的理论。会议期间，我住在我位于西瑞桥斯（Syracuse）的妹妹家。我把论文带回家跟她说：“我搞不懂李政道和杨振宁说的东西，这全都那么复杂！”“不，”她说，“你的意思并不是说你无法弄懂它，而是你没有发明它。你没有用你的方法，从听到线索开始做起，把它推演出来。你应该做的是想象自己重新在当学生，把这篇论文带到楼上去，逐字逐句地读，检查每一条方程式。然后你就什么都弄懂了。”我接受了她的建议，把那东西从头看到尾，发现它真的很明显简单。我只是一直害怕去读它，总觉得它太深奥。","link":"/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Linux常用命令整理（1）","text":"Linux命令基础知识 1234567891011$ command [-options] parameter1 parameter2 ... 命令 选项 参数(1) 参数(2) 说明： 1. 任何命令中第一个输入的部分绝对是『命令(command)』或者『可运行文件』 2. command 命令的名称 3. [-options] 选项并不存在于实际的命令中，而加入选项配置时，通常选项前会带 - 号（比如-h）。有时候会使用选项的完整全名，此时带有 -- 符号（比如--help） 4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数； 5. 命令, 选项, 参数等以空格来区分，但是不论空几格 ，shell 都同一视为一格； 6. [Enter]按键代表着一行命令的开始启动。 7. 命令太长的时候，可以使用反斜杠 (\\) 来跳脱[Enter]符号，使命令连续到下一行。反斜杠后需要立刻接特殊字符才行。8. 在 Linux 中，区分大小写。 基本查询查询所支持的语言123456$ echo $LANG zh_TW.UTF-8#修改为英文语系 $ LANG=en_US$ echo $LANG en_US 时间日历与计算器123$ date //date 时间$ cal //cal 日历$ bc //计算器 版本信息查询uname －a查看版本当前操作系统内核信息 cat /proc/version查看当前操作系统版本信息 cat /etc/issue 或 cat /etc/redhat-release查看版本当前操作系统发行版信息 cat /proc/cpuinfoLinux查看cpu相关信息，包括型号、主频、内核信息等 getconf LONG_BITLinux查看版本多少位 lsb_release -aCentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用 命令信息查询命令总数：[Tab][Tab]按下两个[Tab]按键，查看共有多少命令可以让用户使用用。 man page有时忘记了命令全称，也可以根据不完整的名称查出来，系统有哪些跟这个名词有关的说明文件 12 -f 查询以keyword开头所有相关帮助信息列表，只会找数据中的左边那个命令(或文件)的完整名称。$ man -f keyword 12 -k 将说明文件里面只要含有keyword的都列出来。$ man -k keyword 1234$ whatis [命令或者是数据] 相当于 man -f [命令或者是数据] $ apropos [命令或者是数据] 相当于 man -k [命令或者是数据] 两个特殊命令要能使用，必须要有创建 whatis 数据库才行！这个数据库的创建需要以 root 的身份下达如下的命令：[root@ ~]# makewhatis 关机/重新启动命令数据同步写入硬盘中： sync惯用的关机命令： shutdown重新启动，关机： reboot, halt, poweroff在默认的情况下， 这几个命令都会完成一样的工作！(因为halt会先呼叫shutdown，而shutdown最后会呼叫halt！)。 不过，shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt却能够在不理会目前系统状况下， 进行硬件关机的特殊功能 123[root@ ~]# reboot [root@ ~]# shutdown -h now [root@ ~]# poweroff -f halt若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。使用权限：系统管理者。 1[root@ ~]# halt 切换运行等级：initLinux共有七种运行等级run level 0：关机run level 3：纯文本模式run level 5：含有图形接口模式run level 6：重新启动可以使用init来关机 1[root@~]# init 0 文件处理命令目录相关：ls、pwd、mkdir、rmdir1234ls -l //列出当前目录下的文件详细信息pwd [-options] //查看”当前工作目录“的完整路径mkdir [-options] 目录名 //创建目录 rmdir [-options] 目录名 //删除空目录。 文件复制移动：touch、mv、cp、rm1234567mv [选项] 源文件或目录 目标文件或目录//mv命令将文件重命名或将其移至一个新的目录中``` ```bashcp [选项]… [-T] 源 目的//cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。 12touch [选项]… 文件…//touch命令可更改文档或目录的日期时间，包括存取时间和更改时间。 12rm [选项] 文件…rm命令删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。 取得路径的文件名与目录名：basename，dirname查看文件内容：more、less、head、tail、cat、tac、nl、diffmore：一页一页显示文件内容less：less与more类似，但是可以向前翻页head：查看文件时，只显示头几行tail：查看文件时，只显示尾几行【-f 循环读取文件，不断刷新】tac：从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 12345cat [选项] [文件]…主要的三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 1234nl [选项]… [文件]…\\\\可以用来显示文件\\\\nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！\\\\其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 123456789101112diff[参数][文件1或目录1][文件2或目录2]\\\\diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。root@ubuntu:~# diff /snap/ /usr/Only in /snap/: READMEOnly in /usr/: binOnly in /usr/: gamesOnly in /usr/: includeOnly in /usr/: libOnly in /usr/: localOnly in /usr/: sbinOnly in /usr/: shareOnly in /usr/: src 创建文件链接： ln123//ln (link)ln -s source dist # 建立软连接ln source dist # 建立硬连接 软链接(symbolic link)：软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。硬链接(hard link)：硬链接是已存在文件的另一个名字。【不允许给目录创建硬链接；只有在同一文件系统中的文件之间才能创建硬链接。】 硬链接：指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Number)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件,以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。软链接：文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 更改文件权限umask 档案预设权限chattr 配置文件档案隐藏属性lsattr 显示档案隐藏属性file 观察文件类型： chgrp改变所属群组, /etc/group里面可查询群组 1[root@~]# chgrp users code.log chown功能： 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。格式： chown [选项]… [所有者][:[组]] 文件… chmod功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。格式： chmod [-cfvR] [–help] [–version] mode file数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 压缩文件压缩文件和读取压缩文件：tar，gzip，zcat 磁盘占用与挂载dfdf命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。 1234root@ubuntu:~# df Filesystem 1K-blocks Used Available Use% Mounted onudev 491848 0 491848 0% /devtmpfs 100920 628 100292 1% /run du (disk usage)du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。该命令的功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出指定目录，则对当前目录进行统计。 mount在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等 文件查找which12which 可执行文件名称 //查找路径：PATH所含目录//which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 适用场合：查找命令/可执行文件所在的路径。有时候可能在多个路径下存在相同的命令，该命令可用于查找当前所执行的命令到底是哪一个位置处的命令。 whereis123whereis [-bmsu] [BMS 目录名 -f ] 文件名 //查找路径：索引数据库所含目录//whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于源文件，二进制文件，或是帮助文件。//whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 原理：首先会去掉文件名中的前缀空格和以.开头的任何字符，然后在数据库（var/lib/slocate/slocate.db）中查找与经过处理后的文件名相匹配的源文件，二进制文件，或是帮助文件。使用之前可以使用updatedb命令手动更新数据库。适用场合：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate12locate [选择参数] [样式] //查找路径：索引数据库所含目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 原理：默认情况下(文件名中不包含通配符时)，locate会给出所有与filename*相匹配的文件的路径。适用场合：没有文件类型性质的模糊查找 find1find pathname -options [-print -exec -ok …] //查找路径：当前目录/指定目录 适用场合：能用which、whereis和locate的时候尽量不要用find.功能： 用于在文件树种查找文件，并作出相应的处理原理：遍历当前工作目录及其子目录参数： 1.使用name选项，可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。2.按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。3.如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。4.使用type选项,根据不同的文件类型进行查找，如d(目录)、l(链接) find命令之exec-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。例如：find . -type f -exec ls -l {} ;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。find命令之xargsfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 网络管理命令Linux 查看端口占用情况 ip1ip [-option] [动作] [命令] option ：设定的参数，主要有-s显示出该设备的统计数据(statistics)，例如总接受封包数等；动作：就是是可以针对哪些网络参数进行动作，包括有： link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；route ：与路由有关的相关设定 ifconfig1ifconfig [网络设备] [参数] ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 digdig命令是一个功能强大的DNS查询命令。 一般格式： 1dig [@global-server] [domain] [q-type] [q-class] {q-opt} {d-opt} 参数说明：global-server：默认是以/etc/resolv.conf作为DNS查询的主机，这里可以填入其它DNS主机IP。domain：要查询的域名。q-type：查询记录的类型，例如a、any、mx、ns、soa、hinfo、axfr、txt等，默认查询a。q-class：查询的类别，相当于nslookup中的set class。默认值为in（Internet）。q-opt：查询选项，可以有好几种方式，比如：-f file为通过批处理文件解析多个地址；-p port指定另一个端口（缺省的DNS端口为53），等等。d-opt：dig特有的选项。使用时要在参数前加上一个“+”号。 d-opt常用选项：+vc：使用TCP协议查询。+time=###：设置超时时间。 netstat1netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。netstat命令(菜鸟教程) ss(Socket Statistics)12ss [参数]ss [参数] [过滤] 功能： ss命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。ss命令的参数及使用详解 ping1ping [参数] [主机名或IP地址] ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 tracertroute123traceroute[参数][主机]//具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 route1route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 功能： Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 Linux系统的route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 参考资料理解 Linux 的硬链接与软链接鸟哥的linux私房菜Linux下4个查找命令which、whereis、locate、find的总结Linux 命令大全","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/"},{"title":"Linux常用命令整理（2）","text":"统计与过滤 grep用于过滤/搜索的特定字符,可用正则表达式能多种命令配合使用。 1grep [-option] pattern file Linux grep 命令 wc统计指定文件中的行数、字数、字节数，并将统计结果显示输出。 1wc [-option] 文件… 该命令统计指定文件中的行数、字数、字节数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数 12$ wc testfile # testfile文件的统计信息 5 100 600 testfile # testfile文件的行数为5、单词数100、字节数600 Linux wc命令 进程相关进程的挂起1kill -stop PID //将进程挂起（redhat） 需要重新执行当前被挂起的任务时，使用 bg %num 即可将挂起的 job 的状态由 stopped 改为 running，仍在后台执行。需要改为在前台执行时，执行fg %num 即可。也可以使用[ctrl]+[z] pstree123pstree -p //可以显示进程树pstree -apnh //显示进程间的关系pstree -u //显示用户名称 Linux pstree命令 lsof （lists openfiles）1lsof [参数][文件] //需要root执行（因为要访问核心内存和各种文件） 功能： 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。 好用的系统监视工具（神器）。 有着最多开关的Linux/Unix命令之一 lsof打开的文件可以是：1.普通文件2.目录3.网络文件系统的文件4.字符或设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.网络文件（例如：NFS file、网络socket，unix域名socket）9.还有其它类型的文件，等等lsof 菜鸟教程Linux 命令神器：lsof ps(process status)1ps [options] [--help] //用来显示当前进程的状态 ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。如果想要动态的显示进程信息，就可以使用top命令。 1234root@ubuntu:~# ps PID TTY TIME CMD13777 pts/1 00:00:00 bash14564 pts/1 00:00:00 ps Linux ps命令 jobs12jobs[选项][参数] //用于显示Linux中的任务列表及任务状态，包括后台运行的任务。//jobs 的状态可以是 running, stopped, Terminated 该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。 12345678910root@ubuntu:~# jobs //后台没有进程，所以jobs命令的输出是空root@ubuntu:~# ping 192.168.0.1PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.^Z[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs -l //-l：显示进程号；[1]+ 14661 Stopped ping 192.168.0.1 jobs命令 fg、bg、jobs、&amp;、ctrl + z都是与系统任务有关的常用命令 12345command&amp; 或者 ctrl + z 让进程在后台运行 jobs 查看后台运行的进程 fg %jobnumber 让后台的进程jobnumber到前台到前台 bg %jobnumber 让进程jobnumber到后台去 //%jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid) kill1kill[参数][进程号] 功能： 发送指定的信号到相应进程。不指定信号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 1234//通过 jobs 命令查看 job 号（假设为 jobnumber）kill %jobnumber通过 ps 命令查看 job 的进程号（PID，假设为 pid）//kill pid killall1killall[参数][进程名] //用来结束同名的的所有进程（kill processes by name） killall命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。 系统监测top1top [参数] 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 free1free [参数] 功能： free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略 1234root@ubuntu:~# free total used free shared buff/cache availableMem: 1009176 136644 172116 628 700416 687996Swap: 0 0 0 vmstat (virtual memory statistics)功能： 用来显示虚拟内存的信息 1234root@ubuntu:~# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 172200 145008 555428 0 0 0 6 16 15 0 0 100 0 0 虚拟内存的原理：在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。 iostat (I/O statistics)1iostat[参数][时间][次数] 功能： 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。 Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 命令执行watch1watch[参数][命令] 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令（也就是说定个具体时间或者隔一段时间执行一次）watch命令 1watch -n 1 -d 'pstree|grep http' # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。 at1at[参数][时间] 功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on） crontab通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 Linux crontab命令详解 ##文件传输 rcp (remote file copy)1rcp [参数] [源文件] [目标文件] 功能：rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。 rcp（远程文件拷贝）命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。 scp (secure copy)1scp [参数] [源路径] [目标路径] 功能： scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 linux的scp命令可以在linux服务器之间复制文件和目录。 wget1wget [参数] [URL地址] 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。 支持断点下传功能 同时支持FTP和HTTP下载方式 支持代理服务器 参考资料Linux命令大全（手册）Linux 命令大全（菜鸟教程）","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/"},{"title":"Linux概述","text":"Linux设计目标Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。 设计Linux的基本方针： 每个程序只做一件事并且做好。 好的程序员追求的系统 简单，优雅， 一致性 （最小惊讶原理） 较强的功能性与灵活性 意味着系统有较小的一组基本元素，产生多种多样的组合来满足各种应用需要。 Linux的接口 Linux系统层次结构 所有版本的Linux必须提供大量的标准程序，其中一些是POSIX标准指定的，其他的根据Linux的版本而有所不同。它们包括： 命令处理器（shell） 编译器 编辑器 文本处理程序 文件操作工具等 Linux具有三种不同的接口 真正的系统调用接口 库函数接口 由标准应用程序构成的接口 shellshell中，后台运行一个程序的语法是在原本命令后加“&amp;”。 shell脚本：包含shell命令的文件。 可以包含参数，同时使用if、for、while和case等结构。 可以给变量赋值，然后过一段时间再读取这些变量。 linux应用程序应用程序分类Linux的命令行用户界面包含大量的标准应用程序。大致分为6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 过滤器过滤器有： grep、sort、head、tail cut和paste（文档剪切与粘贴） od：将输入（通常是二进制，也包括八，十和十六进制）转化为ASCII文档。 pr：打印机格式化输出 tr：字符大小写转换 编译器和程序设计工具编译器和程序设计工具： gcc ar：将库函数收集到存档文件中 make：维护程序，跟踪哪些头文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。 内核结构 Linux内核结构 内核最底层，负责中断处理程序，这是它们与设备交互的主要方式，以及底层的分派机制。分派在中断时发生。 底层的代码中止正在运行的进程，将其状态存储在内核进程结构中，然后启动相应的驱动程序。 进程分派，在内核完成某些操作并且需要再次启动一个用户进程时，发生。进程分派的代码是汇编代码，并且和进程调度的代码有很大不同。 内核子系统的三个主要部件 I/O部件 包含所有负责与设备交互以及实现联网和存储的I/O功能的内核部件 内存管理部件 维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法。并根据需要把需要的数据和代码页读入内存中。 进程管理部件 主要是进程的创建和中止。还有CPU调度和信号处理。 内核最顶层，是内核的系统调用接口。所有的调用都来自这里，其导致一个陷阱，将系统从用户态切换到受保护的内核态，继而将控制权交给上述的内核部件之一。 参考资料现代操作系统","link":"/2020/04/20/Linux%E6%A6%82%E8%BF%B0/"},{"title":"操作系统与文件系统简述","text":"操作系统 1940s，1950s的年代，计算机慢，一次只能运行一个程序，程序员在打孔纸上写程序，拿到一个计算机房间，交给操作员。操作员等计算机空下来后，将程序放入，然后运行，输出结果，停机。 计算机变快之后，放程序的时间比程序运行时间还长，我们需要计算机以一种方式自动运作——&gt;操作系统 到1950年代尾声，计算机已经变得非常快了，处理器经常闲着，等待慢的设备（比如打印机，读卡器等），也就是程序阻塞在I/O上 50年代后期，曼彻斯特大学研发了世界上第一台超级计算机，Atlas，想法设法最大限度利用它，1962年设计了atlas supervisor程序，能够在一个CPU上运行多个程序（这种能力也叫多任务处理）Atlas是世界上第一台同时支持虚拟内存和内存保护的电脑 同时运行多个程序会有一些问题 每个程序都会占一些内存，切换程序的时候不能丢失数据 解决办法是给每一个程序配置专属内存块 分配专属内存块到物理地址时候，可能物理地址不连续的，为了隐藏这种复杂性，把内存地址虚拟化，也就是虚拟内存机制 这种机制可以使程序内存大小灵活增减，也叫动态内存分配 内存保护：程序只能捣乱自己的内存，不会影响到其他的程序。 分时操作系统Multics 首次在设计时候考虑了安全机制，但是导致系统过于臃肿。 Dennis 和 Thompson 联手打造了Unix，将os分为两部分 操作系统的核心功能，比如内存管理，多任务和输入输出管理，称之为内核 一堆有用的工具，比如程序和运行库 Unix中并没有向multics这么多的错误处理代码-如果有错误产生，就让内核恐慌（kernel panic） 内核崩溃是没有办法恢复的，所以调用了一个pannic的函数，起初只是打印pannic一词，然后无限循环Unix成为1970-1980年代最流行的操作系统之一 1980年代，计算机降价到普通人买得起，这时候叫个人电脑。起初微软的操作系统没有内存保护，经常蓝屏,后来微软都加上了 我们现在用的ios，安卓，windows，macos基本上都有了内存保护，虚拟内存，多任务了； 文件系统文件格式：随机排列文件当然没有问题，但是随机排列会更好的 最简单的文件格式 文本文件（.txt） 元数据（meta data）：关于数据的数据元数据存在于文件开头，在实际的数据前面，因此也叫文件头（header） 早期计算机只做一件事，比如火炮射程表，这时候整个存储器就像一个文件（数据从头到尾直到占用满） 后期计算和存储能力的提升，可以存多个文件了，这时候最简单的方式是把文件连续存储，一个个在内存中连续存放但是存储器没有文件概念，只存储大量位，我们怎么直到文件的开头和结尾在哪呢？所以我们需要一个特殊文件，来记录其他文件存储的位置这个特殊文件有很多名字，这里泛称为“目录文件”,这个文件经常是存放在开头的 目录文件存放 其他文件的名字”文件名+”.“+扩展名“ 文件的元数据，比如创建时间(created)，最后修改时间(last modified)，文件所有者，是否能读写，最重要的是文件的起始位置和长度 就像书的目录意义，更改了书里面的内容，就需要更改对应的目录 目录文件和对目录文件的管理是一个非常简单的文件系统的例子 上面的例子是”平面文件系统“：文件都在同一个层次平面文件系统存在的问题：如果给某个文件加数据，会覆盖掉后面文件的一部分 所以现代的文件系统会做两件事 把空间预先分为一块块，并留一些“预留空间”可以方便改动和管理 （用这样的方案目录文件需要记录文件存放在哪些块里面） 拆分文件，存放在多个块里面，这样文件可以轻松增大和缩小（目录文件会记录不只一个块）//有点像虚拟内存 删除文件只需要在目录文件上删除那条记录即可。 碎片：文件存储在多个块里面，块之间是分开的，顺序也是乱的。//是增删改文件导致的，不可避免的 对很多存储技术来说，碎片是坏事，现实生活中大文件可能存放在数百个块里面，导致打开文件特别慢。如何解决？碎片整理！计算机把数据来回移动，排成正确的顺序 分层文件系统树状目录的形式 目录文件（根目录）不仅要指向文件，还要指向目录（is directory字段）//相对于平面文件系统的变化 无线深度的文件夹 可以轻松移动文件，只需要改动两个目录文件（一个删去一条记录，一个加一条记录） 存储介质如今存储技术正朝向固态前进，没有机械活动部件，里面是集成电路，不用像磁盘那样磁头等待磁盘旋转，ssd访问时间低于1/1000秒，但是仍然比RAM慢很多倍，所以现代计算机仍然用层次存储结构。第一个RAM出现于1972年，成本每比特一美分 参考资料Crash Course Computer Science","link":"/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/"},{"title":"常用数据结构简述","text":"算法处理的数据在内存中的格式是什么？我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构 数组array几乎所有的编程语言都自带了许多函数来处理数组，比如数组的排序 字符串string是数组的亲戚i = “love”虽然长得不像数组，但的确是数组，在计算机幕后的确是这样的字符放在内存中以/0结尾，不是”字符0“而是”二进制0“，这叫字符“null”，表示字符串结尾。 这个字符非常重要，如果调用print函数，会从开始位置逐个显示到屏幕，但是得直到什么时候停下来!否则会把内存中的所有内容输出。 矩阵matrix数组的数组 结构体struct多个变量打包在一起，在内存中会自动组织到一起的 节点node与指针struct可以构建复杂的数据结构，比如node 12345struct listnode{ int value; listnode * next;}; 链表linked list使用node来构建链表灵活性是通过每个节点指向下一个节点实现的循环链表（circular list）：尾部的next指向开头非循环链表：尾部节点指针值是null链表使用的时候很少看具体地址么，而是经常使用链表的抽象模型 链表的优点 容易重新排序，两端缩减，分割，倒序等 因为灵活很多数据结果可以用链表实现，比如队列和栈 队列queueFIFO队列的链表实现比方1-&gt;2-&gt;3-&gt;4-&gt;5可以让队列头指向1，队列尾部指向5 （也就是链表的节点连接是反向的）入队（enqueuing）出队（dequeuing） 栈stackLIFO入栈（push onto the stack）和出栈（pop from the stack） 树tree123456struct treenode{ int value; listnode * nextleft; listnode * nextright;}; 最重要的性质：树到根是单向的 二叉树 binary tree每个节点至多两个孩子 图graph顶点多对多 参考资料Crash Course Computer Science","link":"/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"},{"title":"软件工程简述","text":"为了写大型程序，程序员们使用了各种工具和方法，形成了软件工程这门学科。软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言： 这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。 对象尽管可以将大项目分解为小函数，每个人同时工作，不用关心整个项目，只关心自己的函数高效和正确就好啦，然而把代码打包成函数还是远远不够的。比如微软Office软件有近4000万行代码，打包成函数也还有几十万个，也还是也有点多。解决办法是，把函数再次打包成为层级，把相关的代码都放到一起，打包成对象（objects）。 面向对象编程（object oriented programming）把函数打包成为对象的思想叫做“面向对象编程”。对象可以包含对象，函数，变量。子对象也是同样的，所以会出现沿着对象层级一层层找执行函数的做法。 API软件工程的比喻：就像建造摩天大一样，有管道工配置管道，电工装电线，油漆工涂油漆，还有成败上千人做其他的事情。所以一个大团队中有许多小团队，不同小团队之间负责不同的功能，所以不同团队之间需要文档，才能帮助理解代码都在做什么，还需要定义好的程序编程接口（API）API帮助不同程序员合作，不需要直到细节，只要直到怎么使用就好了。 然后private与public提供不同的权限，哪些不让外部访问，哪些仅供内部访问。 面向对象的核心： 隐藏复杂度 选择性公布功能 IDE与调试（debugging）代码在编译之前只是文字，可以用任何文本处理程序写代码，但是一般来时，还是会用专门的工具来写比较好。IDE提供了许多有用功能，因为集成了所有的东西，所以叫IDE。 代码帮助，提示，整理，编译，测试 文档和注释（readme/comment）程序员另一项重要工作是给代码写文档文档一般放在readme中文档也可以写成注释，放在源代码中好的文档的作用： 能帮助开发者几个月后理解自己和他人的代码 还能提升复用性，与其让程序员一遍遍写已经有的东西，不如直接用别人写好的来解决问题。 版本控制源代码管理，帮助团队协作，也叫版本控制。弄懂git原理即可。 质量控制写代码与测试代码密不可分。测试也称为质量保证测试（QA，quality assurance testing）。严格测试软件的方方面面，看软件会不会出错，也就是找Bug。 Beta Alphabeta版软件（beta software）：意思是软件接近完成，但不是百分之一百通过测试过，公司有时会向公众发布beta版本，以帮助发现问题。alpha版软件（alpha version software）：一般很粗糙，错误多，只在公司内部测试。 参考资料Crash Course Computer Science","link":"/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"title":"文件系统（1）","text":"基础概念文件系统：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容 文件文件结构文件可以有多种构造方式。 字节序列（Windows，UNIX都采用这种文件模型） 记录序列（以前大型计算机系统中的常见模式，现在没多少了） 树（处理商业数据的大型计算机中获得广泛使用） 文件在这种结构中由一棵记录树构成，每个记录并不具有同样长度，记录的固定位置有一个键。树按键排序，从而对特定的键进行快速查找 文件类型Linux中分为 普通文件（regular）：存在于外部存储器中，用于存储普通文件。 目录文件（directory）：用于存放目录项，是文件系统管理的重要文件类型。 管道文件（pipe）：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件（socket）：一种用于网络间通信的特殊文件。 链接文件（link）；用于间接访问另外一个目标文件，相当于widows快捷方式。 字符设备文件（character）:字符设备在应用层的访问结构。 块设备文件（block）：块设备在应用层的访问接口。 文件存取 顺序存取文件（sequential access）：进程可以从头到尾顺序读取文件的全部字节或者记录，但不能跳过某一些内容，也不能不按顺序读取。可以返回到起点的。 随机存取文件（random access）：以任何次序读取其中字节或记录的文件。对很多应用程序来说是必不可少的，比如数据库系统 文件属性操作系统常用的文件属性 文件保护 属性 含义 备注 保护 谁可以存取文件，以什么方式 口令 存取文件需要的口令 有一些系统中，用户必须给出口令才能存取文件 创建者 创建文件者ID 所有者 当前所有者 标志 属性 含义 备注 只读标志 隐藏标志 系统标志 0表普通文件，1表示系统文件 存档标志 0表示已经备份，1表示需要备份 ASCII/二进制标志 0表示ASCII文件，1表示二进制文件 随机存取标志 0表示只允许顺序存取，1表示随机存取 临时标志 0表示正常，1表示进程退出时删除文件 加锁标志 0表示未加锁，非零表示加锁 查找读写相关 属性 含义 备注 记录长度 一个记录中的字节数 键的位置 每个记录中键的偏移量 键的长度 键字段的字节数 当前大小 文件字节数 最大长度 文件可能增长到的字节数 时间 属性 含义 备注 创建时间 最后一次存取时间 最后一次修改时间 文件操作最常用的一些系统调用（不限制系统的总结） create delete open close read write append：write的限制形式，智能在文件末尾读取数据 seek：对于随机存取文件，通常需要指定从何处读取数据，通常使用seek系统调用把当前位置指针指向文件中的特定位置。seek调用结束后，就可以从该位置开始读了。 get attributes set attributes rename Linux文件IO函数，通常包括 open,read,write,lseek,close这五个函数。 目录目录操作 create delete opendir closedir readdir rename link ulink 文件系统的实现文件系统布局文件系统存放：文件系统存放在外存上。多数磁盘划分为一个或者多个分区，每个而分区有一个独立的文件系统。主引导记录（master boot record，MBR）：磁盘的0号扇区称为主引导记录，用来引导计算机，MBR之后挨着的是分区表,该表给出了每一个分区的起始和结束地址。在计算机被引导时，BIOS读入并执行MBR。MBR执行的第一件事情是确定活动分区，读入活动分区的第一个块，称为引导块（boot block），并执行之。引导块中的程序将装载该分区中的操作系统。为了统一，每个分区都从一个启动块开始，即使它不含一个可以启动的操作系统。不过，在将来这个分区也许会有一个操作系统的。 文件的实现文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。不同的操作系统采用不同的方法。 连续分配最简单的分配方案：把每个文件座位一连串连续数据存储在磁盘上。所以，在块大小为1KB的磁盘上，50KB的文件要分配50个连续大小的块。优点 实现简单。记录每个文件用到的磁盘块简化为只需记住两个数字即可：第一块的磁盘地址和文件的块数。 读性能好。单个操作就可以从磁盘上读出整个文件。只需一次查找（对第一个块）。之后就不需要寻道和旋转延迟，所以数据以磁盘全带宽的速率输入。可见连续分配实现简单且具有较高的性能。 很适合DVD，CD-ROM等一次性光学介质的存储。 缺点 磁盘零碎问题。删除文件之后会留下空闲块，随着时间的推移会使得磁盘变得零碎，既有文件也有空洞 要么压缩磁盘。代价太高不可行。 要么重新使用空洞。需要维护一个空闲空间列表，但是为了挑选合适的空闲空间，需要知道该文件的最终大小。如果用户为了避免找到的空闲空间太小而提前给出一个不切实际的较大数字，则可能无法找到合适的空闲空间而导致失败。 链表分配链表分配：为每个文件构造磁盘块列表，每一个块的第一个字作为指向下一块的指针，块的其他部分存放数据。优点 可以充分利用每个磁盘块，不会因为磁盘碎片而浪费存储空间。 顺序读文件很方便 缺点 随机存取非常慢 由于指针占去了一些字节，每个磁盘块存储文件数据的字节数不再是2的整数次幂，这种怪异的大小会降低文件的存储效率。（类似于没有对齐） 很多程序都是以2的整数次幂来读写磁盘块的。因为上面论述的原因，要读出一个完整的2的整数次幂的块需要从两个磁盘中获得和接收信息，这就因为复制引发了额外的开销。 在内存中采用表的链表分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 可以取出每个磁盘块的指针字，把它放在内存的一个表里面，就可以解决链表分配的两个不足。 文件分配表（FAT,File Allocation Table）：这个表实现了链表的操作。文件分配表的每一个表项存放着文件数据的下一个块的块号 优点 磁盘文件块可以不用存放指针，这样整个块都是数据。 随机存取更加容易，整个文件分配表实现的链表都在内存中，不需要磁盘引用。 不管文件多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。 缺点 占用内存空间大。必须整个表都存放在内存中。 对于200GB的磁盘和1KB大小的块，这张表有2亿项，每一项至少三个字节，为了提高查找速度，有时需要4个字节。根据系统对空间和时间的优化方案，这张表需要600MB或者800MB，不实用。 i节点分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 既然整张文件分配表太大了，我们就拆分成小的放，实现一个新的数据结构i节点。 i节点（index-node）：每个文件都赋予了一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。优点： 只有在对应的文件打开时候，其i节点才在内存中 缺点与解决方案： 每个i节点只能存储固定数量的磁盘地址，那么当一个文件所包含的磁盘块的数目超出了i节点所能容纳的数目怎么办呢？ 一个解决方案，最后一个i节点中的磁盘地址不指向数据块，而是指向一个包含磁盘块地址的块的地址。 目录的实现每个目录项只引用i节点的目录 共享文件共享文件：当几个用户在同一个项目里面工作时候，他们常常需要共享文件。其结果是，如果一个共享文件同时出现在属于不同用户的不同目录下面，工作起来就很方便。连接（link）：原本属于C目录下的文件也出现在B目录下的话，B的目录与该共享文件的联系称为一个连接（link）。这样文件系统本身也成为了一个有向无环图（DAG）。 共享文件的问题： 如果目录包含磁盘地址，则当连接文件的时候，必须把C目录中的磁盘地址复制到B目录。如果B或者C之后又向文件中添加内容，则新的数据块只会列入添加工作的用户的目录中。其他用户是不知道的。这违背了共享的初衷 硬连接和软连接解决方案： i节点方法：磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中，目录指向这个数据结构(Linux中的i节点）（硬连接） 实现机制：需要有一个文件所有者计数机制，当B连接到共享文件时，i节点记录文件的所有者是C，建立一个连接并不会改变所有关系，但是它将i节点的连接技术加1，所以系统知道当前有多少目录项指向这个文件。 缺点：C删去这个文件之后，还有许多目录项指向它，其他硬连接会指向错误的文件。 改进：唯一能做的是只删除C的目录项，但是保留i节点，所有者计数减一。只有到计数为0的时候才会真正删除该文件。 符号链接方法（symbolic linking）：让系统建立一个类型为Link的新文件，并把该文件放在B目录下，使得B与C的一个文件存在链接。链接文件只包含了它所连接的文件的路径名。（软连接） 缺点：需要额外的开销。必须读取包含路径的文件，然后一个部分一个部分地扫描路径，直到找到i节点 缺点：每个符号链接需要额外的i节点和一个额外的磁盘块用于存储路径，如果路径很短，作为一种优化，系统可以将它存储在i节点中。 优点：只要简单提供一个机器的网络地址和文件在该机器上的路径，就可以连接全球任何地方的机器的文件。 tips：还有一个由连接带来的问题，在符号连接和其他方式中都存在。如果允许连接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被连接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被连接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被连接的文件将被两次复制到磁盘上，而不是只是被链接起来。 参考资料现代操作系统简直不要太硬了！一文带你彻底理解文件系统理解linux 的 inode解决inode耗尽问题","link":"/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/"},{"title":"C++内存分配与内存划分","text":"C/C++内存使用划分C/C++编译过的程序使用的内存划分： 栈区 是连续的内存区域。 由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。 栈区的变量通常是局部变量、函数参数等。 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 每次程序运行都会分配一个栈，main函数就在栈底，然后通过不同函数的调用顺序，依次进栈出栈。c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗堆区（动态内存分配） 是不连续的内存区域。 自由存储区或堆：每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C 语言程序使用一对标准库函数malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和delete 表达式实现相同的功能。可以手动释放或者程序结束自动释放存储空间。优点：动态内存的生存期人为决定，使用灵活。缺点：是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 全局/静态存储区全局变量和静态变量的存储是放在一起。C语言中，全局变量又分为初始化的和未初始化的。C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统释放。 常量存储区这是一个比较特殊的存储区，里面存放的是常量，不允许修改。程序结束后由系统释放。 程序代码区存放函数的二进制代码。 堆存储/栈存储对象是存放在堆中还是栈中要看怎么去构造这个对象： 如果用new来生成的对象,是放在堆中的。 直接定义的局部变量内都是放在栈中的，全局和静态的对象（包括类的静态数据成员）是放在数据段的静态存储区 1234Class Test；Test p; //栈上分配内存Test* tTest； //指针在栈中tTest = new Test;，//new的在堆中 堆存储 因为没有专门的系统支持，效率很低； 可能引发用户态和核心态的切换，内存的申请代价变得更加昂贵。 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 因为找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 栈存储 用于存储占用空间小，生命周期短的数据（局部变量/参数变量等） 若栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出 出现栈内存溢出的常见原因有2个： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。 局部变量体积太大。 地址分配 堆，往下增长，向内存地址增加的方向增长 栈，往上增长，向内存地址减小的方向增长（对于小端存储，高位字节在高端地址、低位字节在低位地址，因此在压栈时先压高字节后压低字节） 可能会发生堆栈冲突(从堆中分配内存失败或者爆栈) 大端存储：数据高位在内存低位，低位在内存高位（如Freescale的PowerPC处理器） 小端存储：数据高位在内存高位，低位在内存低位（Intel的芯片一般是小端存储） 分配效率栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 堆、栈与大小端存储 数据存放基本数据类型： 直接存储在栈(stack)中的数据。（字符串、布尔值、未定义、数字、null） null只是一个空指针对象，没有数据。 引用类型： 将该对象引用地址存储在栈(stack)中，然后对象里面的数据存放在堆中。（数组、对象、函数） 存储的是该对象在栈中的引用，真实的数据存放在堆内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝与浅拷贝深拷贝既复制对象空间又复制资源在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值，然后同步复拷贝开辟空间的值。 浅拷贝只复制对象空间而不复制资源 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。default memberwise copy即称为浅拷贝。 即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝) 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值； 如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 C/C++内存分配的三种方式 静态存储区分配内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。 栈上分配在函数执行时，函数内的局部变量的存储单元在栈上创建，由操作系统自动分配，函数调用结束时内存也随之析构栈内存分配运算内置于处理器的指令集中，效率高，但栈容量小。 堆上分配堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放,在整个程序运行周期内都存在。 tips: 申请内存后立即判断指针是否为NULL确定内存是否分配成功，如果为NULL则立即用return终止此函数，或者用exit（1）终止整个程序的运行，为new和malloc设置异常处理函数； 为申请的内存赋初值，分配的是一段连续的内存空间的话，要防止指针下标越界； sizeof是操作符，不能用sizeof得到内存空间的大小，只能在申请时候记住申请的空间大小； 在内存使用结束后必须用free或delete释放内存，注意在内存使用中如果存在指针加1或减1 的操作应特别注意，释放的内存要和申请的内存一致，放置内存泄漏，释放内存后，应该立即将指针置为NULL，不要存在野指针。 参考资料[1]浅拷贝与深拷贝的区别[2]C++中数据存储的位置[3]C++经典面试之 内存分配的三种方式[4]堆、栈与大小端存储[5]c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗","link":"/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"},{"title":"C++特性及优缺点","text":"C++语言优缺点 优点 兼容性好，C++在保持了C语言简洁高效的特点的同时，还对C的类型系统进行改革性扩充，相比C语言，C++更安全，其编译系统也能检查出更多错误类型。 面向对象编程能力，可复用性好，可以让团队衍化出自己的的类库。 性能优势，程序效率高。 缺点 C++ 是 C 语言的一个超集，既有指针又有对象使它成为最复杂的语言，学习难度大。过分的精细和复杂了。C++的复杂度，超过了C和OO（面向对象）的复杂度之和 没有垃圾回收机制。 C++本质上说是提前编译的，Fortran也是。C#和Java大多时候是编译成字节码，运行的时候再 即使编译。Python和Ruby通常是解释型。这就产生了一个性能的分级：C++和Fortran比Java和C#快，Java和C#又比Python 和Ruby快。几种计算机语言的评价（修订版）为什么一些语言会比别的快？ C++特性C++面向对象的三个基本特征：封装、继承、多态。它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用在 C++ 中，用类进行封装（数据抽象），用类派生从一个类继承另一个：派生类继承基类的成员。多态（动态绑定）使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数继承和多态（动态绑定）在两个方面简化了我们的程序：能够容易地定义与其他类相似但又不相同的新类，能够更容易地编写忽略这些相似类型之间区别的程序。 封装（encapsulation）封装是一项低层次的元素组合起来的形成新的、高层次实体的技术。 函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。 类也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。 目的： 将抽象得到的数据和行为相结合，形成一个有机的整体（结合性） 将对象的使用者和设计者分开，以提高软件的可维护性和可修改性 实现代码重用 继承（inheritance）继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 通过继承关联起来的类型都共享共同的接口。当一个类继承另一个类时，这两个类通常可以使用相同的操作。更确切地说，如果两种类型存在继承关系，则可以说一个类“继承”了其父类的行为——接口。 C++ 中所提及的父类称为基类（base class），而继承而来的类则称为派生类（derived class）。 多态（polymorphism）多态：多态的基础是继承。多态下，子类重写父类的方法，实际使用过程中，用父类引用变量指向子类对象，此时父类引用调用的是子类重写后的方法，由于是父类引用变量，所有无法调用子类特有的方法。如果想调用子类特有的方法，必须强制类型转换到子类。多态性派生于一个希腊单词，意思是“许多形态”。之所以称通过继承而相关联的类型为多态类型，是因为在许多情况下可以互换地使用派生类型或基类型的“许多形态”。在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。多态性：指的是基于引用或指针的动态类型获得类型明确的行为的能力。 在C++中的主要表现是动态多态（动态绑定） 动态多态（动态绑定）：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。 在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。 引用和指针的静态类型与动态类型可以不同，这是 C++ 用以支持多态性的基石。 静态多态（编译期/早绑定）template（模板）：静态多态（编译时完成，效率高，适配性高，松耦合性），隐形接口overload（重载）：静态多态 同名函数，不同参数/函数返回值 相同范围，同一个类中 overwrite（重写）：静态多态，子类屏蔽父类的同名基函数 同名同参，无virtual 同名不同参 动态多态（运行期/晚绑定）override（覆盖重写）：动态多态（运行时完成，接口重用，编译器无法优化） 不同类中 同名，同参 基类函数有virtual 参考资料[1]C++ primer 第四版[2]几种计算机语言的评价（修订版）[3]为什么一些语言会比别的快？[4]C++ 特性及类（面试复习整理）[5]C++ 多态-菜鸟教程","link":"/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"设计模式总结","text":"设计模式是什么？ 基础概念设计模式（Design pattern）: 是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。GOF（Gang of Four）1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 为什么要用设计模式？ 为了重用代码 让代码更容易被他人理解 保证代码可靠性。 设计模式在软件开发中的两个主要用途： 开发人员的共同平台，提供了一个标准的术语系统，且具体到特定的情景。 例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。设计模式有哪些？共有 23 种设计模式，可以分为三类： 创建型模式（Creational Patterns） 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式（Structural Patterns） 用于在许多不同的对象之间形成大型对象结构,关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 行为型模式（Behavioral Patterns） 关注对象之间的通信,用于管理对象之间的算法、关系和职责。 创建型模式单例模式（Singleton Pattern）单例模式-菜鸟教程目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。何时使用：当您想控制实例数目，节省系统资源的时候。面临的问题：一个全局使用的类频繁地创建与销毁。解决方案判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。应用实例：1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。使用场景：1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。实现方式:《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 常见的单例模式分为两种：1、饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式2、懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式【C++】单例模式/工厂模式 工厂模式（Factory Pattern）设计模式之工厂模式（factory pattern）讲的很形象工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式。工厂模式-菜鸟教程提供了一种创建对象的最佳方式，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。目的：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程（类的实例化）延迟到子类进行。何时使用：我们明确地计划不同条件下创建不同实例时。面临的问题： 抽象工厂模式（Abstract Factory Pattern）根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者（生成器）模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 深拷贝与浅拷贝浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深拷贝：把要复制的对象所引用的对象都复制一遍。深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 结构型模式适配器模式（Adapter Pattern）作为两个不兼容的接口之间的桥梁。将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 装饰者模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。作为现有的类的一个包装。动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）用于减少创建对象的数量，以减少内存占用和提高性能。尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern）为其他对象提供一个代理以控制对这个对象的访问。 行为型模式模版方法模式（Template Method Pattern）设计模式 - 模板方法.定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。比如冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 命令模式（Command Pattern）设计模式 - 命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 观察者模式（Observer Pattern）当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。 中介者模式（Mediator Pattern）用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 备忘录模式 （Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 解释器模式（Interpreter Pattern）为语言创建解释器，通常由语言的语法和语法分析来定义。给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 状态模式（State Pattern）类的行为是基于它的状态改变的。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。 职责链模式 （Chain of Responsibility Pattern）为请求创建了一个接收者对象的链，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 访问者模式 （Visitor Pattern）使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 参考资料设计模式之工厂模式（factory pattern）《大话设计模式》读书笔记设计模式-菜鸟教程C++ 设计模式-CSDN【C++】单例模式/工厂模式C++中的单例模式和工厂模式","link":"/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"C++标准库容器类概述","text":"基础概念容器（container）： 容纳特定类型对象的集合。 C++中所有的容器都是类模板。 所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。容器默认构造函数不带参数。 为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。容器适配器（adaptors）： 适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。 STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。 什么是适配器，C++ STL容器适配器详解 顺序容器和关联容器关联容器和顺序容器的根本不同在于： 关联容器中的元素是按关键字来保存和访问的 顺序容器中的元素则是按它们在容器中的位置来顺序保存和访问的。 顺序容器顺序容器（sequential container）： 它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。 顺序容器不是排序的：元素排列次序与元素值无关。 而是由元素添加到容器里的次序决定。 主要的有三种：可变长动态数组 vector、双端队列 deque、双向链表 list。 汇总的有vector、deque、list、forward_list、array、string等。 表1. 顺序容器与顺序容器适配器: 顺序容器 用途 顺序容器适配器 用途 底层基础容器 vector 可变长动态数组，支持快速随机访问 stack 后进先出（LIFO）堆栈 默认使用deque。满足条件的基础容器有 vector、deque、list list 双向链表，支持快速插入/删除 queue 先进先出（FIFO）队列 默认使用deque。满足条件的基础容器有 deque、list deque 双端队列 priority_queue 有优先级管理的队列 默认使用vector。满足条件的基础容器有vector、deque。 除了上面的表格之外还存在forward_list顺序容器（单向链表，只支持单向顺序访问），请看文章链接 关联容器关联容器（Associative containers）： 支持通过键（key）来高效地查找和读取元素。 关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。虽然关联容器的大部分行为与顺序容器相同，但其独特之处在于支持键的使用。 关联容器支持很多顺序容器也提供的相同操作，此外，还提供管理或使用键的特殊操作。关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 有序关联容器有序关联容器有以下四种：set、multiset、map、multimap。 容器元素根据键的次序排列。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 在迭代遍历关联容器时，我们可确保按键的顺序的访问元素，而与元素在容器中的存放位置完全无关。 map 以键－值（key-value）对的形式组织：键(key)用作元素在 map 中的索引，而值(value)则表示所存储和读取的数据。 map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。 常用操作： map查询操作 操作 作用 m.count(k) 返回 m 中 k 的出现次数 m.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在: 123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 读取元素而不插入该元素: 12345//find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器：int occurs = 0;map&lt;string,int&gt;::iterator it = word_count.find(\"foobar\");if (it != word_count.end()) occurs = it-&gt;second; 更好的请参考：《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;map multimap 支持同一个键多次出现的 map 类型 set set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询。 适用条件： 如果希望有效地存储不同值的集合，那么使用 set 容器比较合适 当只想知道一个值是否存在时，使用 set 容器是最适合的。 set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。 set 容器存储的键也必须唯一，而且不能修改（也体现了 set 存储的元素仅仅是键，而没有所关联的值） multiset 支持同一个键多次出现的 map 类型 multimap和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和set 头文件。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。 无序关联容器unordered_mapunordered_multimapunordered_setunordered_multiset STL容器类库&lt;vector&gt;：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。&lt;list&gt;：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。&lt;deque&gt;：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。&lt;queue&gt;：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。&lt;stack&gt;：为堆栈(后进先出)数据结构定义序列适配器stack。&lt;map&gt;：map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。&lt;set&gt;：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。&lt;bitset&gt;：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。&lt;array&gt;：（TR1）固定大小数组，支持复制。&lt;forward_list&gt;：（c++11）单向列表，forward_list不提供随机访问，这一点跟list相同。forward_list是一个单向链表，只支持单向顺序访问，在链表的任何位置进行插入/删除操作都非常快。&lt;unordered_set&gt;：（TR1)无序容器set，其元素随机存放。唯一键的集合，按键散列。multiset类似于set，但是值不必是唯一的。&lt;unordered_map&gt;：（C++11）（TR1)无序容器map，其键值随机存放。键-值对的集合，由键散列，键是唯一的multimap类似于map，但键不是唯一的。完整的看C++中常用的std标准容器 STL容器类底层实现vector底层数据结构为数组 ，支持快速随机访问 list底层数据结构为双向链表，支持快速增删 deque 底层数据结构为一个中央控制器和多个缓冲区 支持首尾（中间不能）快速增删，也支持随机访问 STL源码分析146页 forward_list 顺序容器，底层数据结构为单向链表。 只支持单向顺序访问，支持快速增删 stack 底层一般用list和deque实现，封闭头部即可。 不用vector的原因应该是容量大小有限制，扩容耗时。 queue 底层一般用list和deque实现，封闭头部即可 不用vector的原因应该是容量大小有限制，扩容耗时 priority_queue底层数据结构：一般是vector为底层容器，堆heap为处理规则来管理底层容器实现 set底层数据结构为红黑树，有序，不重复 multiset底层数据结构为红黑树，有序，可重复 map 底层数据结构为红黑树，有序，不重复 multimap底层数据结构为红黑树，有序，可重复 hash_set 底层数据结构为hash表，无序，不重复 hash_multiset底层数据结构为hash表，无序，可重复 hash_map 底层数据结构为hash表，无序，不重复 hash_multimap底层数据结构为hash表，无序，可重复 C++STL的容器的底层实现详解 参考资料C++容器（STL容器）C++语言学习（九）——C++标准库简介Containers library(cppreference.com)C++中常用的std标准容器 //可以做查找表C++中容易忘的知识点——list和forward_list（四）//可做查寻表C++ STL 的底层实现C++标准模板库（STL）的容器的底层实现C++STL的容器的底层实现详解//可以做查找表","link":"/2020/05/10/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%A6%82%E8%BF%B0/"},{"title":"数据结构总结","text":"（未完待续） 基本概念数据结构： 是数据项的结构化集合。 结构性的表现 数据项之间的相互联系和作用 或者理解为定义于数据项之间的某种逻辑次序 依据逻辑次序的复杂程度划分： 线性结构 半线性结构 非线性结构 序列（sequence）序列（sequence）：最基本的线性结构的统称。序列（sequence）依据数据项之间的逻辑次序与其物理存储的对应关系不同，又可以进一步划分向量和列表： 向量（vector）向量（vector）:所有数据项之间物理存储位置与逻辑次序完全吻合。此时的逻辑次序也称为秩（rank） 循秩访问（call-by-rank），静态存储策略。 列表（list）列表（list）:所有数据项之间物理存储位置与逻辑次序不一定吻合。采用间接定址的方法通过封装后的位置（position）相互引用。 循位置访问（call-by-position）或者称为循链接访问（call-by-link），动态存储策略。 栈（stack）栈（stack）：线性数据结构的一种，视作向量与列表的特例。对象的插入和删除限制在栈的一端。禁止操作的一端称为盲端。栈顶（stack top）：可操作（插入和删除）的一端。入栈（push）与出栈（pop）。栈底（stack bottom）：无法直接操作的盲端。 栈与递归函数调用栈调用栈（call stack）和执行栈（execution）:大部分操作系统中，每个运行的二进制程序都都配有一个调用栈，用来跟踪属于同一个程序的所有函数，记录它们之间的调用关系，并保证在每一个调用实例执行完毕之后，可以准确返回。帧（frame）：调用栈的基本单位，每次函数调用时，都会相应的创建一帧： 记录了函数实例在二进制程序中的返回地址，局部变量，传入参数，还有上一帧的栈中地址。 逆序输出进制转换 递归嵌套栈混洗（stack permutation）：栈的数据从stackA——&gt;stackS——&gt;stackB。 括号匹配： 延迟缓冲： 逆波兰表达式（reverse Polish notation，RPN）： 试探回溯法剪枝试探回溯 八皇后迷宫寻径队列（queue）视作向量与列表的特例 基本概念队列（queue）：线性数据结构的一种，对象的插入和删除限制在队列的两端。队头（front）：允许取出元素的一端。出队（dequeue）:元素的删除操作。队尾（rear）：允许插入元素的一端。入队（enqueue）：元素的插入操作。 队列应用循环分配器银行服务模拟树 半线性结构（semi-linear structure） 其中的元素之间并不存在天然的直接后继或者直接前驱关系。但是只要附加某种约束（比如遍历），就可以在树的元素之间确定某种线性次序关系。因此树属于半线性结构 叶节点（leaf）：无孩子的节点。树的高度（height）:树的所有节点深度的最大值称作该树的高度。教材中约定，单个节点的树高度为0，空树的高度为-1。 如果根结点第0，层数=深度=高度-1 如果根结点第1，层数=深度=高度 节点的高度：任一节点V的高度对应于子树的高度subtree（V）。 多叉树（k-ary tree）k叉树（k-ary tree）：每个节点的孩子均不超过k个的有根树。 多叉树的表示法父节点表示法：一个向量表，存两个属性，一个是data，一个是parent孩子节点表示法：一个向量表，存两个属性，一个是data，一个是children（组织成vector或者list）父亲+孩子节点表示法：一个向量表，存三个属性，一个是data，一个是parent，最后一个是children（组织成vector或者list） 有序树（ordered tree）有序树（ordered tree）：同一节点的所有孩子之间必须具有某一线性次序。这个约束条件使得作为多叉树特例的二叉树有足够的能力表示任何一颗多叉树。 长子+兄弟转换法同一列的是长子，同一行的是兄弟 二叉树（binary tree）二叉树（binary tree）：每个节点的读书均不超过2。有序二叉树（ordered binary tree）：同一父节点的孩子都可以左右相互切分。真二叉树（proper binary tree）：不含一度节点的二叉树 完全二叉树（complete binary tree）完全二叉树（complete binary tree）： 对于使用队列操作的层次遍历，前(n/2向下取整）次迭代中都有左孩子入队，前(n/2向上取整然后-1）次迭代中都有右孩子入队 叶节点只出现在最底部的两层。 高度为：h=（log n）的向下取整 //根节点设置为高度0的情况下 规模介于2^h与2^(h+1)-1 根节点为1，左孩子编号等于2v,右孩子编号2v+1 满二叉树（full binary tree） 规模2^(h+1)-1 遍历递归式遍历迭代版先序遍历迭代版中序遍历迭代版后续遍历层次遍历 编码树编码解码前缀无歧义编码（PFC）huffman编码 二叉编码树根通路串（root path string） 搜索树对线性数据结构查找性能的改进。如果既要求对象集合的组成可以高效率地动态调整，同时也要求能够高效率的查找，对于向量和列表这类线性结构是难以胜任的。兼顾高效率的动态修改和高效率的静态查找，可以使用搜索树。理想平衡和适度平衡，引入平衡二叉树结构，比如AVL树即使在最坏情况下，单次动态查找和静态查找也均在O（log n）时间内完成。 理想平衡和适度平衡理想平衡：如果树的高度恰好为log n，向下取整，则成为理想平衡树 ，比如完全二叉树和满二叉树 适度平衡：渐进意义下适当放松标准的平衡性。渐进的不超过O(log n)下面介绍的红黑树，AVL树，伸展树，kd-树都是适度平衡的变种。也可以归入平衡二叉搜索树之列。 搜索树的局部性 刚刚被访问的节点，可能不久后就能访问到 将被访问的下一个顶点，极可能就在不久之前被访问的某个节点附近 二叉搜索树（BST）二叉搜索树（binary search tree）：处处都满足顺序性——任一节点r的左（右）子树中，所有节点均不大于（不小于）节点r二叉搜索树的判定:任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降。 复杂度分析：insert，remove，search时间：线性正比于查找路径的长度或者最终返回节点的深度。最坏情况下可能退化成为链表。 等价二叉搜索树若两个二叉搜索树的中序遍历相同，则称它们彼此等价。概括一下就是：上下可变，左右不乱。也就是说节点的左右相对关系是不变的，但是上下关系是可以改变的。局部性： 经过单词动态修改操作，至多只有O(log n)处局部不再满足限制条件。 可以在O(log n)时间内，使这O(log n)处局（乃至全树）重新满足限制条件。 旋转调整（修复）zig 顺时针旋转zag 逆时针旋转 平衡二叉搜索树（BBST）AVL树平衡因子(balance factor)：其左，右子树的高度差。各个节点的平衡因子绝对值不超过1。也就是各个节点左右子树高度差不超过1。 失重与重新平衡：单旋与双旋：统一重平衡算法： 伸展树（splay tree）伸展树（splay tree）： 无须时刻都保持全树的平衡，但是却能够在任何足够长的序列上，保持分摊意义上的效率。 不需要对基本的二叉树节点结构，做任何附加的要求或者改动，不需要记录平衡因子或者高度之类的额外信息，故适用范围更广 利用了数据局部性，将刚刚被访问的节点，转移至树根附近。 伸展（splaying）：随着节点e的不断上升，两侧子树的结构也在不断的调整，这种过程也形象地称为伸展。 单层伸展树节点e每次提升1层，直至成为树根 双层伸展树节点e每次提升2层，直至成为树根。 zig-zig/zag-zagzig-zig/zag-zagzig/zag 复杂度分析：分摊的情况下，O（log n） 红黑数（red-black tree）通过假想地引入外部节点（黑色），将二叉树真正扩展为真二叉树。 根节点始终为黑色 外部节点均为黑色 其余节点若为红色，其孩子节点必为黑色 从任一外部节点到根节点的沿途，黑节点的数目相等 由1，2可知，红节点属于内部节点，且红节点的父节点和左右孩子肯定存在 由3可知，红节点之父必为黑色，树的任一通路不会包含相邻的红节点。7 由4可知，所有外部节点的黑高度统一 所有外部节点的黑高度统一特别的，根节点的黑高度也称为全树的黑高度，在数值上与外部节点的黑高度相等。所有外部节点的黑高度为0. 双红修正双黑修正 平衡多路搜索树平衡二叉搜索树（BBST）的推广当数据规模大到内存已经不足以容纳时候，常规平衡二叉搜索树的效率会大打折扣。其原因在于查找过程对外存的访问次数过多。 外部存储适合于批量式访问，不妨通过时间成本较低的多次内存操作，来替代时间成本相对较高的单次外存操作。 结合上面的思想，我们可以将通常的二叉树搜索树，改造为多路搜索树（等价变换） 四路搜索树：每个大节点拥有四个外部的分支。 通常是将二叉搜索树以两层为间隔合并。 一个大节点包含3个关键码和4个外部分支. 多路搜索树（multi-way search tree）：一般地，以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树。 优点： 访问外存的方式相对于二叉搜索树已经发生了本质的变化，可以以大节点为单位读取一组（而不是一个）关键码。 这组关键码在逻辑上与物理上都彼此相邻，故可以以批量方式从外存一次性读出，且需要的时间与读取单个关键码几乎一样。 每组关键码的最佳数目，取决于不同外存的批量访问特性。可以根据扇区的容量等因素来计算。 B- 树平衡多路搜索树的典型代表B-树（B-tree）：m阶B-树，也就是m路平衡搜索树 所有外部节点的深度都相等，每个内部节点都存有不超过m-1个关键码，以及用以指示对应分支不超过m个引用。各个节点的分支数应该介于m/2（向上取整）与m之间，故也称为(m/2向上取整，m)-树B-树的外部节点：B-树的宽度B-树的叶节点 非常适合在相对较小的内存中，实现对大规模数据的高效操作。 复杂度：O(logmN) kd-树（k-dimensional tree）四叉树与八叉树的一般性推广递归定义的平衡二叉树一维范围查询（range query）：给定直线L上的点集P={p0,pn-1},对于任一区间R=[x1,x2],P中的哪些顶点落在其中？离线方式和在线方式输出敏感（output sensitive）的算法平衡二叉搜索树解决一维度范围i查询问题， 找到最低共同祖先，忽略分割成为矩形，举行左边底边开，右边和顶边封闭每次切分都在中位点（对应的坐标排序居中者）。 以保证全树的高度不超过O(log n)复杂度O（根号n） 图非线性结构 邻接矩阵邻接表BFSDFS拓扑排序优先级队列与堆二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。最大堆:，任何一个父节点的值，都大于或等于它左、右孩子节点的值。最小堆:，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 完全二叉堆上滤与下滤左式堆串字符串串匹配散列表看这篇文章即可：哈希表（散列表）详解 注解偏序只对部分元素成立关系R，全序对集合中任意两个元素都有关系R。 集合的包含关系是偏序，因为两个集合可以互不包含。 复数中的大小就是偏序，其中虚数不能比较大小。 实数中的大小关系是全序，两个实数必有一个大于等于另一个。 参考资料数据结构 邓俊辉","link":"/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"title":"环状链表判断算法","text":"判断该链表是否有环 采用两个指针，一个用来遍历，一个用来从头到当前遍历位置的数据对比。思想：比较元素是否出过；复杂度：时间O(n^2),空间O(1) hash表的方法，记录元素，一旦在hash表中出现过,就证明有环复杂度：时间O(n),空间O(n) 双指针类型方法：两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。思想：追及问题，让快的先跑，如果有环，快的绕一圈后肯定会追上慢的。复杂度：时间O(n),空间O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;struct node{ int value; node *next; node(int a):value(a),next(NULL){}};typedef node list;bool iscycle(list * head){ node *p1,*p2; p1 = head; p2= head; while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL) //因为p1每次走两步，所以需要判断一下最后两个是否为空，以便决定是否循环； { p1 = p1-&gt;next-&gt;next; p2 = p2-&gt;next; if(p1==p2) { return 1; } } return 0;}int main(){ node * node1 = new node(5); node * node2 = new node(3); node * node3 = new node(7); node * node4 = new node(2); node * node5 = new node(6); node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = node5; node5-&gt;next = node2; //cout &lt;&lt; node5-&gt;next &lt;&lt; endl; cout &lt;&lt; iscycle(node1) &lt;&lt; endl;} 如何求出环的长度？当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数也就是 环长=1×前进次数 如何求出入环节点？如果链表有环，如何求出入环节点？答：只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。以上答案根据一个走两步一个走一步计算出的。 参考资料漫画算法","link":"/2020/05/14/%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95/"},{"title":"无序数组排序后的最大相邻差","text":"解法1： 使用任意一种时间复杂度为O（nlogn）的排序算法（如快速排序）给原数组排序，然后遍历排好序的数组，并对每两个相邻元素求差。复杂度：时间O（nlogn），在不改变原数组的情况下，空间复杂度是O(n) 解法2：基数排序的思想 利用计数排序的思想，先求出原数组的最大值max与最小值min的区间长度k（k=max-min+1），以及偏移量d=min。 创建一个长度为k的新数组Array。 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1。例如原数组元素的值为n，则将Array[n-min]的值加1。遍历结束后，Array的一部分元素值变成了1或更高的数值，一部分元素值仍然是0。 遍历新数组Array，统计出Array中最大连续出现0值的次数+1，即为相邻元素最大差值。 解法3：桶排序的思想解法3： 利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。其中第1个桶从原数组的最小值min开始，区间跨度是（max-min）/（n-1）。 遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值。 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。时间复杂度是O（n），空间复杂度是O（n*k） 代码C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//获取数组中数字之间的最大差值#include&lt;iostream&gt;#include &lt;algorithm&gt;#include\"memory.h\"using namespace std;struct bucket{ int min; int max; bucket():min(NULL),max(NULL){}};int getmaxdtce(int *a,int n){ //1.找到数列的最大最下值 int *max = max_element(a,a+n); int *min = min_element(a,a+n); int d = *max - *min; if(d==0) { return 0; } //2.初始化桶 int bucketnum = n; bucket *buckets = new bucket[n]; //3.遍历原始数组，确定每个桶的最大最小值 //注意，最大点独占一个桶 //所以前面n-1个桶的间隙是(a[i] - *min) / (d / bucketnum - 1); for (int i = 0; i &lt; n;i++) { int index = (a[i] - *min) / (d / (bucketnum - 1)); if(buckets[index].min==NULL||buckets[index].min&gt;a[i]) { buckets[index].min = a[i]; } if(buckets[index].max==NULL||buckets[index].max&gt;a[i]) { buckets[index].max = a[i]; } } //4. 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。 int leftmax = buckets[0].max; int maxdistance = 0; for (int i = 1; i &lt; n;i++) { if(buckets[i].min==NULL){ continue; } if(buckets[i].min-leftmax&gt;maxdistance) { maxdistance = buckets[i].min - leftmax; } leftmax = buckets[i].max; } return maxdistance;}int main(int argc,char *argv[] ){ int *test = new int[5]; memset(test, 0, sizeof(int) * 5); test[0] = 1;test[1] = 6; test[2] = 3; test[3] = 8; test[4] = 0; cout &lt;&lt;getmaxdtce(test,5);}","link":"/2020/05/14/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B8%E9%82%BB%E5%B7%AE/"},{"title":"使用栈实现的队列","text":"算法思想 其中一个栈A作为队列的入口，用于插入新元素；另一个栈B作为队列的出口，用于移除老元素。 当B为空的时候需要及时将A中的数据转移进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;/* stack&lt;int&gt;q; q.push(1); //入栈 q.pop(); //出栈 q.top(); //返回栈顶成员 q.size(); //返回栈成员个数 q.empty(); //判断是否为空栈*/class stackqueue{ private: stack&lt;int&gt; stacka; stack&lt;int&gt; stackb; public: void enqueue(int a); int dequeue(); void transfer();};int stackqueue::dequeue(){if(!stackb.empty()){ int tmp = stackb.top(); stackb.pop(); return tmp;}else{ if(stacka.empty()) { return NULL; } transfer(); int tmp = stackb.top(); stackb.pop(); return tmp;}}void stackqueue::transfer(){ while(!stacka.empty()) { stackb.push(stacka.top()); stacka.pop(); }}void stackqueue::enqueue(int a){ stacka.push(a);}int main() { stackqueue *que = new stackqueue(); que-&gt;enqueue(1); que-&gt;enqueue(2); que-&gt;enqueue(3); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; que-&gt;enqueue(4); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl;}","link":"/2020/05/14/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%98%9F%E5%88%97/"},{"title":"vector常用操作","text":"vector初始化方法123vector&lt;int&gt; vec; //初始化size为0的vectorvector&lt;int&gt; vec(10); //初始化size为10，默认值都为0的vectorvector&lt;int&gt; vec(10,1); //初始化size为10，值都为1的vector 通过数组初始化通过数组a的地址初始化，注意地址是从0到5（左闭右开区间），类似迭代器 12int a[5] = {1,2,3,4,5};vector&lt;int&gt; vec(a, a+5); 通过vector初始化12vector&lt;int&gt; a(5,1);vector&lt;int&gt; b(a); 通过insert初始化insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中//助记，插入开始的地方 123vector&lt;int&gt; a(6,6);vecot&lt;int&gt; b;b.insert(b.begin(), a.begin(), a.begin() + 3); //将a[0]~a[2]插入到b中，b.size()由0变为3 insert还可以插入m个值为n的元素 12//在b开始位置处插入6个6b.insert(b.begin(), 6, 6); 通过copy函数赋值//助记，拷贝到目标地 1234567vector&lt;int&gt; a(5,1);int a1[5] = {2,2,2,2,2};vector&lt;int&gt; b(10);//将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间copy(a.begin(), a.end(), b.begin());//拷贝区间也可以是数组地址构成的区间copy(a1, a1+5, b.begin() + 5); 常用操作注意：std::vector 不支持 push_front，，它的目的是为了O(1)的push_back(),对它来说O(n)次的insert()就能做到push_front。支持push_front()的是deque支持的是deque。 加入元素1234q.push_back(x); //尾部加入元素q.insert(iter,x); //在iter位置插入x，传回新数据位置q.insert(iter,n,x); //在iter位置插入n个x，无返回值q.insert(iter,l,r); //在iter位置插入[l,r)区间内的数据，无返回值 vector交换12q.swap(p); //交换p，q容器内元素q.assign(iter1,iter2); //将区间[iter1，iter2)内元素赋值给vector，并清空vector容器之前的内容。 删除元素123q.pop_back(); //删除最后一个元素q.erase(iter1); //删除iter位置元素，返回值是指向被删元素之后的那个元素(即下一个元素)的迭代器。q.erase(iter1,iter2); //删除[iter1，iter2)区间内的元素 清空/覆盖12q.clear(); //清空Vectorq.assign(n,x); //将n个x赋值到vector中，并清空vector容器之前的内容。 返回元素123q.front(); //返回第一个数据q.back(); //返回最后一个数据q.at(i); //返回第i个元素 vector元素个数/是否为空123q.size(); //返回容器内成员个数q.resize(x); //重新指定容器大小q.empty(); //判断Vector是否为空 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 vector内存容量12q.capacity(); //返回Vector可用空间的大小q.reserve(); //重新指定空间大小，小于当前capacity时保持为原本的capacity值 参考资料vector的几种初始化及赋值方式STL中erase()的用法","link":"/2020/05/19/vector%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"演讲","slug":"演讲","link":"/tags/%E6%BC%94%E8%AE%B2/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"名著","slug":"名著","link":"/tags/%E5%90%8D%E8%91%97/"},{"name":"生产力","slug":"生产力","link":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"学术论文","slug":"学术论文","link":"/tags/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"基本结构","slug":"基本结构","link":"/tags/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"},{"name":"心态","slug":"心态","link":"/tags/%E5%BF%83%E6%80%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"性能分析","slug":"性能分析","link":"/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"目录结构","slug":"目录结构","link":"/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"费曼","slug":"费曼","link":"/tags/%E8%B4%B9%E6%9B%BC/"},{"name":"诺贝尔奖","slug":"诺贝尔奖","link":"/tags/%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96/"},{"name":"传记","slug":"传记","link":"/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux概述","slug":"Linux概述","link":"/tags/Linux%E6%A6%82%E8%BF%B0/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"简述","slug":"简述","link":"/tags/%E7%AE%80%E8%BF%B0/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"文档和注释","slug":"文档和注释","link":"/tags/%E6%96%87%E6%A1%A3%E5%92%8C%E6%B3%A8%E9%87%8A/"},{"name":"软连接","slug":"软连接","link":"/tags/%E8%BD%AF%E8%BF%9E%E6%8E%A5/"},{"name":"硬连接","slug":"硬连接","link":"/tags/%E7%A1%AC%E8%BF%9E%E6%8E%A5/"},{"name":"文件与目录","slug":"文件与目录","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"内存分配","slug":"内存分配","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"内存分区","slug":"内存分区","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"静态多态","slug":"静态多态","link":"/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"动态多态","slug":"动态多态","link":"/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"容器类","slug":"容器类","link":"/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"},{"name":"关联容器","slug":"关联容器","link":"/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"},{"name":"顺序容器","slug":"顺序容器","link":"/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"},{"name":"C++标准库","slug":"C-标准库","link":"/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"vector","slug":"vector","link":"/tags/vector/"}],"categories":[{"name":"博客维护","slug":"博客维护","link":"/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"},{"name":"醒世通言","slug":"醒世通言","link":"/categories/%E9%86%92%E4%B8%96%E9%80%9A%E8%A8%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"效率工具","slug":"效率工具","link":"/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"学术论文","slug":"学术论文","link":"/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件工程","slug":"软件工程","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}