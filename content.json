{"pages":[{"title":"关于","text":"关于博主博主是目前是一名在在校的计算机研究生（master student）,为未来而学习着，成长着。专业是计算机系统结构。目标是能够怀着求知与探索的品质，能够对社会有所贡献，在信息化浪潮中搏一番自己的精彩。 在此奉上牛顿的名言： 我好像是一个海边玩耍的孩子,不时为拾到比通常更光滑的石子或更美丽的贝壳而欢欣鼓舞,而展现在我面前的是完全未探明的真理之海。 关于博客博主搭建了这个博客主要是为了记录一些思考、经验、收藏和笔记。博客的内容可能倾向于记录博主的日常所学所思，当然也会有一些技术文章 在此奉上查理芒格的名言： 如果要变得聪明，不停地问：为什么为什么为什么。 在此奉上高德纳（Donald Knuth，现代计算机鼻祖，《计算机程序设计艺术》作者）的名言： “让我们改变一下对构建程序的态度：不要把我们的主要工作想象为教计算机怎么做，相反，让我们集中精力向人们解释我们想让机器做什么。” 在此奉上梭罗（Henry David Thoreau）的名言： 所有对真理的认识都是通过类比得来！ 联系博主博客搭建了评论系统，直接用github授权评论即可，博主隔一段时间会看一下。","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/28/hello-world/"},{"title":"成为一个不惑、不忧、不惧的人","text":"说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。 演讲全文诸君!我在南京讲学将近三个月了，这边苏州学界里，有好几回写信邀我，可惜我在南京是天天有功课的，不能分身前来。今天到这里，能够和全城各校诸君聚在一堂，令我感激的很，但有一件，还要请诸君原谅：因为我一个月以来，都带着些病，勉强支持，今天不能作很长的讲演，恐怕有负诸君期望哩。 问诸君“为什么进学校?” 我想人人都会众口一词的答道：“为的是求学问”。再问：“你为什么要求学问?”“你想学些什么?”恐怕各人的答案就很不相同，或者竟自答不出来了。诸君啊!我替你们回答一句罢：“为的是学做人。”你在学校里头学的什么数学、几何、物理、化学、生理、心理、历史、地理、国文、英语，乃至什么哲学、文学、科学、政治、法律、经济、教育、农业、工业、商业等等，不过是做人所需的一种手段，不能说专靠这些便达到做人的目的，任凭你把这些件件学的精通，你能够成个人不成个人还是个问题。 人类心理，有知、情、意三部分。这三部分圆满发达的状态，我们先哲名为三达德——智、仁、勇。为什么叫做“达德”呢?因为这三件事是人类普通道德的标准，总要三个具备，才能成一个人。三件的完成状态怎么样呢?孔子说：“知者不惑，仁者不忧，勇者不惧。”所以教育应分为知育、情育、意育三方面，——现在讲的智育、德育、体育不对，德育范围太笼统，体育范围太狭隘——知育要教到人不惑，情育要教到人不忧，意育到教到人不惧。教育家教育学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。 1. 怎么样才能不惑呢?最要紧的是养成我们的判断力。想要养成判断力，第一步，最少须有相当的常识，进一步，对于自己要做的事须有专门智识，再进一步，还要有遇事能断的智慧。 假如一个人连常识都没有，听见打雷，说是雷公发威，看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，碰到一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。学校里小学中学所教，就是要人有了许多基本的知识，免得凡事都暗中摸索。 但仅仅有点常识还不够，我们做人，总要各有一件专门职业。这门职业，也并不是我一人破天荒去做，从前已经许多人做过，他们积累了无数经验，发现出好些原理原则，这就是专门学识。我打算做这项职业，就应该有这项专门的学识。例如我想做农吗，怎么的改良土壤，怎么的改良种子，怎么的防御水旱病虫，等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。做工、做商等等都各有他的专门学识，也是如此。我想做财政家吗，何种租税可以生出何样结果，何种公债可以生出何样结果等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。教育家、军事家等等，都各有他的专门学说，也是如此。 我们在高等以上学校所求的知识，就是这一类。但专靠这种常识和学识就够吗?还不能。宇宙和人生是活的不是呆的，我们每日碰见的事理是复杂的变化的，不是单纯的刻板的，倘若我们只是学过这一件，才懂这一件，那么，碰着一件没有学过的事来到跟前，便手忙脚乱了。 所以还要养成总体的智慧，才能有根本的判断力。这种总的智慧如何才能养成呢?第一件，要把我们向来粗浮的脑筋着实磨炼他，叫他变成细密而且踏实。那么，无论遇着如何繁难的事，我都可以彻头彻尾想清楚他的条理，自然不至于惑了。 第二件，要把我们向来浑浊的脑筋，着实将养他，叫他变成清明。那么，一件事理到跟前，我才能很从容很莹澈的去判断他，自然不至于惑了。以上所说常识学识和总体的智慧，都是知育的要件，目的是教人做到“知者不惑”。 2. 怎么样才能不忧呢?为什么仁者便会不忧呢?想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么?很难用言语说明，勉强下个解释，可以说是：“普遍人格之实现。”孔子说：“仁者人也。”意思是说人格完成就叫做“仁”。 但我们要知道，人格不是单独一个人可以表现的，要从人和人的关系上来看。所以仁字从二人，郑康成解他做“相人偶”。总而言之，要彼此交感互发，成为一体，然后我的人格才能实现。所以我们若不讲人格主义，那便无话可说;讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我们的人格，和宇宙无二区别，体验得这个道理，就叫做“仁者”。然则这种仁者为什么就会不忧呢?大凡忧之所从来，不外两端，一曰忧成败，二曰忧得失。我们得着“仁”的人生观，就不会忧成败。为什么呢?因为我们知道宇宙和人生是永远不会圆满的，所以《易经》六十四卦，始“乾”而终“未济”。正为在这永远不会圆满的宇宙中，才永远容得我们创造进化。 我们所做的事，不过在宇宙进化几万万里的长途中，往前挪一寸，两寸，那里配说成功呢?然则不做怎么样呢?不做便连这一寸都不往前挪，那可真是失败了。 “仁者”看透这种道理，信得过只有不做事才算失败，肯做事便不会失败。所以《易经》说：“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的几万万里路挪了一两寸，算成功吗?所以《论语》：“知其不可而为之。”你想，有这种人生观的人，还有什么成败可忧呢? 再者，我们得着“仁”的人生观，便不会忧得失。为什么呢?因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则哪里有东西可以为我们所得?既已没有东西为我所得，当然也没有东西为我所失。 我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等做手段来达某种目的——可以为我们“所得”得。所以老子说：“生而不有，为而不恃。”“既以为人已愈有，既以与人已愈多。”你想，有这种人生观的人，还有什么得失可忧呢?总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无人而不自得”。他的生活，纯然是趣味化艺术化。这是最高的情感教育，目的教人做到“仁者不忧”。 3. 怎么样才能不惧呢?有了不惑不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便会有丰富的智识，临时也会用不着，便有优美的情操，临时也会变了卦。然则意志怎么会才坚强呢?头一件须要心地光明，孟子说：“浩然之气，至大至刚。行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不惴焉;自反而缩，虽千万人，吾往矣。” 俗话说得好：“生平不作亏心事，夜半敲门心不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一着。第二件要不为劣等欲望之所牵制。 《论语》记：子曰：“吾未见刚者。”或对曰伸枨。子曰：“枨也欲，焉刚。”一被物质上无聊得嗜欲东拉西扯，那么百炼成刚也会变成绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。 自己作不起自己的主，还有什么事可做?受别人压制，做别人奴隶，自己只要肯奋斗，终必能恢复自由。自己的意志做了自己情欲的奴隶，那么，真是万劫沉沦，永无恢复自由的余地，终身畏首畏尾，成了个可怜人了。 孔子说：“和而不流，强哉矫;中立而不倚，强哉矫。国有道，不变塞焉，强哉矫;国无道，至死不变，强哉矫。”我老实告诉诸君说罢，做人不做到如此，决不会成一个人。但做到如此真是不容易，非时时刻刻做磨炼意志的功夫不可，意志磨炼得到家，自然是看着自己应做得事，一点不迟疑，扛起来便做，“虽千万人吾往矣。”这样才算顶天立地做一世人，绝不会有藏头躲尾左支右绌的丑态。这便是意育的目的，要教人做到“勇者不惧”。 我们拿这三件事作做人的标准，请诸君想想，我自己现时做到哪一件——哪一件稍微有一点把握。倘若连一件都不能做到，连一点把握都没有，嗳哟!那可真危险了，你将来做人恐怕做不成。讲到学校里的教育吗，第二层的情育，第三层的意育，可以说完全没有，剩下的只有第一层的知育。就算知育罢，又只有所谓常识和学识，至于我所讲的总体智慧靠来养成根本判断力的，却是一点儿也没有。 这种“贩卖知识杂货店”的育，把他前途想下去，真令人不寒而栗!现在这种教育，一时又改革不来，我们可爱的青年，除了他更没有可以受教育的地方。诸君啊!你到底还要做人不要?你要知道危险呀，非你自己抖擞精神方法自救，没有人救你呀! 诸君啊!你千万别要以为得些断片的智识，就算是有学问呀。我老实不客气告诉你罢;你如果做成一个人，知识自然是越多越好：你如果做不成一个人，知识却是越多越坏。你不信吗?试想想全国人所唾骂的卖国贼某人某人，是有智识的呀，还是没有智识的呢?试想想全国人所痛恨的官僚政客——专门助军阀作恶鱼肉良民的人，是有智识的呀，还是没有智识的呢?诸君须知道啊，这些人当十几年前在学校的时代，意气横历，天真烂漫，何尝不和诸君一样?为什么就会堕落到这样的田地呀? 屈原说：“何昔日之芳草兮，今直为此萧艾也!岂其有他故兮，莫好修之害也。”天下最伤心的事，莫过于看着一群好好的青年，一步一步的往坏路上走。诸君猛醒啊!现在你所厌所恨的人，就是你前车之鉴了。 诸君啊!你现在怀疑吗?沉闷吗?悲哀痛苦吗?觉得外边的压迫你不能抵抗吗?我告诉你：你怀疑和沉闷，便是你因不知才会惑;你悲哀痛苦，便是你因不仁才会忧;你觉得你不能抵抗外界的压迫，便是你因不勇才有惧。这都是你的知、情、意未经过修养磨炼，所以还未成个人。我盼望你有痛切的自觉啊!有了自觉，自然会成功。那么，学校之外，当然有许多学问，读一卷经，翻一不史，到处都可以发现诸君的良师呀! 诸君啊，醒醒罢!养足你的根本智慧，体验出你的人格人生观，保护好你的自由意志。你成人不成人，就看这几年哩!","link":"/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/"},{"title":"《苏菲的世界》读书笔记","text":"伊甸园 在某个时刻事物必然从无到有你是谁？世界从何处来？ 要么一直存在 要么从无到有 比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。 生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。 魔术师的礼帽 要成为一个优秀的哲学家只有一个条件：要有好奇心哲学是什么？天底下有没有一种东西是所有人都感兴趣的呢？有的！当人的基本需求（比如衣食住行，亲情爱情，爱与关怀等）满足之后，还有一些东西是人人都需要的，那就是明白我们是谁，我们为何在这里。宇宙，地球与生命是如何产生的？ 探讨哲学的最好方式就是问一些哲学性的问题，如：这世界是如何创造出来的？其背后是否有某种一直或者意义？人死后还有生命吗？我们如何能够解答这些问题呢？最重要的是，我们应该如何生活？我们无法从百科全书上得到这些答案，不过读一读别人的意见倒可以帮助我们建立自己对于生命的看法。 哲学家追求真理的过程很想一步侦探小说，对于案件，警方有时候可以侦破，但也有可能永远无法查出真相（虽然在某个地方一定有一个破案的办法）。因此，即使要回答一个问题很不容易，但无论如何总会有一个（且仅此一个）正确答案的。比如人死后要么就是透过某种形式存在，要不就是根本不在存在。 作者很好的比喻：许多人对于这个世界的种种也同样有种不可置信的感觉，就像我们看到魔术师突然从一顶原本空空如也的帽子里拉出一只小兔子一般。实际上我们就生活在这个世界上，是这个世界的一部分。形象的比喻一下，我们就是那只从礼帽里面变出的小兔子的一部分，小兔子可以比作是是整个宇宙，而我们则是寄居在小兔子身上的小小生物，但是我们和兔子不同的是，小兔子可不知道自己参与了一场魔术表演，而我们知道自己是某种神秘事物的一部分，我们想了解其中的奥秘；哲学家们总是试图沿着兔子的细毛往上爬，以便将魔术师的看个清楚； 神话 善与恶之间脆弱的平衡神话的世界观 北欧 （挪威）索尔和铁锤 北欧人相信人类居住的这部分是一部分岛屿，名为米德加德(Midgard)，也就是”中央王国“的意思，在这个中央王国内，有一个地方名叫阿斯加德（Asgard），乃是诸神的领地。中央王国之外，有一个叫乌特加德（Utgard），是狡猾的巨人居住的地方。 象征肥沃多产的额女神芙瑞雅 侍童洛奇 《史莱慕之诗》 巨人之王史莱慕希腊 公元前700左右，有一大部分希腊神话被荷马与赫西俄德（赫西俄德Hesiod以长诗《工作与时日》《神谱》闻名于后世，被称为“希腊训谕诗之父”。）记录下来。 赞诺芬尼司(Xnphans),古希腊哲学家。是早期批评荷马的神话的哲学家之一。 赞诺芬尼斯_百度百科 他指出人类按照自己的形象创造出这些天神。 随后这段期间，希腊人在希腊本土与意大利南部，小亚细亚等希腊殖民地建立了许多城市。在这些城市中，所有劳力工作由奴隶担任，因此市民有充分的闲暇，可以将所有的时间投注在政治与文化上；这时候的人们思考方式与以前大不相同，无需借助神话而提出一些哲学性的问题；我们称这样的现象为“从神话的思考模式发展到以经验与理性为基础的思考模式” 自然派哲学家 没有一件事物可以来自空无万事万物是否有一种基本的物质组成？哲学家的课题：每个人关注和质疑的事项是什么？了解了每一位哲学家的课题之后，我们就比较容易了解他的思想脉络，因为没有任何一位哲学家会企图探讨哲学的所有领域。 自然派哲学家关注的课题是“大自然与它的循环和变化”最重要的是，他们想要透过对大自然本身的研究来了解实际的变化过程，而不是借助神话来解释。这样，哲学逐渐脱离了宗教的范畴。自然派哲学家朝科学推理的方向迈出了第一步，成为后来科学的先驱。 米雷特斯的三位哲学家泰利斯安娜克西曼德安那西梅尼斯 没有任何事物会来自于虚无帕梅尼德斯（约公元前540年~公元前480年）他认为： 没有任何事物会改变。 因此我们的感官认知是不可靠的 理性主义：坚决相信人的理智的态度理性主义者：百分百相信人类的理智是时间所有知识源泉的人 所有的事物都是流动的赫拉克里德斯（约公元前540年~公元前480年）他认为： 万物都会改变（”一切事物都是流动的“） 我们的感官认知是可靠的 恩培窦克里斯（西西里）恩培窦克里斯认为帕梅尼德斯与赫拉克里德斯各有一点是对的，也各有一点是错的，造成这个根本性差异的原因是之前的两人都认定世间只有一种元素存在。恩培窦克里斯认为： 没有任何事物会改变。 我们的感官认知是可靠的 恩培窦克里斯的结论是：大自然不可能只有一种元素构成。 安纳萨格拉斯（约公元前500年~公元前428年） 德谟克里特斯 世界上最巧妙的玩具 积木为何是世界上最巧妙的玩具？ 原子理论德谟克里特斯（约公元前460年~公元前370年，来自爱琴海北部海岸的阿布拉德小镇） 唯物论者：只相信物质的东西。 命运 算命者试图预测某些事实上极不可测的事物古希腊的德尔菲（Delphi）神论与宿命论 现在看来都是迷信 历史与医学历史上最早的一批历史学家开始为历史事件寻求合理的解释。贺若多陀斯（约公元前484年~公元前424年）与修西德底斯（约公元前460年~公元前400年） 在希腊哲学、历史学发展的同时，希腊医学兴起，其目的是为了疾病与健康寻求合乎自然的解释。希波克拉底（约公元前460~公元前377年，生于寇斯岛，希腊医学始祖）比较出名的是希波克拉底誓言： 我将依照自身的能力与判断，采用对病人有利的疗法与处方，绝不施以有害或有毒之物。无论应何人之请，我也绝不给与致命药物或做此类之建议，也绝不协助妇女堕胎。进入病家访视时，我将以病人的福祉为念，不做任何贪渎害人之事，不受男女奴仆之引诱。我在执业时之所见所闻，反不应泄露者，我将严予保密。若我遵行此一誓言，不懈不怠，愿上苍使我乐享生命、精进医事并受世人敬重。若我违反誓言，愿我遭相反之命运。 苏格拉底 最聪明的是明白自己无知的人 是否有人天生就很害羞呢？最聪明的是明白自己无知的人。真正的智慧来自内心。明白是非者必能够进退合宜。 雅典的哲学以人为中心苏格拉底是谁？谈话的艺术 “苏格拉底式的反讽”神圣的声音雅典的小丑正确的见解导致正确的行动 雅典 废墟中升起了几栋高楼柏拉图 回归灵魂世界的渴望柏拉图学院永远的真善美理型的世界真正的知识不朽的灵魂走出黑暗的洞穴（洞穴神话）哲学之国（理想国） 少校的小木屋 镜中的女孩双眼眨了一眨亚力士多德 一位希望澄清我们观念的严谨的逻辑学家逻辑亚里士多德创立了逻辑学这门学科，他以实例显示我们在得出合乎逻辑的结论或证明时，必须遵循若干法则。 希腊文化 一丝火花生命与容忍的哲学宗教，哲学与科学 犬儒学派 斯多葛学派 伊比鸠鲁学派 新柏拉图派哲学神秘主义 明信片 我对自己实施严格的检查制度两种文化 避免在真空中飘浮的唯一方式印欧文化 闪族文化 中世纪 对了一部分并不等于错文艺复兴 啊！藏在凡俗身躯里的神明子孙哪实证法：以亲身的经验，而不是以古人的著作或凭空想象来作为知识的基础。 巴洛克时期 宛如梦中的事物笛卡尔 他希望清除工地上所有的瓦砾斯宾诺莎 上帝不是一个傀儡戏师傅洛克 赤裸、空虚一如教师来到教室前的黑板休姆 将它付之一炬如果我们手里有一本书，我们应该问：书里是否有包含任何与数量和数目有关的抽象思考？如果答案是没有，那么我们应该再问：书里是否包含任何与事实有关的经验性思考？如果答案是没有，那么我们还是将它付之一炬吧，因为这样的书纯粹是诡辩和幻想。 印象观念 不可知论者：不持肯定或否定的态度，持怀疑态度。 柏克莱 宛如燃烧的恒星旁一颗晕眩的行星柏客来 曾祖母向一名吉普赛妇人买的一面古老魔镜启蒙 从制针的技术到铸造大炮的方法康德 头上闪烁的星空与心中的道德规范浪漫主义 神秘之路通向内心黑格尔 可以站得住脚的就是有道理的祁克果 欧洲正迈向破产的地步主观的真理可以测算的真理我信因为荒谬个体主义者 马克思 在欧洲游荡的幽灵达尔文 满载基因航行过生命的一艘小船弗洛伊德 他内心出现那股令人讨厌的自大的冲动弗洛伊德发展了所谓的深度心理学或精神分析弗洛依德主张人和他的环境之间不断有一种紧张关系存在。这种紧张关系（也就是冲突）尤其存在于他的驱策力，需要和社会之间。基本需求可能会被伪装和升华；快乐原则/本我现实原则/自我这世界的道德规范已经成为我们内心的一部分/成为超我潜意识:我们并不一定能够意识到我们曾经有过的各种经验。但那些只要我们“用心想便可以记起来的想法或经验”通常是指被压抑的想法或经验。不错的比喻：演讲厅说话演讲厅称为”意识“，演讲厅之外称为“潜意识”；大声喧哗者被”压抑“，椅子堵住门口作为”防御“ 我们的感觉和行为会受到“潜意识的鼓动”这类机制有好几种：比如“说溜了嘴”“合理化”我们自己也不愿意承认，也不愿意告诉别人我们做一件事的真正动机，因为这个动机是让人无法接受的。–&gt;”两面式沟通“的经验“投射”把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较。如何对抗不愉快的经历呢？弗洛伊德发展出一个”自由联想“的技巧。梦的解析显梦 mainfest dream 潜梦意念把潜梦意念转换成显梦面向的工作，他称之为“梦的运作”超现实主义 灵感：潜意识的盖子被打开了，好像我们突然所想的东西是来自某种外部的源泉似的。创作的过程是想象与理性细密交织的时刻 想象力也许可以创造新的事物，但是却不能加以挑选，这时候理智就发挥作用了！ 我们这个时代 人是注定要受自由之苦的花园宴会 一只白色的乌鸦对位法 两首或多首旋律齐响那轰然一响 我们也是星尘","link":"/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"好用的chrome插件","text":"深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。 Awesome Autocomplete for GitHub增强github的搜索功能 Git History Browser Extension查看github的历史更新记录，超级好用，可以对比不同人对代码做的更新； octotree可以查看github的目录结构，并且下载单个的文件； Sourcegraph可以查看相关的代码，搜索代码，查找代码定义的地方 The Great Suspender休眠chrome不必要的标签页 Tab Resize - split screen layouts浏览器分屏 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/"},{"title":"学术论文的基本结构","text":"基本结构 标题 真实反应论文内容 简短明了 吸引人 大背景 小背景 技术特色 摘要 概括你的研究 假设或要研究的问题 研究方法 主要成果 引言 说明选题的背景，目的，意义 陈述研究的主要内容和论文的假说或研究问题 文章的研究方法与章节编排 文献综述 阐述前人的研究，展示文献批判能力，说明你对研究问题的掌握程度，表明你研究的创新之处。 研究方法 详细介绍相关信息，便于读者采取同样的方法能够重复此项研究。 研究性质 对象 步骤 工具 条件 … 研究结果 用文字和/或图表真实报告你获得的数据或结果。 讨论 基于你获得的数据论述对于研究问题可能得到的结论。 结论 简明总结所得到的数据，得出的结论及意义。 说明研究的价值，不足或局限性。 致谢 参考文献 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"title":"《练习的心态》读书笔记","text":"引言 人生就是漫长的练习第1章 学习开始当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种没有压力的愉快与平和的体验，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。 压力与焦虑主要来源于我们自己对目标的依恋。练习的心态这也是一种技能：尽可能迅速，最少的付出来发展任何一项技能的能力，以及在这个过程体验内心平和与愉悦的能力。 在不感到失败和焦虑的情况下去努力实现目标。学习的渴望仅仅是第一步，需要正确理解技术性细节与努力，否则会耗尽的 当今的文化是多任务的，比如开车时第一件事会习惯性打开收音机。 而滑冰正相反，滑冰时候不会注意边上嘈杂的声音！由于习惯于一心多用，我们大脑躁动不安，且具有极大惯性，没法安静下来。 练习的心态是安静的意识是第一位的：没法控制自己的思维，不管设立什么样的目标，都没有用。我们对自己要去的方向就像乘坐马车，必须要拉紧思维的缰绳才行啊！填补空虚是一个循环往复的过程 学会走路的过程并不会在心里让你压力倍增。我们要意识并掌控这个过程，学会从中享受！ 第2章 以过程为导向，不以结果为导向 人生的悖论：耐心与自律的问题是，要培养它们中的任何一个，需要同时具备它们两个。 简单法则 以过程为导向 重点关注当前 将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。 对自己想要做的事情刻意训练，带着意图训练，并且自始至终清醒的知道那种意图 第3章 关键是视角当我们试图理解自己以及我们对人生中各种努力的痛苦挣扎时，可以通过观察一朵鲜花来找到平和。问你自己：一朵鲜花的生命，从撒下种子到完全盛开，在什么时候可以达到完美？ 然后呢？ 达成目标之后，然后呢？然后又能干什么呢？？？？初学者心态鲜花的生命，自始至终都是完美的 他了解到，假如将自己的思绪集中在当前，并只专注了他在这一刻正在做的事情的过程，那便可以喜欢上他正在做的任何事情。 第4章 培养期望的习惯习惯是学来的。明智地选择它们。自己创造想要的习惯，不带情绪和判断的采取哪些行为，之后坚持下去。 就像一名优秀的老师，对待学生的错误不会情绪化，那种情绪化来源于自我期望，与结果和产物关联，如果你体验到这些情绪，就证明你没有专注于当前过程！！！ 怎么样阻止旧的习惯，采用一种例行行为来阻止，比如击球前例动作 第5章 感知变化，创造耐心！你需要的所有耐心，都已经处在你的内心了。知道什么时候内心疯狂奔走接受什么事情不会尽善尽美 放弃某种幸福和乐趣就在某个地方的徒劳想法 在探索的道路上，除了去追求，没有别的可以达到的目标了//我们20岁的目标肯定与18岁的不同，参照对象也是不一样的，不要指望能达到你的目标。探索本身就是一种目标。 对于没有费力得到的东西，那种兴奋感在得到东西早已烟消云散。 得到目标和实现目标是两种完全不同的概念真正的愉悦 第6章 4“S”方法力求简化，将征服大多数复杂的任务。 简化 细分 缩短 放慢 第7章 平静与DOC方法客观是通往宁静心灵之路！ 主观判断需要一个评估和对比的过程，这要求有一个相对的点，即理想状况判断有一个不利的地方，它不会以一种超然的方式运行，常常会包含着某些情绪，有趣的是，对事情我们感觉到的重要性越多，我们带的情绪越多将自我与观察者合并 。就像我们安慰他人时候带着的超然智慧一样。 怎么合并呢 冥想！ do observe correct就像射箭运动员一样，安静，不复杂完全没有心理的杂乱 第8章 教孩子，也从孩子身上学习智慧并不是年龄的副产物。从你身边所有的人身上学习，同时也用自己的行为影响身边的人。 第9章 你的技能在成长有了刻意的和反复的努力，进步便水到渠成。 如果说各种软件上的信息不能使你知识变得丰富，那么你就不需要它们 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"linux 性能分析，测试与调优工具","text":"静态性能分析工具(static performance analysis tools) dmesg 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。 blockdev 工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。 ldd （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。 lsblk (list block)即用于列出所有可用块设备的信息,而且还能显示他们之间的依赖关系,但是它不会列出RAM盘的信息 lsscsi 可以看到Raid卡信息和所有虚拟磁盘以及光驱的信息，如果没有硬件SCSI控制器，那就不会返回信息。 lspci 显示有关pci总线的信息以及连接到它们的设备。 lscpu (list cpu)显示CPU的详细信息，比如CPU的制造商、架构、CPU数量、型号、主频、缓存及支持的虚拟化技术等信息。 lstopo (list topology of the system)显示可视化的方式组成 CPU、缓存、内存和I/O设备的拓扑结构。这个命令用来识别处理器结构和系统的NUMA拓扑结构。 likwid (Like I Knew What I’m Doing) 是一个用来测量、配置并显示硬件相关特性的命令行收集工具。其中的likwid拓扑结构能显示CPU硬件(线程/缓存/NUMA)的拓扑结构信息，还能识别处理器家族(比如：Intel Core 2, AMD Shanghai)。 smartctl 查看硬盘的SMART信息。 fdisk 创建和维护分区表的程序(兼容DOS类型的分区表、BSD或SUN的磁盘列表） schedtool (scheduling tool)查询或设置CPU状态的工具。通过不同的参数可以查看或设置不同的属性。 numactl (Control NUMA policy)用于控制 进程与共享存储的 NUMA 技术机制。 cpuid 获取CPU的信息。该命令的底层是CPUID指令。它获取的内容比/proc/cpuinfo要详细很多。 MegaCli 管理维护硬件RAID的软件 App Config 观测工具(Observability Tools) iostat (input/output statistics)报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息。 vmstat (VirtualMeomoryStatistics,虚拟内存统计) 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。 dstat 用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具,是一个全能系统信息统计工具。 pidstat 是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。 mpstat (multiprocessor statistics)查看多核心的cpu中每个计算核心的统计数据。类似工具vmstat只能查看系统的整体cpu情况 netstat ( network statistics)显示当前的网络状态，包括传输控制协议层的连线状况、路由表、网络接口状态和网络协议的统计信息等。 iotop 用来监视磁盘I/O使用状况的top类工具 top (display Linux processes)实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。 htop top命令的升级版。交互式的进程浏览器，可以用来替换Linux下的top命令 gtop JavaScript 编写的开源系统资源监控实用程序,它是 Linux 系统自带 top 工具的替代品 tiptop 通过读取CPU硬件计数器的信息（比如cahche miss，executed instructions per cycle等等）了解程序执行效率 strace 可跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。 uptime 可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息 lsof (list open files)列出当前系统打开的文件，注意linux中设备也是文件 perf 性能分析工具，能够进行函数级与指令级的热点查找。 Flame Graphs 性能分析的利器,通过它可以快速定位性能瓶颈点。 测试工具(Benchmarking Tools) fio 开源的I/O压力测试工具，主要是用来测试磁盘/SSD的IO性能，也可测试cpu，nic的IO性能。 hdparm (hard disk parameters)用于显示与设定硬盘的参数 dd 用于读取、转换并输出数据。可从标准输入或文件中读取数据,根据指定的格式来转换数据,再输出到文件、设备或标准输出。 perf_events 网上很多叫法如perf_events , perf profiler , Performance Counters for Linux。叫法不同，都指perf perf-tools 基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集，能够收集ftrace和perf_events中乱七八糟的参数。 ktap Linux的基于脚本的动态跟踪工具 允许用户跟踪Linux内核动态。 sysbench 一个开源的、模块化的、跨平台的多线程性能测试工具,可以用来进行CPU、内存、磁盘I/O、线程、数据库的性能测试。 ab (apachebench) ab命令会创建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。 wrk 针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 jmeter Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试。 openssl 加解密能力也是CPU性能测试的一部分。 UnixBench 类unix系(Unix,BSD,Linux)统下的性能测试工具 lmbench 多平台软件，因此能够对同级别的系统进行比较测试，反映不同系统的优劣势，可用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能. perfbench perf下的工具 测试系统性能 hping3 面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。 iperf 网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 ping 向特定的目的主机发送 ICMP（Iternet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。 ttcp 传统的测试TCP性能的工具,它主要测试两个机器之间TCP的吞吐量(在应用层模拟消息传递的过程) traceroute 利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。 mtr 网络连通性判断工具，它结合了ping, traceroute,nslookup 的相关特性 pchar 沿Internet路径执行网络测量 调优工具(Tuning Tools) sysctl (System Administration)用来配置与显示在/proc/sys目录中的内核参数 swapon 用于激活Linux中的交换空间，Linux的内存管理必须使用交换区来建立虚拟内存。 env gnu的coreutils包内的一个软件，用来显示系统中已存在的环境变量,以及在定义的环境中执行指令。 tune2fs 允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。 ionice 获取或设置程序的IO调度与优先级。PRI(new)=PRI(default)+nice nice 调整程序运行的优先级，当前程序运行优先级基础之上调整指定值得到新的程序运行优先级。 renice 重新指定一个或多个进程的优先级 taskset 将某个进程与某个CPU核心绑定。 ulimit 为shell内建指令，可用来控制shell执行程序的资源 chcpu 修改cpu的状态,启用和关闭cpu，扫描新的CPU,改变底层虚拟机监控程序的CPU调度模式,并请求CPU的系统管理程序(配置)或返回CPU hypervisor numactl 用于控制进程与共享存储的 NUMA 技术机制。 sysctl 用于运行时配置内核参数,这些参数位于/proc/sys目录下。 ethtool 用于查询及设置网卡参数 stap (SystemTap) 内核开发者必须要掌握的一个工具,用于内核监控和跟踪，以及诊断性能或功能问题。 kpatch 给Linux内核动态打补丁但是不必重启系统 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"},{"title":"Linux系统目录结构","text":"/bin (binary)目录存放着最经常使用的命令 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 包括Linux内核文件，以及开机菜单与开机所需的配置文件 linux kernel常用的文件名为vmlinux /dev (device)该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc (Editable Text Configuration)可配置文件存放所有的系统管理所需要的配置文件和子目录。 /etc/init.d所有服务的默认启动脚本都是放置在这个目录内 /etc/xinetd.d所谓的super daemon管理的各项服务的配置文件目录 /etc/X11与X Windows有关的各种配置文件都在这里 /etc/securetty只有/etc/securetty中登记的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录 这个终端指tty1之类的 /etc/passwd保存的就是系统中所有的用户和用户的主要信息 /etc/shadow/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。 /home (home directory)用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 系统默认的用户主文件夹 比较重要的是 主文件夹有两者代号 ~ 代表目前这个用户的主文件夹 ~dmtsai 代表dmtsai的主文件夹 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 放置的是开机会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库而已 尤其重要的是/lib/modules/这个目录 放置内核相关的模块（驱动程序） /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 这个目录是使用标准的ext2/ext3文件系统格式才会产生的目录 /medialinux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 包括软盘，光盘，DVD等设备都暂时挂载于此 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，或者说是额外的设备 比较早的时候，这个目录的用途与/media相同。只是有了/media之后这个目录就暂时用来挂载用了 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 给第三方软件放置的目录 /proc (process)这个目录本身是一个虚拟的文件系统，放置的数据都是在内存中:例如，系统内核，进程，外部设备的状态及网络状态等 目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息 这个目录的内容不在硬盘上而是在内存里，本身不占用任何硬盘空间，我们也可以直接修改里面的某些文件 /root该目录为系统管理员，也称作超级权限者的用户主目录。 /run是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 这个目录的内容数据也是在内存中的信息，同样不会占用任何的硬盘容量 Secure Enhance Linux的执行目录 /srv (service) 该目录存放一些服务启动之后需要提取的数据。 一些网络服务启动之后，这些服务所取用的数据目录 存放服务启动后需要提取的数据（不用服务器就是空） /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 这个目录与/proc目录类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。包括目前已经加载的内核模块与内核检测到的硬件设备信息等。 这个目录同样不占用硬盘容量。 /tmp这个目录是用来存放一些临时文件的。 /usr (UNIX Software Resource,而不是user)是UNIX 操作系统软件资源所放置的目录，而不是用户的数据.这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。注意事项：FHS建议所有软件开发者将他们的数据合理地放置到这个目录下的子目录，而不要自行新建软件自己独立的目录有点像windows系统中C:\\Windows\\和C:\\Program files\\这两个目录的综合体 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 附注上面这些目录比较完备了 我主要是根据菜鸟教程，鸟哥的私房菜进行整理的 关于/run这个目录稍微特殊一点点，有的系统是二级目录，如果你的系统上有 /var/run 目录，应该让它指向 run。 可以用ls -l / 命令查看目录树 关于挂载开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"哈希表（散列表）详解","text":"基本概念散列方法（hashing）：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立起映射关系。散列表（hashtable）：逻辑上由一些列可存放词条（或者其引用）的单元（称作桶（bucket）或桶单元）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作桶数组（bucket array）地址空间（address space）：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。 散列函数（hash function）：用来描述散列方法，是从关键码空间到桶数组地址空间的函数。比如下面的hash()： 1hash() : key -&gt; hash(key) key的散列地址（hashing address）：也就是上面的hash(key) 。 完美散列（perfect hashing）：在时间和空间性能方面均达到最优的散列，也就是没有空余，没有重复的散列。 装填因子（load factor）：散列表中非空桶的数目与桶单元总数的比值。是散列表的空间利用率度量方法。 散列冲突（collision）：关键码不同的词条映射到同一个散列地址的情况。 词条的聚集（clustering）：词条集中到散列表内少数若干桶中（或附近）的现象。 综上散列表的基本构思概括为： 开辟物理地址连续的桶数组hba[],借助散列函数hash(),将词条关键码key映射为桶地址hash(key),从而快速确定待操作的词条的位置。 散列函数好的散列函数应该具备的条件： 确定性 ：也就是说词条E的映射地址hash(E.key)必须完全取决于E.key。 简单性 ：映射过程不能过于复杂 所有关键码经过映射后应该尽量覆盖整个地址空间。也就是说hash()最好是满射。 均匀性 ：最重要的原则，关键码映射到各个桶的概率是同等的，应该尽量为1/R ，R为散列表长度或容量。 直接定址法直接定址法：关键码就可以直接用作为散列地址 1hash(key)=key 除余法（devision method）除余法：选择一个适当的正整数R,用R去除关键码去除关键码,余数作为 散列地址.这个方法的关键是选取适当的R。一般R为素数，采用素数表长是是降低聚集发生概率的捷径。 1hash(key)=key mod R //R为散列表长度或容量。一般R为素数。 缺点：残留有某种连续性，比如相邻关键码所对应的散列的地址，总是彼此相邻。 MAD法（multiply-add-divide method）乘加除法乘加除法：需要依次执行乘法，加法，和除法运算得名。解决的问题：用来克服除余法的连续性缺陷。 12hash(key)=(a * key + b)mod R //a&gt;0，b&gt;0，且(a mod R) !=0//R为散列表长度或容量。一般R为素数。 数字分析法（selecting digits）数字分析法：从关键码key中特定进制的展开中抽出特定的若干位，构成一个整型地址。对关键码的各位进行分析（多种方法），丢下分布不均匀的位，留下均匀的位作为地址。数字分析法举例： 平方取中法（mid-square） 折叠法（folding） 一般折叠 往复折返式折叠 异或法（xor） 一般异或 往复折返式异或 伪随机数法越是随机，越是没有规律的就是好的散列函数。 1hash(key)=rand(key) mod R //R为散列表长度或容量。 冲突及其排解开散列策略/封闭定址开散列（open hashing）或封闭定址（closed addressing）： 开放基本的散列表结构，引入次级关联结构。 散列表中的地址只对特定的词条开放（每个桶可以只能能存放特定的一组词条）。 多槽位法（multiple slots）多槽位法：将每个桶细分为更小的称作槽位（slot）的若干单元，每一组槽位可以组织为向量或列表。//类似于二维数组 独立链法（separate chaining)（拉链法）拉链法：某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。//引入链表先计算哈希地址，然后搜索该地址的单链表。 公共溢出区法（overflow）在原有散列表hashA之外再设置一个公共溢出区（散列表hashB），如果抽入词条发生冲突，就将该词条转存至公共溢出区（散列表hashB）中。 //引入新的散列表可以说是一种递归形式的散列表。 闭散列策略/开放定址闭散列（open hashing）或开放定址（closed addressing）： 仅仅依靠基本的散列表结构，就地排解冲突。 散列表中的地址对所有的词条开放（每个桶可以都有可能存放任一词条）。 一个桶冲突了，只允许在散列表内部为其寻找另一空桶。 线性试探法（linear probing）线性试探法：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。被尝试的桶依次为： 1[(hash(key) + i)mod R ] ,i=1,2,3,... 平法试探法（二次探测法）被尝试的桶依次为： 1[(hash(key) + i^2)mod R ] ,i=1,2,3,... 伪随机试探法被尝试的桶依次为： 1[rand(i)mod R ] ,rand(i)为系统定义的第i个随机数。 再散列法（rehashing）再散列法：使用哈希函数去散列一个输入的时候，如果输出是同一个散列地址就再次散列，直至不发生冲突为止。缺点：每次冲突都要重新散列，计算时间增加。被尝试的桶依次为： 12//hash2为二级散列函数[(hash(key) + i*hash2(key) ] ,i=1,2,3,... 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"},{"title":"《别闹了费曼先生》读书笔记","text":"当科学大师碰上菜鸟 报告时间终于到了。我面前坐了这些科学大师，全在等我开口讲话！我生平第一次学术报告，却碰上这样的听众！我的意思是说，他们会问很多难题，我将会大大地出丑了！我还清楚记得，从牛皮纸袋抽出讲稿时，双手不住地发抖。但奇迹出现了——事实上我很幸运，类似的奇迹在我一生中一再发生——只要我开始思考物理、必须全神贯注于要说明的问题上，我的脑袋中就再没有其他杂念，完全不会紧张。因此当我开始报告以后，我根本不知道听众是谁了；我只不过在说明这些物理概念。事情就那么简单！ 向数学家挑战 我向他们挑战：“我跟你们打赌，随便你提出一个定理——只要你用我听得懂的方式告诉我，它假设些什么、定理是什么等等——我立刻可以告诉你，它是对的还是错的！” 其实，我也并不是随便乱猜的。我有一套方法，甚至到了今天，当别人对我说明一些什么，而我努力要弄明白时，我还在用这些方法：不断地举实例。譬如说，那些念数学的提出一个听起来很了不得的定理，大家都非常兴奋。当他们告诉我这个定理的各项条件时，我便一边构思符合这些条件的情况。当他们说到数学上的“集”时，我便想到一个球，两个不相容的集便是两个球。然后视情况而定，球可能具有不同的颜色、长出头发或发生其他千奇百怪的状况。最后，当他们提出那宝贝定理时，我只要想到那跟我长满头发的绿球不吻合时，便宣布：“不对！” 看怎样用些有趣、近代的数学观念来教数学。原先的目的，是要使那些觉得数学枯燥无味的学生提高兴趣。 费曼教授 20 世纪40 年代，我待在普林斯顿的期间，亲眼看到高等研究院内那些卓越心灵的下场。他们都具备了聪明绝顶的头脑，因此特别被选中，来到坐落在森林旁边的漂亮房子里，整天悠哉游哉地闲坐——不用教书，没有任何约束或负担。但等过了一段日子，他们想不出什么新东西来，每个人心里一定开始感到内疚或沮丧，更加担心提不出新想法。可是一切还是如旧，仍然没有灵感。会发生这种情况，完全是因为那里缺乏真正的活动和挑战：他们没有跟做实验的学者接触，也不必思索如何回答学生提出的问题，什么都没有！ 在任何思考过程中，当一切进行顺利、灵感源源不绝时，教书确实是一种妨碍，十分讨厌。但有更多的时候是脑袋空空的，如果既想不出什么、又没做什么，那真会教人疯狂！你甚至不能说：“我在教书呀！”。 不敢面对问题到弄明白 在罗彻斯特举行了一个会议——一年一度的罗彻斯特研讨会（Rochester Conference）。我还是事事落于人后，而李政道已在发表关于宇称不守恒的论文。他和杨振宁作出宇称并不守恒的结论，现在他正提出解释这现象的理论。会议期间，我住在我位于西瑞桥斯（Syracuse）的妹妹家。我把论文带回家跟她说：“我搞不懂李政道和杨振宁说的东西，这全都那么复杂！”“不，”她说，“你的意思并不是说你无法弄懂它，而是你没有发明它。你没有用你的方法，从听到线索开始做起，把它推演出来。你应该做的是想象自己重新在当学生，把这篇论文带到楼上去，逐字逐句地读，检查每一条方程式。然后你就什么都弄懂了。”我接受了她的建议，把那东西从头看到尾，发现它真的很明显简单。我只是一直害怕去读它，总觉得它太深奥。","link":"/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Linux常用命令整理（1）","text":"Linux命令基础知识 1234567891011$ command [-options] parameter1 parameter2 ... 命令 选项 参数(1) 参数(2) 说明： 1. 任何命令中第一个输入的部分绝对是『命令(command)』或者『可运行文件』 2. command 命令的名称 3. [-options] 选项并不存在于实际的命令中，而加入选项配置时，通常选项前会带 - 号（比如-h）。有时候会使用选项的完整全名，此时带有 -- 符号（比如--help） 4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数； 5. 命令, 选项, 参数等以空格来区分，但是不论空几格 ，shell 都同一视为一格； 6. [Enter]按键代表着一行命令的开始启动。 7. 命令太长的时候，可以使用反斜杠 (\\) 来跳脱[Enter]符号，使命令连续到下一行。反斜杠后需要立刻接特殊字符才行。8. 在 Linux 中，区分大小写。 基本查询查询所支持的语言123456$ echo $LANG zh_TW.UTF-8#修改为英文语系 $ LANG=en_US$ echo $LANG en_US 时间日历与计算器123$ date //date 时间$ cal //cal 日历$ bc //计算器 版本信息查询uname －a查看版本当前操作系统内核信息 cat /proc/version查看当前操作系统版本信息 cat /etc/issue 或 cat /etc/redhat-release查看版本当前操作系统发行版信息 cat /proc/cpuinfoLinux查看cpu相关信息，包括型号、主频、内核信息等 getconf LONG_BITLinux查看版本多少位 lsb_release -aCentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用 命令信息查询命令总数：[Tab][Tab]按下两个[Tab]按键，查看共有多少命令可以让用户使用用。 man page有时忘记了命令全称，也可以根据不完整的名称查出来，系统有哪些跟这个名词有关的说明文件 12 -f 查询以keyword开头所有相关帮助信息列表，只会找数据中的左边那个命令(或文件)的完整名称。$ man -f keyword 12 -k 将说明文件里面只要含有keyword的都列出来。$ man -k keyword 1234$ whatis [命令或者是数据] 相当于 man -f [命令或者是数据] $ apropos [命令或者是数据] 相当于 man -k [命令或者是数据] 两个特殊命令要能使用，必须要有创建 whatis 数据库才行！这个数据库的创建需要以 root 的身份下达如下的命令：[root@ ~]# makewhatis 关机/重新启动命令数据同步写入硬盘中： sync惯用的关机命令： shutdown重新启动，关机： reboot, halt, poweroff在默认的情况下， 这几个命令都会完成一样的工作！(因为halt会先呼叫shutdown，而shutdown最后会呼叫halt！)。 不过，shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt却能够在不理会目前系统状况下， 进行硬件关机的特殊功能 123[root@ ~]# reboot [root@ ~]# shutdown -h now [root@ ~]# poweroff -f halt若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。使用权限：系统管理者。 1[root@ ~]# halt 切换运行等级：initLinux共有七种运行等级run level 0：关机run level 3：纯文本模式run level 5：含有图形接口模式run level 6：重新启动可以使用init来关机 1[root@~]# init 0 文件处理命令目录相关：ls、pwd、mkdir、rmdir1234ls -l //列出当前目录下的文件详细信息pwd [-options] //查看”当前工作目录“的完整路径mkdir [-options] 目录名 //创建目录 rmdir [-options] 目录名 //删除空目录。 文件复制移动：touch、mv、cp、rm1234567mv [选项] 源文件或目录 目标文件或目录//mv命令将文件重命名或将其移至一个新的目录中``` ```bashcp [选项]… [-T] 源 目的//cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。 12touch [选项]… 文件…//touch命令可更改文档或目录的日期时间，包括存取时间和更改时间。 12rm [选项] 文件…rm命令删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。 取得路径的文件名与目录名：basename，dirname查看文件内容：more、less、head、tail、cat、tac、nl、diffmore：一页一页显示文件内容less：less与more类似，但是可以向前翻页head：查看文件时，只显示头几行tail：查看文件时，只显示尾几行【-f 循环读取文件，不断刷新】tac：从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 12345cat [选项] [文件]…主要的三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 1234nl [选项]… [文件]…\\\\可以用来显示文件\\\\nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！\\\\其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 123456789101112diff[参数][文件1或目录1][文件2或目录2]\\\\diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。root@ubuntu:~# diff /snap/ /usr/Only in /snap/: READMEOnly in /usr/: binOnly in /usr/: gamesOnly in /usr/: includeOnly in /usr/: libOnly in /usr/: localOnly in /usr/: sbinOnly in /usr/: shareOnly in /usr/: src 创建文件链接： ln123//ln (link)ln -s source dist # 建立软连接ln source dist # 建立硬连接 软链接(symbolic link)：软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。硬链接(hard link)：硬链接是已存在文件的另一个名字。【不允许给目录创建硬链接；只有在同一文件系统中的文件之间才能创建硬链接。】 硬链接：指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Number)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件,以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。软链接：文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 更改文件权限umask 档案预设权限chattr 配置文件档案隐藏属性lsattr 显示档案隐藏属性file 观察文件类型： chgrp改变所属群组, /etc/group里面可查询群组 1[root@~]# chgrp users code.log chown功能： 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。格式： chown [选项]… [所有者][:[组]] 文件… chmod功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。格式： chmod [-cfvR] [–help] [–version] mode file数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 压缩文件压缩文件和读取压缩文件：tar，gzip，zcat 磁盘占用与挂载dfdf命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。 1234root@ubuntu:~# df Filesystem 1K-blocks Used Available Use% Mounted onudev 491848 0 491848 0% /devtmpfs 100920 628 100292 1% /run du (disk usage)du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。该命令的功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出指定目录，则对当前目录进行统计。 mount在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等 文件查找which12which 可执行文件名称 //查找路径：PATH所含目录//which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 适用场合：查找命令/可执行文件所在的路径。有时候可能在多个路径下存在相同的命令，该命令可用于查找当前所执行的命令到底是哪一个位置处的命令。 whereis123whereis [-bmsu] [BMS 目录名 -f ] 文件名 //查找路径：索引数据库所含目录//whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于源文件，二进制文件，或是帮助文件。//whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 原理：首先会去掉文件名中的前缀空格和以.开头的任何字符，然后在数据库（var/lib/slocate/slocate.db）中查找与经过处理后的文件名相匹配的源文件，二进制文件，或是帮助文件。使用之前可以使用updatedb命令手动更新数据库。适用场合：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate12locate [选择参数] [样式] //查找路径：索引数据库所含目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 原理：默认情况下(文件名中不包含通配符时)，locate会给出所有与filename*相匹配的文件的路径。适用场合：没有文件类型性质的模糊查找 find1find pathname -options [-print -exec -ok …] //查找路径：当前目录/指定目录 适用场合：能用which、whereis和locate的时候尽量不要用find.功能： 用于在文件树种查找文件，并作出相应的处理原理：遍历当前工作目录及其子目录参数： 1.使用name选项，可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。2.按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。3.如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。4.使用type选项,根据不同的文件类型进行查找，如d(目录)、l(链接) find命令之exec-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。例如：find . -type f -exec ls -l {} ;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。find命令之xargsfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 网络管理命令Linux 查看端口占用情况 ip1ip [-option] [动作] [命令] option ：设定的参数，主要有-s显示出该设备的统计数据(statistics)，例如总接受封包数等；动作：就是是可以针对哪些网络参数进行动作，包括有： link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；route ：与路由有关的相关设定 ifconfig1ifconfig [网络设备] [参数] ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 digdig命令是一个功能强大的DNS查询命令。 一般格式： 1dig [@global-server] [domain] [q-type] [q-class] {q-opt} {d-opt} 参数说明：global-server：默认是以/etc/resolv.conf作为DNS查询的主机，这里可以填入其它DNS主机IP。domain：要查询的域名。q-type：查询记录的类型，例如a、any、mx、ns、soa、hinfo、axfr、txt等，默认查询a。q-class：查询的类别，相当于nslookup中的set class。默认值为in（Internet）。q-opt：查询选项，可以有好几种方式，比如：-f file为通过批处理文件解析多个地址；-p port指定另一个端口（缺省的DNS端口为53），等等。d-opt：dig特有的选项。使用时要在参数前加上一个“+”号。 d-opt常用选项：+vc：使用TCP协议查询。+time=###：设置超时时间。 netstat1netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。netstat命令(菜鸟教程) ss(Socket Statistics)12ss [参数]ss [参数] [过滤] 功能： ss命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。ss命令的参数及使用详解 ping1ping [参数] [主机名或IP地址] ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 tracertroute123traceroute[参数][主机]//具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 route1route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 功能： Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 Linux系统的route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 参考资料理解 Linux 的硬链接与软链接鸟哥的linux私房菜Linux下4个查找命令which、whereis、locate、find的总结Linux 命令大全","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/"},{"title":"Linux常用命令整理（2）","text":"统计与过滤 grep用于过滤/搜索的特定字符,可用正则表达式能多种命令配合使用。 1grep [-option] pattern file Linux grep 命令 wc统计指定文件中的行数、字数、字节数，并将统计结果显示输出。 1wc [-option] 文件… 该命令统计指定文件中的行数、字数、字节数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数 12$ wc testfile # testfile文件的统计信息 5 100 600 testfile # testfile文件的行数为5、单词数100、字节数600 Linux wc命令 进程相关进程的挂起1kill -stop PID //将进程挂起（redhat） 需要重新执行当前被挂起的任务时，使用 bg %num 即可将挂起的 job 的状态由 stopped 改为 running，仍在后台执行。需要改为在前台执行时，执行fg %num 即可。也可以使用[ctrl]+[z] pstree123pstree -p //可以显示进程树pstree -apnh //显示进程间的关系pstree -u //显示用户名称 Linux pstree命令 lsof （lists openfiles）1lsof [参数][文件] //需要root执行（因为要访问核心内存和各种文件） 功能： 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。 好用的系统监视工具（神器）。 有着最多开关的Linux/Unix命令之一 lsof打开的文件可以是：1.普通文件2.目录3.网络文件系统的文件4.字符或设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.网络文件（例如：NFS file、网络socket，unix域名socket）9.还有其它类型的文件，等等lsof 菜鸟教程Linux 命令神器：lsof ps(process status)1ps [options] [--help] //用来显示当前进程的状态 ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。如果想要动态的显示进程信息，就可以使用top命令。 1234root@ubuntu:~# ps PID TTY TIME CMD13777 pts/1 00:00:00 bash14564 pts/1 00:00:00 ps Linux ps命令 jobs12jobs[选项][参数] //用于显示Linux中的任务列表及任务状态，包括后台运行的任务。//jobs 的状态可以是 running, stopped, Terminated 该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。 12345678910root@ubuntu:~# jobs //后台没有进程，所以jobs命令的输出是空root@ubuntu:~# ping 192.168.0.1PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.^Z[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs -l //-l：显示进程号；[1]+ 14661 Stopped ping 192.168.0.1 jobs命令 fg、bg、jobs、&amp;、ctrl + z都是与系统任务有关的常用命令 12345command&amp; 或者 ctrl + z 让进程在后台运行 jobs 查看后台运行的进程 fg %jobnumber 让后台的进程jobnumber到前台到前台 bg %jobnumber 让进程jobnumber到后台去 //%jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid) kill1kill[参数][进程号] 功能： 发送指定的信号到相应进程。不指定信号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 1234//通过 jobs 命令查看 job 号（假设为 jobnumber）kill %jobnumber通过 ps 命令查看 job 的进程号（PID，假设为 pid）//kill pid killall1killall[参数][进程名] //用来结束同名的的所有进程（kill processes by name） killall命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。 系统监测top1top [参数] 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 free1free [参数] 功能： free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略 1234root@ubuntu:~# free total used free shared buff/cache availableMem: 1009176 136644 172116 628 700416 687996Swap: 0 0 0 vmstat (virtual memory statistics)功能： 用来显示虚拟内存的信息 1234root@ubuntu:~# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 172200 145008 555428 0 0 0 6 16 15 0 0 100 0 0 虚拟内存的原理：在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。 iostat (I/O statistics)1iostat[参数][时间][次数] 功能： 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。 Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 命令执行watch1watch[参数][命令] 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令（也就是说定个具体时间或者隔一段时间执行一次）watch命令 1watch -n 1 -d 'pstree|grep http' # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。 at1at[参数][时间] 功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on） crontab通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 Linux crontab命令详解 ##文件传输 rcp (remote file copy)1rcp [参数] [源文件] [目标文件] 功能：rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。 rcp（远程文件拷贝）命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。 scp (secure copy)1scp [参数] [源路径] [目标路径] 功能： scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 linux的scp命令可以在linux服务器之间复制文件和目录。 wget1wget [参数] [URL地址] 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。 支持断点下传功能 同时支持FTP和HTTP下载方式 支持代理服务器 参考资料Linux命令大全（手册）Linux 命令大全（菜鸟教程）","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/"},{"title":"Linux概述","text":"Linux设计目标Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。 设计Linux的基本方针： 每个程序只做一件事并且做好。 好的程序员追求的系统 简单，优雅， 一致性 （最小惊讶原理） 较强的功能性与灵活性 意味着系统有较小的一组基本元素，产生多种多样的组合来满足各种应用需要。 Linux的接口 Linux系统层次结构 所有版本的Linux必须提供大量的标准程序，其中一些是POSIX标准指定的，其他的根据Linux的版本而有所不同。它们包括： 命令处理器（shell） 编译器 编辑器 文本处理程序 文件操作工具等 Linux具有三种不同的接口 真正的系统调用接口 库函数接口 由标准应用程序构成的接口 shellshell中，后台运行一个程序的语法是在原本命令后加“&amp;”。 shell脚本：包含shell命令的文件。 可以包含参数，同时使用if、for、while和case等结构。 可以给变量赋值，然后过一段时间再读取这些变量。 linux应用程序应用程序分类Linux的命令行用户界面包含大量的标准应用程序。大致分为6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 过滤器过滤器有： grep、sort、head、tail cut和paste（文档剪切与粘贴） od：将输入（通常是二进制，也包括八，十和十六进制）转化为ASCII文档。 pr：打印机格式化输出 tr：字符大小写转换 编译器和程序设计工具编译器和程序设计工具： gcc ar：将库函数收集到存档文件中 make：维护程序，跟踪哪些头文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。 内核结构 Linux内核结构 内核最底层，负责中断处理程序，这是它们与设备交互的主要方式，以及底层的分派机制。分派在中断时发生。 底层的代码中止正在运行的进程，将其状态存储在内核进程结构中，然后启动相应的驱动程序。 进程分派，在内核完成某些操作并且需要再次启动一个用户进程时，发生。进程分派的代码是汇编代码，并且和进程调度的代码有很大不同。 内核子系统的三个主要部件 I/O部件 包含所有负责与设备交互以及实现联网和存储的I/O功能的内核部件 内存管理部件 维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法。并根据需要把需要的数据和代码页读入内存中。 进程管理部件 主要是进程的创建和中止。还有CPU调度和信号处理。 内核最顶层，是内核的系统调用接口。所有的调用都来自这里，其导致一个陷阱，将系统从用户态切换到受保护的内核态，继而将控制权交给上述的内核部件之一。 参考资料现代操作系统","link":"/2020/04/20/Linux%E6%A6%82%E8%BF%B0/"},{"title":"操作系统与文件系统简述","text":"操作系统 1940s，1950s的年代，计算机慢，一次只能运行一个程序，程序员在打孔纸上写程序，拿到一个计算机房间，交给操作员。操作员等计算机空下来后，将程序放入，然后运行，输出结果，停机。 计算机变快之后，放程序的时间比程序运行时间还长，我们需要计算机以一种方式自动运作——&gt;操作系统 到1950年代尾声，计算机已经变得非常快了，处理器经常闲着，等待慢的设备（比如打印机，读卡器等），也就是程序阻塞在I/O上 50年代后期，曼彻斯特大学研发了世界上第一台超级计算机，Atlas，想法设法最大限度利用它，1962年设计了atlas supervisor程序，能够在一个CPU上运行多个程序（这种能力也叫多任务处理）Atlas是世界上第一台同时支持虚拟内存和内存保护的电脑 同时运行多个程序会有一些问题 每个程序都会占一些内存，切换程序的时候不能丢失数据 解决办法是给每一个程序配置专属内存块 分配专属内存块到物理地址时候，可能物理地址不连续的，为了隐藏这种复杂性，把内存地址虚拟化，也就是虚拟内存机制 这种机制可以使程序内存大小灵活增减，也叫动态内存分配 内存保护：程序只能捣乱自己的内存，不会影响到其他的程序。 分时操作系统Multics 首次在设计时候考虑了安全机制，但是导致系统过于臃肿。 Dennis 和 Thompson 联手打造了Unix，将os分为两部分 操作系统的核心功能，比如内存管理，多任务和输入输出管理，称之为内核 一堆有用的工具，比如程序和运行库 Unix中并没有向multics这么多的错误处理代码-如果有错误产生，就让内核恐慌（kernel panic） 内核崩溃是没有办法恢复的，所以调用了一个pannic的函数，起初只是打印pannic一词，然后无限循环Unix成为1970-1980年代最流行的操作系统之一 1980年代，计算机降价到普通人买得起，这时候叫个人电脑。起初微软的操作系统没有内存保护，经常蓝屏,后来微软都加上了 我们现在用的ios，安卓，windows，macos基本上都有了内存保护，虚拟内存，多任务了； 文件系统文件格式：随机排列文件当然没有问题，但是随机排列会更好的 最简单的文件格式 文本文件（.txt） 元数据（meta data）：关于数据的数据元数据存在于文件开头，在实际的数据前面，因此也叫文件头（header） 早期计算机只做一件事，比如火炮射程表，这时候整个存储器就像一个文件（数据从头到尾直到占用满） 后期计算和存储能力的提升，可以存多个文件了，这时候最简单的方式是把文件连续存储，一个个在内存中连续存放但是存储器没有文件概念，只存储大量位，我们怎么直到文件的开头和结尾在哪呢？所以我们需要一个特殊文件，来记录其他文件存储的位置这个特殊文件有很多名字，这里泛称为“目录文件”,这个文件经常是存放在开头的 目录文件存放 其他文件的名字”文件名+”.“+扩展名“ 文件的元数据，比如创建时间(created)，最后修改时间(last modified)，文件所有者，是否能读写，最重要的是文件的起始位置和长度 就像书的目录意义，更改了书里面的内容，就需要更改对应的目录 目录文件和对目录文件的管理是一个非常简单的文件系统的例子 上面的例子是”平面文件系统“：文件都在同一个层次平面文件系统存在的问题：如果给某个文件加数据，会覆盖掉后面文件的一部分 所以现代的文件系统会做两件事 把空间预先分为一块块，并留一些“预留空间”可以方便改动和管理 （用这样的方案目录文件需要记录文件存放在哪些块里面） 拆分文件，存放在多个块里面，这样文件可以轻松增大和缩小（目录文件会记录不只一个块）//有点像虚拟内存 删除文件只需要在目录文件上删除那条记录即可。 碎片：文件存储在多个块里面，块之间是分开的，顺序也是乱的。//是增删改文件导致的，不可避免的 对很多存储技术来说，碎片是坏事，现实生活中大文件可能存放在数百个块里面，导致打开文件特别慢。如何解决？碎片整理！计算机把数据来回移动，排成正确的顺序 分层文件系统树状目录的形式 目录文件（根目录）不仅要指向文件，还要指向目录（is directory字段）//相对于平面文件系统的变化 无线深度的文件夹 可以轻松移动文件，只需要改动两个目录文件（一个删去一条记录，一个加一条记录） 存储介质如今存储技术正朝向固态前进，没有机械活动部件，里面是集成电路，不用像磁盘那样磁头等待磁盘旋转，ssd访问时间低于1/1000秒，但是仍然比RAM慢很多倍，所以现代计算机仍然用层次存储结构。第一个RAM出现于1972年，成本每比特一美分 参考资料Crash Course Computer Science","link":"/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/"},{"title":"常用数据结构简述","text":"算法处理的数据在内存中的格式是什么？我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构 数组array几乎所有的编程语言都自带了许多函数来处理数组，比如数组的排序 字符串string是数组的亲戚i = “love”虽然长得不像数组，但的确是数组，在计算机幕后的确是这样的字符放在内存中以/0结尾，不是”字符0“而是”二进制0“，这叫字符“null”，表示字符串结尾。 这个字符非常重要，如果调用print函数，会从开始位置逐个显示到屏幕，但是得直到什么时候停下来!否则会把内存中的所有内容输出。 矩阵matrix数组的数组 结构体struct多个变量打包在一起，在内存中会自动组织到一起的 节点node与指针struct可以构建复杂的数据结构，比如node 12345struct listnode{ int value; listnode * next;}; 链表linked list使用node来构建链表灵活性是通过每个节点指向下一个节点实现的循环链表（circular list）：尾部的next指向开头非循环链表：尾部节点指针值是null链表使用的时候很少看具体地址么，而是经常使用链表的抽象模型 链表的优点 容易重新排序，两端缩减，分割，倒序等 因为灵活很多数据结果可以用链表实现，比如队列和栈 队列queueFIFO队列的链表实现比方1-&gt;2-&gt;3-&gt;4-&gt;5可以让队列头指向1，队列尾部指向5 （也就是链表的节点连接是反向的）入队（enqueuing）出队（dequeuing） 栈stackLIFO入栈（push onto the stack）和出栈（pop from the stack） 树tree123456struct treenode{ int value; listnode * nextleft; listnode * nextright;}; 最重要的性质：树到根是单向的 二叉树 binary tree每个节点至多两个孩子 图graph顶点多对多 参考资料Crash Course Computer Science","link":"/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"},{"title":"软件工程简述","text":"为了写大型程序，程序员们使用了各种工具和方法，形成了软件工程这门学科。软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言： 这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。 对象尽管可以将大项目分解为小函数，每个人同时工作，不用关心整个项目，只关心自己的函数高效和正确就好啦，然而把代码打包成函数还是远远不够的。比如微软Office软件有近4000万行代码，打包成函数也还有几十万个，也还是也有点多。解决办法是，把函数再次打包成为层级，把相关的代码都放到一起，打包成对象（objects）。 面向对象编程（object oriented programming）把函数打包成为对象的思想叫做“面向对象编程”。对象可以包含对象，函数，变量。子对象也是同样的，所以会出现沿着对象层级一层层找执行函数的做法。 API软件工程的比喻：就像建造摩天大一样，有管道工配置管道，电工装电线，油漆工涂油漆，还有成败上千人做其他的事情。所以一个大团队中有许多小团队，不同小团队之间负责不同的功能，所以不同团队之间需要文档，才能帮助理解代码都在做什么，还需要定义好的程序编程接口（API）API帮助不同程序员合作，不需要直到细节，只要直到怎么使用就好了。 然后private与public提供不同的权限，哪些不让外部访问，哪些仅供内部访问。 面向对象的核心： 隐藏复杂度 选择性公布功能 IDE与调试（debugging）代码在编译之前只是文字，可以用任何文本处理程序写代码，但是一般来时，还是会用专门的工具来写比较好。IDE提供了许多有用功能，因为集成了所有的东西，所以叫IDE。 代码帮助，提示，整理，编译，测试 文档和注释（readme/comment）程序员另一项重要工作是给代码写文档文档一般放在readme中文档也可以写成注释，放在源代码中好的文档的作用： 能帮助开发者几个月后理解自己和他人的代码 还能提升复用性，与其让程序员一遍遍写已经有的东西，不如直接用别人写好的来解决问题。 版本控制源代码管理，帮助团队协作，也叫版本控制。弄懂git原理即可。 质量控制写代码与测试代码密不可分。测试也称为质量保证测试（QA，quality assurance testing）。严格测试软件的方方面面，看软件会不会出错，也就是找Bug。 Beta Alphabeta版软件（beta software）：意思是软件接近完成，但不是百分之一百通过测试过，公司有时会向公众发布beta版本，以帮助发现问题。alpha版软件（alpha version software）：一般很粗糙，错误多，只在公司内部测试。 参考资料Crash Course Computer Science","link":"/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"title":"文件系统（1）","text":"基础概念文件系统：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容 文件文件结构文件可以有多种构造方式。 字节序列（Windows，UNIX都采用这种文件模型） 记录序列（以前大型计算机系统中的常见模式，现在没多少了） 树（处理商业数据的大型计算机中获得广泛使用） 文件在这种结构中由一棵记录树构成，每个记录并不具有同样长度，记录的固定位置有一个键。树按键排序，从而对特定的键进行快速查找 文件类型Linux中分为 普通文件（regular）：存在于外部存储器中，用于存储普通文件。 目录文件（directory）：用于存放目录项，是文件系统管理的重要文件类型。 管道文件（pipe）：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件（socket）：一种用于网络间通信的特殊文件。 链接文件（link）；用于间接访问另外一个目标文件，相当于widows快捷方式。 字符设备文件（character）:字符设备在应用层的访问结构。 块设备文件（block）：块设备在应用层的访问接口。 文件存取 顺序存取文件（sequential access）：进程可以从头到尾顺序读取文件的全部字节或者记录，但不能跳过某一些内容，也不能不按顺序读取。可以返回到起点的。 随机存取文件（random access）：以任何次序读取其中字节或记录的文件。对很多应用程序来说是必不可少的，比如数据库系统 文件属性操作系统常用的文件属性 文件保护 属性 含义 备注 保护 谁可以存取文件，以什么方式 口令 存取文件需要的口令 有一些系统中，用户必须给出口令才能存取文件 创建者 创建文件者ID 所有者 当前所有者 标志 属性 含义 备注 只读标志 隐藏标志 系统标志 0表普通文件，1表示系统文件 存档标志 0表示已经备份，1表示需要备份 ASCII/二进制标志 0表示ASCII文件，1表示二进制文件 随机存取标志 0表示只允许顺序存取，1表示随机存取 临时标志 0表示正常，1表示进程退出时删除文件 加锁标志 0表示未加锁，非零表示加锁 查找读写相关 属性 含义 备注 记录长度 一个记录中的字节数 键的位置 每个记录中键的偏移量 键的长度 键字段的字节数 当前大小 文件字节数 最大长度 文件可能增长到的字节数 时间 属性 含义 备注 创建时间 最后一次存取时间 最后一次修改时间 文件操作最常用的一些系统调用（不限制系统的总结） create delete open close read write append：write的限制形式，智能在文件末尾读取数据 seek：对于随机存取文件，通常需要指定从何处读取数据，通常使用seek系统调用把当前位置指针指向文件中的特定位置。seek调用结束后，就可以从该位置开始读了。 get attributes set attributes rename Linux文件IO函数，通常包括 open,read,write,lseek,close这五个函数。 目录目录操作 create delete opendir closedir readdir rename link ulink 文件系统的实现文件系统布局文件系统存放：文件系统存放在外存上。多数磁盘划分为一个或者多个分区，每个而分区有一个独立的文件系统。主引导记录（master boot record，MBR）：磁盘的0号扇区称为主引导记录，用来引导计算机，MBR之后挨着的是分区表,该表给出了每一个分区的起始和结束地址。在计算机被引导时，BIOS读入并执行MBR。MBR执行的第一件事情是确定活动分区，读入活动分区的第一个块，称为引导块（boot block），并执行之。引导块中的程序将装载该分区中的操作系统。为了统一，每个分区都从一个启动块开始，即使它不含一个可以启动的操作系统。不过，在将来这个分区也许会有一个操作系统的。 文件的实现文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。不同的操作系统采用不同的方法。 连续分配最简单的分配方案：把每个文件座位一连串连续数据存储在磁盘上。所以，在块大小为1KB的磁盘上，50KB的文件要分配50个连续大小的块。优点 实现简单。记录每个文件用到的磁盘块简化为只需记住两个数字即可：第一块的磁盘地址和文件的块数。 读性能好。单个操作就可以从磁盘上读出整个文件。只需一次查找（对第一个块）。之后就不需要寻道和旋转延迟，所以数据以磁盘全带宽的速率输入。可见连续分配实现简单且具有较高的性能。 很适合DVD，CD-ROM等一次性光学介质的存储。 缺点 磁盘零碎问题。删除文件之后会留下空闲块，随着时间的推移会使得磁盘变得零碎，既有文件也有空洞 要么压缩磁盘。代价太高不可行。 要么重新使用空洞。需要维护一个空闲空间列表，但是为了挑选合适的空闲空间，需要知道该文件的最终大小。如果用户为了避免找到的空闲空间太小而提前给出一个不切实际的较大数字，则可能无法找到合适的空闲空间而导致失败。 链表分配链表分配：为每个文件构造磁盘块列表，每一个块的第一个字作为指向下一块的指针，块的其他部分存放数据。优点 可以充分利用每个磁盘块，不会因为磁盘碎片而浪费存储空间。 顺序读文件很方便 缺点 随机存取非常慢 由于指针占去了一些字节，每个磁盘块存储文件数据的字节数不再是2的整数次幂，这种怪异的大小会降低文件的存储效率。（类似于没有对齐） 很多程序都是以2的整数次幂来读写磁盘块的。因为上面论述的原因，要读出一个完整的2的整数次幂的块需要从两个磁盘中获得和接收信息，这就因为复制引发了额外的开销。 在内存中采用表的链表分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 可以取出每个磁盘块的指针字，把它放在内存的一个表里面，就可以解决链表分配的两个不足。 文件分配表（FAT,File Allocation Table）：这个表实现了链表的操作。文件分配表的每一个表项存放着文件数据的下一个块的块号 优点 磁盘文件块可以不用存放指针，这样整个块都是数据。 随机存取更加容易，整个文件分配表实现的链表都在内存中，不需要磁盘引用。 不管文件多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。 缺点 占用内存空间大。必须整个表都存放在内存中。 对于200GB的磁盘和1KB大小的块，这张表有2亿项，每一项至少三个字节，为了提高查找速度，有时需要4个字节。根据系统对空间和时间的优化方案，这张表需要600MB或者800MB，不实用。 i节点分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 既然整张文件分配表太大了，我们就拆分成小的放，实现一个新的数据结构i节点。 i节点（index-node）：每个文件都赋予了一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。优点： 只有在对应的文件打开时候，其i节点才在内存中 缺点与解决方案： 每个i节点只能存储固定数量的磁盘地址，那么当一个文件所包含的磁盘块的数目超出了i节点所能容纳的数目怎么办呢？ 一个解决方案，最后一个i节点中的磁盘地址不指向数据块，而是指向一个包含磁盘块地址的块的地址。 目录的实现每个目录项只引用i节点的目录 共享文件共享文件：当几个用户在同一个项目里面工作时候，他们常常需要共享文件。其结果是，如果一个共享文件同时出现在属于不同用户的不同目录下面，工作起来就很方便。连接（link）：原本属于C目录下的文件也出现在B目录下的话，B的目录与该共享文件的联系称为一个连接（link）。这样文件系统本身也成为了一个有向无环图（DAG）。 共享文件的问题： 如果目录包含磁盘地址，则当连接文件的时候，必须把C目录中的磁盘地址复制到B目录。如果B或者C之后又向文件中添加内容，则新的数据块只会列入添加工作的用户的目录中。其他用户是不知道的。这违背了共享的初衷 硬连接和软连接解决方案： i节点方法：磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中，目录指向这个数据结构(Linux中的i节点）（硬连接） 实现机制：需要有一个文件所有者计数机制，当B连接到共享文件时，i节点记录文件的所有者是C，建立一个连接并不会改变所有关系，但是它将i节点的连接技术加1，所以系统知道当前有多少目录项指向这个文件。 缺点：C删去这个文件之后，还有许多目录项指向它，其他硬连接会指向错误的文件。 改进：唯一能做的是只删除C的目录项，但是保留i节点，所有者计数减一。只有到计数为0的时候才会真正删除该文件。 符号链接方法（symbolic linking）：让系统建立一个类型为Link的新文件，并把该文件放在B目录下，使得B与C的一个文件存在链接。链接文件只包含了它所连接的文件的路径名。（软连接） 缺点：需要额外的开销。必须读取包含路径的文件，然后一个部分一个部分地扫描路径，直到找到i节点 缺点：每个符号链接需要额外的i节点和一个额外的磁盘块用于存储路径，如果路径很短，作为一种优化，系统可以将它存储在i节点中。 优点：只要简单提供一个机器的网络地址和文件在该机器上的路径，就可以连接全球任何地方的机器的文件。 tips：还有一个由连接带来的问题，在符号连接和其他方式中都存在。如果允许连接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被连接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被连接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被连接的文件将被两次复制到磁盘上，而不是只是被链接起来。 参考资料现代操作系统简直不要太硬了！一文带你彻底理解文件系统理解linux 的 inode解决inode耗尽问题","link":"/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/"},{"title":"C++内存分配与内存划分","text":"C/C++内存使用划分C/C++编译过的程序使用的内存划分： 栈区 是连续的内存区域。 由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。 栈区的变量通常是局部变量、函数参数等。 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 每次程序运行都会分配一个栈，main函数就在栈底，然后通过不同函数的调用顺序，依次进栈出栈。c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗 堆区（动态内存分配） 是不连续的内存区域。 自由存储区或堆：每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C 语言程序使用一对标准库函数malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和delete 表达式实现相同的功能。可以手动释放或者程序结束自动释放存储空间。优点：动态内存的生存期人为决定，使用灵活。缺点：是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 全局/静态存储区全局变量和静态变量的存储是放在一起。C语言中，全局变量又分为初始化的和未初始化的。C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统释放。 常量存储区这是一个比较特殊的存储区，里面存放的是常量，不允许修改。程序结束后由系统释放。 程序代码区存放函数的二进制代码。 堆存储/栈存储对象是存放在堆中还是栈中要看怎么去构造这个对象： 如果用new来生成的对象,是放在堆中的。 直接定义的局部变量内都是放在栈中的，全局和静态的对象（包括类的静态数据成员）是放在数据段的静态存储区 1234Class Test；Test p; //栈上分配内存Test* tTest； //指针在栈中tTest = new Test;，//new的在堆中 堆存储 因为没有专门的系统支持，效率很低； 可能引发用户态和核心态的切换，内存的申请代价变得更加昂贵。 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 因为找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 栈存储 用于存储占用空间小，生命周期短的数据（局部变量/参数变量等） 若栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出 出现栈内存溢出的常见原因有2个： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。 局部变量体积太大。 地址分配 堆，往下增长，向内存地址增加的方向增长 栈，往上增长，向内存地址减小的方向增长（对于小端存储，高位字节在高端地址、低位字节在低位地址，因此在压栈时先压高字节后压低字节） 可能会发生堆栈冲突(从堆中分配内存失败或者爆栈) 大端存储：数据高位在内存低位，低位在内存高位（如Freescale的PowerPC处理器） 小端存储：数据高位在内存高位，低位在内存低位（Intel的芯片一般是小端存储） 分配效率栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 堆、栈与大小端存储 数据存放基本数据类型： 直接存储在栈(stack)中的数据。（字符串、布尔值、未定义、数字、null） null只是一个空指针对象，没有数据。 引用类型： 将该对象引用地址存储在栈(stack)中，然后对象里面的数据存放在堆中。（数组、对象、函数） 存储的是该对象在栈中的引用，真实的数据存放在堆内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝与浅拷贝深拷贝既复制对象空间又复制资源在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值，然后同步复拷贝开辟空间的值。 浅拷贝只复制对象空间而不复制资源 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。default memberwise copy即称为浅拷贝。 即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝) 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值； 如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 C/C++内存分配的三种方式 静态存储区分配内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。 栈上分配在函数执行时，函数内的局部变量的存储单元在栈上创建，由操作系统自动分配，函数调用结束时内存也随之析构栈内存分配运算内置于处理器的指令集中，效率高，但栈容量小。 堆上分配堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放,在整个程序运行周期内都存在。 tips: 申请内存后立即判断指针是否为NULL确定内存是否分配成功，如果为NULL则立即用return终止此函数，或者用exit（1）终止整个程序的运行，为new和malloc设置异常处理函数； 为申请的内存赋初值，分配的是一段连续的内存空间的话，要防止指针下标越界； sizeof是操作符，不能用sizeof得到内存空间的大小，只能在申请时候记住申请的空间大小； 在内存使用结束后必须用free或delete释放内存，注意在内存使用中如果存在指针加1或减1 的操作应特别注意，释放的内存要和申请的内存一致，放置内存泄漏，释放内存后，应该立即将指针置为NULL，不要存在野指针。 参考资料[1]浅拷贝与深拷贝的区别[2]C++中数据存储的位置[3]C++经典面试之 内存分配的三种方式[4]堆、栈与大小端存储[5]c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗","link":"/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"},{"title":"C++特性及优缺点","text":"C++语言优缺点 优点 兼容性好，C++在保持了C语言简洁高效的特点的同时，还对C的类型系统进行改革性扩充，相比C语言，C++更安全，其编译系统也能检查出更多错误类型。 面向对象编程能力，可复用性好，可以让团队衍化出自己的的类库。 性能优势，程序效率高。 缺点 C++ 是 C 语言的一个超集，既有指针又有对象使它成为最复杂的语言，学习难度大。过分的精细和复杂了。C++的复杂度，超过了C和OO（面向对象）的复杂度之和 没有垃圾回收机制。 C++本质上说是提前编译的，Fortran也是。C#和Java大多时候是编译成字节码，运行的时候再 即使编译。Python和Ruby通常是解释型。这就产生了一个性能的分级：C++和Fortran比Java和C#快，Java和C#又比Python 和Ruby快。几种计算机语言的评价（修订版）为什么一些语言会比别的快？ C++特性C++面向对象的三个基本特征：封装、继承、多态。它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用在 C++ 中，用类进行封装（数据抽象），用类派生从一个类继承另一个：派生类继承基类的成员。多态（动态绑定）使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数继承和多态（动态绑定）在两个方面简化了我们的程序：能够容易地定义与其他类相似但又不相同的新类，能够更容易地编写忽略这些相似类型之间区别的程序。 封装（encapsulation）封装是一项低层次的元素组合起来的形成新的、高层次实体的技术。 函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。 类也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。 目的： 将抽象得到的数据和行为相结合，形成一个有机的整体（结合性） 将对象的使用者和设计者分开，以提高软件的可维护性和可修改性 实现代码重用 继承（inheritance）继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 通过继承关联起来的类型都共享共同的接口。当一个类继承另一个类时，这两个类通常可以使用相同的操作。更确切地说，如果两种类型存在继承关系，则可以说一个类“继承”了其父类的行为——接口。 C++ 中所提及的父类称为基类（base class），而继承而来的类则称为派生类（derived class）。 多态（polymorphism）多态：多态的基础是继承。多态下，子类重写父类的方法，实际使用过程中，用父类引用变量指向子类对象，此时父类引用调用的是子类重写后的方法，由于是父类引用变量，所有无法调用子类特有的方法。如果想调用子类特有的方法，必须强制类型转换到子类。多态性派生于一个希腊单词，意思是“许多形态”。之所以称通过继承而相关联的类型为多态类型，是因为在许多情况下可以互换地使用派生类型或基类型的“许多形态”。在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。多态性：指的是基于引用或指针的动态类型获得类型明确的行为的能力。 在C++中的主要表现是动态多态（动态绑定） 动态多态（动态绑定）：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。 在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。 引用和指针的静态类型与动态类型可以不同，这是 C++ 用以支持多态性的基石。 静态多态（编译期/早绑定）template（模板）：静态多态（编译时完成，效率高，适配性高，松耦合性），隐形接口overload（重载）：静态多态 同名函数，不同参数/函数返回值 相同范围，同一个类中 overwrite（重写）：静态多态，子类屏蔽父类的同名基函数 同名同参，无virtual 同名不同参 动态多态（运行期/晚绑定）override（覆盖重写）：动态多态（运行时完成，接口重用，编译器无法优化） 不同类中 同名，同参 基类函数有virtual 参考资料[1]C++ primer 第四版[2]几种计算机语言的评价（修订版）[3]为什么一些语言会比别的快？[4]C++ 特性及类（面试复习整理）[5]C++ 多态-菜鸟教程","link":"/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"设计模式总结","text":"设计模式是什么？ 基础概念设计模式（Design pattern）: 是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 GOF（Gang of Four）1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 为什么要用设计模式？ 为了重用代码 让代码更容易被他人理解 保证代码可靠性。 设计模式在软件开发中的两个主要用途： 开发人员的共同平台，提供了一个标准的术语系统，且具体到特定的情景。 例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式有哪些？共有 23 种设计模式，可以分为三类： 创建型模式（Creational Patterns） 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式（Structural Patterns） 用于在许多不同的对象之间形成大型对象结构,关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 行为型模式（Behavioral Patterns） 关注对象之间的通信,用于管理对象之间的算法、关系和职责。 创建型模式单例模式（Singleton Pattern）单例模式-菜鸟教程目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。何时使用：当您想控制实例数目，节省系统资源的时候。面临的问题：一个全局使用的类频繁地创建与销毁。解决方案判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。应用实例：1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。使用场景：1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。实现方式:《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 常见的单例模式分为两种：1、饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式2、懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式【C++】单例模式/工厂模式 工厂模式（Factory Pattern）设计模式之工厂模式（factory pattern）讲的很形象工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式。工厂模式-菜鸟教程提供了一种创建对象的最佳方式，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。目的：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程（类的实例化）延迟到子类进行。何时使用：我们明确地计划不同条件下创建不同实例时。面临的问题： 抽象工厂模式（Abstract Factory Pattern）根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者（生成器）模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 深拷贝与浅拷贝浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深拷贝：把要复制的对象所引用的对象都复制一遍。深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 结构型模式适配器模式（Adapter Pattern）作为两个不兼容的接口之间的桥梁。将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 装饰者模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。作为现有的类的一个包装。动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）用于减少创建对象的数量，以减少内存占用和提高性能。尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern）为其他对象提供一个代理以控制对这个对象的访问。 行为型模式模版方法模式（Template Method Pattern）设计模式 - 模板方法.定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。比如冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 命令模式（Command Pattern）设计模式 - 命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 观察者模式（Observer Pattern）当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。 中介者模式（Mediator Pattern）用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 备忘录模式 （Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 解释器模式（Interpreter Pattern）为语言创建解释器，通常由语言的语法和语法分析来定义。给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 状态模式（State Pattern）类的行为是基于它的状态改变的。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。 职责链模式 （Chain of Responsibility Pattern）为请求创建了一个接收者对象的链，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 访问者模式 （Visitor Pattern）使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 参考资料设计模式之工厂模式（factory pattern）《大话设计模式》读书笔记设计模式-菜鸟教程C++ 设计模式-CSDN【C++】单例模式/工厂模式C++中的单例模式和工厂模式","link":"/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"C++标准库容器类概述","text":"基础概念容器（container）： 容纳特定类型对象的集合。 C++中所有的容器都是类模板。 所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。容器默认构造函数不带参数。 为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。容器适配器（adaptors）： 适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。 STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。 什么是适配器，C++ STL容器适配器详解 顺序容器和关联容器关联容器和顺序容器的根本不同在于： 关联容器中的元素是按关键字来保存和访问的 顺序容器中的元素则是按它们在容器中的位置来顺序保存和访问的。 顺序容器顺序容器（sequential container）： 它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。 顺序容器不是排序的：元素排列次序与元素值无关。 而是由元素添加到容器里的次序决定。 主要的有三种：可变长动态数组 vector、双端队列 deque、双向链表 list。 汇总的有vector、deque、list、forward_list、array、string等。 表1. 顺序容器与顺序容器适配器: 顺序容器 用途 顺序容器适配器 用途 底层基础容器 vector 可变长动态数组，支持快速随机访问 stack 后进先出（LIFO）堆栈 默认使用deque。满足条件的基础容器有 vector、deque、list list 双向链表，支持快速插入/删除 queue 先进先出（FIFO）队列 默认使用deque。满足条件的基础容器有 deque、list deque 双端队列 priority_queue 有优先级管理的队列 默认使用vector。满足条件的基础容器有vector、deque。 除了上面的表格之外还存在forward_list顺序容器（单向链表，只支持单向顺序访问），请看文章链接 关联容器关联容器（Associative containers）： 支持通过键（key）来高效地查找和读取元素。 关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。虽然关联容器的大部分行为与顺序容器相同，但其独特之处在于支持键的使用。 关联容器支持很多顺序容器也提供的相同操作，此外，还提供管理或使用键的特殊操作。关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 有序关联容器有序关联容器有以下四种：set、multiset、map、multimap。 容器元素根据键的次序排列。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 在迭代遍历关联容器时，我们可确保按键的顺序的访问元素，而与元素在容器中的存放位置完全无关。 map 以键－值（key-value）对的形式组织：键(key)用作元素在 map 中的索引，而值(value)则表示所存储和读取的数据。 map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。 常用操作： map查询操作 操作 作用 m.count(k) 返回 m 中 k 的出现次数 m.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在: 123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 读取元素而不插入该元素: 12345//find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器：int occurs = 0;map&lt;string,int&gt;::iterator it = word_count.find(\"foobar\");if (it != word_count.end()) occurs = it-&gt;second; 更好的请参考：《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;map multimap 支持同一个键多次出现的 map 类型 set set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询。 适用条件： 如果希望有效地存储不同值的集合，那么使用 set 容器比较合适 当只想知道一个值是否存在时，使用 set 容器是最适合的。 set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。 set 容器存储的键也必须唯一，而且不能修改（也体现了 set 存储的元素仅仅是键，而没有所关联的值） multiset 支持同一个键多次出现的 map 类型 multimap和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和set 头文件。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。 无序关联容器unordered_mapunordered_multimapunordered_setunordered_multiset STL容器类库&lt;vector&gt;：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。&lt;list&gt;：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。&lt;deque&gt;：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。&lt;queue&gt;：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。&lt;stack&gt;：为堆栈(后进先出)数据结构定义序列适配器stack。&lt;map&gt;：map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。&lt;set&gt;：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。&lt;bitset&gt;：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。&lt;array&gt;：（TR1）固定大小数组，支持复制。&lt;forward_list&gt;：（c++11）单向列表，forward_list不提供随机访问，这一点跟list相同。forward_list是一个单向链表，只支持单向顺序访问，在链表的任何位置进行插入/删除操作都非常快。&lt;unordered_set&gt;：（TR1)无序容器set，其元素随机存放。唯一键的集合，按键散列。multiset类似于set，但是值不必是唯一的。&lt;unordered_map&gt;：（C++11）（TR1)无序容器map，其键值随机存放。键-值对的集合，由键散列，键是唯一的multimap类似于map，但键不是唯一的。完整的看C++中常用的std标准容器 STL容器类底层实现vector底层数据结构为数组 ，支持快速随机访问 list底层数据结构为双向链表，支持快速增删 deque 底层数据结构为一个中央控制器和多个缓冲区 支持首尾（中间不能）快速增删，也支持随机访问 STL源码分析146页 forward_list 顺序容器，底层数据结构为单向链表。 只支持单向顺序访问，支持快速增删 stack 底层一般用list和deque实现，封闭头部即可。 不用vector的原因应该是容量大小有限制，扩容耗时。 queue 底层一般用list和deque实现，封闭头部即可 不用vector的原因应该是容量大小有限制，扩容耗时 priority_queue底层数据结构：一般是vector为底层容器，堆heap为处理规则来管理底层容器实现 set底层数据结构为红黑树，有序，不重复 multiset底层数据结构为红黑树，有序，可重复 map 底层数据结构为红黑树，有序，不重复 multimap底层数据结构为红黑树，有序，可重复 hash_set 底层数据结构为hash表，无序，不重复 hash_multiset底层数据结构为hash表，无序，可重复 hash_map 底层数据结构为hash表，无序，不重复 hash_multimap底层数据结构为hash表，无序，可重复 C++STL的容器的底层实现详解 参考资料C++容器（STL容器）C++语言学习（九）——C++标准库简介Containers library(cppreference.com)C++中常用的std标准容器 //可以做查找表C++中容易忘的知识点——list和forward_list（四）//可做查寻表C++ STL 的底层实现C++标准模板库（STL）的容器的底层实现C++STL的容器的底层实现详解//可以做查找表","link":"/2020/05/10/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%A6%82%E8%BF%B0/"},{"title":"数据结构总结","text":"（未完待续） 基本概念数据结构： 是数据项的结构化集合。 结构性的表现 数据项之间的相互联系和作用 或者理解为定义于数据项之间的某种逻辑次序 依据逻辑次序的复杂程度划分： 线性结构 半线性结构 非线性结构 序列（sequence）序列（sequence）：最基本的线性结构的统称。序列（sequence）依据数据项之间的逻辑次序与其物理存储的对应关系不同，又可以进一步划分向量和列表： 向量（vector）向量（vector）:所有数据项之间物理存储位置与逻辑次序完全吻合。此时的逻辑次序也称为秩（rank） 循秩访问（call-by-rank），静态存储策略。 列表（list）列表（list）:所有数据项之间物理存储位置与逻辑次序不一定吻合。采用间接定址的方法通过封装后的位置（position）相互引用。 循位置访问（call-by-position）或者称为循链接访问（call-by-link），动态存储策略。 栈（stack）栈（stack）：线性数据结构的一种，视作向量与列表的特例。对象的插入和删除限制在栈的一端。禁止操作的一端称为盲端。栈顶（stack top）：可操作（插入和删除）的一端。入栈（push）与出栈（pop）。栈底（stack bottom）：无法直接操作的盲端。 栈与递归函数调用栈调用栈（call stack）和执行栈（execution）:大部分操作系统中，每个运行的二进制程序都都配有一个调用栈，用来跟踪属于同一个程序的所有函数，记录它们之间的调用关系，并保证在每一个调用实例执行完毕之后，可以准确返回。帧（frame）：调用栈的基本单位，每次函数调用时，都会相应的创建一帧： 记录了函数实例在二进制程序中的返回地址，局部变量，传入参数，还有上一帧的栈中地址。 逆序输出进制转换 递归嵌套栈混洗（stack permutation）：栈的数据从stackA——&gt;stackS——&gt;stackB。 括号匹配： 延迟缓冲： 逆波兰表达式（reverse Polish notation，RPN）： 试探回溯法剪枝试探回溯 八皇后迷宫寻径队列（queue）视作向量与列表的特例 基本概念队列（queue）：线性数据结构的一种，对象的插入和删除限制在队列的两端。队头（front）：允许取出元素的一端。出队（dequeue）:元素的删除操作。队尾（rear）：允许插入元素的一端。入队（enqueue）：元素的插入操作。 队列应用循环分配器银行服务模拟树 半线性结构（semi-linear structure） 其中的元素之间并不存在天然的直接后继或者直接前驱关系。但是只要附加某种约束（比如遍历），就可以在树的元素之间确定某种线性次序关系。因此树属于半线性结构 叶节点（leaf）：无孩子的节点。树的高度（height）:树的所有节点深度的最大值称作该树的高度。教材中约定，单个节点的树高度为0，空树的高度为-1。 如果根结点第0，层数=深度=高度-1 如果根结点第1，层数=深度=高度 节点的高度：任一节点V的高度对应于子树的高度subtree（V）。 多叉树（k-ary tree）k叉树（k-ary tree）：每个节点的孩子均不超过k个的有根树。 多叉树的表示法父节点表示法：一个向量表，存两个属性，一个是data，一个是parent孩子节点表示法：一个向量表，存两个属性，一个是data，一个是children（组织成vector或者list）父亲+孩子节点表示法：一个向量表，存三个属性，一个是data，一个是parent，最后一个是children（组织成vector或者list） 有序树（ordered tree）有序树（ordered tree）：同一节点的所有孩子之间必须具有某一线性次序。这个约束条件使得作为多叉树特例的二叉树有足够的能力表示任何一颗多叉树。 长子+兄弟转换法同一列的是长子，同一行的是兄弟 二叉树（binary tree）二叉树（binary tree）：每个节点的读书均不超过2。有序二叉树（ordered binary tree）：同一父节点的孩子都可以左右相互切分。真二叉树（proper binary tree）：不含一度节点的二叉树 完全二叉树（complete binary tree）完全二叉树（complete binary tree）： 对于使用队列操作的层次遍历，前(n/2向下取整）次迭代中都有左孩子入队，前(n/2向上取整然后-1）次迭代中都有右孩子入队 叶节点只出现在最底部的两层。 高度为：h=（log n）的向下取整 //根节点设置为高度0的情况下 规模介于2^h与2^(h+1)-1 根节点为1，左孩子编号等于2v,右孩子编号2v+1 满二叉树（full binary tree） 规模2^(h+1)-1 遍历递归式遍历迭代版先序遍历迭代版中序遍历迭代版后续遍历层次遍历 编码树编码解码前缀无歧义编码（PFC）huffman编码 二叉编码树根通路串（root path string） 搜索树对线性数据结构查找性能的改进。如果既要求对象集合的组成可以高效率地动态调整，同时也要求能够高效率的查找，对于向量和列表这类线性结构是难以胜任的。兼顾高效率的动态修改和高效率的静态查找，可以使用搜索树。理想平衡和适度平衡，引入平衡二叉树结构，比如AVL树即使在最坏情况下，单次动态查找和静态查找也均在O（log n）时间内完成。 理想平衡和适度平衡理想平衡：如果树的高度恰好为log n，向下取整，则成为理想平衡树 ，比如完全二叉树和满二叉树 适度平衡：渐进意义下适当放松标准的平衡性。渐进的不超过O(log n)下面介绍的红黑树，AVL树，伸展树，kd-树都是适度平衡的变种。也可以归入平衡二叉搜索树之列。 搜索树的局部性 刚刚被访问的节点，可能不久后就能访问到 将被访问的下一个顶点，极可能就在不久之前被访问的某个节点附近 二叉搜索树（BST）二叉搜索树（binary search tree）：处处都满足顺序性——任一节点r的左（右）子树中，所有节点均不大于（不小于）节点r二叉搜索树的判定:任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降。 复杂度分析：insert，remove，search时间：线性正比于查找路径的长度或者最终返回节点的深度。最坏情况下可能退化成为链表。 等价二叉搜索树若两个二叉搜索树的中序遍历相同，则称它们彼此等价。概括一下就是：上下可变，左右不乱。也就是说节点的左右相对关系是不变的，但是上下关系是可以改变的。局部性： 经过单词动态修改操作，至多只有O(log n)处局部不再满足限制条件。 可以在O(log n)时间内，使这O(log n)处局（乃至全树）重新满足限制条件。 旋转调整（修复）zig 顺时针旋转zag 逆时针旋转 平衡二叉搜索树（BBST）AVL树平衡因子(balance factor)：其左，右子树的高度差。各个节点的平衡因子绝对值不超过1。也就是各个节点左右子树高度差不超过1。 失重与重新平衡：单旋与双旋：统一重平衡算法： 伸展树（splay tree）伸展树（splay tree）： 无须时刻都保持全树的平衡，但是却能够在任何足够长的序列上，保持分摊意义上的效率。 不需要对基本的二叉树节点结构，做任何附加的要求或者改动，不需要记录平衡因子或者高度之类的额外信息，故适用范围更广 利用了数据局部性，将刚刚被访问的节点，转移至树根附近。 伸展（splaying）：随着节点e的不断上升，两侧子树的结构也在不断的调整，这种过程也形象地称为伸展。 单层伸展树节点e每次提升1层，直至成为树根 双层伸展树节点e每次提升2层，直至成为树根。 zig-zig/zag-zagzig-zig/zag-zagzig/zag 复杂度分析：分摊的情况下，O（log n） 红黑数（red-black tree）通过假想地引入外部节点（黑色），将二叉树真正扩展为真二叉树。 根节点始终为黑色 外部节点均为黑色 其余节点若为红色，其孩子节点必为黑色 从任一外部节点到根节点的沿途，黑节点的数目相等 由1，2可知，红节点属于内部节点，且红节点的父节点和左右孩子肯定存在 由3可知，红节点之父必为黑色，树的任一通路不会包含相邻的红节点。7 由4可知，所有外部节点的黑高度统一 所有外部节点的黑高度统一特别的，根节点的黑高度也称为全树的黑高度，在数值上与外部节点的黑高度相等。所有外部节点的黑高度为0. 双红修正双黑修正 平衡多路搜索树平衡二叉搜索树（BBST）的推广当数据规模大到内存已经不足以容纳时候，常规平衡二叉搜索树的效率会大打折扣。其原因在于查找过程对外存的访问次数过多。 外部存储适合于批量式访问，不妨通过时间成本较低的多次内存操作，来替代时间成本相对较高的单次外存操作。 结合上面的思想，我们可以将通常的二叉树搜索树，改造为多路搜索树（等价变换） 四路搜索树：每个大节点拥有四个外部的分支。 通常是将二叉搜索树以两层为间隔合并。 一个大节点包含3个关键码和4个外部分支. 多路搜索树（multi-way search tree）：一般地，以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树。 优点： 访问外存的方式相对于二叉搜索树已经发生了本质的变化，可以以大节点为单位读取一组（而不是一个）关键码。 这组关键码在逻辑上与物理上都彼此相邻，故可以以批量方式从外存一次性读出，且需要的时间与读取单个关键码几乎一样。 每组关键码的最佳数目，取决于不同外存的批量访问特性。可以根据扇区的容量等因素来计算。 B- 树平衡多路搜索树的典型代表B-树（B-tree）：m阶B-树，也就是m路平衡搜索树 所有外部节点的深度都相等，每个内部节点都存有不超过m-1个关键码，以及用以指示对应分支不超过m个引用。各个节点的分支数应该介于m/2（向上取整）与m之间，故也称为(m/2向上取整，m)-树B-树的外部节点：B-树的宽度B-树的叶节点 非常适合在相对较小的内存中，实现对大规模数据的高效操作。 复杂度：O(logmN) kd-树（k-dimensional tree）四叉树与八叉树的一般性推广递归定义的平衡二叉树一维范围查询（range query）：给定直线L上的点集P={p0,pn-1},对于任一区间R=[x1,x2],P中的哪些顶点落在其中？离线方式和在线方式输出敏感（output sensitive）的算法平衡二叉搜索树解决一维度范围i查询问题， 找到最低共同祖先，忽略分割成为矩形，举行左边底边开，右边和顶边封闭每次切分都在中位点（对应的坐标排序居中者）。 以保证全树的高度不超过O(log n)复杂度O（根号n） 图非线性结构 邻接矩阵邻接表BFSDFS拓扑排序优先级队列与堆二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。最大堆:，任何一个父节点的值，都大于或等于它左、右孩子节点的值。最小堆:，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 完全二叉堆上滤与下滤左式堆串字符串串匹配散列表看这篇文章即可：哈希表（散列表）详解 注解偏序只对部分元素成立关系R，全序对集合中任意两个元素都有关系R。 集合的包含关系是偏序，因为两个集合可以互不包含。 复数中的大小就是偏序，其中虚数不能比较大小。 实数中的大小关系是全序，两个实数必有一个大于等于另一个。 参考资料数据结构 邓俊辉","link":"/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"title":"环状链表判断算法","text":"判断该链表是否有环 采用两个指针，一个用来遍历，一个用来从头到当前遍历位置的数据对比。思想：比较元素是否出过；复杂度：时间O(n^2),空间O(1) hash表的方法，记录元素，一旦在hash表中出现过,就证明有环复杂度：时间O(n),空间O(n) 双指针类型方法：两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。思想：追及问题，让快的先跑，如果有环，快的绕一圈后肯定会追上慢的。复杂度：时间O(n),空间O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;struct node{ int value; node *next; node(int a):value(a),next(NULL){}};typedef node list;bool iscycle(list * head){ node *p1,*p2; p1 = head; p2= head; while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL) //因为p1每次走两步，所以需要判断一下最后两个是否为空，以便决定是否循环； { p1 = p1-&gt;next-&gt;next; p2 = p2-&gt;next; if(p1==p2) { return 1; } } return 0;}int main(){ node * node1 = new node(5); node * node2 = new node(3); node * node3 = new node(7); node * node4 = new node(2); node * node5 = new node(6); node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = node5; node5-&gt;next = node2; //cout &lt;&lt; node5-&gt;next &lt;&lt; endl; cout &lt;&lt; iscycle(node1) &lt;&lt; endl;} 如何求出环的长度？当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数也就是 环长=1×前进次数 如何求出入环节点？如果链表有环，如何求出入环节点？答：只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。以上答案根据一个走两步一个走一步计算出的。 参考资料漫画算法","link":"/2020/05/14/%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95/"},{"title":"无序数组排序后的最大相邻差","text":"解法1： 使用任意一种时间复杂度为O（nlogn）的排序算法（如快速排序）给原数组排序，然后遍历排好序的数组，并对每两个相邻元素求差。复杂度：时间O（nlogn），在不改变原数组的情况下，空间复杂度是O(n) 解法2：基数排序的思想 利用计数排序的思想，先求出原数组的最大值max与最小值min的区间长度k（k=max-min+1），以及偏移量d=min。 创建一个长度为k的新数组Array。 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1。例如原数组元素的值为n，则将Array[n-min]的值加1。遍历结束后，Array的一部分元素值变成了1或更高的数值，一部分元素值仍然是0。 遍历新数组Array，统计出Array中最大连续出现0值的次数+1，即为相邻元素最大差值。 解法3：桶排序的思想解法3： 利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。其中第1个桶从原数组的最小值min开始，区间跨度是（max-min）/（n-1）。 遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值。 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。时间复杂度是O（n），空间复杂度是O（n*k） 代码C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//获取数组中数字之间的最大差值#include&lt;iostream&gt;#include &lt;algorithm&gt;#include\"memory.h\"using namespace std;struct bucket{ int min; int max; bucket():min(NULL),max(NULL){}};int getmaxdtce(int *a,int n){ //1.找到数列的最大最下值 int *max = max_element(a,a+n); int *min = min_element(a,a+n); int d = *max - *min; if(d==0) { return 0; } //2.初始化桶 int bucketnum = n; bucket *buckets = new bucket[n]; //3.遍历原始数组，确定每个桶的最大最小值 //注意，最大点独占一个桶 //所以前面n-1个桶的间隙是(a[i] - *min) / (d / bucketnum - 1); for (int i = 0; i &lt; n;i++) { int index = (a[i] - *min) / (d / (bucketnum - 1)); if(buckets[index].min==NULL||buckets[index].min&gt;a[i]) { buckets[index].min = a[i]; } if(buckets[index].max==NULL||buckets[index].max&gt;a[i]) { buckets[index].max = a[i]; } } //4. 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。 int leftmax = buckets[0].max; int maxdistance = 0; for (int i = 1; i &lt; n;i++) { if(buckets[i].min==NULL){ continue; } if(buckets[i].min-leftmax&gt;maxdistance) { maxdistance = buckets[i].min - leftmax; } leftmax = buckets[i].max; } return maxdistance;}int main(int argc,char *argv[] ){ int *test = new int[5]; memset(test, 0, sizeof(int) * 5); test[0] = 1;test[1] = 6; test[2] = 3; test[3] = 8; test[4] = 0; cout &lt;&lt;getmaxdtce(test,5);}","link":"/2020/05/14/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B8%E9%82%BB%E5%B7%AE/"},{"title":"使用栈实现的队列","text":"算法思想 其中一个栈A作为队列的入口，用于插入新元素；另一个栈B作为队列的出口，用于移除老元素。 当B为空的时候需要及时将A中的数据转移进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;/* stack&lt;int&gt;q; q.push(1); //入栈 q.pop(); //出栈 q.top(); //返回栈顶成员 q.size(); //返回栈成员个数 q.empty(); //判断是否为空栈*/class stackqueue{ private: stack&lt;int&gt; stacka; stack&lt;int&gt; stackb; public: void enqueue(int a); int dequeue(); void transfer();};int stackqueue::dequeue(){if(!stackb.empty()){ int tmp = stackb.top(); stackb.pop(); return tmp;}else{ if(stacka.empty()) { return NULL; } transfer(); int tmp = stackb.top(); stackb.pop(); return tmp;}}void stackqueue::transfer(){ while(!stacka.empty()) { stackb.push(stacka.top()); stacka.pop(); }}void stackqueue::enqueue(int a){ stacka.push(a);}int main() { stackqueue *que = new stackqueue(); que-&gt;enqueue(1); que-&gt;enqueue(2); que-&gt;enqueue(3); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; que-&gt;enqueue(4); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl;}","link":"/2020/05/14/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%98%9F%E5%88%97/"},{"title":"vector常用操作","text":"vector初始化方法123vector&lt;int&gt; vec; 初始化size为0的vectorvector&lt;int&gt; vec(10); 初始化size为10，默认值都为0的vectorvector&lt;int&gt; vec(10,1); 初始化size为10，值都为1的vector 通过数组初始化通过数组a的地址初始化，注意地址是从0到5（左闭右开区间），类似迭代器 12int a[5] = {1,2,3,4,5};vector&lt;int&gt; vec(a, a+5); 通过vector初始化12vector&lt;int&gt; a(5,1);vector&lt;int&gt; b(a); 通过insert初始化insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中//助记，插入开始的地方 123vector&lt;int&gt; a(6,6);vecot&lt;int&gt; b;b.insert(b.begin(), a.begin(), a.begin() + 3); 将a[0]~a[2]插入到b中，b.size()由0变为3 insert还可以插入m个值为n的元素 12在b开始位置处插入6个6b.insert(b.begin(), 6, 6); 通过copy函数赋值//助记，拷贝到目标地 1234567vector&lt;int&gt; a(5,1);int a1[5] = {2,2,2,2,2};vector&lt;int&gt; b(10);将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间copy(a.begin(), a.end(), b.begin());拷贝区间也可以是数组地址构成的区间copy(a1, a1+5, b.begin() + 5); 常用操作注意：std::vector 不支持 push_front，，它的目的是为了O(1)的push_back(),对它来说O(n)次的insert()就能做到push_front。支持push_front()的是deque支持的是deque。 加入元素1234q.push_back(x); 尾部加入元素q.insert(iter,x); 在iter位置插入x，传回新数据位置q.insert(iter,n,x); 在iter位置插入n个x，无返回值q.insert(iter,l,r); 在iter位置插入[l,r)区间内的数据，无返回值 vector交换12q.swap(p); 交换p，q容器内元素q.assign(iter1,iter2); //将区间[iter1，iter2)内元素赋值给vector，并清空vector容器之前的内容。 删除元素123q.pop_back(); 删除最后一个元素q.erase(iter1); 删除iter位置元素，返回值是指向被删元素之后的那个元素(即下一个元素)的迭代器。q.erase(iter1,iter2); 删除[iter1，iter2)区间内的元素 清空/覆盖12q.clear(); //清空Vectorq.assign(n,x); //将n个x赋值到vector中，并清空vector容器之前的内容。 返回元素123q.front(); 返回第一个数据q.back(); 返回最后一个数据q.at(i); //返回第i个元素 vector元素个数/是否为空123q.size(); 返回容器内成员个数q.resize(x); //重新指定容器大小q.empty(); 判断Vector是否为空 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 vector内存容量12q.capacity(); //返回Vector可用空间的大小q.reserve(); //重新指定空间大小，小于当前capacity时保持为原本的capacity值 二维vector的初始化123456789vector&lt;vector&lt;int&gt;&gt; vec1;int row = 3;int col = 3;vec1.resize(row);for(int i=0;i&lt;vec1.size();i++) vec1[i].resize(col);for(int i=0;i&lt;row;i++) for(int j=0;j&lt;col;j++) vec1[i][j]=5; 或者 1vector&lt;vector&lt;int&gt; &gt;vec(row,vector&lt;char&gt;(col,5)); 参考资料C++ 给vector去重的两种方法vector的几种初始化及赋值方式STL中erase()的用法","link":"/2020/05/19/vector%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"stack常用操作","text":"stack初始化方法123std::stack&lt;int&gt; q;std::stack&lt;int&gt; second(first); std::stack&lt;int, std;:vector&lt;int&gt;&gt; third; 使用vector初始化stack 交换swap将两个 stack的内容交换。这两个 stack的模板参数 T和 Container必须都相同。 12void swap(stack&amp; x) 重载1：x.swap(y)void swap(stack&amp; x, stack&amp; y) 重载2: swap(x, y) 常用操作12345q.push(element); 入栈q.pop(); 出栈q.top(); 返回栈顶成员q.size(); 返回栈成员个数q.empty(); 判断是否为空栈 参考资料C++ STL容器——stack用法介绍","link":"/2020/05/19/stack%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"queue常用操作","text":"queue初始化方法1queue&lt;int&gt;q; 交换swap(queue&lt;T&gt; &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(queue&lt;T&gt; &amp;x, queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作123456q.push(1); 入队列，无返回值q.pop(); 出队列，无返回值q.front(); 返回最上面（最后进入）的成员的引用q.back() 返回 queue 中最后一个元素的引用，但不删除该元素。q.size(); 返回队列成员个数q.empty(); 判断是否为空队列，bool 参考资料C++ queue(STL queue)用法详解","link":"/2020/05/19/queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"priority_queue常用操作","text":"概念priority_queue容器适配器定义了一个元素有序排列的队列。 默认队列头部的元素优先级最高。 因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。 如何定义“优先级”完全取决于我们自己。 模板1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; priority_queue初始化方法123队列的排序，右边是出队列的地方priority_queue&lt;int&gt;q; 经常使用的，默认是less，元素大的优先级高。priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 元素小的优先级高。 交换swap(priority_queue&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 queue 中的元素和参数 priority_queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(priority_queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(priority_queue&lt;T&gt; &amp;x, priority_queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作12345q.push(element); 入优先级队列q.pop(); 出优先级队列q.top(); 返回优先级队列头成员q.size(); 返回优先级队列成员个数q.empty(); 是否为空 参考资料C++ priority_queue(STL priority_queue)用法详解","link":"/2020/05/19/priority-queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"set常用操作","text":"基本概念set是一个关联容器类型，用于以升序方式存储唯一值。 属于关联容器（关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。） 特性 遵循数学集合三特性，互异性、无序性、确定性。 底层数据结构为红黑树，有序，不重复 set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询 set 容器存储的键也必须唯一，而且不能修改 set 容器以升序方式存储唯一值 set 不支持下标操作符 和map一样，set无法存储无法比较大小的数据； 头文件1# include&lt;set&gt; 模板1set&lt;int,greater&lt;int&gt; &gt;q; set初始化方法12set&lt;int&gt;q;set&lt;int&gt; numbers {8, 7, 6, 5, 4, 3, 2, 1}; 小的在前（less）/大的在前（greater）默认的比较函数是 less，因此容器中的元素会升序排列。 12set&lt;int, less&lt;int&gt;&gt; set1; 小的在前（less），升序set&lt;int, greater&lt;int&gt;&gt; set1; 大的在前（greater），降序 参考：C++ STL set greater less详解 交换swap(set&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(set&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(set&lt;T&gt; &amp;x, set&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入1234567int a[] = {1,2,3,4,5};set&lt;int&gt;q;q.insert(elem)); 集合中插入元素q.insert(a,a+5); 插入数组a至a+5的元素q.insert(pos, elem); 在容器中插入元素elem的一份拷贝，并返回新元素的iterator位置； q.insert(beg, end); 在容器中插入[beg, end)范围中所有元素的拷贝，没有返回值。 删除与清空123456q.erase(iterator pos); 删除集合中的元素 无返回值删除后pos不会自动++！被删除元素的迭代器，在删除之后失效！这里是和vector的区别q.erase(iterator first, iterator last); 移除迭代区间[first,last)内的所有元素，无返回值q.erase(value); 移除set容器内元素值为value的所有元素，返回移除元素的个数(size_type类型)q.clear(); 删除set容器中的所有的元素，无返回值 大小/是否为空123q.size(); 返回当前set容器中的元素个数q.max_size(); 返回set容器可能包含的元素最大个数q.empty(); 判断set容器是否为空 find和count12q.find(element); 返回element值位置的迭代器，找不到返回q.end()q.count(); 返回某个值元素的个数(根据set的特性，就是判断这个元素在不在，返回0或1) 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器 注意是set&lt;int,greater&lt;int&gt;&gt;::reverse_iteratorq.rend(); //返回头部反向迭代器 大于等于元素的迭代器12q.lower_bound(); 返回指向大于（或等于）某值的第一个元素的迭代器q.upper_bound(); 返回大于某个值元素的迭代器 参考资料C++ set初始化（STL set初始化）详解C++标准库容器类概述C++ STL set greater less详解 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/19/set%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"pair常用操作","text":"基本概念pair pair 是一个比较简单的模板类型，它只有两个 public 数据成员 first 和 second。 pair 对象可以封装任意类型的对象，可以生成任何想生成的 pair&lt;T1,T2&gt; 对象，可以是数组对象或者包含 pair&lt;T1,T2&gt; 的 vector 容器。例如，pair 可以封装两个序列容器或两个序列容器的指针。pair&lt;T1，T2&gt; 模板定义在 utility 头文件中，如果不想使用 map 而只想使用 pair 对象，可以包含这个头文件。 头文件123# include&lt;utility&gt;或者# include&lt;map&gt; 模板1pair&lt;const K, T&gt; q; pair初始化方法123456789pair&lt;int,int&gt;q; 创建一个空对pair&lt;int,int&gt;p(2,3); 创建一个对p，并分别赋值2，3pair&lt;int,int&gt;s(p); 创建一个对s，拷贝p给spair&lt;string, string&gt; anon; // holds two stringspair&lt;string, int&gt; word_count; // holds a string and an intpair&lt;string, vector&lt;int&gt; &gt; line; // holds string and vector&lt;int&gt;赋值利用make_pair函数q = make_pair(1,2); 如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。int初始化为0，string初始化为空； 交换swap(pair&lt;T1,T2&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(pair&lt;T1,T2&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (pair&lt;T1,T2&gt;&amp; x, pair&lt;T1,T2&gt;&amp; y) 重载2: swap(x, y) 123std::pair&lt;int,char&gt; foo (10,'a');std::pair&lt;int,char&gt; bar (90,'z');swap (foo,bar); 常用操作查找1234访问pair内元素操作 q.first; 返回成员第一个数据 q.second; 返回成员第二个数据 比较1p1 == p2 如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑 参考资料STL之pair类型详细分析C++ set初始化（STL set初始化）详解C++标准库容器类概述","link":"/2020/05/19/pair%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"map常用操作","text":"基本概念map map不能直接修改关键字，只能通过修改关键字的值间接修改关键字。 底层数据结构为红黑树，有序，不重复 map&lt;K，T&gt; 类模板定义在 map 文件头中，它定义了一个保存 T 类型对象的 map，每个 T 类型的对象都有一个关联的 K 类型的键。容器内对象的位置是通过比较键决定的。 头文件1# include&lt;map&gt; 模板12345678910template &lt; class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt;class map{ ... typedef pair&lt; const Key, T &gt; value_type; ...};经常使用的，默认是lessmap&lt;int,double,less&lt;int&gt; &gt; MYMAP; 元素升序map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; 元素降序 pair初始化方法1234map&lt;int,int&gt; q;map&lt;k, v&gt; m; 创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 vmap&lt;k, v&gt; m(m2); 创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型map&lt;k, v&gt; m(b, e); 创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt; 交换swap(map&lt;K,V&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(map&lt;K,V&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (map&lt;K,V&gt;&amp; x, map&lt;K,V&gt;&amp; y) 重载2: swap(x, y) map定义的类型123map&lt;K,V&gt;::key_type 在 map 容器中，用做索引的键的类型map&lt;K,V&gt;::mapped_type 在 map 容器中，键所关联的值的类型map&lt;K,V&gt;::value_type 一个 pair 类型，它的first 元素具有 const map&lt;K,V&gt;::key_type 类型，而 second 元素则为 map&lt;K,V&gt;::mapped_type 类型 常用操作使用下标访问 map 对象123map &lt;string, int&gt; word_count; // empty map// insert default initialzed element with key Anna; then assign 1 to its valueword_count[\"Anna\"] = 1; 存在则改变，不存在则加入 查找123456map&lt;int,int&gt;q;q.insert(pair&lt;int,int&gt;(1,2)); //通过pair进行插入操作q.insert(map&lt;int,int&gt;::value_type (1,2));//通过value_type进行插入q[1] = 2; //用数组方式进行插入三者不同的是，当map存在这个关键字时数组方式会覆盖关键字的值，而insert操作无法插入。 123m.insert(e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素m.insert(beg,end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。(返回 void 类型)m.insert(iter,e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。(返回一个迭代器，指向 m 中具有给定键的元素)。 比较函数12q.key_comp(); 返回比较元素key的函数q.value_comp(); 返回比较元素value的函数 大小与是否为空123q.size(); 返回容器内元素个数q.empty(); 判断容器是否为空q.max_size(); 返回可以容纳的最大元素个数 删除1234q.erase(iter); 删除迭代器iter的元素q.erase(iter1,iter2);删除[iter1,iter2)区间内的元素q.erase(key); 删除关键字为key的元素q.clear(); 清空容器 查找和计数12q.count(k) 返回 m 中 k 的出现次数,（map中有则返回1，否则0）q.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 查找迭代器123m.lower_bound();返回键值&gt;=给定元素的第一个位置 返回一个迭代器m.upper_bound();返回键值&gt;给定元素的第一个位置 返回一个迭代器m.equal_range();返回一个迭代器的 pair 对象。它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k) 初始化为0使用C++中的map容器定义一个mp，当你执行if语句判断mp[3]是否为1时，那么如果mp[3]以前不存在，此时mp[3]就会被无参初始化，second赋值为0。 123456789101112int main(){ vector&lt;int&gt; numbers; int n = numbers.size(); map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; //这里原来元素是不存在的，但是却可以直接加1； if (count &gt; n/2) return numbers[i]; } return 0;} 参考资料关于map容器的元素被无参初始化《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;mapC++ map是什么C++标准库容器类概述","link":"/2020/05/19/map%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"list常用操作","text":"基本概念list 底层数据结构为双向链表，支持快速增删 缺点是无法通过位置来直接访问序列中的元素，也就是说，不能索引元素。为了访问 list 内部的一个元素，必须一个一个地遍历元素，通常从第一个元素或最后一个元素开始遍历。 节点对象维护了两个指针，一个指向前一个节点，另一个指向下一个节点。 第一个元素的前向指针总是为 null,因为它前面没有元素，尾部元素的后向指针也总为 null。 头文件1#include &lt;list&gt; 模板1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class list; list初始化方法12345list&lt;int&gt;q; //创建空Listlist&lt;int&gt;p(5); 创建拥有5个成员的Listlist&lt;int&gt;s(5,1); 创建拥有5个成员，且初始值为1的Listlist&lt;int&gt;s2(s); 创建s2，并拷贝s元素给s2list&lt;int&gt;s3(s.begin(),s.end()); 创建s3，拷贝s.begin()至s.end()中元素给s3 交换swap(list&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 123void swap(list&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap (list&lt;T&gt;&amp; x, list&lt;T&gt;&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个list 常用操作插入12345q.push_front(num) 返回值空 在list的头部添加一个元素 q.push_back(num) 返回值空 在list末尾增加一个元素。q.insert(iter,num) 在iter位置插入元素num。q.insert(iter,n,num) 在iter位置插入n个元素num。q.insert(iter,beg,end) 在iter位置插入区间为[beg,end)的元素。 大小与是否为空12345q.empty() 如果list是空的则返回trueq.max_size() 返回list能容纳的最大元素数量q.size() 返回list中的元素个数q.resize(n) 从新定义链表的长度,超出原始长度部分用0代替,小于原始部分删除。q.resize(n,num)从新定义链表的长度,超出原始长度部分用num代替。 删除与清空123456q.clear() 返回值空，删除所有元素 q.pop_back() 返回值空 删除最后一个元素q.pop_front() 返回值空 删除第一个元素q.erase(iter) 删除一个元素，并且返回下一个位置的迭代器q.remove(value) 从list删除元素 void remove ( const T&amp; value );q.remove_if(MATCH) 按指定条件删除元素 返回值为空void list::remove_if( MATCH ) 12iterator erase ( iterator position );iterator erase ( iterator first, iterator last ); list中remove和erase都是删除一个元素，其中remove参数类型和数据类型一致，而erase参数类型是迭代器。remove（aim）是删除链表中的aim元素，若有多个aim，都会删除，而erase（it）是删除迭代器指定位置的元素，并且返回下一个位置的迭代器来看例子。 查找12q.back() 返回最后一个元素 reference back ( );q.front() 返回第一个元素 reference front ( ); 迭代器1234q.begin() //返回指向第一个元素的迭代器q.end() //返回末尾的迭代器q.rbegin() //返回指向第一个元素的逆向迭代器q.rend() //指向list末尾的逆向迭代器 查找迭代器1q.get_allocator() //返回list的配置器 反转list1q.reverse() //把list的元素倒转 void reverse ( ); 合并两个listSTL list容器由于采用了双向迭代器，不支持随机访问，所以标准库的merge(), sort()等功能函数都不适用，list单独实现了merge()，sort()等函数。splice与merge 最大的不同:不用排序，也不要求原始链表有序。 相同点:被合并的链表或元素将消失。 123q.merge(p); 合并2个有序的链表并使之有序,从新放到q中,释放p。q.merge(p,comp); 合并2个有序的链表并使之按照自定义规则排序之后从新放到q中,释放p。q.splice() //合并两个list 12list1.merge(list2)在使用merge前，必须使list1和list2已经排好顺序。并且，合并之后list1仍然是有序的 splice是剪切，粘贴。用splice时当B与A合并后，B就为空。但是要记住：迭代器仍然指向原来的位置，即使原来的元素不存在了。 12345678将list2中的所有元素拷贝到list1中。在list1中的起始位置是it1.复制结束后，list2将为空。list1.splice(it1, list2); 将list2中的元素，从it2开始，剪切到list1的it1起始的地方。list1.splice(it1, list2, it2);将链表list2从开始到结束都合并到it1开始的位置。list1.splice(it1, list2, it2begin, it2end); 排序sort()1q.sort() 给list排序 返回值为空 一个自定义的类，那么如果想为这个类所生成的对象排序的话，因为list.sort()默认排序需要重载 &lt; 操作符。所以我们必须在类对象里重载这个操作符 删除list中重复的元素unique()1q.unique() 删除list中重复的元素 返回值为空 输出1copy(q.begin(),q.end(),ostream_iterator&lt;int&gt;(cout,\"\")); 参考资料STL 如何使用list::remove_if容器链表中splice()、merge()、insert()方法的区别c++ list 合并listSTL 中list的sort()方法使用总结(运算符重载)C++ list.merge()使用方法stl list中erase和remove区别std::list::sort()排序分析C++ list(STL list)使用、创建和初始化C++标准库容器类概述 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/20/list%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"C++运算符重载","text":"运算符重载重载的运算符是带有特殊名称的函数 函数名是由关键字 operator 和其后要重载的运算符符号构成的。 与其他函数一样，重载运算符有一个返回类型和一个参数列表。 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。 保持语义不变 不改变运算符的优先级 不改变运算符的结合性 不改变运算符需要的操作数 不能创建新的运算符 定义为类成员函数(令运算符重载函数作为类的成员函数)例子,这里是二元运算符，在类的内部，只需要传入一个外部元素。 1Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 定义为普通的非成员函数(令运算符重载函数作为类的友元函数)例子,这里是二元运算符，不在类里面，需要传入两个元素。 1Box operator+(const Box&amp;, const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 这时候，就需要作为友元函数来操作类的对象了； 两种方式的区别区别在于令运算符重载函数作为类的成员函数在调用时只需输入一个被操作数参数即可，另一个操作数参数则不需要输入；令运算符重载函数作为类的友元函数在调用时不仅要求输入被操作数参数，还要求输入被操作数参数。 产生了这个区别的原因在于令运算符重载函数作为类的成员函数和令运算符重载函数作为类的友元函数有本质区别： (1)调用作为类的成员函数的运算符重载函数时，类对象肯定已经被建立了，这时对象中对应的私有数据成员存在。 (2)调用作为类的友元函数的运算符重载函数时，类对象还未被建立，这时对象中对应私有数据成员不存在。运算符重载的方法步骤运算符重载函数的参数个数 等于 运算符操作数的个数。但要注意，用成员函数重载时，对应于运算符左操作数的参数是默认传递的。 参数的顺序和左右操作数的顺序是一样的，这一点看看&lt;&lt; 和 &gt;&gt; 的重载就知道了。 tips重载一元运算符，在类的内部，不需要传入元素，参数为0。 重载++和–运算符号int类型参数只是用来区别后置++与前置++，此外没有任何其他作用。 令运算符重载函数作为类的友元函数重载前置运算符和重载后置运算符分别如何实现？答：也是一样的，传入参数多加一个int即可了 参考资料C++的运算符重载C++ 重载运算符和重载函数STL 中list的sort()方法使用总结STL 如何使用list::remove_ifC++ list.merge()使用方法","link":"/2020/05/20/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"C++变量初始化","text":"声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。 静态成员类的静态成员（static member）必须在类内声明，在类外初始化比如： 12345class A{ private: static int count ; // 类内声明 }; int A::count = 0 ; 类外初始化，不必再加static关键字 为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 类内初始化的成员能在类中初始化的成员只有一种，那就是静态常量成员。 1234class A{ private: static const int count = 0; 静态常量成员可以在类内初始化 }; 静态成员和常量成员不能在类内初始化。比如const int count = 0; 和static int count = 0;是不能在类里面初始化的。 总结静态常量数据成员static const int count: 可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化。 不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化； 静态非常量数据成员static int count: 只能在类外，即类的实现文件中初始化 不能在构造函数中初始化 不能在构造函数的初始化列表中初始化 非静态的常量数据成员const int count: 不能在类内初始化，也不能在构造函数中初始化， 只能且必须在构造函数的初始化列表中初始化； 非静态的非常量数据成员int count: 不能在类内初始化,不能在类外。 可以在构造函数中初始化 可以在构造函数的初始化列表中初始化 在类外定义的成员变量肯定是有static 关键字的。 初始化规则系统如何初始化取决于变量的类型以及变量定义的位置。 内置类型变量初始化 内置类型变量是否自动初始化取决于变量定义的位置。 函数体外定义的变量初始成0；（注意是主函数外） 函数体内定义的变量不进行自动初始化。 类类型变量初始化类类型变量在定义时，如果没有提供初始化式，则会自动调用默认构造函数进行初始化（不论变量在哪里定义，都会被初始化，只不过初始化为什么样子由编译器决定了）。如果某类型没有默认构造函数，则定义该类型对象时必须提供显示初始化式。 参考资料C++中静态变量的声明与初始化详解C++中变量的初始化规则C++的变量初始化","link":"/2020/05/20/C-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"单例模式C++实现","text":"单例模式singleton patternpurpose：使得一个类只能有一个实例，并提供一个全局访问的位置probliem：遇到实例的频繁创建和销毁时，效率低solution：创建时候检测实例是否存在key code：构造函数是私有的 如何选择懒汉和饿汉模式：特点与选择：懒汉：在访问量较小时，采用懒汉实现。这是以时间换空间。饿汉：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。 懒汉式单例模式代码（线程不安全）顾名思义，该模式只在你需要对象时才会生成单例对象(意思是太懒了，懒汉不到万不得已就不会去实例化类)缺点： 懒汉式是以时间换空间的方式。（在getInstance中new instance然后返回） 适用于单线程的环境！ 不是线程安全的！ 它不是线程安全的。假设当前有N个线程同时调用getInstance（）方法，由于当前还没有对象生成，所以一部分同时都进入步骤 2,那么就会由多个线程创建多个多个singleton对象。 123456789101112131415161718192021222324252627282930313233343536373839懒汉式单例模式- 私有静态指针，指向单例- 私有构造函数- 公有获取实例的静态函数# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance() { if (instance == NULL) 步骤 1 { instance = new singleton(); 步骤 2 return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } } private: static singleton * instance ; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = NULL;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();}//输出//instance initialized//instance has already initialized 饿汉式单例模式代码（线程安全）顾名思义，该模式在类被加载时就会实例化一个对象。（意思是有就吃，有加载个类的话，饿汉就直接在类里面建立） 饿汉式是以空间换时间的方式。（在静态区初始化instance，然后通过getInstance返回） 该模式能简单快速的创建一个单例对象，而且是线程安全的(只在类加载时才会初始化，以后都不会)。 缺点，就是不管你要不要都会直接创建一个对象，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单) 1234567891011121314151617181920212223# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance(){ return instance; } private: static singleton *instance; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = new singleton(); //关键的一步int main(){ singleton *singleton1 = singleton::getinstance(); singleton *singleton2 = singleton::getinstance();} 注意，这个单例在主函数之前就已经加载了，比如下面主函数输出的结果就是instance initialized。 123int main(){return 0;} 线程安全的懒汉式单例模式代码加了一个互斥锁 12345678910111213141516171819202122232425262728293031323334353637383940# include &lt;iostream&gt;# include &lt;mutex&gt;# include &lt;pthread.h&gt;using namespace std;class singleton{ public: static pthread_mutex_t mutex; static singleton *getinstance() { pthread_mutex_lock(&amp;mutex); if (instance == NULL) { instance = new singleton(); return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } pthread_mutex_unlock(&amp;mutex); } private: static singleton * instance ; singleton() { pthread_mutex_init(&amp;mutex,NULL); //初始化为一个互斥锁 cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; } };singleton * singleton::instance = NULL;pthread_mutex_t singleton::mutex;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();} 注意：互斥变量使用特定的数据类型：pthread_mutex_t线程函数编译时需要添加特殊编译选项：gcc read.c -lpthread 比如最简单的编译命令，记住要在后加-lpthread选项，否则会出现undefined reference to ‘pthread_mutex_lock’报错。 参考资料饿汉式和懒汉式（单例模式详解)C++ 单例模式(懒汉、饿汉模式)C++关于锁的总结（一）windows下std 没有成员 thread、thread not member of stdc++线程中的几种锁 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"},{"title":"音标发音","text":"清辅音与浊辅音 分类 音标 清辅音 发音时声带不振动的辅音，有/p/ /t/ /k/ /f/ /θ/ /s/ /ʃ/ /h/ /tʃ/ /ts/ /tr/ 浊辅音 发音时声带振动的辅音，有/b/ /d/ /g/ /v/ /ð/ /z/ /ʒ/ /r/ /dʒ/ /dz/ /dr/ /j/ /w/ /m/ /n/ /ŋ/ /l/ 二者区别 读一下/v/和/f/感受一下就知道了 /ts/ 清辅音 声带不震动 发“次”的音 牙齿轻咬，舌端贴住齿龈，堵住气流。然后舌尖略微下降，气流泄出。 /ð/ 浊辅音，发音时声带要稍微振动，发出声来，但不要送气。 口型助记： 外形则像舌头顶在上下牙齿之间。 英语中只有字母组合“th”会发这个音。 容易把它发成舌尖齿龈摩擦音/z/；还有些人误把它发成舌端齿龈破擦音/dz/，其实只要记住轻轻舌头顶住，就不会错。 /θ/ 清辅音，发音时把舌尖放在上下齿之间，舌尖轻触上齿，略略露出齿外，气流由舌齿间泻出，摩擦成音 口型助记：外形像上下牙齿咬着舌头。 英语中只有字母组合“th”发这个音。 容易把它发成“舌尖齿龈摩擦音”/s/，其实只要记住轻轻咬住舌尖，就不会错。 音标中辅音并不难，发音基本和汉语一样，需要注意的是[θ]和[ð]这两个，因为这两个发音在汉语里是没有的。可以毫不客气地说，在中国，80%以上学英语的人这两个发音都是发成[s]和[z]的 相关资源清辅音/ts/的发音方法浊辅音/ð/的发音方法如何用英语48个音标发音用中文谐音标示","link":"/2020/05/24/%E9%9F%B3%E6%A0%87%E5%8F%91%E9%9F%B3/"},{"title":"STL排序相关库","text":"sort函数声明 12345template &lt;class RandomAccessIterator&gt; void sort (RandomAccessIterator first, RandomAccessIterator last); template &lt;class RandomAccessIterator, class Compare&gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); cmp()函数的返回值要是bool，核心要义也是比较。sort默认是从小到大，所以在cmp如果还是要从小到大，那就a &lt; b，返回值bool为true，不改变；如果想要从大到小排，那么就要return a &gt; b，因为默认a小于b，所以此时返回的bool就是false，要改变排序。也就是说， 返回的值是true的话，代表a先放，b后放 返回的值是false的话，代表b先放，a后放 stable_sort排序的时候保持相对位置，即相同的数字相对位置是不变的。 partition函数声明 12template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred); 作用：对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last stable_partition排序的时候保持相对位置，即相同的数字相对位置是不变的 参考资料C++ STL算法随记：C++ sort()函数，自定义cmp()的使用理解STL—–排序类——sort与partitionC++ stl算法——partition","link":"/2020/05/24/STL%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E5%BA%93/"},{"title":"多线程编程-按序打印（leetcode 1114）","text":"题目描述 提供了一个类： 12345public class Foo { public void one() { print(\"one\"); } public void two() { print(\"two\"); } public void three() { print(\"three\"); }} 三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法 线程 B 将会调用 two() 方法 线程 C 将会调用 three() 方法 请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 题目解析多个线程在cpu中执行，运行不同的程序段，但是这些程序之间有先后关系： one()方法如果不运行完毕啊，就不能运行two()方法。 two()方法如果不运行完毕啊，就不能运行three()方法。 也属于并发的问题：并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种： 竞态条件（Race Condition）：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。 死锁：并发程序等待一些必要资源，导致没有程序可以执行。 资源不足：进程被永久剥夺了运行所需的资源。 竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。（比如有一个if判断语句，多个线程都通过这个判断时候，下一步的执行可能造成各种奇怪的结果） 竞态条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。(可以将这种机制看做限制关键部分代码访问的锁) 在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。 如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。 这种机制还具有唤醒其他等待线程的功能。 总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制： 关键部分的访问控制。 通知阻塞线程。 代码实现方法1：使用 synchronization信号量和互斥锁(mutex)的区别：互斥锁只允许一个线程进入临界区，而信号量允许多个线程同时进入临界区。 12345678910111213141516171819202122232425262728293031#include &lt;semaphore.h&gt; 信号量Semaphore头文件class Foo {protected: sem_t firstJobDone; 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 sem_t secondJobDone;public: Foo() { sem_init(&amp;firstJobDone, 0, 0); sem_init(&amp;secondJobDone, 0, 0); } void first(function&lt;void()&gt; printFirst) { printFirst(); sem_post(&amp;firstJobDone); } void second(function&lt;void()&gt; printSecond) { sem_wait(&amp;firstJobDone); printSecond(); sem_post(&amp;secondJobDone); } void third(function&lt;void()&gt; printThird) { sem_wait(&amp;secondJobDone); printThird(); }}; semaphore是由操作系统提供的。 LINUX下，一般是＃include&lt;asm/semaphore.h&gt; 或 ＃include&lt;semaphore.h&gt; Windows下，一般是windows.h 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。sem_init：sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。 12345int sem_init(sem_t *sem, int pshared, unsigned int value);sem ：指向信号量对象pshared : 指明信号量的类型。不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享。value : 指定信号量值的大小sem_init() 成功时返回 0；错误时，返回 -1，并把 errno 设置为合适的值。 sem_post：sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的； 12int sem_post(sem_t *sem);sem_post() 成功时返回 0；错误时，信号量的值没有更改，-1 被返回，并设置 errno 来指明错误 sem_wait: sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。(也就是说是等于0时会阻塞操作) 1int sem_wait(sem_t *sem) 方法2：使用mutex加锁解锁1234567891011121314151617181920212223242526class Foo {public: Foo() { //构造函数先执行，将mutex变量进行加锁初始化。 m2.lock(); /首先给second()和third()上锁 m3.lock(); } void first(function&lt;void()&gt; printFirst) { printFirst(); m2.unlock(); /first()运行完了就解开second()的锁 } void second(function&lt;void()&gt; printSecond) { m2.lock(); 这里是锁的入口，如果已经上锁了，就不能执行了，如果没有，就可以执行下一步，并把锁值0置为1 printSecond(); m3.unlock(); //second()运行完了就解开third()的锁 } void third(function&lt;void()&gt; printThird) { m3.lock(); printThird(); m3.unlock(); }private: std::mutex m2, m3; }; 参考资料力扣（LeetCode）C++多线程同步之Semaphore(信号量)进程间通信方式——信号量（Semaphore）线程同步之信号量（sem_init,sem_post,sem_wait）","link":"/2020/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88leetcode-1114%EF%BC%89/"},{"title":"deque常用操作","text":"概念Deque（双向队列） 和Queue差不多 ,但是特殊的是Deque可是扩充内存。（实际上连续内存的容器不能随意扩充，所以Deque也不是真正意义上的扩充内存，而是封装了底层的表象。 Deque是由一段段构成的，当走到尾端时自动跳到下一段，（支持迭代器++操作）。 每次扩充，就会申请一个段，从而实现了内存连续的假象。 默认的stack 和 queue 都基于 deque 容器实现， priority_queue 则基于 vector 容器实现。对于给定的适配器，其关联的容器必须满足一定的约束条件。 stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在vector、list 或者 deque 容器之上。 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 或deque容器上，而不能建立在vector 容器上。 priority_queue 适配器要求提供随机访问功能，因此可建立在vector 或 deque 容器上，但不能建立在 list 容器上。 特性 deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。 deque 容器也可以根据需要修改自身的容量和大小。 缺点：频繁的插入删除时候，Deque并不适合。 Deque采用分块线型结构存储数据，两个迭代器分别指向首尾元素，而且拥有具有高效的push_back(),push_front()函数。 正因如此，所以Deque不易实现capacity和reverse函数。 头文件1#include &lt;deque&gt; 模板deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。 set初始化方法1234567int num[] = {1,2,3,4,5,6};deque&lt;int&gt; di{1,2,3,4,5};deque&lt;int&gt;q; 创建一个空双向队列 deque&lt;T&gt; deqT;默认构造形式deque&lt;int&gt;p(5); 创建一个具有5个成员的双向队列deque&lt;int&gt;s(5,1); 创建一个具有5个成员且初始值为1的双向队列 deque(n, elem);构造函数将n个elem拷贝给本身deque&lt;int&gt;s2(s); 创建一个双向队列s2，并拷贝s中所有成员 deque(const deque &amp;deq);拷贝构造函数。deque&lt;int&gt;n(num,num+5); 创建一个双向队列n，并拷贝num至num+5中元素入队 deque(beg, end);构造函数将[beg, end)区间中的元素拷贝给本身。 交换swap(deque&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 deque 中的元素和参数 deque 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(deque&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(deque&lt;T&gt; &amp;x, deque&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入操作123q.push_front(a); 头部入队q.push_back(b); 尾部入队q.insert(iter,x); 在iter位置插入x，iter为迭代器 覆盖12q.assign(n,x); 将n个x赋值到deque中，并清空deque容器之前的内容。q.assign(iter1,iter2); 将区间[iter1，iter2)内元素赋值给deque，并清空deque容器之前的内容。 删除与清空操作12345q.pop_front(); 头部出队q.pop_back(); 尾部出队q.clear(); 清空双向队列q.erase(iter); 删除iter元素，iter为迭代器q.erase(beg,end);删除[beg,end)区间的数据，返回下一个数据的位置。 deque数据存取1234q.front(); 返回头成员q.back(); 返回尾元素q.at(idx); 返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[]; 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 大小/是否为空123q.size(); 返回双向队列成员个数q.max_size(); 返回系统支持成员最大个数q.empty(); 判断双向队列是否为空 迭代器12345678q.begin(); 返回头部迭代器q.end(); 返回尾部迭代器q.rbegin(); 返回尾部反向迭代器q.rend(); 返回头部反向迭代器q.cbegin(); 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.cend(); 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crbegin();和rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crend(); 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 参考资料C++ STL deque容器底层实现原理（深度剖析）STL教程：C++ STL快速入门（非常详细）[C++ STL]deque使用详解C++ deque的用法与示例//解释的图片不错《C++Primer》第九章-顺序容器-学习笔记(3)-容器适配器&amp;栈&amp;队列","link":"/2020/06/01/deque%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"红黑树详解","text":"二叉查找树学习红黑树之前，先理解一下二叉查找树。 二叉查找树（BST）具备什么特性呢？ 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找和插入的过程类似于二分查找的思想，查找所需的最大次数等于二叉树的深度 二叉查找树（BST）缺点有哪些？主要体现在插入新的节点的时候假设初始的二叉查找树只有三个结点，根结点值为9，左孩子值为8，右孩子值为12：接下来我们依次插入如下五个结点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？最终的二叉查找树会非常的不平衡，左子树的深度为6，右边子树的深度为1（一棵好端端的树变成了瘸子，两边的子树不均衡了），这样会导致查找的性能大打折扣，几乎变成了线性查找； 二叉查找树的删除操作 待删除的结点没有子结点：节点没有孩子，因此直接删除即可。 待删除的结点有一个孩子：只有左孩子，于是我们让左孩子结点A取代被删除的结点，结点A以下的结点关系无需变动。（右孩子也是一样的） 待删除的结点有两个孩子：这种情况比较复杂。此时，我们需要选择与待删除结点最接近的结点来取代它。 AVL树与红黑树的差别AVL是严格平衡的二叉树，要求每个节点的左右子树高度差不超过1；红黑树更宽松一些，要求任一一条路径的长度都不超过其他路径长度的两倍。正因为这个差别AVL的查找效率更高，但是平衡调整的成本也更高。在需要频繁查找时，选用AVL树更合适，频繁插入删除时，选用红黑树更合适。 红黑树目的红黑树主要是为了解决上面的问题（可以说是一种策略，通过红黑树算法，让二叉查找树变成平衡二叉查找树） 概念红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。红黑树针对AVL树的不足（AVL树删除操作之后的重新平衡可能需要做到多达O(lon n)次旋转，从而频繁地导致全树的整体拓扑结构的大幅变化）进行了改进。红黑树保证：每次插入或者删除之后的重新平衡过程，全树拓扑结构的更新仅仅涉及常数个节点。尽管最坏情况下也需要对多达O(lon n)个节点重新染色，但是就分摊意义而言，仅仅为O(1)个。红黑树的适度平衡标准：任一节点左右子树的高度不得超过两倍。（由下面这五条规则来保证）除了符合二叉查找树的特性之外，还具体下列的特性： 结点是红色或者黑色 根结点是黑色 每个叶子的节点都是黑色的空结点（NULL）//这些是引入的外部节点，使得二叉树扩展为真二叉树 每个红色结点的两个子结点都是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色结点） 从任意结点到其每个叶子的所有路径都包含相同的黑色结点。 引申: 红节点都是树的内部结点，根节点和外部结点（叶结点）都是黑结点//由第(1)(2)两条规则可知 红节点的孩子不可能是红节点，也就是说红节点的父亲必为黑节点，从每个叶子到根的所有路径上不能有两个连续的红色结点//由第(3)两条规则可知 从根节点到任一节点的途中，黑节点都不少于红节点 从任一节点到其任一后代外部节点的沿途，黑节点的总数亦必相等。//由第(4)两条规则可知 //根节点深度解释为1，更好理解；解释为0，更好计算；我们在这里采用后者黑深度（black depth）从上向下描述： 从根节点到任一节点的途中，黑节点都不少于红节点，除去根节点本身，沿途所经过的黑节点的总数成为黑深度 所有外部节点的黑深度统一 黑高度（black height）从下向上描述： 从任一节点到其任一后代外部节点的沿途，除去外部节点（黑色），沿途所经过的黑节点的总数称为该节点的黑高度。 所有外部节点的黑高度统一，均为0 插入和删除当插入和删除节点的时候，红黑树的规则可能会被打破，这时候就需要做出一些调整，从而继续维持我们的规则什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子：这个例子去找一下图吧例如上面标准的红黑树，插入值为14的节点。插入之后发现仍然满足红黑树的要求！但是如果插入值为21的节点呢？由于父结点22是红色结点（插入的节点默认是红色是因为如果是黑色可能会影响规则5），因此这种情况打破了红黑树的规则4（每个红色结点的两个子结点都是黑色），必须进行调整，使之重新符合红黑树的规则。 调整红黑树的方法 开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也和玩魔方一样。红黑树有两大操作: recolor (重新标记黑色或红色) rotation (旋转，这是树达到平衡的关键)- 左旋转 - 右旋转 左旋的示意图逆时针旋转红黑树的两个结点，使得父结点被自己的右孩子取代，而自己成为自己的左孩子。 右旋的示意图顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己成为自己的右孩子。 示例为了符合红黑树的规则，会把节点红变黑或者黑变红。下图展示的是红黑树的部分，需要注意节点25并非根节点。因为21和22链接出现红色，不符合规则4，所以把22红变黑：但这样还是不符合规则5（但是，仅仅把一个结点变色，会导致相关路径凭空多出一个黑色结点，这样就打破了规则5。），所以需要把25黑变红，看下图：但是25和27仍然是红色，不满规则4，所以需要将27变为黑色但这只是局部结束了，全局仍然不能满足条件，15和17仍然是两个连续的红节点，不满足规则4，把17变黑也不行，因为13根节点为黑色，其子节点必为红色。只能进行旋转了！按照左旋转，对上边已经变色完成之后图进行左旋转。旋转之后，由于根节点是红色，需要变黑色但是仍然不满足规则5，接下来使用右旋转最后一个步骤，变色我晕，这也太复杂了！！！！ 红黑树插入节点的5种情况 新结点（A）位于树根，没有父结点。 //这种局面，直接让新结点变色为黑色， 新结点（B）的父结点是黑色。 //这种局面，新插入的红色结点B并没有打破红黑树的规则，所以不需要做任何调整。 新结点（D）的父结点和叔叔(父节点的兄弟)结点都是红色。 //参照下面的总结 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。 4.1 以结点B为轴，做一次左旋转，使得新结点D成为父结点，原来的父结点B成为D的左孩子,变成了局面5. 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。 5.1 我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子。接下来，我们让结点B变为黑色，结点A变为红色。 红黑树，超强动静图详解，简单易懂概括起来就是假设我们插入的新节点为 X 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1. 如果 X 的 uncle (叔叔) 是红色3.11. 将 parent 和 uncle 标记为黑色 3.12. 将 grand parent (祖父) 标记为红色 3.13. 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2. 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理。//刚刚说了 X 的 uncle 是红色的情况，接下来要说是黑色的情况3.21. 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.22. 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.23. 右右 (和 3.21镜像过来，恰好相反) 3.24. 右左 (和 3.22镜像过来，恰好相反) 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 红黑树删除节点的5种情况第一步：如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。 第二步：根据待删除结点和其唯一子结点的颜色，分情况处理。 自身是红色，子结点是黑色： 自身是黑色，子结点是红色： 自身是黑色，子结点也是黑色，或者子结点是空叶子结点： 第三步：遇到双黑结点，在子结点顶替父结点之后，分成6种子情况处理。 结点2是红黑树的根结点： 结点2的父亲、兄弟、侄子结点都是黑色： 结点2的兄弟结点是红色： 结点2的父结点是红色，兄弟和侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，左侄子结点是红色，右侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，右侄子结点是红色： 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 总结参考资料漫画：什么是红黑树？（完整版）漫画算法：5分钟搞明白红黑树到底是什么？30张图带你彻底理解红黑树红黑树(一)之 原理和算法详细介绍红黑树，超强动静图详解，简单易懂//这个讲的比较好数据结构 邓俊辉","link":"/2020/06/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"B树与B+树详解","text":"基本概念多路搜索树（multi-way search tree）： 将传统的二叉搜索树，改造为多路搜索树——在中序的遍历下，这也是一种等价变换 以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树，统称为多路搜索树。 多路搜索树同样支持查找等操作，而且效果与原来的二叉树完全等同；但是重要的是，其对外存的访问方式已经发生本质变化，是以大节点为单位从外存读取一组（而不是单个）关键码。 B树就是B-树： B-树就是B树，中间的横线不是减号，直接读成B树即可。 有的文章里出现的B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，而事实上是，B-tree就是指的B树。 B树是一种多路平衡搜索树，它的每一个节点最多包含K个孩子，k被称为B树的阶。 k的大小取决于磁盘页的大小 B树比较矮胖，扁平化，B-树的宽度往往大于其高度 B+树： 是应文件系统所需而产生的一种B-tree的变形树。 应用数据库索引主要基于什么数据结构？hash表和B+树 数据库索引为什么要用B+树结构来存储呢？树的查询效率高。而且可以保持有序。但是为什么不用二叉查找树呢？主要是因为磁盘I/O的影响，数据库索引是存储在磁盘上的，当数据量比较大的时候，索引的大小可能有几个G甚至更多。当我们利用索引查询时候，能把整个索引全部加载到内存吗？很显然不可能的，我们能做的是逐一加载每一个磁盘页，这里的磁盘页面对应着索引树的节点。这样的话，每遍历到一个节点就需要进行一次I/O操作。磁盘这种外部存储器适合批量式的访问，为了减少I/O，我们需要把原本瘦高的树结构变得矮胖，这就是B-树的特征之一。 大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的，如何减少树的深度？一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的） B-树主要应用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。 B-树（Balance Tree）所谓m阶B-树，即为m路平衡搜索树（m大于等于2）,除了根节点，各个节点的分支数目介于[M/2向上取整, M]。M为设定的非叶子结点最多子树个数，N为关键字总数。由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的利用率，其最底搜索性能为：O(log n) 根结点至少有两个子女。 子节点数：每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 关键字数：每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 所有的叶子结点都位于同一层。叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null（可以把这些null看成外部节点） 排序方式：每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B-树的特性 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制； 举一个B-树的例子，一个3阶的B-树，也就是(2,3)-树对于这颗树查询的过程比较次数不比二叉查找树少，尤其当单一节点中的元素数量很多的时候，可是相对于磁盘I/O，内存中的比较耗时几乎可以忽略，所以可以提升查找的性能。 B-树插入优势，自平衡遵循规则： 节点拆分规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须&lt;=3-1（这里关键字数&gt;2就要进行节点拆分，拆分的规则是把中间的元素提取出，放到父节点上，左边的单独构成一个节点，右边的单独构成一个节点）； 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则; 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 B-树删除遵循规则： 节点合并规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须大于等于ceil（3/2）（这里关键字数&lt;1就要进行节点合并）； 满足节点本身比左边节点大，比右边节点小的排序规则; 关键字数小于1时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 自顶向下查找元素11的节点位置。删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋 B-树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B-树中的卫星数据（Satellite Information）:无论是叶子节点还是中间节点都带有卫星数据。 B-树的范围查找过程比方对于上面的B-树，我们想查找3到11的元素，只能依靠繁琐的中序遍历。 B+树（ Tree）B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码； 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 一个m阶的B+树具有如下几个特征： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 示例 B+的特性 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； B+树插入 B+树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B+树中的卫星数据（Satellite Information）:只有叶子节点带有卫星数据。中间节点仅仅是索引，没有任何关联数据。需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树的范围查找过程相对于B-树要简单的多，只需要在链表上做遍历即可！ B树与B+树的优点B+树的优点：由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 B+树的层级更少：单一节点存储更多的元素，使得查询的IO次数更少，相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；。 B+树查询速度更稳定：所有查询都要查找到叶子节点，查询性能稳定。 B+树天然具备排序功能：所有叶子节点形成有序链表，便于范围查询。 B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树的优点: 由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B树和B+树的区别 B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这就意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时候的I/O次数也越少。 B+树的查询必须查到叶子节点，而B-树只要找到匹配元素即可。因此B-树的查找性能并不稳定，最坏情况是查找到叶子节点。而B+树的每一次查找都是稳定的。 为什么说B+树比B树更适合数据库索引？B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B+树的范围查询更加方便：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 总结 B-树和B+树都是很基础的概念，需要掌握好啊！ 二叉搜索树： 二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B（B-）树： 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树： 在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树： 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3 参考资料漫画：什么是B+树？从B树、B+树、B*树谈到R 树平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了漫画：什么是B-树？从二叉查找树到B+树中间的各种树 //写的相当不错B-树 百度百科阿里面试，问了B+树，这个回答让我通过了数据结构 邓俊辉","link":"/2020/06/03/B%E6%A0%91%E4%B8%8EB+%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"string常用操作","text":"基本概念标准库 string 类型：string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。size_type是一个依赖于实现的整型，是在string中定义的。string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。另外，使用缩写NBTS（null-terminated string）来表示以空字符结束的字符串。 头文件1#include &lt;string&gt; 模板123//The string class is an instantiation of the basic_string class template, defined in &lt;string&gt; as:typedef basic_string&lt;char&gt; string;string实际上是basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。 string初始化方法1234string s1; 默认构造函数 s1 为空串string s2(s1); 将 s2初始化为 s1 的一个副本string s3(“value”); 将 s3 初始化为一个字符串字面值副本string s4(n, ‘c’); 将 s4 初始化为字符 ‘c’ 的 n 个副本 注意！因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。 c-style字符转换1s.c_str(); 返回指向以null结尾的字符数组的指针，其数据与存储在字符串中的数据相同 交换swap(string&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 string中的元素和参数 string 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 1234void swap(string &amp;x) 重载1：x.swap(y)void swap (string&amp; x, string&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个string所有迭代器和引用都可能无效 常用操作读写操作对于string类型变量s的输入： 1cin &gt;&gt; s; 从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符： 读取并忽略开头所有的空白字符（如空格，换行符，制表符）。 读取字符直至再次遇到空白字符，读取终止。 读入未知数目的string 对象1234string word;程序将从标准输入读取一组 string 对象，然后在标准输出上逐行输出：while (cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl; 上例中，用输入操作符来读取 string 对象。该操作符返回所读的istream 对象，并在读取结束后，作为 while 的判断条件。如果输入流是有效的，即还未到达文件尾且未遇到无效输入，则执行 while 循环体，并将读取到的字符串输出到标准输出。如果到达了文件尾，则跳出 while 循环。 使用getline 读取整行文本123string line; // read line at time until end-of-filewhile (getline(cin, line)) //循环读取输入流 cout &lt;&lt; line &lt;&lt; endl; 赋值1234// st1 is an empty string, st2 is a copy of the literalstring st1, st2 = \"The expense of spirit\";st1 = st2; // replace st1 by a copy of st2它必须先把 st1 占用的相关内存释放掉，然后再分配给 st2 足够存放 st2 副本的内存空间，最后把 st2 中的所有字符复制到新分配的内存空间。 和字符串字面值的连接当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的： 1234567string s1 = \"hello\"; // no punctuationstring s2 = \"world\";string s3 = s1 + \", \"; // ok: adding a string and a literalstring s4 = \"hello\" + \", \"; // error: no string operand s4 的初始化试图将两个字符串字面值相加，因此是非法的string s5 = s1 + \", \" + \"world\"; // ok: each + has string operandstring s6 = \"hello\" + \", \" + s2; // error: can't add string literals s6 的初始化是非法的。依次来看每个子表达式，则第一个子表达式试图把两个字符串字面值连接起来。这是不允许的，因此这个语句是错误的。 大小与是否为空123456789s.empty(); true如果字符串为空, 否则返回falses.size(); 字符串中CharT元素的数量s.length(); 字符串中CharT元素的数量s.capacity(); 返回字符串当前为其分配空间的字符数s.max_size(); 返回string对象能够容纳的字符的最大数目s.resize(size_t n, char c); 用来改变string的大小，如果size小于原来string的size大小，则截取前面的size个字符，如果大于，则用空格填充。s.resize(size_t n); s.reserve(size_t res_arg=0);为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 s.shrink_to_fit() 请求删除未使用的容量 注意： resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 插入追加覆盖12345s.append(args); 将args追加到s.返回一个指向s的引用.s.assign(args); 将s中的字符替换为args指定的字符.返回一个指向s的引用.s.push_back(char c); 在末尾添加一个元素，返回值为空string&amp; insert ( size_t pos1, size_t n, char c ); 在字符串pos1位置，插入n次c字符。 size_t copy ( char* s, size_t n, size_t pos = 0) const; 从pos位置开始，复制n个字符到s指针指向的内存； insert1234567891011121314 string str=\"to be question\"; string str2=\"the \"; string str3=\"or not to be\"; string::iterator it; // used in the same order as described above: str.insert(6,str2); // to be (the )question str.insert(6,str3,3,4); // to be (not )the question str.insert(10,\"that is cool\",8); // to be not (that is )the question str.insert(10,\"to be \"); // to be not (to be )that is the question str.insert(15,1,':'); // to be not to be(:) that is the question it = str.insert(str.begin()+5,','); // to be(,) not to be: that is the question str.insert (str.end(),3,'.'); // to be, not to be: that is the question(...) str.insert (it+2,str3.begin(),str3.begin()+3); // (or )Output:to be, or not to be: that is the question... append()123456789101112 string str; string str2=\"Writing \"; string str3=\"print 10 and then 5 more\"; str.append(str2); // \"Writing \" str.append(str3,6,3); // \"10 \" str.append(\"dots are cool\",5); // \"dots \" str.append(\"here: \"); // \"here: \" str.append(10,'.'); // \"..........\" str.append(str3.begin()+8,str3.end()); // \" and then 5 more\" str.append&lt;int&gt;(5,0x2E); // \".....\"Output: Writing 10 dots here: .......... and then 5 more..... 查找12345s[index]; s.at(index); index是下标 size_t find (char c, size_t pos =0) const; 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置size_t rfind(char c, size_t pos = npos); 反向查找，从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置string substr(size_t pos = 0, size_t n= npos)const; 在str中从pos位置开始，截取n个字符，然后将其返回 删除与清空12345s.clear() 从字符串中删除所有字符, clear()只是将string中有效字符清空，不改变底层空间大小。s.erase(pos,len); 删除从位置pos开始的len个字符,如果len被省略,则删除从pos开始直至s末尾的所有字符.返回一个指向s的引用.iterator erase (const_iterator p); 删除源字符串中迭代器p指向的字符，返回删除后迭代器的位置。iterator erase (const_iterator first, const_iterator last); 删除源字符串迭代器范围为[first，last）内的所有字符，返回删除后迭代器的位置。s.pop_back(); 删除源字符串的最后一个字符，有效的减少它的长度。 数值转换为string1234567891011s=std::to_string(int/double/...);string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); 迭代器与指针12345678s.data(); 返回指向字符串第一个字符的指针s.begin(); 返回字符串第一个字符的迭代器,consts.cbegin(); 返回字符串第一个字符的迭代器s.end(); 返回字符串最后一个字符的后面一个位置的迭代器s.cend(); 返回字符串最后一个字符的后面一个位置的迭代器,consts.rbegin(); 反向迭代器s.rend(); 反向迭代器string::npos 相当于s.end() string 对象中字符的处理我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下表列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 cctype 头文件中定义。注意这里的”cctype”就是C++中使用C标准的头文件的写法，等价于”ctype.h” 操作 功能描述 isalnum( c ) 如果 c 是字母或数字，则为 True。 isalpha( c ) 如果 c 是字母，则为 true。 iscntrl( c ) 如果 c 是控制字符，则为 true isdigit( c ) 如果 c 是数字，则为 true。 isgraph( c ) 如果 c 不是空格，但可打印，则为 true。 islower( c ) 如果 c 是小写字母，则为 true。 isprint( c ) 如果 c 是可打印的字符，则为 true。 ispunct( c ) 如果 c 是标点符号，则 true。 isspace( c ) 如果 c 是空白字符，则为 true。 isupper( c ) 如果 c 是大写字母，则 true。 isxdigit( c ) 如果是 c 十六进制数，则为 true。 tolower( c ) 如果 c 大写字母，返回其小写字母形式，否则直接返回 c。 toupper( c ) 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c。 列出了各种字符操作函数 表中的大部分函数是测试一个给定的字符是否符合条件，并返回一个 int 作为真值。如果测试失败，则该函数返回 0 ，否则返回一个（无意义的）非 0 ，表示被测字符符合条件。 参考资料《C++Primer》第三章-标准库类型-学习笔记(1)-string&amp;vector&amp;迭代器C++ STL丨string 基本使用（一）STL string常用操作指令C++——string类和标准模板库【C++】String类、String类的常用接口说明及其使用、STL中的迭代器使用c/c++ reference","link":"/2020/06/06/string%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"《复杂》阅读笔记","text":"《复杂》简单讲述了复杂系统科学尝试去回答的迷人与令人费解的问题的一部分。 度量一个事物或过程的复杂性的三个维度描述它有多困难 产生它有多困难 其组织程度如何 物理学家克劳德 模型是什么？科学中是某种实在现象的简化表述模型是我们的思维方式 是用我们熟悉的思维概念解释观察到的现象； 无尺度特性《复杂性》这本书详细解释了什么是无尺度；改变图的尺度，图的形状是不变化的；例子：给定一个大型的样例网络，使用直方图来观察度的分布入度作为横轴，频率作为纵轴1000-1000010000-100000100000-1000000然上面几个图的分布情况曲线的形状几乎一样。这样的分布是自相似的，因为不管在哪种尺度下进行绘制，形状都是一样的——也就是在不同的尺度下具有不变性——就是无尺度一词的由来（无标度）无尺度网络对节点的随机删除具有稳健性，但是如果中心节点失效或是受到攻击就会非常脆弱。 如果你发现某种量遵循幂律分布，你就可以猜想这是某种自相似或分形系统导致的；尽可能填充空间的几何对象其实就是分形分支结构——在所有尺度上的自相似意味着空间在所有尺度上都被同等填充。 偏好依附（Preferential attachment）接下来一个很重要的概念是偏好依附。偏好依附（Preferential attachment）//一种网络生长机制巴拉巴西和艾伯特提出了一种他们称之为“偏好依附”的生成机制，用来解释幂律分布；其中的思想是：网络在生长的时候。连接度高的节点比连接度低的节点更有可能得到新的连接；//直观上说，朋友越多的人，越可能认识新的朋友。网页的入度越高，就越容易被找到； 连锁失效如果某个节点失效了，它的工作就会转移到其他节点，这有可能使得其他节点因为负荷过重而失效，它的工作就会转移到未失效的顶点~","link":"/2020/06/06/%E3%80%8A%E5%A4%8D%E6%9D%82%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"计算机网络教程-传输层概述","text":"传输层 传输层是客户程序和服务器程序之间的联络人，是一个进程到进程的连接。 传输层是TCP/IP 协议簇中的核心； 它是因特网上从一点到另一个点传输数据的端到端逻辑传输媒介。 传输层提供的一般服务进程到进程通信传输层协议的首要任务是提供进程到进程通信（process-to-process communication）。 主机间通信与进程间通信的不同:网络层负责计算机层次的通信（主机到主机通信）。网络层协议只把报文传递到目的计算机。然而，这是不完整的传递。报文仍然需要递交给正确的进程。这正是传输层接管的部分。传输层协议负责将报文传输到正确的进程。 寻址：端口号对通信来说，我们必须定义本地主机、本地进程、远程主机以及远程进程。IP 地址来定义本地主机和远程主机。端口号（port number）来定义进程。TCP/IP 协议簇中，端口号是在0 到65 535 之间的16 位整数。 客户程序用端口号定义它自己，这称为临时端口号（ephemeral port number）。临时这个词表示短期的（short-lived），它之所以被使用是因为客户的生命周期通常很短。为了客户-服务器程序能正常工作，临时端口号推荐值为大于1023。 服务器进程端口号不能随机选择。（因为随机分配的话导致客户端不知道端口号），TCP/IP 决定使用全局端口号，它们称为熟知端口号（well-known port number）。 ICANN 端口范围ICANN已经把端口号编码划分为三种范围：熟知的、注册的和动态的（或私有的） 熟知端口：端口号0~1023，由ICANN 分配和控制。这些是熟知端口号。 在 UNIX 中，熟知端口号存储在/etc/services 文件中，这个文件的每行给出服务器名和熟知端口号 注册端口：端口号1024~49151，ICANN 不分配也不控制。它们可在ICANN 注册以防重复。 动态端口：端口号49152~65535。这一范围内的端口号既不受控制又不需要注册，可以由任何进程使用。它们是临时或私有端口号。49152是2的14次方乘3 套接字地址在 TCP 协议簇中的传输层协议需要IP 地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来称为套接字地址（socket address）。客户套接字地址唯一定义了客户进程;服务器套接字地址唯一地定义了服务器进程;为了使用因特网中的传输层服务，我们需要一对套接字地址：客户套接字地址和服务器套接字地址。 多路复用和多路分解多路复用（multiplexing，多对一）： 多个数据项从多个源发出，一个实体接收它们，然后负责传输。； 指多个应用程序共享同一个传输层建立的连接进行数据的传送，在传输层是通过什么来区分不同的应用程序的（通过端口） 源端的传输层执行复用； 多路分解（demultiplexing，一对多）： 每当一个实体将数据项传递到一个以上的源时。 目的端的传输层执行多路分解 流量控制每当一个实体创建数据项并且有另一个实体消耗它们时，就存在生产速率和消费速率的平衡问题。 如果数据项生产比消费快，那么消费者可能被淹没并且可能要丢弃一些数据项。 如果数据项生产比消费慢，那么消费者必须等待，系统就会变得低效。 流量控制与第一种情况相关。我们需要在消费者端防止丢失数据项。 生产者到消费者消息传输两种方式推（push）:每当发送方生产数据项时，它无须事前获得消费者的请求就会发送它们——这种传递称为推。需要流量控制：当生产者推数据项时，消费者可能被淹没并需要相反方向的流量控制，以此来防止丢弃这些数据项。 拉（pull）:如果生产者在消费者请求这些数据项之后进行发送，这种传递称为拉。不需要流量控制：当消费者拉数据项，它会在自身做好准备时进行请求。在这种情况下，不需要流量控制。 传输层流量控制在传输层通信中，我们需要处理四个实体：发送方进程、发送方传输层、接收方传输层和接收方进程。应用层的发送方进程仅仅是一个生产者。它生产报文块，并把它们推到传输层。发送方传输层有两个作用：是消费者：它消费生产者推来的报文。也是生产者：它将报文封装进分组并传递到接收方传输层。接收方传输有两个作用：是消费者：消费从发送方那里接收来的分组；也是生产者：解封装报文并传递到应用层。然而，最后的传递通常是拉传递；传输层等待直到应用层进程请求报文。 我们至少需要两种流量控制： 从发送方传输层到发送方应用层的流量控制。 从接收方传输层到发送方传输层的流量控制。 这里看图即可： 缓冲区流量控制可以用多种方式实现，但通常的方式是使用两个缓冲区：一个位于发送方传输层，另一个位于接收方传输层。缓冲区是一组内存单元，它可以在发送端和接收端存储分组。消费者向生产者发送信号从而进行流量控制通信。 当发送方传输层的缓冲区已满，它就通知应用层停止传输报文块；当有空闲位置时，它通知应用层可以再次传输报文块。当接收方传输层的缓冲区已满，它就通知发送方传输层停止传输分组；当有空闲位置时，它通知发送方传输层可以再次传输分组。 传输层差错控制由于网络层（IP）是不可靠的，如果应用层需要可靠性，我们需要使传输层变得可靠。可靠性可以通过在传输层加入差错控制服务来实现。 传输层的差错控制负责以下几个方面： 发现并丢弃被破坏的分组。 记录丢失和丢弃的分组并重传它们。 识别重复分组并丢弃它们。 缓冲失序分组直到丢失的分组到达。 差错控制不像流量控制，它仅涉及发送方和接收方传输层。我们假设在应用层和传输层之间交换的报文块是不会产生差错的。 序号差错控制需要发送方传输层知道哪个分组要被重传并且接收方传输层需要知道哪个分组是重复的、哪个分组是失序的。如果分组是编号的，这个就可以实现。我们可以在传输层分组中加入一个字段来保存分组的序号（sequence number）。分组一般按序编号。然而，由于我们需要在头部包含每个分组的序号，因此需要设置一个界限。如果分组的头部允许序号最多为m 比特位，那么序号范围就是0 到2m−1。例如，如果m 是4，序号范围是0 到15 的闭区间。然而，我们可以回绕。序号是模2^m 的。对于差错控制，序号是模2m 的，这里m 是序号字段的大小，单位是比特。 确认接收方可以为每一组正确到达的分组发送一个确认（ACK）。接收方可以简单地丢弃被破坏的分组。发送方如果使用计时器，它就可以发现丢失分组。当一个分组被发送，发送方就开启一个计时器。如果ACK 在计时器超时之前没有到达，那么发送方重发这个分组。重复的分组可以被接收方默默丢弃。失序的分组既可以被丢弃（被发送方当做丢失报文对待），也可以存储直到丢失的那个分组到来。 流量和差错控制的组合流量控制要求使用两个缓冲区，一个在发送端另一个在接收端。差错控制要求两端均使用序号和确认号。流量和差错控制的组合：使用两个带序号的缓冲区：一个位于发送端，一个位于接收端，那么这两个需要可以结合起来。在发送端，当分组准备发送时，我们使用下一个缓冲区空闲位置号码x 作为分组的序号。当分组被发送，一个分组的备份存储在内存位置x，等待来自另一端的确认。当与被发送分组相关的确认到达时，分组被清除，内存位置空闲出来。在接收端，当带有序号y 的分组到达时，它被存储在内存位置y 上，直到应用层准备好接收它。这时发送一个确认表明分组y 的到达。 滑动窗口由于序号进行模2m 操作，因此一个环可以代表从0 到2m−1 的序号。缓冲区由一组片段代表，称为滑动窗口（sliding window），它随时占据环的一部分。在发送端，当一个报文被发送，相应的片段就被标记。当有所片段都被标记时，意味着缓冲区满且不能从应用层进一步接收报文。当确认到达时，相应片段被取消标记。如果从窗口开始处有一些连续的片段没有被标记，那么窗口滑过这些相应序号的范围，允许更多的片段进入窗口尾部。下图 给出发送方的滑动窗口。 序号以16 为模（m = 4）且窗口大小为7。请注意滑动窗口仅仅是一个抽象：实际情况是使用计算机变量来保存下一个和最后一个待发送的分组。大多数协议使用线性形式来表示滑动窗口。虽然想法是相同的，但是它通常占用更少的页面空间。下图给出这种表示方法。这两种表示方法告诉我们相同的事情。如果拿起下图每一幅图的两个端点，并且弯曲它们，我们就可以得到与圆形滑动窗口相同的图。 拥塞控制拥塞（congestion）:因特网之类的分组交换网络中存在一个重要问题，这就是拥塞。如果网络中的负载（load，即发送到网络的分组数）大于网络的容量（网络可以处理的分组数），那么网络就可能发生拥塞。拥塞控制（congestion control）指的是一种机制和技术，它控制拥塞并将负载保持在容量以内。 无连接和面向连接服务传输层协议就像网络层协议一样，可以提供两种类型的服务： 无连接服务 面向连接服务 然而，这些传输层服务的本质与网络层不同。 在网络层，无连接服务可能意味着属于同一个报文的不同数据报有不同路径。 在网络层，面向连接服务意味着两个终端主机以及这之间的所有路由器都进行协调。 在传输层，我们不关心分组的物理路径（我们假设两个传输层之间有一条逻辑连接）。 传输层的无连接服务意味着分组之间的独立；面向连接服务意味着依赖。 无连接服务在无连接服务中，源进程（应用程序）需要将报文分成传输层可接受大小的数据块，并把它们一个一个地传递到传输层。传输层将每一个数据块看做彼此没有关系的单元。当一个块从应用层到达时，传输层将其封装在分组中并发送。 为了展示分组的独立，我们假设客户进程有三个报文块要发送给服务器进程。这些块被按序交给无连接传输协议。然而，由于传输层的这些分组之间没有联系，分组可能失序到达目的地并且被失序传递给服务器进程在客户端，三个报文块按序传递给客户传输层（0、1 和2）。由于第二个分组在传输中的额外延迟，服务器报文的传递失序（0、2 和1）。如果这三个数据块属于同一个报文，那么服务器进程可能会收到一个奇怪的报文。如果一个分组丢了情况就更糟糕了。由于分组没有序号，接收方传输层不知道一个报文已经丢失。它仅仅将两个数据块传送到服务器进程。以上两个问题是由于双方传输层没有互相协调所致。接收方传输层不知道第一个分组将要到来，也不知道所有的分组已经到来。我们可以说，流量控制、差错控制以及拥塞控制都不能在无连接服务中有效实现。 无连接的服务是不可靠的服务，无法许诺不会出现的交付和重复的差错，但这种协议代价很小，更适应于某些服务，比如内部的数据采集、向外的数据分发、请求一响应，以及实时应用等。因此在运输层既有面向连接的位置，也有无连接的用武之地。每一个分组独立地建立和释放逻辑连接，也适合传送大量的数据。无连接的服务的通信线路不都是预设的。无连接的服务需要将目标地址信息加在每个发送的分组上，便于每个分组路由到达目的地。UDP在电路交换或租用专线网络上也能运行。 面向连接服务面向连接的服务中，首先需要建立客户和服务器之间的逻辑连接。只有连接建立之后才能进行数据交换。在数据交换之后，连接需要拆除 连接建立 数据传输 拆除阶段。 在面向连接协议中，我们可以实现流量控制、差错控制以及拥塞控制。面向连接的方式功能强大，允许流量控制、差错控制以及顺序交付等。 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"},{"title":"计算机网络教程-传输层协议-UDP","text":"传输层协议UDP ：不可靠的无连接传输层协议，由于在应用中简单高效而被使用，在那些应用中差错控制由应用层进程提供。TCP ：可靠的面向连接协议，可用于可靠性重要的任何应用。 TCP/IP协议簇协议示意图UDP 和TCP 使用的熟知端口 1234567891011121314151617端口 协议 UDP TCP 说明7 Echo √ 将接收到的数据报回送到发送方9 Discard √ 丢弃接收到的任何数据报11 Users √ √ 活跃的用户13 Daytime √ √ 返回日期和时间17 Quote √ √ 返回每日引用19 Chargen √ √ 返回一字符串20,21 FTP √ 文件传输协议23 TELNET √ 终端网络25 SMTP √ 简单邮件传输协议53 DNS √ √ 域名服务67 DHCP √ √ 动态主机设置协议69 TFTP √ 简单文件传输协议80 HTTP √ 超文本传输协议111 RPC √ √ 远程过程调用123 NTP √ √ 网络时间协议161,162 SNMP √ 简单网络管理协议 UDP(用户数据报协议)用户数据报协议（User Datagram Protocol，UDP）: 无连接不可靠传输层协议。 不提供主机到主机通信，它除了提供进程到进程之间的通信之外，就没有给IP 服务增加任何东西。 此外，它进行非常有限的差错检验。 如果UDP 功能是如此之差，那么为什么进程还要使用它？它有缺点也有优点。UDP 是一个非常简单的协议，开销最小。如果一个进程想发送很短的报文，而且不在意可靠性，就可以使用UDP。使用UDP 发送一个很短的报文，在发送方和接收方之间的交互要比使用TCP 时少得多。 用户数据报UDP 分组称为用户数据报（user datagram），有8 字节的固定头部，这个头部由4 个字段组成，每个字段2 字节（16 位）。8 字节的固定头部的四个字段：每个字段两个字节。头两个字段定义了源和目的端口号。第三个字段定义了用户数据报的总长，即头部加数据的长度。16 位可以定义的总长度范围是0 到65 535。然而，总长度需要更小一些，这是因为UDP数据报存储在总长度为65 535 的IP 数据报中。最后一个字段可以携带可选校验和。 UDP 服务进程到进程的通信UDP 使用套接字地址提供进程到进程通信，这是IP 地址和端口号的组合。 无连接服务 UDP 提供无连接服务。这就表示UDP 发送出去的每一个用户数据报都是一个独立的数据报。不同的用户数据报之间没有关系，即使它们都是来自相同的源进程并发送到相同的目的程序。 用户数据报不进行编号。此外，也没有像TCP 协议那样的连接建立和连接终止，这就表示每一个用户数据报可以沿着不同的路径传递。 无连接的一个结果就是使用UDP 的进程不能够向UDP 发送数据流，并期望它将这个数据流分割成许多不同的相关联的用户数据报。相反，每一个请求必须足够小，使其能够装入用户数据报中，只有那些发送短报文的进程才应当使用UDP。短报文小于65507字节（65535减去UDP头部的8字节再减去IP头部的20 字节）。 无流量控制UDP 是一个非常简单的协议。它没有流量控制（flow control），因而也没有窗口机制。如果到来的报文太多时，接收方可能会溢出。缺乏流量控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 差错控制（仅有校验和）除校验和外，UDP 也没有差错控制（error control）机制，这就表示发送方不知道报文是丢失还是重传。当接收方使用校验和检测出差错时，它就悄悄地将此用户数据报丢弃。缺乏差错控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 校验和UDP 校验和包含三部分：伪头部、UDP 头部和从应用层来的数据。伪头部（psedoheader）是IP 分组的头部的一部分（第4 章讨论），其中有些字段要填入0，用户数据报分装在IP分组中 如果校验和不包括伪头部，用户数据报也可能是安全完整地到达。但是，如果IP 头部受到损坏，那么它可能被提交到错误的主机。 协议字段可确保这个分组是属于UDP，而不是属于其他传输层协议。 如果一个进程既可用UDP 又可用TCP，则端口号可以是相同的。 UDP 的协议字段值是17。如果在传输过程中这个值改变了，在接收端计算校验和时就可检测出来，UDP 就可丢弃这个分组。这样就不会传递给错误的协议。 可选校验和UDP 分组的发送方可以选择不计算校验和。这种情况下，在发送前，校验和字段就全填入0。在发送方决定计算校验和的情况下，如果碰巧结果全是0，那么在发送前校验和全改为1。换言之，发送方填充两次校验和。注意，这不会产生混淆，因为校验和的值在正常情况下不会全为1。 无拥塞控制由于UDP 是无连接协议，它不提供拥塞控制。UDP 假设被发送的分组很小且零星，不会在网络中造成拥塞。今天当UDP 被用做音频和视频的交互实时传输时，这个假设可能对也可能不对。 封装和解封装要将报文从一个进程发送到另一个进程时，UDP 协议就要对报文进行封装和解封装。 排队我们已经讨论过端口，但是没有讨论端口的实际实现。在UDP 中，队列是与端口联系在一起的。在客户端，当进程启动时，它从操作系统请求一个端口号。有些实现是创建一个入队列和一个出队列与每一个进程相关联。而有些实现只创建与每一个进程相关的入队列。 多路复用与多路分解在运行TCP/IP 协议簇的主机上只有一个UDP，但可能有多个想使用UDP 服务的进程。处理这种情况，UDP 采用多路复用和多路分解。 UDP 和通用简单协议比较我们可以将UDP 与之前讨论的无连接简单协议进行比较。唯一的区别就是UDP 提供可选校验和来在接收端发现被破坏分组。如果校验和被加入分组，接收UDP 可以检测分组，如果分组被破坏可以丢弃它。然而，没有反馈被发向发送方。UDP 是我们之前讨论的无连接简单协议的一个例子，区别在于它为差错检测加入了可选校验和。 UDP应用 一位应用设计师有时需要折中来得到最佳情况。例如，在日常生活中，我们都知道一日递送包裹比三日递送要贵。尽管时间和代价在递送包裹中都是想要获取的特性，但是它们是彼此矛盾的。我们需要选择最佳值。 尽管UDP 不满足我们之前讨论的可靠传输层协议标准，但是，UDP 更适合某些应用,因为其他某些服务可能有副作用，这些副作用或许是不可接受的或许是不称心的 UDP特性 无连接服务：UDP 是无连接协议。同一个应用程序发送的UDP 分组之间是独立的。 例如，如果一个客户应用需要向服务器发送一个短的请求并接收一个短的响应，那么这就是优势。如果请求和响应各自可以填充进一个数据报，那么无连接服务可能更可取。在这种情况下，建立和关闭连接的开销可能很可观。在面向连接服务中，要达到以上目标，至少需要在客户和服务器之间交换9 个分组；在无连接服务中只需要交换2 个分组。无连接服务提供了更小的延迟；面向连接服务造成了更多的延迟。如果延迟是应用的重要问题，那么无连接服务更可取。 缺乏差错控制：它提供的是不可靠服务。 缺乏拥塞控制：UDP 不提供拥塞控制。然而，在倾向于出错的网络中UDP 没有创建额外的通信量。TCP 可能多次重发一个分组，因此这个行为促使拥塞发生或者使得拥塞状况加重。因此，在某些情况下，当拥塞是一个大问题时，UDP 中缺乏差错控制可以看做是一个优势 应用 DNS，它使用UDP 服务，因为客户需要向服务器发送一个短的请求，并从服务器接收快速响应。请求和响应可以填充进一个用户数据报。由于在每个方向上只交换一个报文，因此无连接特性不是问题；客户或服务器不担心报文会失序传递。 UDP 可用于某些路由选择更新协议，如路由选择信息协议（RIP） UDP 可用于管理进程，如SNMP UDP 适用于具有内部流量控制和差错控制机制的进程。例如，简单文件传输协议（TFTP）的进程就包含流量控制和差错控制。它可很容易地使用UDP。 UDP 适合于这样的进程：它需要简单的请求-响应通信，而较少考虑流量控制和差错控制。对于需要传送成块数据的进程（如FTP）则通常不使用UDP 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-UDP/"},{"title":"计算机网络教程-传输层协议-TCP(1)","text":"TCP(传输控制协议)传输控制协议（Transmission Control Protocol，TCP）是一个面向连接可靠的协议。 TCP 显式定义了连接建立、数据传输以及连接拆除阶段来提供面向连接服务。 TCP 使用GBN 和SR 协议的组合来提供可靠性。 为了实现这个目的，TCP 使用校验和（为差错发现）、丢失或被破坏分组重传、累积和选择确认以及计时器。 TCP 服务进程到进程的通信像UDP 一样，TCP 通过使用端口号来提供进程到进程通信。 流传递服务与UDP 不同，TCP 是一个面向流的协议。在UDP 中，进程发送一些具有预先规定边界的报文给UDP 进行传递。UDP 将它自己的头部添加到这些报文中并传递到IP 层进行传输。来自进程的每一个报文称为一个用户数据报，最后变成一个IP 数据报。IP 和UDP 都不认识这些数据之间的关系。 而TCP 允许发送进程以字节流形式传递数据，并且接收进程也以字节流形式接收数据。TCP 建立一种环境，在这种环境中，两个进程好像由一个假想的“管道”连接，这个管道通过因特网传送这些进程的数据。 这种假想的环境如图所示。发送进程产生（写入）字节流，而接收进程消费（读出）这些字节流。 发送和接收缓冲区因为发送和接收进程可能以不同的速度写入和读出数据，所以TCP 需要用于存储的缓冲区。 每一个方向都存在一个缓冲区：发送缓冲区和接收缓冲区。 这些缓冲区也用于TCP 流量和差错控制机制。 实现缓冲区的一种方法是使用以一字节为存储单元的循环数组。 实现缓冲区的方法如图所示。为了简化，我们只画出了两个缓冲区，每个缓冲区20个字节。通常情况下，缓冲区是数百甚至数千个字节，这取决于实现方法。这里给出的缓冲区是大小相同的，实际上并非总是如此。上图表示了在一个方向上数据的移动。在发送端，缓冲区有三种类型的存储单元。 白色的部分是空存储单元，可以由发送进程（生产者）填充。 灰色的部分用于保存已经发送但还没有得到确认的字节。TCP 在缓冲区中保留这些字节，直到收到确认为止。 灰色缓冲区是将要由TCP 发送的字节。但是，在本章的后面将会看到，TCP 可能只发送灰色部分。这可能是由于接收进程缓慢或者网络中可能发生的拥塞造成的。 灰色存储单元的字节被确认后，这些存储单元可以回收并且对发送进程可用，这就是我们给出一个环形缓冲区的原因。 接收端的缓冲区操作比较简单。环形缓冲区分成两个区域（表示为白色和灰色）。白色区域包含空存储单元，可以由从网络上接收的字节进行填充。灰色区域表示接收到的字节，可以由接收进程读出。当某个字节被接收进程读出以后，这个存储单元可被回收，并加入到空存储单元池中。 段尽管缓冲能够处理生产进程速度和消费进程速度之间的不相称问题，但在发送数据之前，还需要多个步骤。IP 层作为TCP 服务的提供者，需要以分组的方式而不是字节流的方式发送数据。在传输层，TCP 将多个字节组合在一起成为一个分组，这个分组称为段（segment）。TCP 给每个段添加头部（为了达到控制目的），并将该段传递给IP 层。段被封装到IP 数据报中，然后再进行传输。整个操作对接收进程是透明的。这些段可能被无序接收、丢失，或者损坏和重发。所有这些均由TCP 处理，接收进程不会察觉到任何操作。下图表示了在缓冲区中如何从字节生成段。注意，段的大小不必相同。为了简单起见，我们在图中只表示了一个包含3 个字节的段和另一个包含5 个字节的段。实际的段可能包含数百（或者数千）个字节。 全双工通信TCP 提供全双工服务（full-dupler service），即数据可以在同一时间双向流动。每一方向TCP都有发送和接收缓冲区，它们能在双向发送和接收段。 多路复用和多路分解与UDP 类似，TCP 在发送端执行多路复用，在接收端执行多路分解。然而，由于TCP 是一个面向连接协议，因此需要为每对进程建立连接。 面向连接的服务与UDP 不同，TCP 是一种面向连接的协议。位于站点A 的一个进程与站点B 的另外一个进程想要进行数据的发送和接收，步骤如下：1．在两个TCP 之间建立一个连接。2．在两个方向交换数据。3．连接终止。注意，这是一个逻辑连接，而不是一个物理连接。TCP 段封装成IP 数据段，并且可能被无序地发送，或丢失，或被破坏，然后重发。每个段都可以通过不同的路径到达目的端。TCP 建立一种面向字节流的环境，在这种环境中，TCP 能承担按顺序传递这些字节到其他站点的任务。 可靠的服务TCP 是一种可靠的传输协议。它使用确认机制来检查数据是否安全和完整地到达。 TCP与UDP基本区别 基于连接与无连接 TCP要求系统资源较多，UDP较少 UDP程序结构较简单 字节流模式（TCP）与数据报模式(UDP); TCP保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 TCP 的特点序号系统虽然TCP 软件能够记录发送或接收的段，但是在段的头部没有段序号字段。TCP 在段的头部采用称为序号（sequence number）和确认号（acknowledgment number）的两个字段。这两个字段指的是字节序号，而不是段序号。 字节序号TCP 为在一个连接中传输的所有数据字节（八位字节）编号。在每个方向上序号都是独立的。当TCP 接收来自进程的一些数据字节时，TCP 将它们存储在发送缓冲区中并给它们编号。不必从0 开始编码，TCP 在0到232−1 之间生成一个随机数作为第一个字节的序号，例如，如果随机数是1057，并且发送的全部字节个数是6000，那么这些字节序号是1057~7056。下面将会看到字节序号是用于流量和差错控制。 在每个连接中传送的字节都由TCP 编号，序号开始于一个随机产生的数。 序号字节被编号后，TCP 对发送的每一个段分配一个序号。在每一个方向上的序号定义如下：1．第一段的序号是初始序号（initial sequence number，ISN），这是一个随机数。2．其他段的序号是之前段的序号加之前段携带的字节数（实际上的或想象的）。之后，我们将给出一些控制段，它们被认为携带了一个想象字节。 一个段的序号字段的值定义了该段包含的第一个字节的序号。 当一个段携带数据和控制信息（捎带）时，它使用一个序号。如果一个段没有携带用户数据，那么它逻辑上不定义序号。虽然字段存在，但是值是无效的。然而，当有些段仅携带控制信息时也需要有一个序号用于接收方的确认。这些段用作连接建立、连接终止或连接废弃。这些段中的每一个好像携带一个字节那样使用一个序号，但都没有实际的数据。 确认号TCP 中的通信是全双工的；当建立一个连接时，双方同时都能发送和接收数据。 每一方为字节编号，每一方经常使用不同的起始字节号。 每一方向的序号表明了该段所携带的第一个字节的序号。 每一方也使用确认号来确认它已收到的字节。但是，确认号定义了该方预期接收的下一个字节的序号(也就是序号+1)。另外，确认号是累积的，这意味着接收方记下它已安全而且完整地接收到最后一个字节的序号，然后将它加1，并将这个结果作为确认号进行通告。在这里，术语“累积”指的是，如果一方使用5643 作为确认号，则表示它已经接收了所有从开始到序号为5 642 的字节。但要注意，这并不是指接收方已经接收了5 642 个字节，因为第一个字节的编号通常并不是从0 开始的。 参考资料计算机网络教程-自顶向下方法TCP与UDP的区别","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP/"},{"title":"计算机网络教程-传输层协议-TCP(2)","text":"TCP 连接在 TCP 中，面向连接的传输需要三个过程：连接建立、数据传输和连接终止。在TCP 中的分组称为段（segment） TCP段格式段包含20~60字节的头部，接着是来自应用程序的数据。如果没有选项，那么头部是20 字节；如果有选项，最多是60 字节。 源端口地址。这是一个16 位的字段，它定义了在主机中发送该段的应用程序的端口号。这与UDP 头部的源端口地址的作用一样。 目的端口地址。这是一个16 位的字段，它定义了在主机中接收该段的应用程序的端口号。这与UDP 头部的目的端口地址的作用一样。 序号。这个32 位的字段定义了一个数，它分配给段中数据的第一个字节。 TCP 是一种字节流传输协议。为了确保连通性，对要发送的每一个字节都进行编号。序号告诉目的端，在这个序列中哪一个字节是该段的第一个字节。 在连接建立时，每一方都使用随机数生成器产生一个初始序号（initial sequence number，ISN），通常每一个方向的ISN 都不同。 确认号。这个32 位的字段定义了段的接收方期望从对方接收的字节号。如果段的接收方成功地接收了对方发来的字节号x，它就将确认号定义为x + 1. 确认和数据可捎带一起发送。 头部长度。这个4 位的字段指明了TCP 头部中共有多少个4字节长的字。 头部的长度可以在20 字节到60 字节之间。因此，这个字段的值在5（5 × 4 = 20）到15（15 × 4 = 60）之间。 窗口大小。这个字段定义对方必须维持的窗口的大小（以字节为单位）。 注意，这个字段的长度是16 位，这意味着窗口的最大长度是65 535 字节。这个值通常称为接收窗口（rwnd）。 它由接收方确定。此时，发送方必须服从接收端的支配。 紧急指示符。这个16 位的字段只有当紧急标志置位时才有效，这个段包含了紧急数据。 它定义了一个数，将此数加到序号上就得出此段数据部分中最后一个紧急字节。 选项。在TCP 头部中可以有多达40 个字节的可选信息。 控制字段这个字段定义了6 种不同的控制位或标记，如图所示。 在同一时间可以设置一位或多位。 这些位用在TCP 的流量控制、连接建立和终止、连接失败和数据传送方式等方面。 校验和。这个16 位的字段包含了校验和。TCP 校验和的计算过程与前面描述的UDP 所采用的计算过程相同。但是，在UDP 数据报中校验和是可选的。 然而，对TCP 来说，将校验和包含进去是强制的。 起相同作用的伪头部被加到段上。对TCP 伪头部，协议字段的值是6。如图所示。 在 TCP 中使用校验和是强制的。 连接建立（三次握手）TCP 以全双工方式传输数据。当两个机器中的两个TCP 建立连接后，它们就能够同时向对方发送段。这就表示，在传输数据之前，每一方都必须对通信进行初始化，并得到对方的认可。三次握手（three-way handshaking）：客户的应用程序想要与另一个称为服务器的应用程序使用TCP 作为传输层协议建立连接。 该过程从服务器开始。服务器程序告诉它的TCP，它已准备好接收一个连接。这就称为被动打开（passive open）。虽然TCP 已经准备好接收从世界上任何一个机器发来的连接，但它自己并不能完成这个连接。客户程序发出请求进行主动打开（active open）。想要与服务器进行连接的客户告诉它的TCP，它需要连接到特定的服务器。 少数几个必须要知道的字段，如果序号、确认号、控制标记（仅仅是其中被置位的）和窗口大小等有值。三个步骤如下: 客户发送的第一个段，即SYN 段。这个段仅有SYN 标志被置位，它用于序号同步。它占用一个序号。当数据传输开始时，在我们的例子中，客户随机选择一个数字作为初始序号（ISN）。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。段也能包含一些稍后讨论的选项。 注意，SYN 段是一个控制段并且不携带数据。然而，它消耗一个序号，因为它需要被确认。我们可以说SYN 段携带了一个假想字节。 SYN 段不携带数据，但它占用一个序号。看下面的图就明白了。 服务器发送第二个段，即SYN +ACK 段。这个段有两个目的。 首先，它是另一方向通信的SYN 段。服务器使用这个段来初始化序号，这个序号用来给从服务器发向客户的字节编号。 其次，服务器也通过给ACK 置位并展示下一个序号来确认接收到来自客户的SYN 段，这里的下一个序号是服务器预期从客户接收的序号。 我们将在介绍流量控制那一节看到，因为它包含确认，它也需要定义接收窗口，即rwnd（客户使用）。因为这个段起到SYN段的作用，它需要被确认。因此，它占用一个序号。 SYN + ACK 段不携带数据，但它占用一个序号。 客户发送第三个段，即ACK 段。它使用ACK 标志和确认序号字段来确认收到了第二个段。 注意，如果不携带数据，ACK 段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据。在这种情况下，段消耗的序号与数据字节数相同。 ACK 段，如果不携带数据，则它不占用序号。 数据传输连接建立后，可进行双向数据传输，客户端与服务器双方都可发送数据和确认。数据捎带确认：在同一段内携带确认时，在同一方向上也可以传递数据。 图示在这个例子中，在连接建立后，客户端用两个段发送2000 个字节的数据。然后，服务器用一个段发送2000 个字节的数据。客户端发送另一个段。 前面三个段携带数据与确认，但是最后一个段仅携带确认，这是因为已没有数据发送了。 注意序号与确认号数值，客户端发送的数据段有PSH（推送）标志，所以服务器TCP 知道在接收到数据时立刻传递给服务器进程。 另一方面，来自服务器的段没有设置推送标志。大多数TCP 的实现都有可选标志，可设置或不设置。 推送数据发送方的TCP 使用缓冲区存储来自发送方应用程序的数据流。发送方的TCP 可以选择段的大小。接收方的TCP 在数据到达时也将数据进行缓存，并当应用程序准备就绪时或当接收端TCP 认为方便时将这些数据传递给应用程序。这种灵活性增加了TCP 的效率。 但是，在有些情况下，应用程序并不需要这种灵活性。例如，应用程序与另一方应用程序进行交互式通信。 一方的应用程序打算将其信息发给对方应用程序，并希望接收到立即响应。数据的延迟传输和延迟传递对这个应用程序来说是不可接受的。 TCP 可以处理这种情况。 在发送端的应用程序可请求推送操作。这就表示发送端的TCP 不必等待窗口被填满。 它创建一个段就立即将其发送。发送端的TCP 还必须设置推送位（PSH）以告诉接收端的TCP，这个段所包含的数据必须尽快地传递给接收应用程序，而不要等待更多数据的到来。 这意味着将面向字节的TCP 改为面向块的TCP，但是TCP 可以选择使用或不使用这个特性。 连接终止(四次挥手) 半关闭半关闭（half-close）：指在 TCP 中，一端可以停止发送数据后，还可以接续接收数据。（关闭发送但是不关闭接收）虽然任一端都可发出半关闭，但通常都是由客户端发起的。当服务器在开始处理之前需要接收到所有数据，这时就会出现半关闭。例如，排序是一个很好的例子。客户端发送数据给服务器进行排序，在开始排序之前，服务器需要接收到全部数据。 这就是说，客户端发送全部数据之后，它在客户到服务器方向可关闭连接。（客户端关闭发送） 但为了返回存储数据，服务器到客户方向必须保持打开。（客户端不关闭接收） 服务器在接收数据后还需要时间进行排序；它的向外方向必须保持打开。 从客户到服务器的数据传输停止。客户端通过发送FIN 段实现半关闭连接。服务器通过发送ACK 段确认半关闭。然而，服务器还可以发送数据。当服务器已经发送完被处理的数据时，它发送一个FIN 段。该FIN 段由客户端的ACK 来确认。连接半关闭后，数据可以从服务器传送给客户端，而确认可以从客户端传送给服务器。客户不能再向服务器发送任何数据。 连接重置在一端的TCP 可能拒绝连接请求，可能终止已存在的连接，也可能结束空闲连接。所有这些都通过RST（重置）标志完成。 参考资料详细分析TCP数据的传输过程【网络通信】TCP的通信过程图解TCP传输过程（三次握手、数据传输、四次挥手）TCP 的那些事儿（上）TCP 的那些事儿（下）一个TCP连接上能发起多少个HTTP请求吗？计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP-2/"},{"title":"计算机网络教程-HTTP协议","text":"HTTP（超文本传输协议）超文本传输协议（HyperText Transfer Protocol，HTTP）是一种用来定义客户服务器程序如何编写和如何从万维网获取网页的协议。 一个HTTP 客户发送一个请求；HTTP 服务器返回响应。 服务器使用80 端口号；客户使用一个临时端口号。 HTTP 使用TCP 服务。这意味着，在客户和服务器进行任何事务之前，它们之间必须建立连接。 在事务之后，连接应当终止。然而，客户和服务器不需要担心交换报文中的差错以及报文的丢失，因为TCP 是可靠的而且将处理这个问题。 非持续与持续连接嵌入到网页中的超文本概念可能需要多个请求和应答。 如果网页，这个被获取的对象，位于不同的服务器，那么我们没有其他选择只能每获取一个对象就要创建一个新的TCP 连接。 然而，如果某些对象是位于同一台服务器的，我们可以有两种选择： 一是每次使用一个新的TCP 连接获取一个对象。非持续连接（nonpersistent connection） 二是创建一个TCP 连接获取全部对象。持续连接（persistent connection） 在HTTP1.1 版之前指定的是非持续连接，持续连接在1.1 版中是默认的，但是可以被用户改变。 非持续连接在非持续连接中，一个TCP 连接被每一组请求/应答所创建。下面是这个策略的步骤：1．客户开启一个TCP 连接并发送请求。2．服务器发送响应并关闭连接。3．客户读取数据直到它遇到了文件结束标记，然后关闭连接。 在这种策略中，如果文件包含了N 个位于不同文件的图片连接（全都位于同一台服务器），那么必须开启和关闭连接N+1 (?)次。非持续策略给服务器带来了高额开销，因为每次连接被开启时服器都需要N+1个不同的缓冲区。 下图展示了一个非持续连接的例子。客户需要访问一个包含图片链接的文件。文本文件和图片位于同一台服务器上。这里我们需要两个连接。对于每一个连接，TCP 需要至少三个握手报文来建立连接，但是请求可以和第三个报文一起发送。在连接建立之后，请求对象可以被发送。在接收到一个对象之后，需要另外三次握手报文来结束连接 持续连接 在持续连接中服务器在发送一个响应后，为响应更多的请求而将连接置为打开状态。 服务器可以在客户的请求下或者在超时情况下将连接关闭。 文档发送方（通常是服务器）通常在每次响应中发送数据长度。然而，偶尔情况下发送方不知道数据的长度。这是创建动态文档或活动文档时的情形。在这种情形下，服务器通知客户长度未知并在发送数据后关闭连接，因此客户知道数据已接收完毕。 通过使用持续连接，可以节省时间和资源。每个站点只需要为连接设定一组缓冲区和变量。同时节省了连接建立和终止的往返时间。 报文格式HTTP 协议定义了请求报文和响应报文的格式。每一种报文由四个部分组成。 请求报文中的第一部分称为请求行； 响应报文的第一部分称为状态行。 其他三部分在请求报文和响应报文中有相同的名称。然而，这三部分只是名称相似，它们可能含有不同的内容。 请求报文 请求报文的第一行称为请求行。如图所示，这一行有三部分由空格分隔开并且被两个字符（回车和换行）终止。这些字段称为方法、URL 和版本。 第一个字段：方法字段定义了请求类型。如下所示，在HTTP1.1 版中定义了若干种方法。 第二个字段：URL，在本章的前面部分已经讨论过了。它定义了相关网页的地址和名称。 第三个字段：版本，给出了协议的版本，HTTP 最常用的版本是1.1。 12345678910111213141516171819HTTP请求报文中的方法--------------------------------------------------------------------------------------------GET 向服务器请求文档。绝大多数情况下，客户使用GET 方法发送一个请求。在这种情况下，报文的主体是空的。-------------------------------------------------------------------------------------------- HEAD 请求关于文档的信息，而不是文档本身。当客户仅需要从服务器获得关于网页的信息，如上次修改的时间，这时使用HEAD 方法。它也可以用来检测URL 的有效性。这种情况下的响应报文只有头部；主体是空的。 --------------------------------------------------------------------------------------------PUT 从客户端向服务器发送文档。PUT 方法与GET 方法是相反的；它允许客户将一个新的页面发送到服务器上（如果允许的话）。 --------------------------------------------------------------------------------------------POST 从客户端向服务器发送一些信息。POST 方法与PUT 方法类似，但是它用来发送一些信息到服务器上，这些信息被加入网页或用来修改网页--------------------------------------------------------------------------------------------TRACE 回送输入的请求。用来调试；客户要求服务器回送请求来检查服务器是否正在获得请求。DELETE 删除网页。如果客户获得许可，DELETE 方法允许客户删除一个服务器上的网页。CONNECT 预留。原先作为预留方法；后文会讨论到，这个方法可能被代理服务器使用。 OPTIONS 询问有关可用的选项。允许客户询问网页属性。 在请求行之后我们可以有一个或多个请求头部（request header）行。 每一个头部行都从客户端向服务器发送额外的信息。 例如，客户可以请求以某种特定格式发送文档。每个头部行有头部名字、一个冒号、一个空格和一个头部值（见图3）。下面列出了一些请求中常用的头部名字。 值字段定义了与每个头部名字相关的值。 值列表可以在相应的RFC 中查找到。 主体可以出现在请求报文中。通常，当使用POST 或PUT 方法时，它包含要发送的评论或要发布到网站上的文档。 12345678910111213请求头部名称-----------------------------------------------------------User-agent 标识客户端程序 Accept 给出客户端能够接受的媒体格式 Accept-charset 给出客户端可以处理的字符集 Accept-encoding 给出客户端可以处理的编码方案 Accept-language 给出客户端可以接受的语言Authorization 给出客户端有哪些许可 Host 给出主机及客户端的端口号Date 给出当前日期Upgrade 确定首选的通信协议Cookie 返回cookie 给服务器（稍后解释）If-Modified-Since 如果文档在指定的日期之后被更新，则发送文档 响应报文图3给出了响应报文的格式。响应报文包含状态行、头部行并且有时包含主体。 响应报文的第一行称为状态行。这一行有三个字段，它们由空格分隔开并且被两个字符（回车和换行）终止。 第一个字段：版本字段，定义了HTTP 协议的版本，通常为1.1。 第二个字段：状态码字段,定义了请求的状态。 它包含三个数字。在100 范围内的代码只代表一个报告 在200 范围内的代码表示这是一个成功的请求。 在300范围内的代码表示把客户端重定向到另一个URL 在400 范围内的代码表示在客户端发生错误。 最后，在500 范围内的代码表示错误发生在服务器端。 第二个字段：状态短语字段，以文本格式解释了状态码。 在状态行之后，我们可以有一个或多个响应头部行。每一个头部行都从服务器向客户端发送额外的信息。例如，发送方可以发送关于文档的额外信息。每个头部行都有一个头部名称、一个冒号、一个空格和一个头部值。下面列出了一些常用的头部名称。 12345678910111213响应头部名称------------------------------------------------------Date 给出当前日期 Upgrade 确定首选的通信协议 Server 给出服务器信息 Set-Cookie 服务器要求客户存储Content-Encoding 指定编码方案 Content-Language 指定语言Content-Length 给出文档长度Content-Type 指定媒体类型Location 指明新建或移动后文档的位置cookie Accept-Ranges 服务器将会接收的被请求的字节范围Last-modified 给出上次改变的日期和时间 主体包含了从服务器发送给客户的文档。除非响应是一个错误报文，否则主体是存在的。 示例客户要向服务器发送一个网页在这个例子中，客户要向服务器发送一个网页。我们使用PUT 方法。 请求行给出方法（PUT）、URL 以及HTTP 版本（1.1）。其头部有四行。请求主体包含要发送的网页。 响应报文包含状态行和四个头部行。被创建的文档是一个CGI 文档，它包含在响应报文的主体中 客户要向服务器获取一个文档使用GET 方法来获取一个路径为/usr/bin/image1 的图片。 请求行给出了使用的方法（GET）、URL 以及HTTP 版本（1.1）。 头部有两行，它们表示客户可以接收GIF 或JPEG 格式的图片。请求是没有主体的。 响应报文包含了状态行以及四个头部行。头部行定义了日期、服务器、内容编码（MIME 版本，在电子邮件部分将会描述）以及文档长度。文档主体在头部之后。 条件请求客户可以在请求中加入条件。在这种情况下，如果条件满足，服务器将会发送被请求的网页或者通知用户。 客户加入的最常见的一种条件是网页被修改的时间和日期。 客户可以在发送请求时附带头部行If-Modified-Since，这样来告知服务器客户只需要在指定日期之后更新的页面。 一个客户在请求中加入了修改日期和时间的条件。 123GET http://www.commonServer.com/information/file1 HTTP/1.1 请求行If-Modified-Since: Thu, Sept 04 00:00:00 GMT 头部行 空行 响应中的状态行表示在指定日期之后文档没有修改。所以响应报文的主体是空的。 12345HTTP/1.1 304 Not Modified 状态行Date: Sat, Sept 06 08 16:22:46 GMT 头部第一行Server: commonServer.com 头部第二行 空行(Empty Body) 空主体 HTTP 安全HTTP 本质上并不提供安全。然而，，HTTP 可以在安全套接层（SSL）上运行。在这种情况下，HTTP 称为HTTPS。HTTPS 提供保密性、客户和服务器鉴别，以及数据完整性。HTTPS 端口号443 状态码（Status-Code）1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 参考资料HTTP状态码-菜鸟教程HTTP 教程-菜鸟教程浅谈HTTP中GET、POST用法以及它们的区别 计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"计算机网络教程-TCP状态转换","text":"TCP状态表 状态 说明 状态 说明 CLOSED 没有连接存在 FIN-WAIT-2 首个FIN 的ACK 已被接收；等待第二个FIN LISTEN 接收到被动打开；等待SYN CLOSE-WAIT 首个FIN 被接收，ACK 被发送；等待应用关闭 SYN-SENT SYN已被发送；等待ACK TIME-WAIT 第二个FIN 被接收，ACK 被发送；等待2MSL 超时 SYN-RCVD SYN + ACK 已被发送；等待ACK LAST-ACK 第二个FIN 被发送；等待ACK ESTABLISHED 连接建立；数据传输正在进行 CLOSING 双端决定同时关闭 FIN-WAIT-1 首个FIN 已被发送；等待ACK 示例客户进程向它的TCP 发出主动打开命令来请求连接到特定套接字地址。 TCP 发送一个SYN 段并转移到SYN-SENT 状态。 在收到SYN + ACK 段后，TCP 发送了一个ACK 段并且进入ESTABLISHED状态。 数据被传输，可能是双向的，并且被确认。 当客户进程没有数据要发送了，它发出称为主动关闭的命令。 TCP 发送FIN 段并进入FIN-WAIT-1状态。 当它接收到ACK 段，它进入FIN-WAIT-2状态。 当客户接收到FIN 段时，它发送一个ACK 段并进入TIME-WAIT状态。 客户保持这种状态2MSL秒（TCP 计时器）。 当相应计时器超时，客户进入CLOSED状态。 服务器进程发出被动打开命令。 服务器TCP 进入LISTEN 状态并且保持这种状态直到它接收到一个SYN 段。 TCP 之后发送一个SYN + ACK 段并且进入SYN-RCVD 状态，等待客户发送ACK段。 在接收到ACK 段后，TCP 进入ESTABLISHED 状态，这就开始了数据传输。 TCP 保持这种状态直到它接收到一个来自客户的FIN 段，这表示没有其他数据要被交换且连接可以被关闭。 一旦服务器接收到FIN 段，那么它就向客户发送带有虚拟EOF 标记的排队中所有的数据，这意味连接必须被关闭。 它发送一个ACK 段且进入CLOSE-WAIT状态，但是推迟确认来自客户的FIN 段，直到它接收到来自进程的被动关闭命令。 在接收到被动关闭命令后，服务器向客户发送FIN 段并进入LAST-ACK状态，等待最终ACK。 当ACK 段从客户发送后被服务器接收，服务器进入CLOSE 状态。","link":"/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"},{"title":"计算机网络教程-套接字","text":"套接字的数据结构C 语言将套接字定义为一个结构（struct）。套接字结构由五个字段组成；每个套接字地址是一个由五部分构成的结构。 族。这个字段定义了协议簇（如何解释地址和端口号）。 通常值是PF_INET（用于当前因特网）、PF_INET6（用于下一代因特网）等等。我们在本节使用PF_INET。 类型。这个字段定义了四个套接字类型： SOCK_STREAM（用于TCP） SOCK_DGRAM（用于UDP）、 SOCK_SEQPACKET（用于SCTP） SOCK_RAW（用于直接使用ISP 服务的应用）。 协议。这个字段定义了族中特定协议。对于TCP/IP 协议簇这个字段设置为0，因为它是族中唯一的协议。 本地套接字地址。这个字段定义了本地套接字地址。 一个套接字地址是一个结构，它由长度字段、族字段（对于TCP/IP 协议簇，它被设置为常量AF_INET）、端口号字段（定义了进程）以及IP 地址字段（定义了正在运行的进程所在的主机）构成。它也包含未使用字段。 远程套接字地址。这个字段定义了远程套接字地址。它的结构与本地套接字地址相同。 头文件123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/innet.h&gt;#include &lt;sys/wait.h&gt; 使用 TCP 通信 TCP 是面向连接的协议。在发送或接收数据之前，需要在客户端和服务器之间建立连接。在连接建立之后，只要它们有数据要发送或接收，两端就可以彼此发送以及接收数据块。 TCP 连接可以是迭代的（一次服务一个客户）也可以是并发的（一次服务多个客户）。 TCP 中使用的套接字TCP 服务器使用两个不同的套接字: 一个用于连接建立。称为监听套接字（listen socket）。 一个用于数据传输。称为套接字（socket）。 设置两种套接字的目的是将建立阶段和数据交换阶段分开。 服务器使用监听套接字来监听试图建立连接的新客户。在连接建立之后，服务器创建一个用于和客户交换数据的套接字并且最终终止连接。客户只使用一个套接字用于连接建立以及数据交换。 通信流程图 服务器进程 TCP 服务器进程调用socket 和bind 函数，但是这两个函数创建监听套接字，它只在连接建立阶段被使用。 之后，服务器进程调用listen函数，允许操作系统开始接收客户、完成连接阶段并把他们放入等待被服务的列表。 这个函数也定义了被连接的客户等待列表的大小，这依赖于服务器进程的复杂性，但是通常值为5。 现在，服务器进程开始循环并且逐一对客户进行服务。 在每次循环中，服务器进程调用accept函数从已连接客户的等待列表中去除一个客户，对其进行服务。 如果列表是空的，那么accept 函数进入阻塞状态直到出现一个客户待服务。 当accept 函数返回，它创建一个新的与监听套接字一样的套接字。 监听套接字现在移入后台，并且新的套接字成为活动套接字。 服务器进程现在使用连接建立期间获得的客户套接字地址，用它来填充新建套接字的远程套接字地址。 此时，客户和服务器可以交换数据。我们没有给出数据传输的特定方式，因为这取决于特定的客户-服务器对。 TCP 使用send以及recv程序在它们之间传输数据字节。这两个函数比UDP 中使用的sendto 和recvfrom 函数更简单，因为它们不提供远程套接字地址；连接已经在客户和服务器之间建立。 然而，由于TCP 用于传输无边界报文，每个应用需要仔细设计数据传输部分。 send 和recv 函数可能被调用多次来处理大量数据传输。可以将上图的流程图当作一个通用流程图；如果是特殊用途，需要定义服务器数据传输（sever data-transfer）盒。 客户进程客户进程进行主动开启（active open）。换言之，它开启连接。它调用socket 函数来创建一个套接字并填充前三个字段。尽管某些实现要求客户进程也调用bind 函数来填充本地套接字，但通常这是由操作系统自动完成的，操作系统为客户选择一个临时端口号最终close 函数被调用以销毁套接字。客户流程图与UDP 版本类似，除了客户数据传输（client data-transfer）盒需要为每个特定情况定义。 套接字接口编程（TCP）编写客户和服务器程序来模拟使用TCP的标准回送应用——客户程序发送一个短的字符串给服务器；服务器将相同的字符串回送到客户。在我们这样做之前，需要为客户和服务器数据传输盒提供流程图 客户和服务器数据传输盒的流程图（发送消息和回送消息）对于发送和回送短的字符这个特定的情况，因为待发送的字符串很短（小于几个单词），我们可以在客户端调用send函数一次完成。然而，TCP 并不保证把整个报文在一个报文段内发送。因此，我们需要在服务器端调用一组recv（在一个循环内）来接收整个报文并将它们收集到缓冲区内，从而能一次性发送回去。当服务器向客户发送回送报文时，它也可能使用多个报文段，这意味着客户的recv 程序需要调用多少次就会被调用多少次。 缓冲区设置另一个有待解决的问题是设置缓冲区，缓冲区用于在每个站点接收数据。 我们需要控制接收的字节数以及下一个数据块存储的位置。 如图所示，程序设置了一些变量进行控制。 在每次迭代中，指针（ptr）移动指向下一个要接收的字节，接收字节的长度（len）呈增长趋势并且待接收的最大字节数（maxLen）呈减少趋势。 回送服务器程序程序遵循迭代TCP通信流程图。第 6 行到第16 行声明并定义了变量。第18 行到第21 行分配内存并且按UDP 情况下所述创建了本地（服务器）套接字地址。第23 行到第27 行创建了监听套接字。第29 行到第33 行将监听套接字绑定到第18 行到第21 行创建的服务器套接字地址上。第35 行到第39 行是TCP 通信中的新内容。调用 listen 函数让操作系统完成连接建立阶段并将客户置入等待列表。第44 行到第48 行调用accept 函数来移除等待列表中的第一个客户并开始为其服务。如果在等待列表中没有客户，那么这个函数处于阻塞状态。第50 行到第56 行对图2-63 中描述的数据传输部分进行编码。最大缓冲区大小与回送字符串长度都和图5中所示相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//回送服务器程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(){ //声明并定义 int ls; //监听套接字描述符（引用） int s; //套接字描述符（引用） char buffer[256]; //数据缓冲区 char *ptr=buffer; //数据缓冲区 int len=0; //等待接收或者发送的字节数 int maxLen=sizeof(buffer); //最大接收字节数 int n; //每次调用receive接收的字节数 int waitSize=16; //等待客户数量 struct sockaddr_in servAddr; //服务器地址 struct sockaddr_in clntAddr; //客户地址 int clntAddrLen; //客户地址长度 //创建本地（服务器）套接字地址 memset(&amp;servAddr,0,sieof(servAddr)); servAddr.sin_family=AF_INET; servAddr.sin_addr.s_addr=htonl(INADDR_ANY); //默认IP地址 servAddr.sin_port=htonl(SERV_PORT); //默认端口 //创建监听套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) //PF_INET族，SOCK_STREAM指套接字类型（tcp） { perror(\"Error:Listen socket failed!\"); exit(1); } //将套接字绑定到本地套接字地址 if(bind(ls,&amp;servAddr,sizeof(servAddr))&lt;0) { perror(\"Error:binding failed!\"); exit(1); } //创建连接请求 if(listen(ls,waitSize)&lt;0) { perror(\"Error:listening failed!\"); exit(1); } //处理连接 for(;;) //永远运行 { //接收来自客户的连接 if(s=accept(ls,&amp;clntAddr,&amp;clntAddrLen)&lt;0) { perror(\"Error:accepting failed!\"); exit(1); } //数据传输部分 while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } send(s,buffer,len,0); //发回（回送）所有接收的字节 //关闭套接字 close(s); }//循环结束}//回送服务器程序结束 tips: 在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到htonl(), ntohl(), ntohs()，htons()这4个函数。 htonl()–”Host to Network Long” ntohl()–”Network to Host Long” htons()–”Host to Network Short” ntohs()–”Network to Host Short” 回送客户程序TCP 的客户程序与UDP 的客户程序非常相似，只有些许不同。 因为TCP 是面向连接的协议第36 行到第40 行调用connect 函数连接服务器。 第42 行到第48 行使用图3中的思想完成数据传输。 按图5所示方式完成接收数据的长度调整和指针移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//回送客户程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(int argc,char *argv[]) //三个参数之后待检验{ //声明并定义 int s; //套接字描述符 int n; //每次调用recv接收的字节数 char servName; //服务器名 int servPort; //服务器名 char *string; //被回送的字符串 int len; //被回送的字符串的长度 char buffer[256+1]; //缓冲区 char *ptr=buffer; //在缓冲区上移动指针 struct sockaddr_in serverAddr; //服务器套接字地址 //检测并设置参数 if(argc!=3) { printf(\"Error:three arguments are needed!\"); exit(1); } servName=argv[1]; servPort=atoi(argv[2]); string=arg[3]; //创建远程（服务器）套接字地址 memset(&amp;serverAddr,0,sieof(serverAddr)); servAddr.sin_family=AF_INET; inet_pton(AF_INET,servName,&amp;serverAddr.sin_addr); //服务器IP地址 serverAddr.sin_port=htons(SERV_PORT); //默认端口 //创建套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) { perror(\"Error: socket creation failed!\"); exit(1); } //连接到服务器 if(connect(sd,(struct sockaddr*)&amp;serverAddr,sizeof(serverAddr))&lt;0) { perror(\"Error:connection failed!\"); exit(1); } //数据传输部分 send(s,string,strlen(string),0); while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } //打印并验证回送的字符串 buffer[len]='\\0'; printf(\"Echoed string received:\"); fputs(buffer,stdout); //关闭套接字 close(s); //停止程序 exit(0);}//回送客户程序结束 Linux下的socket()函数inux中的一切都是文件，每个文件都有一个整数类型的文件描述符；socket也是一个文件，也有文件描述符。使用socket()函数创建套接字以后，返回值就是一个 int类型的文件描述符。在 Linux 下使用 &lt;sys/socket.h&gt; 头文件中 socket()函数来创建套接字，原型为： 1int socket(int af, int type, int protocol); 1) af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。 AF 是“Address Family”的简写，INET是“Inetnet”的简写。 AF_INET 表示 IPv4 地址，例如 127.0.0.1； AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。 也可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。 需要记住127.0.0.1，它是一个特殊IP地址，表示本机地址 2) type 为数据传输方式/套接字类型， 常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） SOCK_DGRAM（数据报套接字/无连接的套接字） 3) protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？ 正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。 本教程使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用 socket() 函数： 1int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //IPPROTO_TCP表示TCP协议 这种套接字称为 TCP 套接字。 如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket() 函数： 1int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPPROTO_UDP表示UDP协议 这种套接字称为 UDP 套接字。 上面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示： 12int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP套接字 Windows下的socket()函数Windows 会区分 socket 和普通文件，它把 socket 当做一个网络连接来对待，调用 socket() 以后，返回值是 SOCKET 类型，用来表示一个套接字。Windows 下也使用 socket() 函数来创建套接字，原型为： 1SOCKET socket(int af, int type, int protocol); 除了返回值类型不同，其他都是相同的。Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。 参考资料计算机网络-自顶向下方法bind()和connect()函数：绑定套接字并建立连接listen()和accept()函数：让套接字进入监听状态并响应客户端请求send()/recv()和write()/read()：发送数据和接收数据TCP协议的无消息边界问题TCP协议的粘包问题（数据的无边界性）TCP网络传输“粘包”问题，经典解决（附代码）socket()函数用法详解：创建套接字","link":"/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E5%A5%97%E6%8E%A5%E5%AD%97/"},{"title":"数据库常用概念","text":"基本概念 实体（entity）：客观存在并可相互区别的事物称为实体。实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。实体集（entity set）：同一实体型的集合称为实体集。 术语对比 关系模型的数据结构术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或者行 属性 列 属性名 列名 分量 一条记录中的一个列值 域 值的集合，值的取值范围 非规范关系 表中有表 关系关系模型（relational model） 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 主属性（prime attribute）：候选码的诸属性 码（key）：表中可以唯一确定一个元组的某个属性组，也可以说是主码。 候选码（candidate key）：关系的某一属性组的值能唯一地标识一个元组，但是子集不能 主码（primary key）：若一个关系有多个候选码，选定其中一个为主码 域（domain）：一组具有相同数据类型的值的集合 笛卡尔积：域之间的排列组合。 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, …, 属性n) 关系的三种类型基本表：实际存在的表，实际存储数据的逻辑表示查询表：查询结果对应的表视图表：由基本表或其他视图导出来的表，是虚表，不对应实际存储的数据。 关系的完整性实体完整性 主属性不能取空值 参照完整性：指的是关系之间存在着属性的引用，比如学生（学号，姓名，专业号），专业（专业号，专业名）。学生这个表参照了专业表里的专业号 上面学生表的专业号可以看作是专业表的专业号的引用，也就是专业表的外码 外码只有两种情况 为空值 专业未确定 非空值 专业确定 用户定义的完整性用户自己设置的规则，比如某个属性的范围，某个属性必须取为唯一值等。 关系代数并 差 交 笛卡儿积称为集合运算.(1) 并(Union)并是抽取两个表格中所有行的运算,经过并运算后能够抽取两个表格中的所有数据.(2) 差(difference)能够调取两张表中其中一张表独有的数据,这种运算叫做差,以不同的表格为基准会获得不同的运算结果.(3) 交(intersection)能够调取两张表格共有数据的这种运算叫做交.(4) 笛卡儿积(Cartesian product)笛卡儿积是一种可以将两个表格中所有数据排列组合的方法 (5) 投影(projection)抽取列的运算叫做投影.投影是调取表中某一列.(6) 选择(Selection)选择是调取表中某一行的运算.(7) 连接(join)连接就是将表格连接起来.外键参照其他表中的主键,通过连接,将两个表格粘合起来. 笛卡尔集中选取合适的；等值连接 选取某些属性的值相等的那些元组自然连接 重复的属性列去掉(8) 除除就是从’被除表格’中调取’除表格’中包含的所有行,然后再从中去掉’除表格’中所有行的运算. 常用 SQL 操作 对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE SCHEMA，ALTER TABLE 视图 CREATE VIEW 索引 CREATE INDEX 数据 基本表和视图 SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES 属性列 SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES 一些最重要的 SQL 命令SELECT - 从数据库中提取数据UPDATE - 更新数据库中的数据DELETE - 从数据库中删除数据INSERT INTO - 向数据库中插入新数据CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 范式一个低一级范式的关系模式通过模式分解可以转换为若干高一级范式的关系模式的集合，这个过程叫规范化 。//通俗的说，就是为了方便增删改查才转为为各种范式。第一范式（1NF）：属性（字段）是最小单位不可再分。 //不可以一个属性里面的值还可以再分为多个值第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键 （消除 1NF 非主属性对码的部分函数依赖）。 //第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性 （消 除 2NF 非主属性对码的传递函数依赖）。 //鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖 （消除 3NF 主属性对码的部分和传递函数依赖）。第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖 （消除 3NF 非平凡且非函数依赖的多值依赖）。 关系模式的简化三元组 R&lt;U,F&gt; F是属性组上面的一组数据依赖。 数据依赖 函数依赖（function dependency）：类似于y=f(x) x一旦确定，y就确定了 非平凡的函数依赖 比如(Sno,Cno)-&gt;Grade //Grade不属于码 平凡的函数依赖 (Sno,Cno)-&gt;Cno //Cno属于码 部分函数依赖 Sno-&gt;Sdept,(Sno,Cno)-&gt;Sdept //Sdept依赖(Sno,Cno)，但是还可以再细分，Sdept依赖于Sdept 传递函数依赖 多值依赖（multi-value dependency）： // X Y Z 由X Z的值可以确定一组Y的值。而且Z变一下，还是可以确定一组相同的Y的值，这组Y的值只和X有关的 事务事务：用户定义的一个数据库操作序列，这些操作要么做，要么不做，是一个不可分割的工作单位一个程序包含多个事务 事务的开始可以由用户显式控制。如果用户没有显式义，由DBMS按照默认规定自动划分事务。在SQL中，定义事务的语句一般是三条 123BEGIN TRANSCTION; COMMIT; //提交事务ROLLBACK; //回滚，之前完成的操作撤销，回滚到事务开始的状态 事务的ACID特性原子性：事务要么做要么不做一致性：事务前后数据的完整性必须保持一致。隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。 并发控制事务是并发控制的基本单位。并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。活锁死锁：活锁：事务永远处于等待状态，可通过先来先服务的策略避免。死锁：事物永远不能结束预防：一次封锁法、顺序封锁法；诊断：超时法、等待图法；解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则 SQL语言简洁，易学易用 完成核心功能只用了9个动词。 SQL的动词 1234数据查询 SELECT 数据定义 CREATE,DROP,ALTER数据操纵 INSERT,UPDATE,DELETE数据控制 GRANT,REVOKE //grant 授予 revoke 撤销废除 综合统一 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体 基本操作对象有：模式、表、视图和索引 数据定义123456操作对象| 创建 | 删除 | 修改----------------------------------------------------模式 CREATE SCHEMA DROP SCHEMA -表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW - 索引 CREATE INDEX DROP INDEX ALTER INDEX SQL不提供修改模式定义和修改视图定义的操作，如果想修改就只能删除然后重建；示例 1234567CREATE SCHEMA test AUTHORIZATION zhangCREATE TABLE tab1(COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2) ); 1234删除模式DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; //CASCADE和RESTRICT必选1个CASCADE表示级联，删除模式的时候把模式中的所有数据对象都删除RESTRICT只有在模式没有任何数据对象的时候才能执行 索引的建立和删除表太大的时候，查询操作会比较耗时，可以用索引来加快。在基本表上建立一个或者多个索引，加快查找速度 数据库索引类型 顺序文件上的索引 按属性值降序或者升序的形式建立一个顺序索引文件 B+树索引 叶节点为属性值和相应的元组指针 动态平衡的优点 散列索引 hash桶存放相应的索引属性值和元组的指针 位图索引 用位向量记录索引属性值中可能出现的值，每个位向量对应一个可能值； 建立索引和删除索引由数据库管理员或者表的建立者负责完成。但是查询时候是由数据库管理系统自动选择合适的索引，用户不能显式选择。 数据字典是数据库管理系统中的一组系统表，记录了数据库所有的定义信息关系数据库执行SQL相关的数据定义语句的时候，实际上就是在更新数据字典表中的信息。 数据查询12345SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [&lt;目标列表达式 &gt;]... //DISTINCT 取消重复值，ALL 不取消重复值FROM &lt;表名或者视图名&gt; [WHERE &lt;条件表达式&gt;] //代表限制条件[GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;] ] //Group分组，比方一个表课程号，选课的人，可以根据课程和分组，作用有点像按某个属性来拆分成多个表。HAVING指定筛选条件[ORDER BY &lt;列名2&gt; [ASC|DESC]]; //结果按照列名2的值升序或者降序 数据更新插入数据123INSERT INTO student(Sno,Sname,Ssex,Sdept,Sage)VALUES('201215128','陈','男','IS',18) 修改数据123UPDATE studentSET Sage=22WHERE Sno='201215121'; //WHERE可以省略，省略时候表示修改表中所有的元组 删除数据1234//只能删除元组DELETE FROM studentWHERE Sno='201215128'; 视图操作123456CREATE VIEW IS_STUDENTASSELECT Sno,Sname,SageFROM studentWHERE Sdept='IS'WITH CHECK OPTION //可以省略，带上这条语句表示对视图插入修改删除时候会满足where中的条件 1DROP VIEW &lt;视图名&gt;[CASCADE] //级联代表删除相关联的视图 参考资料数据库系统概论 王珊 萨师煊SQL 语法数据库篇（每位开发者必备）","link":"/2020/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/"},{"title":"STL 堆常用操作","text":"基本概念 STL中并没有把heap作为一种容器组件，heap的实现亦需要更低一层的容器组件（诸如list,array,vector）作为其底层机制。 Heap是一个类属算法，包含在&lt; algorithm &gt;中。 STL中关于heap默认调整成的是大顶堆，可以用自定义的compare_fuction函数实现大顶堆或小顶堆。 heap的低层机制vector本身就是一个类模板，heap基于vector便实现了对各种数据类型（无论基本数据类型还是用户自定义的数据类型）的堆排（前提是用户自定义的数据类型要提供比较机制compare_fuction函数）。 堆是一棵树完全二叉树，对于该完全二叉树中的每一个结点x，其关键字大于等于(或小于等于）其左右孩子结点，而其左右子树均为一个二叉堆。 在上述的定义中，若堆中父亲结点关键字的值大于等于孩子结点，则称该堆为大顶堆；若堆中父亲结点关键子的值小于等于孩子结点，则称该堆为小顶堆。 由于堆是一棵完全二叉树，所以我们可以很轻易地用一个数组存储堆中的每一个元素，并且由子结点访问到其父亲结点和由父亲结点访问到其子结点。 头文件1# include &lt; algorithm &gt; STL堆操作STL里面的堆操作一般用到的只有4个。 1234make_heap Make heap from range (function template)push_heap Push element into heap range (function template) pop_heap Pop element from heap range (function template) sort_heap Sort elements of heap (function template) make_heap12345template &lt;class RandomAccessIterator&gt; void make_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void make_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 一个参数是数组或向量的头指针，第二个向量是尾指针。第三个参数是比较函数的名字。在缺省的时候，默认是大跟堆。作用 ：以[ begin,end )内元素建立堆。 push_heap向堆中插入元素分为两个步骤： 先将待插入的元素插入到底层容器的末端，通过push_back函数实现。 再调用push_heap(b,e,cmp)函数堆新插入的元素做向上调整。 所以，调用push_heap函数之前，先要保证待插入的元素已经放到了原容器的末尾，否则push_heap就做了无用功。 12345template &lt;class RandomAccessIterator&gt; void push_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void push_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 假设由[first,last-1)是一个有效的堆，然后，再把堆中的新元素加进来（新元素放到最后一个位置），做成一个堆。 sort_heap12345template &lt;class RandomAccessIterator&gt; void sort_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void sort_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); sort_heap对[first,last)中的序列进行排序。它假设这个序列是有效堆。（当然，经过排序之后就不是一个有效堆了） pop_heap12345template &lt;class RandomAccessIterator&gt; void pop_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void pop_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 不是真的把最大（最小）的元素从堆中弹出来,而是重新排序堆，使得第一个和最后一个进行交换，但是并不弹出最大值。它把first和last交换，然后将[first,last-1)的数据再做成一个堆。需要手动删除最后一个元素（a.pop_back()）; 示例1234567891011121314151617181920212223242526272829303132// range heap example#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main () { int myints[] = {10,20,30,5,15}; vector&lt;int&gt; v(myints,myints+5); vector&lt;int&gt;::iterator it; make_heap (v.begin(),v.end()); 建立堆 cout &lt;&lt; \"initial max heap : \" &lt;&lt; v.front() &lt;&lt; endl; pop_heap (v.begin(),v.end()); v.pop_back(); cout &lt;&lt; \"max heap after pop : \" &lt;&lt; v.front() &lt;&lt; endl; v.push_back(99); 添加元素 push_heap (v.begin(),v.end()); cout &lt;&lt; \"max heap after push: \" &lt;&lt; v.front() &lt;&lt; endl; sort_heap (v.begin(),v.end()); 排序堆中元素 cout &lt;&lt; \"final sorted range :\"; for (unsigned i=0; i&lt;v.size(); i++) cout &lt;&lt; \" \" &lt;&lt; v[i]; cout &lt;&lt; endl; return 0;} 输出： 1234initial max heap : 30max heap after pop : 20max heap after push: 99final sorted range : 5 10 15 20 99 参考资料C++ primerC++ Library ReferenceSTL 堆heap的用法 C++ STL 常见算法(比较详细)STL之heap相关操作算法 //写的详细","link":"/2020/06/21/STL-%E5%A0%86%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"STL 算法整理","text":"标准库中常见的函数与头文件 1234567891011121314151617181920212223242526272829&lt;cstdlib&gt;: abort,&lt;numeric&gt;: accumulate, inner_product,&lt;memory&gt;: allocator, auto_ptr, uninitialized_copy,&lt;iterator&gt;: back_inserter, front_inserter, inserter, istream_iterator, ostream_iterator, reverse_iterator,&lt;new&gt;: bad_alloc,&lt;typeinfo&gt;: bad_cast, type_info,&lt;functional&gt;: bind2nd, less_equal, negate, not1, plus,&lt;bitset&gt;: bitset,&lt;iostream&gt;: boolalpha, cerr, cin, cout, dec, endl, ends, fixed, flush, hex, internal, istream, left, noboolalpha, noshowbase, noskipws, nounitbuf, nouppercase, oct, ostream, right, scientific, showbase, sowpoint, skippws, unitbuf, uppercase&lt;algorithm&gt;: copy, count, count_if, equal_range, fill, fill_n, find, find_end, find_first_of, for_each, max, main, nth_element, partial_sort, replace, replace_copy, set_difference, set_intersection, set_union, sort, stable_sort, unique, unique_copy, upper_bound,&lt;deque&gt;: deque,&lt;exception&gt;: exception, unexpected,&lt;fstream&gt;: fstream, ifstream, ofstream,&lt;string&gt;: getline, string,&lt;ios_base&gt;: ios_base,&lt;cctype&gt;: isalpha, islower, ispunct, isspace, isupper,&lt;sstream&gt;: istringstream, ostringstream, stringstream,&lt;list&gt;: list,&lt;stdexcept&gt;: logic_error, out_of_range, range_error, runtime_error,&lt;utility&gt;: make_pair, pair,&lt;map&gt;: map, multimap&lt;set&gt;: multiset, set&lt;queue&gt;: priority_queue, queue&lt;cstddef&gt;: ptrdiff_t, size_t,&lt;iomanip&gt;: setfill, setprecision, setw,&lt;cmath&gt;: sqrt,&lt;stack&gt;: stack,&lt;cstring&gt;: strcmp, strcpy, strlen, strncpy,&lt;vector&gt;: vector 标准库定义了 100多个算法，要学习如何使用它们，需要理解它们的结构，而不是记住每个算法的细节。 beg和end表示元素范围的迭代器 beg2表示第二个序列开始位置迭代器，end2表示第二个序列末尾迭代器(如果有)。如没有则假定系列2至少与beg end表示的范围一样大。beg和beg2类型不必匹配，但必须保证两个序列中的元素可以执行特性操作或调用给定的可调用对象。 des表示目的序列的迭代器，目的序列保证有足够的空间存放算法生成的元素。 unaryPred和binaryPred是一元和二元谓词，分别接受来自输入序列的元素，两个谓词都返回可用作条件的类型。 comp是一个二元谓词，满足关联容器中对关键字序的要求 unaryOp和binaryOp是可调用对象，分别使用来自输入序列的一个和两个实参来调用。 查找对象的算法：find12find(beg,end,val); 在迭代区间[begin,end)内查找等于val的元素，找到返回相应的迭代器，否则返回end。find_if(beg,end,unaryPred); 函数find的带一个函数参数的_if版本，条件：使函数unaryPred返回true。 find_first_of/find_end123find_first_of(beg1,end1,beg2,end2);find_first_of(beg1,end1,beg2,end2,binaryPred); 依次遍历元素,在[beg1, end1)中查找首次出现[beg2, end2)中的任一元素,使用==或unarypred相匹配。//注意是任意一个匹配即可。 例：vec1 –{1,2,3,4,5}, vec2{3,2,4}, vec3{8,6,7}在vec1中查找vec2，则返回元素2在vec1中的迭代器。在vec1中查找vec3，则返回vec1.end()迭代器。 1234find_end(beg1,end1,beg2,end2);find_end(beg1,end1,beg2,end2,binaryPred);在[beg1,end1)范围内查找[beg2,end2)最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回end1。依次遍历元素，在[beg1, end1）中查找最后一个匹配的子序列[beg2, end2），若存在，则返回beg2在[beg1, end1）中对应的迭代器，否则返回end1。[beg2, end2)中序列必须完全匹配。 例：vec1 –{1,2,3,4,5}, vec2{2,3,4}, vec3{3,2,4}在vec1中查找vec2，则返回元素2在vec1中的迭代器。在vec1中查找vec3，则返回vec1.end()迭代器。 adjacent_find12adjacent_find(beg,end);adjacent_find(beg,end,binaryPred); 依次遍历元素，查范围内相邻元素，使用==或unarypred相匹配，若存在，返回第一个元素对应的迭代器，否则返回end. search1234567search(beg1,end1,beg2,end2);search(beg1,end1,beg2,end2,binaryPred);依次遍历元素，在[beg1, end1）中查找第一个匹配的子序列[beg2, end2）。若存在，则返回beg2在[beg1, end1）中对应的迭代器，否则返回end1。[beg2, end2)中序列必须完全匹配。search_n(beg,end,count,val); //找第n个匹配的search_n(beg,end,count,val,binaryPred);依次遍历元素，在[beg1, end1）中查找匹配val的元素，使用==或unarypred匹配。若存在，返回count指定的第count个元素所对应的迭代器，否则返回end1。若count指定值为负数或0，则返回beg1。 count123count(beg,end,val);count_if(beg,end,unaryPred);依次遍历元素，查找范围内与val相匹配或使unarypred为真的元素个数。 其他只读算法：for_each12for_each(beg,end,f); 将[beg,end)范围内所有元素依次调用函数func，返回func。不修改序列中的元素。 mismatch1234mismatch(beg1,end1,beg2);mismatch(beg1,end1,beg2,binaryPred);并行比较[beg1,end1)与[beg2,end2)，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的end。 equal123判断[beg1,end1)与[beg2,end2)内元素都相等equal(beg1,end1,beg2); equal(beg1,end1,beg2,binaryPred); 二分查找算法：lower_bound/upper_boundlower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。 123456789lower_bound(beg,end,val);lower_bound(beg,end,val,comp);从[beg,end)位置二分查找第一个大于或等于val的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound(beg,end,val);upper_bound(beg,end,val,comp);从[beg,end)位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 equal_range返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 12equal_range(beg,end,val);equal_range(beg,end,val,comp); binary_search在[beg,end)中查找val，找到返回true。 12binary_search(beg,end,val);binary_search(beg,end,val,comp); 写容器元素的算法：fill_n/fill12fill_n(dest,cnt,val); 将值val赋给[beg,beg+n)范围内的所有元素。fill(beg,end,val); 将值val赋给[beg,end)范围内的所有元素。 generate_n/generate连续调用函数func填充[beg,end)范围内的所有元素。 12generate_n(dest,cnt,Gen);generate(beg,end,Gen); copy/copy_n复制[beg,end)到res 123copy(beg,end,dest);copy_backward(beg,end,dest);dest是输出序列的尾后迭代器。输入范围内的元素被拷贝或移动到目的序列的尾元素，然后是倒数第二个，类推。返回从beg拷贝或移动的元素的位置。如范围为空则返回dest transform1234将[beg,end)范围内所有元素依次调用函数unary，结果放入res中。transform(beg,end,dest,unaryOp); transform(beg,end,beg2,dest,binaryOp);将[beg,end)范围内所有元素与[beg2,beg2+end-beg)中所有元素依次调用函数unary，结果放入res中。 replace_copy将[beg,end)内所有等于oval的元素都用nval代替.将结果写入res。 12replace_copy(beg,end,dest,old_val,new_val);replace_copy_if(beg,and,dest,unaryPred,new_val); replace_if/replace将[beg,end)内所有等于old_val的元素都用nval代替 12replace(beg,end,old_val,new_val);replace_if(beg,end,unaryPred,new_val); merge12merge(beg1,end1,beg2,end2,dest); 合并[beg1,end1)与[beg2,end2)存放到res。merge(beg1,end1,beg2,end2,dest,comp); swap/swap_ranges123swap(elem1,elem2);swap_ranges(beg1,end1,beg2);iter_swap(iter1,iter2); inplace_merge合并[beg,mid)与[mid,end)，结果覆盖[beg,end)。 12inplace_merge(beg,mid,end);inplace_merge(beg,mid,end,comp); 划分与排序算法：partial_sort和nth_element只进行部分排序，速度比整体排序算法更快。 partition12stable_partition(beg,end,unaryPred); 与partition()类似，保留容器中的相对顺序。partition(beg,end,unaryPred); 元素重新排序，使用pred函数，把结果为true的元素放在结果为false的元素之前。 sort/stable_sort1234sort(beg,end); 默认升序重新排列元素sort(beg,end,comp);stable_sort(beg,end); 与sort()类似，保留相等元素之间的顺序关系。stable_sort(beg,end,comp); partial_sort/partial_sort_copy123456partial_sort(beg,mid,end); 排序mid-beg个元素。排序后，从beg到mid中的元素都是有序的，mid到end中的元素顺序未指定。partial_sort(beg,mid,end,comp);partial_sort_copy(beg,end,destBeg,destEnd);partial_sort_copy(beg,end,destBeg,destEnd,comp);排序输入范围内的元素，并将足够多的元素拷贝到destBeg和destEnd所指示的序列中。如果目的序列大于等于输入范围则排序整个输入序列并存入输出序列，若目的序列小于输入范围，则拷贝输入序列中与目的范围一样多的元素。返回一个迭代器，指向目的范围中已排序部分的尾后迭代器。如目的序列小于等于输入范围，则返回destEnd(此时是否整个输入序列排序？？？)。 nth_element单个元素序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。 12nth_element(beg,nth,end);nth_element(beg,nth,end,comp); 通用重新排序算法：remove/remove_copy1234567删除[beg,end)内所有等于val的元素。注意，该函数不是真正删除函数。采用的办法是:用保留的元素覆盖要删除的元素。算法返回一个迭代器，指向最后一个保留元素的尾后位置。remove(beg,end,val); remove_if(beg,end,unaryPred);remove_copy(beg,end,dest,val);remove_copy_if(beg,end,dest,unaryPred);将所有不等于val元素复制到res，返回OutputIterator指向被拷贝的末元素的下一个位置。 unique123456重排序列，对于相邻的满足条件的元素，通过覆盖来进行删除，返回一个迭代器，指向最后一个保留元素的尾后位置。unique(beg,end);unique(beg,end,binaryPred);unique_copy(beg,end,dest);unique_copy(beg,end,dest,binaryPred);与unique类似，不过把结果输出到dest。 rotate围绕mid指向的元素进行元素转动。元素mid成为首元素，随后是mid+1-&gt;end之间的之前的元素，再接着是beg到mid之前的元素。返回一个迭代器，指向原来beg位置的元素。 12rotate(beg,mid,end);rotate_copy(beg,mid,end,dest); reverse翻转序列中的元素。reverse返回void，reverse_copy返回一个迭代器，指向拷贝到目的序列的元素的尾后位置。 12reverse(beg,end);reverse_copy(beg,end,dest); random_shuffle使用随机访问迭代器的重排算法 12random_shuffle(beg,end); 元素随机调整次序。random_shuffle(beg,end,rand); 使用函数gen代替随机生成函数执行random_shuffle()。 排列算法：这些算法假定序列中的元素都是唯一的。要求双向迭代器。 is_permutation判断两个序列是否为同一元素集的不同排列 12is_permutation(beg1, end1, beg2)is_permutation(beg1, end1, beg2, binaryPred) next_permutation生成序列的字典序排列中的下一个,返回要给bool指出是否还有下一个如果序列已经是最后一个排序，则本函数将序列重排为最小的序列，返回false。否则将输入序列转为字典序的下一个排列，返回true。 12next_permutation(beg,end);next_permutation(beg,end,comp); 123456int a[6]={1,2,3,4,5,6};do{ for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl;}while(next_permutation(a,a+6)); prev_permutation生成序列的字典序排列中的前一个,返回要给bool指出是否还有前一个。若序列已经是第一个排序，则本函数将序列重排为最大的序列，返回false。否则将序列转为字典序的上一个排序，返回true。 12prev_permutation(beg,end);prev_permutation(beg,end,comp); 有序序列的集合算法：includes判断[beg1,end1)是否包含[beg2,end2)，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 12includes(beg,end,beg2,end2);includes(beg,end,beg2,end2,comp); set_union取[beg1,end1)与[beg2,end2)元素并集存放到dest。 12set_union(beg,end,beg2,end2,dest);set_union(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符，执行set_union() set_intersection取[beg1,end1)与[beg2,end2)元素交集存放到res。 12set_intersection(beg,end,beg2,end2,dest);set_intersection(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符 set_difference取[beg1,end1)与[beg2,end2)元素内差集存放到res。 12set_difference(beg,end,beg2,end2,dest);set_difference(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符 set_symmetric_difference取[beg1,end1)与[beg2,end2)元素外差集存放到res。 12set_symmetric_difference(beg,end,beg2,end2,dest);set_symmetric_difference(beg,end,beg2,end2,dest,comp); 最大值和最小值算法：min/max1234min(va1,va2); 返回两个元素中较小一个。min(val1,val2,comp);max(val1,val2);max(val1,val2,comp); 返回两个元素中较大一个。 min_element/max_element1234min_element(beg,end); 返回一个ForwardIterator，指出[beg,end)中最大的元素。min_element(beg,end,comp);max_element(beg,end); 返回一个ForwardIterator，指出[beg,end)中最小的元素。max_element(beg,end,comp); lexicographical_compare12lexicographical_compare(beg1,end1,beg2,end2); 按字典序判断[beg1,end1)是否小于[beg2,end2)lexicographical_compare(beg1,end1,beg2,end2,comp); 将函数comp代替&lt;操作符 算术算法：&lt; numeric &gt;accumulate1234对[beg,end)内元素之和，加到初始值val上。accumulate(beg,end,init);accumulate(beg,end,init,BinaryOp);将函数BinaryOp代替加法运算，执行accumulate()。 partial_sum123将[beg,end)内该位置前所有元素之和放进dest中。partial_sum(beg,end,dest);partial_sum(beg,end,dest,BinaryOp); inner_product123对两个序列做内积(对应元素相乘，再求和)并将内积加到初始值init上。inner_product(beg1,end1,beg2,init);inner_product(beg1,end1,beg2,init,BinOp1,BinOp2); adjacent_difference将新序列写入dest，每个新元素(除了首元素)的值都为输入范围中当前位置和前一个位置元素之差。第一个版本使用-，第二个版本使用binaryOp。 12adjacent_difference(beg,end,dest);adjacent_difference(beg,end,dest,BinaryOp); 参考资料C++ primer 附录C++ STL 常见算法(比较详细)C++进阶：STL算法总结C/C++基础—算法概览关于lower_bound( )和upper_bound( )的常见用法","link":"/2020/06/21/STL-%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"},{"title":"Linux内核驱动","text":"设备文件类Unix操作系统都是基于文件概念的。 可以直接把I/O设备当作设备文件（device file）来处理。 操作普通文件的系统调用也可以直接用于I/O设备。 设备文件划分根据设备驱动程序的基本特性划分 块设备：块设备的数据可以被随机访问。 字符设备：字符设备的数据不可以随机访问（声卡）。或者可以随机访问但是随机访问数据时间很大程度上依赖于数据在设备内的位置（磁带）。 网卡是例外，网卡是不直接与设备文件相对应的硬件设备。 设备文件属性设备文件的索引节点： 设备文件是存放在文件系统中的实际文件。它的索引节点并不包含指向磁盘数据块的指针，因为它们是空的。 它的索引节点必须包含硬件设备的一个标识符，它对应字符或者块设备文件。 设备标识符: 由设备文件的类型（字符或者块）和一对参数组成（主设备号，从设备号）。 主设备号：标识了设备的类型。通常，具有相同主设备号和类型的所有设备文件共享相同的文件操作集合，因为它们是由同一个设备驱动程序处理的。 从设备号：标识了主设备号相同的设备组中的一个特定设备。例如相同磁盘控制器下的一组磁盘，有相同的主设备号，但是拥有不同的从设备号码。 创建设备文件:mknod()系统调用用来创建设备文件。参数有设备文件名，设备类型，主设备号以及次设备号。 设备文件通常在/dev下。 设备文件通常与硬件设备（比如硬盘/dev/hda）,或者硬件设备的某一个物理或者逻辑分区（比如磁盘分区/dev/hda2）对应。 有些情况下，设备文件不会和任何的实际硬件对应，而仅仅标识一个虚拟的逻辑设备。 比如 /dev/null 。 黑洞 注意块设备的编号（3，0）不等同与字符设备的（3，0） 设备文件的用户态处理早期的Unix系统中，设备的主设备号和次设备号是8位长，并不够用。 真正的问题是设备文件被分配一次并且永远保留在/dev中；系统中的每个逻辑设备都应该有一个与其相对应的，明确定义了设备号的设备文件。 Documentation/devices.txt 存放了官方注册的已经分配的设备号和/dev目录节节点 include/linux/major.h 文件也可能包含了设备的主设备号对应的宏。 为了解决上述问题：从linux2.6开始，增加了设备号码的大小； 主设备号为12位 从设备号为20位 通常把两个参数合并为一个32位的dev_t变量； MAJOR宏和 MINOR宏 可以从dev_t中分别提取主设备号和次设备号 MKDEV宏把主设备号和次设备号合并称为一个dev_t值 动态分配设备号分配设备号和创建设备文件来说，倾向做法是高度动态地处理设备文件。 每个设备驱动程序在注册阶段都会指定它将要处理的设备号范围，驱动程序可以只指定设备号的分配范围，无需指定精确值，在这种情况下，内核会分配一个合适的设备号范围给驱动程序。因此，新的硬件设备驱动程序不再需要从官方注册表中分配的一个设备号；它们可以仅仅使用当前系统中空闲的设备号。然而这种情形下，就不能永久的创建设备文件，它只在设备驱动程序初始化一个主设备号和次设备号时才创建。因此，这就需要一个标准的方法将每个驱动程序所使用的设备号输出到用户态应用程序中，为此，设备驱动程序模型提供了一个非常好的解决办法：把主设备号和次设备号存放在/sys/class子目录下的dev属性中。 动态创建设备文件Linux内核可以动态地创建设备文件：它无需把每一个可能想到的硬件设备的设备文件都填充到/dev目录下，因为设备文件可以按照需要来创建。由于设备驱动程序模型的存在，在Linux2.6内核提供了一个简单的方法来处理：系统中必须安装一组udev工具集的用户态程序。 统启动时，/dev目录是清空的，这时udev程序将扫描/sys/class子目录来寻找dev文件。 对每一个这样的文件（主设备号和次设备号的组合表示一个内核所支持的逻辑设备文件），udev程序都会在/dev目录下为它创建一个相应的设备文件。udev程序也会根据配置文件为其分配一个文件名并创建一个符号链接，该方法类似于Unix设备文件的传统命名模式。 最后，/dev目录里只存放了系统中内核所支持的所有设备的设备文件，而没有任何其他的文件。 通常在系统初始化后才创建设备文件。它要么发生在加载设备驱动程序所在的模块时，要么发生在一个热插拔的设备加入系统中时。udev工具集可以自动地创建相应的设备文件，因为设备驱动程序模型支持设备的热插拔。当发现一个新的设备时，内核会产生一个新的进程来执行用户态shell脚本文件/sbin/hotplug，并将新设备上的有用信息作为环境变量传递给shell脚本，用户态脚本文件读取配置文件信息并关注完成新设备初始化所必需的任何操作。如果安装了udev工具集，脚本文件也会在/dev目录下创建适当的设备文件。 设备文件的 VFS处理虽然设备文件也在系统的目录树中，但是它们和普通文件及目录文件有根本的不同: 进程访问普通文件时，它会通过文件系统访问磁盘分区中的一些数据块。 进程访问设备文件时，它只要驱动硬件设备就可以了。 隐藏设备文件和普通文件之间的差异就是vfs的责任：为了做到这点，VFS在设备文件打开时改变其缺省文件操作；因此，可把设备文件的每个系统调用都转换成与设备相关的函数的调用，而不是对主文件系统相应函数的调用。与设备相关的函数对硬件设备进行操作以完成进程所请求的操作。（注意：在路径名查找中，指向设备文件的符号链接与设备文件的作用相同）。 例子：假定open()一个设备文件，从本质上来说，相应的服务例程解析到设备文件的路径名，并建立相应的索引节点对象、目录项对象和文件对象。通过适当的文件系统函数（通常为ext2_read_inode()或ext3_read_inode()）读取磁盘上的相应的索引节点来对索引节点对象进行初始化。当这个函数确定磁盘索引节点与设备文件对应时，则调用init_special_inode()，该函数把索引节点对象的i_rdev字段初始化为设备文件的主设备号和次设备号，而把索引节点对象的i_fop字段设置为def_blk_fops或者def_chr_fops文件操作表的地址。因此，open()系统调用的服务例程也调用dentry_open()函数，后者分配一个新的文件对象并把其f_op字段设置为i_fop中存放的地址，即再一次指向def_blk_fops或者def_chr_fops的地址。正是这两个表的引入，才使得在设备文件上所发出的任何系统调用都将激活设备驱动程序的函数而不是基本文件系统的函数。 设备驱动程序设备驱动程序是内核例程的集合，它使硬件设备响应控制设备的编程接口。该编程接口是一组规范的VFS函数集合（open read lseek ioctl）。这些函数的实际实现由设备驱动程序全权负责。每一个设备都有自己的I/O控制器，因此就有唯一的命令和唯一的状态信息，所以大部分I/O设备都有自己的驱动程序。 设备驱动程序的组成？ 使用驱动设备有几个活动肯定是要发生的。 注册设备驱动程序 初始化设备驱动程序 监控I/O操作 访问I/O共享存储器 注册设备驱动程序在设备文件上发出的系统调用都由内核转化为相应设备驱动程序的对应函数的调用。为了完成这个操作，设备驱动程序必须注册自己。 注册的过程注册一个设备驱动程序意味着分配一个新的device_driver描述符，将其插入到设备驱动程序模型的数据结构中，并把它对应的设备文件（可能多个）连接起来。如果设备文件对应的驱动程序以前没有注册，则对该设备文件的访问会返回错误码-ENODEV。 如果设备驱动程序是静态编译到内核的，则它的注册在内核初始化阶段进行。如果是作为一个内核模块来编译的，则它的注册在模块装入的时候进行，而且在模块卸载的时候也会注销自己。 通用PCI设备的注册示例：该设备必须分配一个pci_driver类型的描述符，pci内核层使用该描述符来处理设备。初始化描述符的一些字段，设备驱动程序调用pci_regester_driver()函数。 pci_driver描述符包括一个内嵌的device_driver描述符 pci_regester_driver()函数仅仅初始化内嵌的驱动程序描述符中的字段，然后调用device_register()函数把驱动程序插入设备驱动程序模型的数据结构中。、 注册设备驱动程序的时候 内核会寻找可能由该驱动程序处理但是尚未获得支持的硬件设备。主要依靠bus_type的match方法以及device_driver对象的probe方法。如果探测到可被驱动程序处理的硬件设备，内核会分配一个设备对象，然后调用device_register()函数把设备插入设备驱动模型中。 初始化设备驱动程序设备驱动程序的注册和初始化是不同的。设备驱动程序应该尽快被注册，以便用户态应用程序能够通过相应的设备文件来使用它。设备驱动程序在最后可能的时刻才会被初始化。因为，初始化驱动程序意味着分配宝贵的系统资源，这些资源因此就对其他驱动程序不可用了。 监控I/O操作I/O操作的持续时间通常不可预知。在任何情况下，启动I/O操作的设备驱动程序都必须依靠一种监控技术在I/O操作终止或超时时候发出信号。 终止操作的情况下：设备驱动程序读取I/O接口状态寄存器的内容来确定I/O操作是否成功执行。 超时的情况下：时间过了，驱动程序就知道出了什么问题了。 轮询模式CPU依靠这种技术重复检查（轮询）设备的状态寄存器，直到寄存器的值表明I/O操作完成。有点类似于自旋锁。 如果完成I/O操作需要的时间相对较多，比如说毫秒级别，那么这种模式就变得低效，因为CPU花费宝贵的机器周期去等待I/O操作的完成。 轮询的简单例子： 1234567for(;;){ if(read_status(device)&amp;DEVICE_END_OPERATION) break; if(--count==0) //粗略的超时机制，精确的可以使用jiffies break;} 中断模式如果I/O控制器能够控制IRQ总线发出I/O操作结束的信号，那么中断模式才能被使用。 例子：实现一个简单的输入字符设备的驱动程序。 用户在相应的设备文件上发出read()系统调用，一条输入命令被发往设备的控制寄存器。 在一个不可预知的长时间间隔后，设备把一个字节的数据放进控制寄存器。 设备驱动程序然后将这个字节作为read()系统调用的结果返回。 驱动程序包含两个函数： 实现文件对象read方法的foo_read()函数。 处理中断的foo_interrupt()函数。 用户读设备文件，foo_read()函数就触发，foo_read()函数主要操作如下： 12345678910111213//参数filp是设备文件，buf是输入数据缓存，count是输入数据长度，ppos当前位置ssize_t foo_read(struct file *filp, char *buf, size_t count, loff_t *ppos){ foo_dev_t * foo_dev = filp-&gt;private_data; //foo_dev_t 自定义描述符 if (down_interruptible(&amp;foo_dev-&gt;sem) //获取foo_dev-&gt;sem信号量 return -ERESTARTSYS; foo_dev-&gt;intr = 0; //清intr标志 outb(DEV_FOO_READ, DEV_FOO_CONTROL_PORT); //对I/O设备发出读命令 wait_event_interruptible(foo_dev-&gt;wait, (foo_dev-&gt;intr = =1)); //执行wait_event_interruptible以挂起进程，直到intr标志变为1 if (put_user(foo_dev-&gt;data, buf)) return -EFAULT; up(&amp;foo_dev-&gt;sem); return 1; 设备驱动程序依赖类型为foo_dev_t的自定义描述符； 包含信号量sem（保护硬件设备免受并发访问） 等待队列wait 标志intr（当设备发出一个中断时设置） 单个字节缓冲区data（由中断处理程序写入且由read方法读取）。 一般而言，所有使用中断的I/O驱动程序都依赖中断处理程序及read和write方法均访问的数据结构。foo_dev_t描述符的地址通常存放在设备文件的文件对象的private_data字段中或一个全局变量中。 foo_read()函数的主要操作如下： 获取foo_dev-&gt;sem信号量，因此确保没有其他进程访问该设备。 清intr标志。 对I/O设备发出读命令。 执行wait_event_interruptible以挂起进程，直到intr标志变为1。 一定时间后，我们的设备发出中断信号以通知I/O操作已经完成，数据已经放在适当的DEV_FOO_DATA_PORT数据端口。中断处理程序置intr标志并唤醒进程。当调度程序决定重新执行这个进程时，foo_read()的第二部分被执行，步骤如下： 把准备在foo_dev-&gt;data变量中的字符拷贝到用户地址空间。 释放foo_dev-&gt;sem信号量后终止。 为了简单起见，没有包含任何超时控制。一般来说，超时控制是通过静态或动态定时器实现的；定时器必须设置为启动I/O操作后正确的时间，并在操作结束时删除。 foo_interrupt()函数的代码： 1234567irqreturn_t foo_interrupt(int irq, void *dev_id, struct pt_regs *regs){ foo-&gt;data = inb(DEV_FOO_DATA_PORT);//从设备的输入寄存器中读字符 foo-&gt;intr = 1; //设置intr标志 wake_up_interruptible(&amp;foo-&gt;wait); //调用`wake_up_interruptible()函数`唤醒在`foo-&gt;wait等待队列上`阻塞的进程。 return 1;} 中断处理程序从设备的输入寄存器中读字符，并把它存放在foo全局变量指向的驱动程序描述符foo_dev_t的data字段中。然后设置intr标志，并调用wake_up_interruptible()函数唤醒在foo-&gt;wait等待队列上阻塞的进程。注意：三个参数中没有一个被中断处理程序使用，这是其实是相当普遍的情况。 访问I/O共享存储器（内存映射）根据设备和总线的类型，现代PC体系结构里的I/O共享存储器可以被映射到不同的物理地址范围。主要有： 对于连接到ISA总线上的大多数设备 I/O共享存储器通常被映射到Oxa0000一Oxfffff的16位物理地址范围；这就在640 KB和1 MB之间留出了一段空间。 对连接到PCI总线上的设备 I/O共享存储器被映射到接近4GB的32位物理地址范围。这种类型的设备更加容易处理。 I/O共享存储器机制是极其重要的，因为建立好这些映射以后，访问设备接口中的存储器如同访问内存一样简单，就不需要那么多纷繁复杂的I/O交换了，大大提升了系统I/O处理的效率。 设备驱动程序如何访问一个I/O共享存储器单元？让我们从比较简单的PC体系结构开始人手，之后再扩展到其他体系结构。 不要忘了内核程序作用于线性地址，因此I/O共享存储器单元必须表示成大于PAGE_OFFSET的地址（？？？），这样，才有利于对I/O共享存储器单元的物理地址进行映射。我们假设PAGE_OFFSET等于Oxc0000000（在x86的32为体系中，实际上也是这样干的），也就是说，内核线性地址是在第4个GB。 设备驱动程序必须把I/O共享存储器单元的物理地址转换成内核空间的线性地址: 在PC体系结构中，这可以简单地把32位的物理地址和Oxc0000000常量进行或运算得到。 例如，假设内核需要把物理地址为Ox000b0fe4的I/O单元的值存放在t1中，把物理地址为Oxfc000000的I/O单元的值存放在t2中。你可能认为使用下面的表达式就可以完成这项工作： 12 t1 = *((unsigned char *)(0xc00b0fe4)); //括号里面的是线性地址 t2 = *((unsigned char *)(0xfc000000)); //强制转换为指针类型，也就是地址，然后再进行取地址所存的值 在初始化阶段，内核已经把可用的RAM物理地址映射到线性地址空间第4个GB的开始部分。因此，分页单元把出现在第一个语句中的线性地址OXCOObOfe4映射回到原来的I/O物理地址OXOOObOfe4，这正好落在从640KB到IMB的这段“ISA洞”中。这工作得很好。 但是，对于第二个语句来说，这里有一个问题，因为其I/O物理地址超过了系统RAM的最大物理地址（加上Oxc0000000常量会超过32位）。因此，线性地址Oxfc000000就不需要与物理地址Oxfc000000相对应。在这种情况下，为了在内核页表中包括对这个I/O物理地址进行映射的线性地址，必须对页表进行修改。这可以通过调用ioremap()或ioremap_nocache()函数来实现，第一个函数与vmalloc()函数类似，都调用get_vm_area()为所请求的I/O共享存储区的大小建立一个新的vm_struct描述符。然后，这两个函数适当地更新常规内核页表中的对应页表项。ioremap_nocache()不同于ioremap()，因为前者在适当地引用再映射的线性地址时还使硬件高速缓存内容失效。 因此，第二个语句的正确形式应该为： 12 io_mem = ioremap(0xfb000000, 0x200000); t2 = *((unsigned char *)(io_mem + 0x100000)); 第一条语句建立一个2MB的新的线性地址区间，该区间映射了从Oxfb000000开始的物理地址，第二条语句读取地址为Oxfc000000的内存单元。设备驱动程序以后要取消这种映射，就必须使用iounmap()函数。 在其他体系结构（PC之外的体系结构）上，简单地间接引用物理内存单元的线性地址并不能正确访问I/O共享存储器。因此，Linux定义了下列依赖于体系结构的函数，当访问I/O共享存储器时来使用它们： readb(), readw(), readl()：分别从一个I/O共享存储器单元读取1、2或者4个字节writeb(), writew(), writel()：分别向一个I/O共享存储器单元写入1、2或者4个字节memcpy_fromio(), memcpy_toio()：把一个数据块从一个I/O共享存储器单元拷贝到动态内存中，另一个函数正好相反memset_io()：用一个固定的值填充一个I/O共享存储器区域 最后，对于Oxfc000000 I/O单元的访问推荐使用这样的方法： 12 io_mem = ioremap(0xfb000000, 0x200000); t2 = readb(io_mem + 0x100000); 正是由于这些函数，就可以隐藏不同平台访问I/O共享存储器所用方法的差异。 //上面这一段话实在是太复杂了，现在总结一下； 一些概念IO空间与内存空间在X86处理器才存在IO空间，是相对于内存空间的概念。目前大多数嵌入式处理器（如ARM、PowerPC等）并不提供IO空间。所以内存空间是必须的，IO空间是可选的。嵌入式开发只关心内存空间即可。IO空间和内存空间是彼此独立的地址空间，在32位的X86处理器中，IO空间大小为64K ，内存空间为4G。 参考资料深入理解LINUX内核Linux下对IO内存的访问 //一些概念的介绍Linux内核开发之内存与I/O访问(一)","link":"/2020/06/29/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"Linux 设备驱动概述","text":"同类的东西，学习起来找共性就好了。学习Linux设备驱动，需要寻找各种驱动程序与系统的共性，探索其中的规律； 设备驱动的作用驱动程序的作用主要是实现硬件对软件工程师的隐形。 详细作用解释： 驱使硬件设备行动。 驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备记录文件和数据。 设备驱动充当了硬件和应用软件之间的纽带，它使得应用软件只需要调用系统软件的应用编程接口（API）就可以让硬件去完成要求的工作。 没有操作系统的情况，工程师可以根据硬件设备的特点自行定义接口，如对串口定义SerialSend()、SerialRecv()；对 LED 定义LightOn()、LightOff()；以及对 Flash 定义FlashWrite()、FlashRead()等。 有操作系统的情况，设备驱动的架构则由相应的操作系统定义，驱动工程师必须按照相应的架构设计设备驱动，这样，设备驱动才能良好地整合到操作系统的内核中。 无操作系统时的设备驱动对于功能比较单一、控制并不复杂的系统，如公交车刷卡机、电冰箱、微波、简单的手机和小灵通等，并不需要多任务调度、文件系统、内存管理等复杂功能，单任务架构完全可以很好地支持它们的工作。一个无限循环中夹杂对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构。 单任务软件典型架构 1234567891011121314151617181920212223int main(int argc,char* avgv[]){ while(1) { if(serialInt==1) // 有串口中断 { ProcessSerialInt(); //处理串口中断 serialInt=0; //中断标志变量清0 } if(keyInt==1) //有按键中断 { ProcessKeyInt(); //处理按键中断 keyInt=0; //中断标志标量清0 } status=CheckXXX(); switch(status) { . . . } . . . } } 这样的系统中，虽然不存在操作系统，但是设备驱动是必须存在的。 一般情况下，对每一种设备驱动都会定义为一个软件模块，包含.h文件和.c文件。 .h文件定义该设备驱动的数据结构并声明外部函数，.c文件进行设备驱动的具体实现。 举例：一个串口驱动serial.c serial.h，主要是配置GPIO，串口控制寄存器，以及串口的收发（读写）寄存器，而这几个配置都是自定义函数实现的，比如串口的写（发）SerialSend 函数等。 12345678910111213141516171819202122232425262728293031/***********************serial.h 文件**********************/extern void SerialInit(void);extern void SerialSend(const char buf*,int count);extern void SerialRecv(char buf*,int count);/***********************serial.c 文件**********************//* 初始化串口 */void SerialInit(void){...}/* 串口发送 */void SerialSend(const char buf*,int count){...}/* 串口接收 */void SerialRecv(char buf*,int count){...}/* 串口中断处理函数 */void SerialIsr(void){...serialInt = 1;} 其他模块需要使用这个设备的时候，只需要包含设备驱动的头文件 serial.h，然后调用其中的外部接口函数即可。如我们要从串口上发送字符串“Hello World”，使用函数SerialSend( “ Hello World “,11)即可。 这样子，在没有操作系统的情况下，设备驱动的接口被直接提交给了应用软件工程师， 应用软件没有跨越任何层次就直接访问了设备驱动的接口。 设备驱动包含的接口函数也与硬件的功能直接吻合， 没有任何附加功能。 有的工程师把单任务系统设计成设备驱动和具体的应用软件模块处于同一层次（即应用程序也在比如serial.c中实现），这显然是不合理的，不符合软件设计中高内聚低耦合的要求。另一种不合理的设计是直接在应用中操作硬件的寄存器（单独一个main.c，所有功能都在一个函数中实现，不采用其他任何接口/函数），而不单独设计驱动模块，这种设计意味着系统中不存在或未能充分利用可被重用的驱动代码。 有操作系统时的设备驱动当系统中包含操作系统后，设备驱动会变得怎样？ 首先，无操作系统时设备驱动的硬件操作工作仍然是必不可少的， 没有这一部分，设备驱动不可能与硬件打交道。 其次，我们还需要将设备驱动融入内核。为了实现这种融合，必须在所有的设备驱动中设计面向操作系统内核的接口。 这样的接口由操作系统规定，对一类设备而言结构一致，独立于具体的设备。 由此可见，当系统中存在操作系统的时候，设备驱动变成了连接硬件和内核的桥梁。 操作系统的存在势必要求设备驱动附加更多的代码和功能（主要是提供了很多结构），把单一的“驱使硬件设备行动”变成了操作系统内与硬件交互的模块，它对外呈现为操作系统的API，不再给应用软件工程师直接提供接口。 有了操作系统之后，设备驱动反而变得复杂，那要操作系统干什么？ 首先，一个复杂的软件系统需要处理多个并发的任务，没有操作系统，想完成多任务并发是很困难的。 其次，操作系统给我们提供内存管理机制。一个典型的例子是，对于多数含 MMU的处理器而言，Windows、Linux 等操作系统可以让每个进程都独立地访问 4GB的内存空间。 上述优点似乎并没有体现在设备驱动身上，操作系统的存在给设备驱动究竟带来了什么好处呢？ 简而言之，操作系统通过给设备驱动制造麻烦来达到给上层应用提供便利的目的。 如果设备驱动都按照操作系统给出的独立于设备的接口而设计，应用程序将可使用统一的系统调用接口来访问各种设备。 对于类UNIX的VxWorks、Linux等操作系统而言，应用程序通过write()、read()等函数读写文件就可以访问各种字符设备和块设备，而不用管设备的具体类型和工作方式，是非常方便的。 不管有无操作系统，不管是SerialSend，或者write，访问设备都需要对寄存器进行读写操作，比如串口，在dev目录下有个ttys0结点，我们可以通过ioctl函数对其进行读写操作，当然，write、read更为直接咯。而上层的应用可以对这些函数进行封装，定义不同的接口，从而实现更多的功能 Linux设备的分类及特点驱动针对的对象是存储器和外设（包括CPU 内部集成的存储器和外设），而不是针对CPU 内核。 多说一点，以前的通过总线挂载到cpu的一些设备，正在被逐渐集成到CPU上。随着IC 制作工艺的发展，目前，芯片的集成度越来越高，往往在CPU 内部就集成了存储器和外设适配器。譬如，相当多的ARM、PowerPC、MIPS 等处理器都集成了UART、I2C 控制器、SPI 控制器、USB 控制器、SDRAM 控制器等，有的处理器还集成了GPU（图形处理器）、视频编解码器等。 Linux 将存储器和外设分为3 个基础大类。 字符设备 字符设备指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等。 块设备 块设备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC 等。 网络设备 网络设备面向数据包的接收和发送而设计，它并不倾向于对应于文件系统的节点。内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，前者主要还是使用套接字接口。 Linux设备驱动与整个软硬件系统的关系如图所示，除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open()、write()、read()、close()等即可访问字符设备和块设备。所有字符设备和块设备都统一呈现给用户。 Linux的块设备有两种访问方法： 类似dd命令对应的原始块设备，如“/dev/sdb1”等； 在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径如“/home/barry/hello.txt”的形式进行访问。 在Linux中，针对NOR、NAND等提供了独立的内存技术设备（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡能力的文件系统。 针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。 应用程序可以使用Linux的系统调用接口编程，但也可使用C库函数，出于代码可移植性的目的，后者更值得推荐。 C库函数本身也通过系统调用接口而实现，如C库函数fopen()、fwrite()、fread()、fclose()分别会调用操作系统的API open()、write()、read()、close()。 Linux 设备驱动学习的重点、难点 好的硬件基础:懂得 SRAM、Flash、SDRAM、磁盘的读写方式，UART、I2C、USB 等设备的接口以及轮询、中断、DMA 的原理，PCI 总线的工作方式以及CPU 的内存管理单元（MMU）等。 好的 C 语言基础: 能灵活地运用 C 语言的结构体、指针、函数指针及内存动态申请和释放等。 一定的 Linux 内核基础:至少要明白驱动与内核的接口。尤其是对于块设备、网络设备、Flash 设备、串口设备等复杂设备，内核定义的驱动体系结构本身就非常复杂。 非常好的多任务并发控制和同步的基础:在驱动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。 资源与工具 类似http://lxr.free-electrons.com/、http://lxr.oss.org.cn/ 这样的网站提供了Linux 内核源代码的交叉索引，在其中输入Linux 内核中的函数、数据结构或变量的名称就可以直接得到以超链接形式给出的定义和引用它的所有位置。 一些网站也提供了Linux 内核中函数、变量和数据结构的搜索功能，在google 中搜索“linux identifier search ”可得。 Linux 主机上阅读和编辑Linux 源码的常用方式是vim + cscope 或者vim + ctags，vim是一个文本编辑器，而cscope 和ctags 则可建立代码索引 LED驱动示例（选看）无操作系统时的LED 驱动在嵌入式系统的设计中，LED 一般直接由CPU 的GPIO（通用可编程I/O）口控制。GPIO 一般由两组寄存器控制，即一组控制寄存器和一组数据寄存器。 控制寄存器可设置GPIO 口的工作方式为输入或者输出。 当引脚被设置为输出时，向数据寄存器的对应位写入1和0 会分别在引脚上产生高电平和低电平； 当引脚设置为输入时，读取数据寄存器的对应位可获得引脚上的电平为高或低。 假设: 在GPIO_REG_CTRL 物理地址中控制寄存器处的第n 位写入1 可设置GPIO 口为输出 在地址GPIO_REG_DATA 物理地址中数据寄存器的第n 位写入1 或0 可在引脚上产生高或低电平 则在无操作系统的情况下，设备驱动见代码3。 123456789101112131415161718192021//代码3#def ine reg_gpio_ctrl *(volatile int *)(ToVirtual(GPIO_REG_CTRL))#def ine reg_gpio_data *(volatile int *)(ToVirtual(GPIO_REG_DATA))// 程序中ToVirtual() 的作用是当系统启动了硬件MMU 之后，根据物理地址和虚拟地址的映射关系，将寄存器的物理地址转化为虚拟地址。/* 初始化LED */void LightInit(void){reg_gpio_ctrl |= (1 &lt;&lt; n); /* 设置GPIO 为输出 */}/* 点亮LED */void LightOn(void){reg_gpio_data |= (1 &lt;&lt; n); /* 在GPIO 上输出高电平 */}/* 熄灭LED */void LightOff(void){reg_gpio_data &amp;= ～ (1 &lt;&lt; n); /* 在GPIO 上输出低电平 */} 上述程序中的LightInit()、LightOn()、LightOff() 都直接作为驱动提供给应用程序的外部接口函数。 Linux 下的LED驱动在Linux 下，可以使用字符设备驱动的框架来编写对应于代码3的LED 设备驱动（这里仅仅是为了方便讲解，内核中实际实现了一个提供sysfs 节点的GPIO LED 驱动，位于drivers/leds/leds-gpio.c 中），操作硬件的LightInit()、LightOn()、LightOff() 函数仍然需要，但是，遵循Linux 编程的命名习惯，重新将其命名为light_init()、light_on()、light_off()。这些函数将被LED 设备驱动中独立于设备并针对内核的接口进行调用。 代码4，Linux 操作系统下的LED 驱动: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include .../* 包含内核中的多个头文件 *//* 设备结构体 */struct light_dev { struct cdev cdev; /* 字符设备cdev 结构体 */ unsigned char vaule; /* LED 亮时为1，熄灭时为0，用户可读写此值 */};struct light_dev *light_devp;int light_major = LIGHT_MAJOR;MODULE_AUTHOR(\"Barry Song &lt;21cnbao@gmail.com&gt;\");MODULE_LICENSE(\"Dual BSD/GPL\");/* 打开和关闭函数 */int light_open(struct inode *inode, struct file *filp){ struct light_dev *dev; /* 获得设备结构体指针 */ dev = container_of(inode-&gt;i_cdev, struct light_dev, cdev); /* 让设备结构体作为设备的私有信息 */ filp-&gt;private_data = dev; return 0;}int light_release(struct inode *inode, struct file *filp){ return 0;}/* 读写设备: 可以不需要 */ssize_t light_read(struct file *filp, char __user *buf, size_t count,loff_t *f_pos){ struct light_dev *dev = filp-&gt;private_data; /* 获得设备结构体 */ if (copy_to_user(buf, &amp;(dev-&gt;value), 1)) return -EFAULT; return 1;}ssize_t light_write(struct file *filp, const char __user *buf, size_t count,loff_t *f_pos){ struct light_dev *dev = filp-&gt;private_data; if (copy_from_user(&amp;(dev-&gt;value), buf, 1)) return -EFAULT; /* 根据写入的值点亮和熄灭LED */ if (dev-&gt;value == 1) light_on(); else light_off(); return 1;}/* ioctl 函数 */int light_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,unsigned long arg){ struct light_dev *dev = filp-&gt;private_data; switch (cmd) { case LIGHT_ON: dev-&gt;value = 1; light_on(); break; case LIGHT_OFF: dev-&gt;value = 0; light_off(); break; default: /* 不能支持的命令 */ return -ENOTTY; } return 0;}struct file_operations light_fops = { .owner = THIS_MODULE, .read = light_read, .write = light_write, .ioctl = light_ioctl, .open = light_open, .release = light_release,};/* 设置字符设备cdev 结构体 */static void light_setup_cdev(struct light_dev *dev, int index){ int err, devno = MKDEV(light_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;light_fops); dev-&gt;cdev.owner = THIS_MODULE; dev-&gt;cdev.ops = &amp;light_fops; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE \"Error %d adding LED%d\", err, index);}/* 模块加载函数 */int light_init(void){ int result; dev_t dev = MKDEV(light_major, 0); /* 申请字符设备号 */ if (light_major) result = register_chrdev_region(dev, 1, \"LED\"); else { result = alloc_chrdev_region(&amp;dev, 0, 1, \"LED\"); light_major = MAJOR(dev); } if (result &lt; 0) return result;/* 分配设备结构体的内存 */ light_devp = kmalloc(sizeof(struct light_dev), GFP_KERNEL); if (!light_devp) { result = -ENOMEM; goto fail_malloc; } memset(light_devp, 0, sizeof(struct light_dev)); light_setup_cdev(light_devp, 0); light_gpio_init(); return 0; fail_malloc: unregister_chrdev_region(dev, light_devp); return result;}/* 模块卸载函数 */void light_cleanup(void){ cdev_del(&amp;light_devp-&gt;cdev); /* 删除字符设备结构体 */ kfree(light_devp); /* 释放在light_init 中分配的内存 */ unregister_chrdev_region(MKDEV(light_major, 0), 1); /* 删除字符设备 */}module_init(light_init);module_exit(light_cleanup); 除了代码3 中的硬件操作函数仍然需要外，代码4 中还包含了大量暂时陌生的元素，如结构体file_operations、cdev，Linux 内核模块声明用的MODULE_AUTHOR、MODULE_LICENSE、module_init、module_exit，以及用于字符设备注册、分配和注销的函数register_chrdev_region()、alloc_chrdev_region()、unregister_chrdev_region() 等。我们也不能理解为什么驱动中要包含light_init ()、light_cleanup ()、light_read()、light_write() 等函数。此时，我们只需要有一个感性认识，那就是，上述暂时陌生的元素都是Linux 内核为字符设备定义的，以实现驱动与内核接口而定义的。Linux 对各类设备的驱动都定义了类似的数据结构和函数。 概括来说： 没有操作系统的时候，设备驱动编写的函数可以自己定义，对外提供给应用程序调用。 有了操作系统之后，设备驱动的内容就变多了，除了之前没有操作系统时候写的一些，还需要根据操作系统内核进行适配。这时候的驱动程序并不能直接和应用程序打交道了，而是和操作系统内核打交道，对外呈现出操作系统的API。 设备驱动都按照操作系统给出的独立于设备的接口而设计，应用程序将可使用统一的系统调用接口来访问各种设备。 也就是说这些接口的形式都是操作系统给出的，操作系统会对一类设备给出一致的接口，不会针对一个特定的设备给接口。 注解C 语言结构体，以点号开头： C99标准中的结构体初始化方法 ，结构体的乱许赋值，好像是GCC的扩展。 和linux无关，是一个C的问题，初始化的时候指定成员的名字，即使在结构体增加，插入字段的时候代码也可以正常工作。 参考资料《Linux设备驱动开发详解：基于最新的Linux 4.0内核》","link":"/2020/06/29/Linux-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A6%82%E8%BF%B0/"},{"title":"Linux程序的执行过程","text":"我们需要知道什么？ 进程的概念在UNIX中的表现就是一组程序竞争系统资源的行为。内核是如何通过程序文件的内容建立进程的执行上下文？一个程序执行的上下文到底是什么呢？ 虽然将一组指令装入内存让 CPU 执行看起来不是大问题，但内核还必须处理以下几方面的问题： 不同的可执行文件格式。Linux 可在 64 位版本的机器上执行 32 位可执行代码。 共享库。很多可执行文件并不包含执行程序所需的所有代码，而是期望内核在运行时从共享库中加载函数。 执行上下文的其它信息。这包括命令行参数与环境变量。 程序是以可执行文件(executable file)的形式存放在磁盘上的，可执行文件既包括被执行函数的目标代码，也包括这些函数所使用的数据。程序中的很多函数是所有程序员都可使用的服务例程，它们的目标代码包含在所谓“库”的特殊文件中: 实际上，一个库函数的代码或被静态地拷贝到可执行文件(静态库) 或在运行时被连接到进程(共享库，因为它们的代码由很多独立的进程所共享)。 当装入并运行一个程序时，用户可以提供影响程序执行方式的两种信息： 命令行参数：用户在shell提示符下紧跟文件名输入的就是命令行参数。 环境变量：环境变量(例如HOME和PATH)是从shell继承来的，但用户在装入并运行程序前可以修改任何环境变量。 接下来各部分的内容可执行文件：解释一个程序的执行上下文是什么。可执行格式：提及一些 Linux 所支持的可执行格式，并说明 Linux 如果改变它的“个性”以执行其它操作系统所编译的程序。exec 函数：描述执行一个新程序的进程所需的系统调用。 可执行文件进程可以定义为执行上下文。这也意味着进行特定的计算需要收集必要的信息，包括所访问的页，打开的文件，硬件寄存器的内容等。可执行文件是一个普通文件，描述了如何初始化一个新的执行上下文，也就是如何开始一个新的计算。 执行过程示例假如一位用户想在当前目录下面显示文件（我们知道用ls命令就可以），用户在shell提示符下只需要简单的敲出外部命令/bin/ls就可以了。这时候具体会发生什么呢？ 命令shell会创建一个新的进程，新的进程又会调用系统调用execve(),其中传递的一个参数就是ls可执行文件的全路径名（本例子中是/bin/ls） sys_exec()找到相应的文件，检查可执行的格式，并根据存放在其中的信息修改当前进程的上下文。 因此，当这个系统调用中止的时候，新的进程开始执行存放在可执行文件中的代码。本例子中是执行目录显示。 当一个进程开始新的程序的时候，它的执行上下文会发生很大的变化。因为进程的前一个计算执行期间所获得的大部分资源会被抛弃，但是进程的 PID 不改变，并且新的计算从前一个计算继承所有打开的文件描述符。 比方上面的示例，当进程开始执行/bin/ls时候，它用execve()系统调用传递来的新参数代替shell的参数，并获得一个新的shell环境。 然后从父进程继承来的所有的页（并通过写时复制机制实现共享）被释放，以便在一个新的用户态空间执行新的计算，甚至进程的特权都可能改变。 当前进程的PID是不会改变的，而且新的计算会继承从之前计算所有打开的文件描述符，当然这些文件描述符是之前执行execve()系统调用时还没有自动关闭的描述符。 进程的信任状和权能进程的信任状作用 信任状把进程与一个特定的用户或用户组捆绑在一起。 信任状在多用户系统上特别重要，因为信任状可以决定每个进程能做什么，不能做什么，保证了用户个人数据的完整性，也保证了系统整体上的稳定性。 信任状的使用需要进程数据结构方面给予支持，也需要被保护的资源方面给与支持。 比如文件，当某个进程试图访问一个文件，VFS总是根据文件的拥有者和进程的信任状所建立的许可权检查访问的合法性。 进程描述符中的信任状字段进程的信任状存放在进程描述符的几个字段中： 12345uid,gid 用户和组的实际标识符euid,egid 用户和组的有效标识符 fsuid,fsgid 文件访问的用户和组的有效标识符 groups 补充的组标识符suid,sgid 用户和组保存的标识符 说明： euid(effective user ID):当进程执行时间, 操作系统会对euid进行识别, 以此来判断到底用什么权限来执行这个进程. 值为0的uid指定给root用户，值为0的gid指定给root超级组。只要有关进程的信任状存放了一个零值，则内核将放弃权限检查，始终允许这个进程做任何事情，如涉及系统管理或硬件处理的那些操作，而这些操作对于非特权进程是不允许的。 setuid是类unix系统提供的一个标志位， 其实际意义是set一个process的euid为这个可执行文件或程序的拥有者(比如root)的uid， 也就是说当setuid位被设置之后， 当文件或程序(统称为executable)被执行时, 操作系统会赋予文件所有者的权限, 因为其euid是文件所有者的uid. setuid的方法是使用Linux的chmod指令，我们都习惯给予一个文件类似“0750” “0644” 之类的权限，它们的最高位0就是setuid的位置 比如 chmod 4750 文件名 当一个进程被创建时，总是继承父进程的信任状。 不过，这些信任状以后可以被修改，这发生在当进程开始执行一个新程序时，或者当进程发出合适的系统调用时。 通常情况下，进程的uid, euid, fsuid及suid字段具有相同的值。然而，当进程执行setuid程序时，即可执行文件的setuid标志被设置时，euid和fsuid字段被置为这个文件拥有者的标识符。几乎所有的检查都涉及这两个字段中的一个：fsuid用于与文件相关的操作，而euid用于其他所有的操作。这也同样适用于组标识符的gid、egid、fsgid及sgid字段。 如何使用fsuid字段考虑一下当用户想改变口令时的情况。所有的口令都存放在一个公共文件中，但用户不能直接编辑这样的文件，因为它是受保护的。因此使用如下操作： 户调用一个名为/usr/bin/passwd的系统程序，它可以设置setuid标志，而且它的拥有者是超级用户。 当shell创建的进程执行这样一个程序时，进程的euid和fsuid字段被置为0，即超级用户的PID。 现在，这个进程可以访问这个文件，因为当内核执行访问控制表时在fsuid字段发现了值。 当然，/usr/bin/passwd程序除了让用户改变自己的口令外，并不允许做其他任何事情。 系统调用怎样影响进程信任状从Unix的历史发展可以得出一个教训，即setuid程序是相当危险的：恶意用户可以以这样的方式触发代码中的一些bug，从而强迫setuid程序执行程序的最初设计者从未安排的操作。这可能常常危及整个系统的安全。为了减少这样的风险，Linux与所有现代Unix操作系统一样，让进程只有在必要时才获得setuid特权，并在不需要时取消它们。可以证明，当使用数个保护级别来实现用户应用程序时，这种特点是很有用的。进程描述符包含一个suid字段，在setuid程序执行以后在该字段中正好存放有效标识符(euid和fsuid)的值。进程可以通过setuid()、setresuid()、setfsuid()和setreuid()系统调用改变有效标识符。 下表显示了这些系统调用是怎样影响进程的信任状的。如果调用进程还没有超级用户特权，即它的euid字段不为0，那么，只能用这些系统调用来设置在这个进程的信任状字段已经有的值。例如，一个普通用户进程可以通过调用系统调用setfsuid()强迫它的fsuid值为500，但这只有在其他信任状字段中有一个字段已经有相同的值500时才行。 设置信任状的系统调用 setuid(e) setuid(e) 字段 euid = 0 euid != 0 setresuid(u,e,s) setresuid(u,e) setresuid(f) uid 设置为e 不改变 设置为u 设置为u 不改变 euid 设置为e 设置为e 设置为e 设置为e 不改变 fsuid 设置为e 设置为e 设置为e 设置为e 设置为f suid 设置为e 不改变 设置为s 设置为e 不改变 为了理解四个用户ID字段之间的关系，考虑setuid()系统调用的效果。 这些操作是不同的，这取决于调用者进程的euid字段是否被置为0(即进程有超级用户特权)或被置为一个正常的UID。 如果euid字段为0，这个系统调用就把调用进程的所有信任状字段(uid, euid, fsuid及suid)置为参数e的值。超级用户进程因此就可以删除自己的特权而变为由普通用户拥有的一个进程。 例如，在用户登录时，系统以超级用户特权创建一个新进程，但这个进程通过调用setuid()系统调用删除自己的特权，然后开始执行用户login shell程序。 如果euid字段不为0，那么这个系统调用只修改存放在euid和fsuid中的值，让其他两个字段保持不变。 当运行setuid程序来提高和降低进程有效权限时(这些权限存放在euid和fsuid字段)，该系统调用的这种功能是非常有用的。 进程的权能（可选看）这个在linux中不怎么用。“权能(capability )”一词引人进程信任状的另一种模型。Linux内核支持POSIX权能，一种权能仅仅是一个标志，它表明是否允许进程执行一个特定的操作或一组特定的操作。这个模型不同于传统的“超级用户VS普通用户”模型，在后一种模型中，一个进程要么能做任何事情，要么什么也不能做，这取决于它的有效UID。在Linux内核中已包含了很多权能。权能的主要优点是，任何时候每个进程只需要有限种权能。因此，即使有恶意的用户发现一种利用有潜在错误的程序的方法，他也只能非法地执行有限个操作类型。 命令含参数和 shell 环境当用户键入一个命令时，为满足这个请求而装入的程序可以从shell接收一些命令行参数(command-line argument)。例如: 当用户键入命令:$ ls -l /usr/bin以获得/usr/bin目录下的全部文件列表时，shell进程创建一个新进程执行这个命令。 这个新进程装入/bin/ls可执行文件。在这样做的过程中，从shell继承的大多数执行上下文被丢弃，但三个单独的参数ls、-l和/usr/bin依然保持。 一般情况下，新进程可以接收任意多个参数。传递命令行参数的约定依赖于所用的高级语言。 传递命令行参数在C语言中，程序的main()函数把传递给程序的参数个数和指向字符串指针数组的地址作为参数。下列原型形式化地表示了这种标准格式: 1int main(int argc，char *argv[]) 回到前面的例子: 当/bin/ls程序被调用时，argc的值为3, argv[0]指向”ls”字符串，argv[1]指向”-l”字符串，而argv[2]指向”/usr/bin”字符串。 argv数组的末尾处总以空指针来标记，因此，argv[3]为NULL。 在C语言中，传递给main()函数的第三个可选参数是包含环境变量的参数。 传递环境变量参数环境变量用来定制进程的执行上下文，由此为用户或其他进程提供通用的信息，或者允许进程在执行execve()系统调用的过程中保持一些信息。为了使用环境变量，main ()可以声明如下： 1int main(int argc，char *argv()，char *envp[]) envp参数指向环境串的指针数组，形式如下： 1VAR_NAME=something 说明： VAR_NAME表示一个环境变量的名字，而“=”后面的子串表示赋给变量的实际值。 envp数组的结尾用空指针标记，就像argv数组。envp数组的地址存放在C库的environ全局变量中。 命令行参数和环境串都存放在用户态堆栈中，正好位于返回地址之前。 下图显示了用户态堆栈的底部单元。环境变量位于栈底附近正好在一个长整数0(即图中的NULL)之后。 库每个高级语言的源码文件都是经过几个步骤才转化为目标文件的（.o文件），目标文件中包含的是汇编语言指令的机器代码，它们和相应的高级语言指令对应。 目标文件并不能被执行，因为它不包含源代码文件所用的全局外部符号名的线性地址，例如库函数或同一程序中的其他源代码文件。 这些地址的分配或解析是由链接程序完成的，链接程序把程序所有的目标文件收集起来并构造可执行文件。 链接程序还分析程序所用的库函数，并以本章后面所描述的方式把它们粘合成可执行文件。 大多数程序，甚至是最小的程序都会利用C库。 例如下面只有一行的C程序： 1void main(void){} 尽管这个程序没有做任何事情，但还是需要做很多工作来建立执行环境，并在程序终止时杀死这个进程。尤其当main()函数终止时，C编译程序把exit_group()函数插入到目标代码中。程序通常通过C库中的封装例程调用系统调用，C编译器亦如此。 任何可执行文件除了包括对程序的语句进行编译所直接产生的代码外，还包括一些“粘合”代码来处理用户态进程与内核之间的交互。这样的粘合代码有一部分存放在C库中。除了C库，Unix系统中还包含很多其他的函数库。一般的Linux系统通常就有几百个不同的库。 传统Unix系统中的所有可执行文件都是基于静态库(static library)的。这意味着链接程序所产生的可执行文件不仅包括原程序的代码，还包括程序所引用的库函数的代码。静态库的一大缺点是它们占用大量的磁盘空间。因为每个静态链接的可执行文件都复制库代码的某些部分。现代Unix系统利用共享库(shared library)。可执行文件不用再包含库的目标代码，而仅仅指向库名。当程序被装入内存执行时，一个名为动态链接器(dynamic linker，也叫ld.so)的程序就专注于分析可执行文件中的库名，确定所需库在系统目录树中的位置，并使执行进程可以使用所请求的代码。进程也可以使用dlopen()库函数在运行时装入额外的共享库。 共享库的优点： 共享库对提供文件内存映射的系统尤为方便，因为它们减少了执行一个程序所需的主内存量。 当动态链接程序必须把某一共享库链接到进程时，并不拷贝目标代码，而是仅仅执行一个内存映射，把库文件的相关部分映射到进程的地址空间中。这就允许共享库机器代码所在的页框被使用同一代码的所有进程共享。如果程序是静态链接的，那么共享是不可能的。 共享库的缺点: 动态链接的程序启动时间通常比静态链接的程序长。 动态链接的程序的可移植性也不如静态链接的好，因为当系统中所包含的库版本发生变化时，动态链接的程序运行时就可能出现问题。 如何编译的时候只使用静态链接： 用户可以始终请求一个程序被静态地链接。例如，GCC编译器提供-static选项，即告诉链接程序使用静态库而不是共享库。程序段和进程的线性区从逻辑上说，Unix程序的线性地址空间传统上被划分为几个叫做段(segment)的区间： 正文段 包含程序的可执行代码。 己初始化数据段 包含已初始化的数据，也就是初值存放在可执行文件中的所有静态变量和全局变量(因为程序在启动时必须知道它们的值)。 未初始化数据段(bss段) 包含未初始化的数据，也就是初值没有存放在可执行文件中的所有全局变量，因为程序在引用它们之前才赋值，历史上把这个段叫做bss段。 堆栈段 包含程序的堆栈，堆栈中有返回地址、参数和被执行函数的局部变量。 每个mm_struct内存描述符都包含一些字段来标识相应进程特定线性区的作用：start_code，end_code：程序的源代码所在线性区的起始和终止线性地址，即可执行文件中的代码。start_data，end_data：程序的初始化数据所在线性区的起始和终止线性地址，正如在可执行文件中所指定的那样。这两个字段指定的线性区大体上与数据段对应。start_brk，brk：存放线性区的起始和终止线性地址，该线性区包含动态分配给进程的内存区。有时把这部分线性区叫做堆。start_stack：正好在main()的返回地址之上的地址。更高的地址被保留(栈向低地址增长)。arg_start，arg_end：命令行参数所在的堆栈部分的起始地址和终止地址。env_start，env_end：环境串所在的堆栈部分的起始地址和终止地址。 可执行格式Linux标淮的可执行格式是ELF(Executable and Linking Format)，它由Unix系统实验室开发并在Unix世界相当流行。著名的Unix操作系统都把ELF作为它们的主要可执行格式。Linux的旧版支持另一种名叫Assembler OUTput Format (a.out)的格式。因为现在ELF非常实用，因此已经很少用a.out格式。 Linux支持很多其他不同格式的可执行文件。 在这种方式下，Linux能运行为.其他操作系统所编译的程序，如MS-DOS的EXE程序。 有几种可执行格式，如Java或bash脚本，是与平台无关的。 由类型为linux_binfmt的对象所描述的可执行格式实质上提供以下三种方法： load_binary 通过读存放在可执行文件中的信息为当前进程建立一个新的执行环境。 load_shlib 用于动态地把一个共享库捆绑到一个已经在运行的进程，这是由uselib()系统调用激活的。 core_dump 在名为core的文件中存放当前进程的执行上下文。这个文件通常在进程接收到缺省操作为“dump”的信号时被创建，格式取决于被执行程序的可执行类型。 所有的linux binfmt对象都处于一个单向链表中。 链表第一个元素的地址：存放在formats变量中。 插入和删除元素：通过调用register_binfmt()和unregister_binfmt()函数在链表中插入和删除元素。 在系统启动期间，为每个编译进内核的可执行格式都执行register_binfmt()函数。 当实现了一个新的可执行格式的模块正被装载时，也执行这个函数，当模块被卸载时，执行unregister_binfmt()函数。 在formats链表中的最后一个元素:是对解释脚本的可执行格式进行描述的一个对象。 这种格式只定义了load_binary方法。其相应的load_script()函数检查这种可执行文件是否以两个#!字符开始。如果是，这个函数就把第一行的其余部分解释为另一个可执行文件的路径名，并把脚本文件名作为参数传递以执行它。 自定义的可执行格式Linux允许用户注册自己定义的可执行格式: 对这种格式的识别或者通过存放在文件前128字节的魔数，或者通过表示文件类型的扩展名。例如，MS-DOS的扩展名由“.”把三个字符从文件名中分离出来：.exe扩展名标识可执行文件，而.bat扩展名标识shell脚本。 如何执行当内核确定可执行文件是自定义格式时，它就启动相应的解释程序。解释程序运行在用户态，读入可执行文件的路径名作为参数，并执行计算。例如，包含Java程序的可执行文件就由Java虚拟机(如//usr/lib/Java/bin/Java)来解释。 建立自定义可执行格式这种机制与脚本格式类似，但功能更加强大，这是因为它对自定义格式不加任何限制。要注册一个新格式，就必须在binfmt_misc文件系统的注册文件内写人一个字符串，其格式为： 1 name:type:offset:string:mask:interpreter:flags 每个字段的含义如下： 1234567name: 新格式的标识符。type: 识别类型(M表示魔数，E表示扩展)。offset: 魔数在文件中的起始偏移量。string: 以魔数或者以扩展名匹配的字节序列。mask: 用来屏蔽掉string中的一些位的字符串。interpreter: 解释程序的完整路径名。flags: 可选标志，控制必须怎样调用解释程序。 例如，超级用户执行的下列命令将使内核识别出Microsoft Windows的可执行格式: 1echo :DOSWin:M:O:MZ:Oxff:/usr/bin/wine:’&gt;/proc/sys/fs/binfmt misc/register Windows可执行文件的前两个字节是魔数MZ，由解释程序/usr/bin/wine执行这个可执行文件。 执行域Linux的一个巧妙的特点就是能执行其他操作系统所编译的程序。当然，只有内核运行的平台与可执行文件包含的机器代码对应的平台相同时这才是可能的。对这些“外来”程序提供两种支持： 模拟执行(emulated execution)：程序中包含的系统调用与POSIX不兼容时才有必要执行这种程序。 原样执行(native execution)：只有程序中所包含的系统调用完全与POSIX兼容时才有效。 模拟执行的例子Microsoft MS-DOS和Windows程序是被模拟执行的，因为它们包含的API不能被Linux所认识，因此不能原样执行。像DOSemu或Wine这样的模拟程序被调用来把每个API调用转换为一个模拟的封装函数调用，而封装函数调用又使用现有的Linux系统调用。 原样执行的例子另一方面，不用太费力就可以执行为其他操作系统编译的与POSIX兼容的程序，因为与POSIX兼容的操作系统都提供了类似的API。 内核必须消除的细微差别通常涉及如何调用系统调用或如何给各种信号编号。这种信息存放在类型为exec_domain的执行域描述符中。 进程可以指定它的执行域： 通过设置进程描述符的personality字段，以及把相应exec_domain数据结构的地址存放到thread_info结构的exec_domain字段来实现的。 进程可以通过发布一个personality()系统调用来改变它的个性(personality)。 程序员通常不希望直接改变其程序的个性;相反，应该通过建立进程的执行上下文的“粘合”代码来发出personality()系统调用。//待定 灵活线性布局(可选看)灵活线性区布局(flexible memory region lagout)在内核版本2.6.9中引人。实际上，每个进程均是按照用户态堆栈预期的增长量来进行内存布局的。但是仍然可以使用老的经典布局(主要用于当内核无法限制进程用户态堆栈的大小时)。 下表是80x86结构的默认用户态地址空间为例描述了这两种布局，地址空间最大可以到3GB。布局之间只在文件内存映射与匿名映射时线性区的位置上有区别。 x86结构的线性布局: 线性区种类 经典布局 灵活布局 正文段(ELF) 开始于：0x08048000 开始于：0x08048000 数据与bss段 开始于：紧接正文段之后 开始于：紧接正文段之后 堆 开始于：紧接数据与bss段之后 开始于：紧接数据与bss段之后 文件内存映射与匿名线性区 开始于：0x40000000(该地址对应整个用户地址空间的1/3)，库连续往高地址追加 开始于：紧接用户态堆栈尾(最小地址)，库连续往低地址追加 用户态堆栈 开始于：OxC0000000并向低地址增长 开始于：OxC0000000并向低地址增长 在经典布局下，这些区域从整个用户态地址空间的1/3开始，通常在地址0x40000000。新的区域往更高线性地址追加，因此，这些区域往用户态堆栈方向扩展。相反的是，在灵活布局中，文件内存映射与匿名映射的线性区是紧接用户态堆栈尾的。新的区域往更低线性地址追加，因此，这些区域往堆的方向扩展。因为堆栈也是连续往低地址追加的。 当内核能通过RLIMIT_STACK资源限制来限定用户态堆栈的大小时，通常使用灵活布局这个限制确定了为堆栈保留的线性地址空间大小。但是这个空间大小不能小于128MB或大于2.5GB。另外，如果RLIMIT_STACK资源限制设为无限(infinity)，或者系统管理员将sysctl_legacy_va_layout变量设为1(通过修改/proc/sys/vm/legacy_va_layout文件或调用相应的sysctl()系统调用实现)，内核无法确定用户态堆栈的上限，就仍然使用经典线性区布局。 引入灵活布局的主要优点在于：可以允许进程更好地使用用户态线性地址空间。 在经典布局中，堆的限制是小于1GB，而其他线性区可以使用到约2GB(减去堆栈大小)。 在灵活布局中，没有这些限制，堆和其他线性区可以自由扩展，可以使用除了用户态堆栈和程序用固定大小的段以外的所有线性地址空间。 参考资料深入理解Linux内核中文版（第三版）linux内核学习之七 可执行程序的装载和运行Linux中的setuid简介进程的虚拟内存，物理内存，共享内存进程虚拟内存空间—线性区的数据结构linux下的三种可执行文件格式的比较linux 如何运行一个可执行文件深入理解Linux内核(完整版)-笔记","link":"/2020/07/04/Linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"title":"Linux程序执行相关函数-exec函数","text":"类Unix系统提供了一系列函数，这些函数能用可执行文件所描述的新上下文代替进程的上下文。这样的函数名以前缀exec开始，后跟一个或两个字母。 exec族函数下表列出了exec族函数，它们之间的差别在于如何解释参数。 函数名 路径搜索 命令行参数 环境数组 execl() 否 列表 否 execlp() 是 列表 否 execle() 否 列表 是 execv() 否 数组 否 execvp() 是 数组 否 execve() 否 数组 是 参数说明第一个参数每个函数的第一个参数表示被执行文件的路径名。 路径名可以是绝对路径或是当前进程目录的相对路径。 此外，如果路径名中不包含“/”字符，execlp()和execvp()函数就在PATH环境变量指定的所有目录中搜索这个可执行文件。 execl(), execlp()和exec1e()中间的参数除了第一个参数，execl(), execlp()和exec1e()函数包含的其他参数个数都是可变的。 每个参数指向一个字符串，这个字符串是对新程序命令行参数的描述，正如函数名中“l”字符所隐含的一样，这些参数组织成一个列表，最后一个值为NULL。 通常情况下，第一个命令行参数复制可执行文件名。 execv(), execvp()和execve()的第二个参数相反，execv(), execvp()和execve()函数指定单个参数的命令行参数，正如函数名中的“v”字符所隐含的一样，这单个参数是指向命令行参数串的指针向量地址。 数组的最后一个元素必须存放NULL值。 最后一个参数execle()和execve()函数的最后一个参数是指向环境串的指针数组的地址：数组的最后一个元素照样必须为NULL。其他函数对新程序环境参数的访问是通过C库定义的外部全局变量environ进行的。 所有的exec函数(除execve()外)都是C库定义的封装例程，并利用了execve()系统调用，这是Linux所提供的处理程序执行的唯一系统调用。 sys_execve()服务sys_execve()服务例程接收下列参数： 可执行文件路径名的地址(在用户态地址空间)。 以NULL结束的字符串指针数组的地址(在用户态地址空间)，每个字符串表示一个命令行参数。 以NULL结束的字符串指针数组的地址(也在用户态地址空间)。每个字符串以NAME = value形式表示一个环境变量。 sys_execve()执行过程sys_execve()把可执行文件路径名拷贝到一个新分配的页框。然后调用do_execve()函数，传递给它的参数为指向这个页框的指针、指针数组的指针及把用户态寄存器内容保存到内核态堆栈的位置。 do_execve()do_execve()依次执行下列操作： 动态地分配一个linux_binprn数据结构，并用新的可执行文件的数据填充linux_binprn数据结构。 调用path_lookup(), dentry_open()和path_release()，以获得与可执行文件相关的目录项对象、文件对象和索引节点对象。如果失败，则返回相应的错误码。 检查是否可以由当前进程执行该文件，再检查索引节点的i_writecount字段，以确定可执行文件没被写入;把-1存放在这个字段以禁止进一步的写访问。 在多处理器系统中，调用sched_exec()函数来确定最小负载CPU以执行新程序，并把当前进程转移过去。 调用ini_new_context()检查当前进程是否使用自定义局部描述符表。如果是，函数为新程序分配和淮备一个新的LDT。 调用prepare_binprm()函数填充linux_binprm数据结构，这个函数又依次执行下列操作： 再一次检查文件是否可执行(至少设置一个执行访问权限)。如果不可执行，则返回错误码(因为带有CAP_DAC_OVERRIDE权能的进程总能通过检查，所以第3步中的检查还不够。 初始化linux_binprm结构的e_uid和e_gid字段，考虑可执行文件的setuid和setgid标志的值。这些字段分别表示有效的用户ID和组ID。也要检查进程的权能。 用可执行文件的前128字节填充linux_binprm结构的buf字段。这些字节包含的是适合于识别可执行文件格式的一个魔数和其他信息。 把文件路径名、命令行参数及环境串拷贝到一个或多个新分配的页框中，最终它们会被分配给用户态地址空间。 调用search_binary_handler()函数对formats链表进行扫描，并尽力应用每个元素的load_binary方法，把linux_binprm数据结构传递给这个函数。只要load_binary方法成功应答了文件的可执行格式，对formats的扫描就终止。 如果可执行文件格式不在formats链表中，就释放所分配的所有页框并返回错误码 -ENOEXEC，表示Linux不认识这个可执行文件格式。 否则，函数释放linux_binprm数据结构，返回从这个文件可执行格式的load_binary方法中所获得的代码。 load_binary方法可执行文件格式对应的load_binary方法执行下列操作(假定这个可执行文件所在的文件系统允许文件进行内存映射并需要一个或多个共享库)： 检查存放在文件前128字节中的一些魔数以确认可执行格式。如果魔数不匹配，则返回错误码 -ENOEXEC。 读可执行文件的首部。这个首部描述程序的段和所需的共享库。 从可执行文件获得动态链接程序的路径名，并用它来确定共享库的位置并把它们映射到内存。 获得动态链接程序的目录项对象，也就获得了索引节点对象和文件对象。 检查动态链接程序的执行许可权。 把动态链接程序的前128字节拷贝到缓冲区。 对动态链接程序类型执行一些一致性检查。 调用flush_old_exec()函数释放前一个计算所占用的几乎所有资源。这个函数又依次执行下列操作： 如果信号处理程序的表为其他进程所共享，那么就分配一个新表并把旧表的引用计数器减1;而且它将进程从旧的线程组脱离。这是通过调用de_ thread()函数完成的。 如果与其他进程共享，就调用unshare_files()拷贝描述进程已打开文件的files_struct结构。 调用exec_mmap()函数释放分配给进程的内存描述符、所有线性区及所有页框，并清除进程的页表。 将可执行文件路径名赋给进程描述符的comm字段。 用flush_thread()函数清除浮点寄存器的值和在TSS段保存的调试寄存器的值。 调用flush_signal_handlers()函数，用于将每个信号恢复为默认操作，从而更新信号处理程序的表。 调用flush_old_files()函数关闭所有打开的文件，这些打开的文件在进程描述符的files-&gt;close_on_exec字段设置了相应的标志。现在，已经不能返回了，如果真出了差错，这个函数再不能恢复前一个计算 清除进程描述符的PF_FORKNOEXEC标志。这个标志用于在进程创建时设置进程记账，在执行一个新程序时清除进程记账。 设立进程新的个性，即设置进程描述符的personality字段。 调用arch_pick_mmap_layout()，以选择进程线性区的布局。 调用setup_arg_pages()函数为进程的用户态堆栈分配一个新的线性区描述符，并把那个线性区插入到进程的地址空间。setup_arg_pages()还把命令行参数和环境变量串所在的页框分配给新的线性区。 调用do_map()函数创建一个新线性区来对可执行文件正文段(即代码)进行映射。这个线性区的起始线性地址依赖于可执行文件的格式，因为程序的可执行代码通常是不可重定位的。因此，这个函数假定从某一特定逻辑地址的偏移量开始装入正文段。ELF程序被装入的起始线性地址为0x080480000。 调用do_mmap()函数创建一个新线性区来对可执行文件的数据段进行映射。这个线性区的起始线性地址也依赖于可执行文件的格式，因为可执行代码希望在特定的偏移量(即特定的线性地址)处找到它自己的变量。在ELF程序中，数据段正好被装在正文段之后。 为可执行文件的其他专用段分配另外的线性区，通常是无。 调用一个装入动态链接程序的函数。如果动态链接程序是ELF可执行的，这个函数就叫做load_elf_interp()。一般情况下，这个函数执行第12-14步的操作，不过要用动态链接程序代替被执行的文件。动态链接程序的正文段和数据段在线性区的起始线性地址是由动态链接程序本身指定的，但它们处于高地址区(通常高于0x40000000)，这是为了避免与被执行文件的正文段和数据段所映射的线性区发生冲突。 把可执行格式的linux_binfmt对象的地址存放在进程描述符的binfmt字段中。 确定进程的新权能。 创建特定的动态链接程序表并把它们存放在用户态堆栈，这些表处于命令行参数和指向环境串的指针数组之间。 设置进程的内存描述符的start_code、end_code、start_data、end_data、start_brk、brk及start_stack字段。 调用do_brk()函数创建一个新的匿名线性区来映射程序的bss段(当进程写入一个变量时，就触发请求调页，进而分配一个页框)。这个线性区的大小是在可执行程序被链接时就计算出来的。因为程序的可执行代码通常是不可重新定位的，因此，必须指定这个线性区的起始线性地址。在ELF程序中，bss段正好装在数据段之后。 调用start_thread()宏修改保存在内核态堆栈但属于用户态寄存器的eip和esp的值，以使它们分别指向动态链接程序的入口点和新的用户态堆栈的栈顶。 如果进程正被跟踪，就通知调试程序execve()系统调用已完成。 返回0(成功)。 当execve()系统调用终止且调用进程重新恢复它在用户态的执行时，执行上下文被大幅度改变，调用系统调用的代码不复存在。从这个意义上看，我们可以说execve()从未成功返回。取而代之的是，要执行的新程序已被映射到进程的地址空间。但是，新程序还不能执行，因为动态链接程序还必须考虑共享库的装载。 如果可执行文件是静态链接的，即如果不需要共享库，load_binary方法只需将程序的正文段、数据段、bss段和堆栈段映射到进程线性区，然后把用户态eip寄存器的内容设置为新程序的入口点即可。 动态链接程序如何运作尽管动态链接程序运行在用户态，但我们还要在这里简要概述一下动态链接程序是如何运作的。 它的第一个工作就是从内核保存在用户态堆栈的信息(处于环境串指针数组和arg start之间)开始，为自己建立一个基本的执行上下文。 然后，动态链接程序必须检查被执行的程序，以识别哪个共享库必须装入及在每个共享库中哪个函数被有效地请求。 接下来，解释器发出几个mmap()系统调用来创建线性区，以对将存放程序实际使用的库函数(正文和数据)的页进行映射。 然后，解释器根据库的线性区的线性地址更新对共享库符号的所有引用。 最后，动态链接程序通过跳转到被执行程序的主入口点而终止它的执行。 从现在开始，进程将执行可执行文件的代码和共享库的代码。 注解魔数：就是一个标识作用的信息。 linux中魔数的作用 参考资料Linux程序的执行过程深入理解Linux内核中文版（第三版）","link":"/2020/07/05/Linux%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-exec%E5%87%BD%E6%95%B0/"},{"title":"Linux程序调试-GDB调试器","text":"我们需要知道什么？ GDB是什么？有什么作用呢？GDB的用法有哪些？ GDB的功能GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具，GDB主要可帮助工程师完成下面4个方面的功能。 启动程序，并给定初始化的环境，可以按照工程师自定义的要求运行程序。 设置断点，让被调试的程序在工程师指定的断点处停住，断点可以是条件表达式。 查询程序执行的各种数据，当程序被停住时，可以检查此时程序中所发生的事，并追踪上文。 动态地改变程序的执行环境。 不管是调试Linux内核空间的驱动还是调试用户空间的应用程序，都必须掌握GDB的用法。在调试内核和调试应用程序时使用的GDB命令是完全相同的。 用于调试的代码以下面代码表示的应用程序为例演示GDB调试器的用法。 1234567891011121314151617int add(int a, int b){ return a + b;}int main(){ int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; int i; int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90}; int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4}; for (i = 0; i &lt; 10; i++) { sum[i] = add(array1[i], array2[i]); } return 0;} 使用下面的命令编译上述程序，得到包含调试信息的二进制文件gdb_example。注意：编译程序时需要加上-g，之后才能用gdb进行调。 1gcc -g gdb_example.c -o gdb_example ps： -c和-o是gcc编译器的可选参数。 -c表示只编译源文du件但不链接，会把.c或.cc的c源程序编译成目标文件，一般是.o文件。 -o用于指定输出文件名。不用-o的话，一般会在当前文件夹下生成默认的a.out文件作为可执行程序。 执行下面的命令进入调试状态 1gdb gdb_example 然后会出现如下效果 12345678910111213141516root@ubuntu:~/cpptest# gdb gdb_example GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-gitCopyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from gdb_example...done. 调试示例： 12345678910111213141516(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3.(gdb) runStarting program: /root/cpptest/gdb_example Breakpoint 1, add (a=48, b=85) at gdb_example.c:33 return a + b;(gdb) next4 }(gdb) nextmain () at gdb_example.c:1212 for (i = 0; i &lt; 10; i++)(gdb) next14 sum[i] = add(array1[i], array2[i]);(gdb) print sum$1 = {133, 0, 0, 0, 0, 0, 0, 0, 0, 0} GDB相关命令list命令作用：在GDB中运行list命令可以列出代码list的具体形式如下: list&lt;linenum&gt;：用于显示程序第linenum行周围的源程序（我的测试是一共显示10行）。效果如下所示：1234567891011(gdb) list 8 //列出文件第九行附近的代码3 return a + b;4 }5 int main()6 {7 int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0};8 int i;9 int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90};10 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4};11 12 for (i = 0; i &lt; 10; i++) list&lt;function&gt;：显示函数名为function的函数对应的源程序。如下所示：1234567891011(gdb) list main1 int add(int a, int b)2 {3 return a + b;4 }5 int main()6 {7 int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0};8 int i;9 int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90};10 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4}; 说明: list， 显示当前行后面的源程序。 list-，显示当前行前面的源程序。 examine命令examine命令来查看内存地址中的值,在GDB中使用的时候缩写为x。examine命令格式： 1x/&lt;number/format/u&gt; &lt;addr&gt; 参数说明 表示一个内存地址。 “x/”后的n、f、u都是可选的参数。 number是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容； format表示显示的格式，和c语言中的格式缩写一样： 如果地址所指的是字符串，那么格式可以是s 如果地址是指令地址，那么格式可以是i； d:整数integer s:字符串string c:字符char u:无符号整数 unsigned integer o:八进制格式显示变量 x:十六进制格式 f: 浮点数格式float u表示从当前地址往后请求的字节数，如果不指定的话，GDB默认的是4字节。 u参数可以被一些字符代替： b表示单字节 h表示双字节 w表示四字节 g表示八字节。 当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来 number，format，u这3个参数可以一起使用,如下面示例所示。 示例： 12(gdb) x/3uh 0x54320效果：表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。 set命令set命令用于修改内存。它的命令格式是: 1set *有类型的指针=value 比如，下列程序，在用gdb运行起来后，通过Ctrl+C停住。 12345main(){void *p = malloc(16);while(1);} 我们可以在运行中用如下命令来修改p指向的内存。 12345(gdb) set *(unsigned char *)p='h' //令p是指向无符号字符的指针变量(gdb) set *(unsigned char *)(p+1)='e'(gdb) set *(unsigned char *)(p+2)='l'(gdb) set *(unsigned char *)(p+3)='l'(gdb) set *(unsigned char *)(p+4)='o' 看看结果： 12(gdb) x/s p0x804b008: \"hello\" 也可以直接使用地址常数： 123456789(gdb) p p //print命令（缩写为p）$2 = (void *) 0x804b008(gdb) set *(unsigned char *)0x804b008='w'(gdb) set *(unsigned char *)0x804b009='o'(gdb) set *(unsigned char *)0x804b00a='r'(gdb) set *(unsigned char *)0x804b00b='l'(gdb) set *(unsigned char *)0x804b00c='d'(gdb) x/s 0x804b0080x804b008: \"world\" run命令在GDB中，运行程序使用run命令。在程序运行前，我们可以设置如下4方面的工作环境。 程序运行参数set args可指定运行时参数，如1set args 10 20 30 40 50； show args命令可以查看设置好的运行参数。 运行环境path&lt;dir&gt;可设定程序的运行路径；how paths可查看程序的运行路径；set environment varname[=value]可设置环境变量，如set env USER=baohua；show environment[varname]则可查看环境变量。 工作目录cd&lt;dir&gt;相当于shell的cd命令，pwd可显示当前所在的目录。 程序的输入输出info terminal用于显示程序用到的终端的模式；在GDB中也可以使用重定向控制程序输出，如run&gt;outfile；用tty命令可以指定输入输出的终端设备，如tty /dev/ttyS1。 break命令在GDB中用break命令来设置断点，设置断点的方法如下： break&lt;function&gt;：在进入指定函数时停住。 在C++中可以使用class::function或function（type，type）格式来指定函数名。12(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3. break &lt;linenum&gt;：在指定行号停住。12(gdb) break 12Breakpoint 2 at 0x752: file gdb_example.c, line 12. break +offset/break -offset:在当前行号的前面或后面的offset行停住，offiset为自然数。 break filename：linenum ：在源文件filename的linenum行处停住。 break filename：function ：在源文件filename的function函数的入口处停住。 break *address ：在程序运行的内存地址处停住。123(gdb) break *0x0000000000000674Note: breakpoint 1 also set at pc 0x674.Breakpoint 7 at 0x674: file gdb_example.c, line 3. break：break命令没有参数时，表示在下一条指令处停住。 break … if&lt;condition&gt; …可以是上述的break、break+offset/break–offset中的参数 condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i=100，表示当i为100时停住程序。 查看断点时，可使用info命令，如info breakpoints[n]、info break[n]（n表示断点号）。 1234567891011121314(gdb) info breakNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000000674 in add at gdb_example.c:32 breakpoint keep y 0x0000000000000752 in main at gdb_example.c:123 breakpoint keep y 0x0000000000000689 in main at gdb_example.c:54 breakpoint keep y 0x0000000000000752 in main at gdb_example.c:125 breakpoint keep y 0x000000000000070c in main at gdb_example.c:106 breakpoint keep y 0x0000000000000698 in main at gdb_example.c:7(gdb) info break 5Num Type Disp Enb Address What5 breakpoint keep y 0x000000000000070c in main at gdb_example.c:10(gdb) info breakpoint 5Num Type Disp Enb Address What5 breakpoint keep y 0x000000000000070c in main at gdb_example.c:10 单步命令next命令：用于单步执行，类似于VC++中的step over。 next的单步不会进入函数的内部。step（缩写为s）命令：与next正好相对，在单步执行一个函数时，进入其内部，类似于VC++中的step into。 12345678910(gdb) break 14Breakpoint 1 at 0x75e: file gdb_example.c, line 14.(gdb) run Starting program: /root/cpptest/gdb_example Breakpoint 1, main () at gdb_example.c:1414 sum[i] = add(array1[i], array2[i]);(gdb) stepadd (a=48, b=85) at gdb_example.c:33 return a + b; 单步执行高级用法如下： step &lt;count&gt; 也就是上面的示例单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。 next &lt;count&gt; 也就是上面的示例单步跟踪，如果有函数调用，它不会进入该函数。同理，next后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。 set step-mode set step-mode on用于打开step-mode模式，这样，在进行单步跟踪（运行step指令）时，若跨越某没有调试信息的函数，程序的执行则会在该函数的第一条指令处停住，而不会跳过整个函数。这样我们可以查看该函数的机器指令。 set step-mod off用于关闭step-mode模式 finish运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址、返回值及参数值等信息。 until（缩写为u）一直在循环体内执行单步而退不出来是一件令人烦恼的事情，用until命令可以运行程序直到退出循环体。 stepi（缩写为si）和nexti（缩写为ni） （选看）stepi和nexti用于单步跟踪一条机器指令。比如，一条C程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令，相反，step和next是C语言级别的命令。另外，运行display/i$pc命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。 continue命令当程序被停住后，可以使用continue命令（缩写为c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点。命令格式为： 123continue [ignore-count] //ignore-count表示忽略其后多少次断点。c [ignore-count]fg [ignore-count] 示例： 12345678910111213141516(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3.(gdb) break 14Breakpoint 2 at 0x75e: file gdb_example.c, line 14.(gdb) break 10Breakpoint 3 at 0x70c: file gdb_example.c, line 10.(gdb) run Starting program: /root/cpptest/gdb_example Breakpoint 3, main () at gdb_example.c:1010 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4};(gdb) continue Continuing.Breakpoint 2, main () at gdb_example.c:1414 sum[i] = add(array1[i], array2[i]); print命令查看当前程序的运行数据：当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式如下： 12print &lt;expr&gt;print /&lt;format&gt; &lt;expr&gt; &lt; expr &gt;是表达式，也是被调试的程序中的表达式&lt; format &gt;是输出的格式，比如，如果要把表达式按十六进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中: @是一个和数组有关的操作符 ::指定一个在文件或是函数中的变量 {&lt;type&gt;}&lt;addr&gt;表示一个指向内存地址的类型为type的对象 当需要查看一段连续内存空间的值时，可以使用GDB的@操作符，@的左边是第一个内存地址，@的右边则是想查看内存的长度。例如如下动态申请的内存： 1int *array = (int *) malloc (len * sizeof (int)); 在GDB调试过程中这样显示这个动态数组的值： 1p *array@len print的输出格式如下。 12345678x：按十六进制格式显示变量。d：按十进制格式显示变量。u：按十六进制格式显示无符号整型。o：按八进制格式显示变量。t：按二进制格式显示变量。a：按十六进制格式显示变量。c：按字符格式显示变量。f：按浮点数格式显示变量。 可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。 当用GDB的print查看程序运行时数据时，每一个print都会被GDB记录下来。GDB会以$ 1，$ 2，$ 3 … 这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如 $ 1。 修改变量值如果要修改变量，如x的值，可使用如下命令： 1print x=4 watch命令watch一般用来观察某个表达式（变量也是一种表达式）的值是否有了变化，如果有变化，马上停止程序运行。设置观察点有如下几种方法来。 watch &lt;expr&gt;：为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停止程序运行。 rwatch &lt;expr&gt;：当表达式（变量）expr被读时，停止程序运行。 awatch &lt;expr&gt;：当表达式（变量）的值被读或被写时，停止程序运行。 info watchpoints：列出当前所设置的所有观察点。 jump命令GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令实现。jump &lt;linespec&gt;来指定下一条语句的运行点。 &lt; linespec &gt;可以是文件的行号，可以是file：line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。 jump &lt;address&gt; 这里的&lt; address &gt; 是代码行的内存地址。 注意：jump命令不会改变当前程序栈中的内容，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能会导致意想不到的结果，因此最好只用jump在同一个函数中进行跳转。 signal命令singal命令，可以产生一个信号量给被调试的程序，如中断信号Ctrl+C。于是，可以在程序运行的任意位置处设置断点，并在该断点处用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。signal命令的语法是 1signal &lt;signal&gt; UNIX的系统信号量通常为1~15，因此的取值也在这个范围内。 return命令如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。 12returnreturn &lt;expression&gt; 上述return命令用于取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被作为函数的返回值。 call命令call命令用于强制调用某函数： 1call &lt;expr&gt; 表达式可以是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。比如在下列程序执行while（1）的时候： 12345main(){void *p = malloc(16);while(1);} 我们可以强制要求其执行strcpy()和printf()： 12345(gdb) call strcpy(p, \"hello world\")$3 = 134524936(gdb) call printf(\"%s\\n\", p)hello world$4 = 12 info命令info命令可以用来在调试时查看寄存器、断点、观察点和信号等信息。 查看寄存器的值，使用如下命令：123info registers （查看除了浮点寄存器以外的寄存器）info all-registers （查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt; （查看所指定的寄存器） 查看断点信息，使用如下命令：1info break 要列出当前所设置的所有观察点，可使用如下命令：1info watchpoints 查看有哪些信号正在被GDB检测，使用如下命令：12info signalsinfo handle info line命令来查看源代码在内存中的地址。 info line后面可以跟行号、函数名、文件名：行号、文件名：函数名等多种形式，例如用下面的命令会打印出所指定的源码在运行时的内存地址：1info line tst.c:func disassembledisassemble命令用于反汇编（将机器语言转换为汇编语言）。可用它来查看当前执行时的源代码的机器码，实际上只是把目前内存中的指令冲刷出来。下面的示例用于查看函数func的汇编代码： 1234567Dump of assembler code for function func:0x8048450 &lt;func&gt;: push %ebp0x8048451 &lt;func+1&gt;: mov %esp,%ebp0x8048453 &lt;func+3&gt;: sub $0x18,%esp0x8048456 &lt;func+6&gt;: movl $0x0,0xfffffffc(%ebp)...End of assembler dump. 注意事项 GDB并不具备记忆功能，每次断开重新开启，之前的断点设置等信息都会丢失的。 总结参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》gdb —- x命令详解gdb学习笔记(一)用GDB调试程序（七） //包含修改变量的值","link":"/2020/07/06/Linux%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95-GDB%E8%B0%83%E8%AF%95%E5%99%A8/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"演讲","slug":"演讲","link":"/tags/%E6%BC%94%E8%AE%B2/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"名著","slug":"名著","link":"/tags/%E5%90%8D%E8%91%97/"},{"name":"生产力","slug":"生产力","link":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"学术论文","slug":"学术论文","link":"/tags/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"基本结构","slug":"基本结构","link":"/tags/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"},{"name":"心态","slug":"心态","link":"/tags/%E5%BF%83%E6%80%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"性能分析","slug":"性能分析","link":"/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"目录结构","slug":"目录结构","link":"/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"费曼","slug":"费曼","link":"/tags/%E8%B4%B9%E6%9B%BC/"},{"name":"诺贝尔奖","slug":"诺贝尔奖","link":"/tags/%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96/"},{"name":"传记","slug":"传记","link":"/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux概述","slug":"Linux概述","link":"/tags/Linux%E6%A6%82%E8%BF%B0/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"简述","slug":"简述","link":"/tags/%E7%AE%80%E8%BF%B0/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"文档和注释","slug":"文档和注释","link":"/tags/%E6%96%87%E6%A1%A3%E5%92%8C%E6%B3%A8%E9%87%8A/"},{"name":"软连接","slug":"软连接","link":"/tags/%E8%BD%AF%E8%BF%9E%E6%8E%A5/"},{"name":"硬连接","slug":"硬连接","link":"/tags/%E7%A1%AC%E8%BF%9E%E6%8E%A5/"},{"name":"文件与目录","slug":"文件与目录","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"内存分配","slug":"内存分配","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"内存分区","slug":"内存分区","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"静态多态","slug":"静态多态","link":"/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"动态多态","slug":"动态多态","link":"/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"容器类","slug":"容器类","link":"/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"},{"name":"关联容器","slug":"关联容器","link":"/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"},{"name":"顺序容器","slug":"顺序容器","link":"/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"},{"name":"C++标准库","slug":"C-标准库","link":"/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"priority_queue","slug":"priority-queue","link":"/tags/priority-queue/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"pair","slug":"pair","link":"/tags/pair/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"运算符","slug":"运算符","link":"/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"重载","slug":"重载","link":"/tags/%E9%87%8D%E8%BD%BD/"},{"name":"初始化","slug":"初始化","link":"/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"音标","slug":"音标","link":"/tags/%E9%9F%B3%E6%A0%87/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"信号量","slug":"信号量","link":"/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"互斥锁","slug":"互斥锁","link":"/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"deque","slug":"deque","link":"/tags/deque/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"B-树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"B+树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","link":"/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"设计方法","slug":"设计方法","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"应用层","slug":"应用层","link":"/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"套接字","slug":"套接字","link":"/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"内核","slug":"内核","link":"/tags/%E5%86%85%E6%A0%B8/"},{"name":"驱动程序","slug":"驱动程序","link":"/tags/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"},{"name":"概述","slug":"概述","link":"/tags/%E6%A6%82%E8%BF%B0/"},{"name":"程序执行","slug":"程序执行","link":"/tags/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/"},{"name":"调试器","slug":"调试器","link":"/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"}],"categories":[{"name":"博客维护","slug":"博客维护","link":"/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"},{"name":"醒世通言","slug":"醒世通言","link":"/categories/%E9%86%92%E4%B8%96%E9%80%9A%E8%A8%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"效率工具","slug":"效率工具","link":"/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"学术论文","slug":"学术论文","link":"/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件工程","slug":"软件工程","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"英语学习","slug":"英语学习","link":"/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}