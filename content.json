{"pages":[{"title":"关于","text":"关于博主博主是目前是一名在在校的计算机研究生（master student）,为未来而学习着，成长着。专业是计算机系统结构。目标是能够怀着求知与探索的品质，能够对社会有所贡献，在信息化浪潮中搏一番自己的精彩。 在此奉上牛顿的名言： 我好像是一个海边玩耍的孩子,不时为拾到比通常更光滑的石子或更美丽的贝壳而欢欣鼓舞,而展现在我面前的是完全未探明的真理之海。 关于博客博主搭建了这个博客主要是为了记录一些思考、经验、收藏和笔记。博客的内容可能倾向于记录博主的日常所学所思，当然也会有一些技术文章 在此奉上查理芒格的名言： 如果要变得聪明，不停地问：为什么为什么为什么。 在此奉上高德纳（Donald Knuth，现代计算机鼻祖，《计算机程序设计艺术》作者）的名言： “让我们改变一下对构建程序的态度：不要把我们的主要工作想象为教计算机怎么做，相反，让我们集中精力向人们解释我们想让机器做什么。” 在此奉上梭罗（Henry David Thoreau）的名言： 所有对真理的认识都是通过类比得来！ 联系博主博客搭建了评论系统，直接用github授权评论即可，博主隔一段时间会看一下。","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/28/hello-world/"},{"title":"成为一个不惑、不忧、不惧的人","text":"说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。 演讲全文诸君!我在南京讲学将近三个月了，这边苏州学界里，有好几回写信邀我，可惜我在南京是天天有功课的，不能分身前来。今天到这里，能够和全城各校诸君聚在一堂，令我感激的很，但有一件，还要请诸君原谅：因为我一个月以来，都带着些病，勉强支持，今天不能作很长的讲演，恐怕有负诸君期望哩。 问诸君“为什么进学校?” 我想人人都会众口一词的答道：“为的是求学问”。再问：“你为什么要求学问?”“你想学些什么?”恐怕各人的答案就很不相同，或者竟自答不出来了。诸君啊!我替你们回答一句罢：“为的是学做人。”你在学校里头学的什么数学、几何、物理、化学、生理、心理、历史、地理、国文、英语，乃至什么哲学、文学、科学、政治、法律、经济、教育、农业、工业、商业等等，不过是做人所需的一种手段，不能说专靠这些便达到做人的目的，任凭你把这些件件学的精通，你能够成个人不成个人还是个问题。 人类心理，有知、情、意三部分。这三部分圆满发达的状态，我们先哲名为三达德——智、仁、勇。为什么叫做“达德”呢?因为这三件事是人类普通道德的标准，总要三个具备，才能成一个人。三件的完成状态怎么样呢?孔子说：“知者不惑，仁者不忧，勇者不惧。”所以教育应分为知育、情育、意育三方面，——现在讲的智育、德育、体育不对，德育范围太笼统，体育范围太狭隘——知育要教到人不惑，情育要教到人不忧，意育到教到人不惧。教育家教育学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。 1. 怎么样才能不惑呢?最要紧的是养成我们的判断力。想要养成判断力，第一步，最少须有相当的常识，进一步，对于自己要做的事须有专门智识，再进一步，还要有遇事能断的智慧。 假如一个人连常识都没有，听见打雷，说是雷公发威，看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，碰到一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。学校里小学中学所教，就是要人有了许多基本的知识，免得凡事都暗中摸索。 但仅仅有点常识还不够，我们做人，总要各有一件专门职业。这门职业，也并不是我一人破天荒去做，从前已经许多人做过，他们积累了无数经验，发现出好些原理原则，这就是专门学识。我打算做这项职业，就应该有这项专门的学识。例如我想做农吗，怎么的改良土壤，怎么的改良种子，怎么的防御水旱病虫，等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。做工、做商等等都各有他的专门学识，也是如此。我想做财政家吗，何种租税可以生出何样结果，何种公债可以生出何样结果等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。教育家、军事家等等，都各有他的专门学说，也是如此。 我们在高等以上学校所求的知识，就是这一类。但专靠这种常识和学识就够吗?还不能。宇宙和人生是活的不是呆的，我们每日碰见的事理是复杂的变化的，不是单纯的刻板的，倘若我们只是学过这一件，才懂这一件，那么，碰着一件没有学过的事来到跟前，便手忙脚乱了。 所以还要养成总体的智慧，才能有根本的判断力。这种总的智慧如何才能养成呢?第一件，要把我们向来粗浮的脑筋着实磨炼他，叫他变成细密而且踏实。那么，无论遇着如何繁难的事，我都可以彻头彻尾想清楚他的条理，自然不至于惑了。 第二件，要把我们向来浑浊的脑筋，着实将养他，叫他变成清明。那么，一件事理到跟前，我才能很从容很莹澈的去判断他，自然不至于惑了。以上所说常识学识和总体的智慧，都是知育的要件，目的是教人做到“知者不惑”。 2. 怎么样才能不忧呢?为什么仁者便会不忧呢?想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么?很难用言语说明，勉强下个解释，可以说是：“普遍人格之实现。”孔子说：“仁者人也。”意思是说人格完成就叫做“仁”。 但我们要知道，人格不是单独一个人可以表现的，要从人和人的关系上来看。所以仁字从二人，郑康成解他做“相人偶”。总而言之，要彼此交感互发，成为一体，然后我的人格才能实现。所以我们若不讲人格主义，那便无话可说;讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我们的人格，和宇宙无二区别，体验得这个道理，就叫做“仁者”。然则这种仁者为什么就会不忧呢?大凡忧之所从来，不外两端，一曰忧成败，二曰忧得失。我们得着“仁”的人生观，就不会忧成败。为什么呢?因为我们知道宇宙和人生是永远不会圆满的，所以《易经》六十四卦，始“乾”而终“未济”。正为在这永远不会圆满的宇宙中，才永远容得我们创造进化。 我们所做的事，不过在宇宙进化几万万里的长途中，往前挪一寸，两寸，那里配说成功呢?然则不做怎么样呢?不做便连这一寸都不往前挪，那可真是失败了。 “仁者”看透这种道理，信得过只有不做事才算失败，肯做事便不会失败。所以《易经》说：“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的几万万里路挪了一两寸，算成功吗?所以《论语》：“知其不可而为之。”你想，有这种人生观的人，还有什么成败可忧呢? 再者，我们得着“仁”的人生观，便不会忧得失。为什么呢?因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则哪里有东西可以为我们所得?既已没有东西为我所得，当然也没有东西为我所失。 我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等做手段来达某种目的——可以为我们“所得”得。所以老子说：“生而不有，为而不恃。”“既以为人已愈有，既以与人已愈多。”你想，有这种人生观的人，还有什么得失可忧呢?总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无人而不自得”。他的生活，纯然是趣味化艺术化。这是最高的情感教育，目的教人做到“仁者不忧”。 3. 怎么样才能不惧呢?有了不惑不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便会有丰富的智识，临时也会用不着，便有优美的情操，临时也会变了卦。然则意志怎么会才坚强呢?头一件须要心地光明，孟子说：“浩然之气，至大至刚。行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不惴焉;自反而缩，虽千万人，吾往矣。” 俗话说得好：“生平不作亏心事，夜半敲门心不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一着。第二件要不为劣等欲望之所牵制。 《论语》记：子曰：“吾未见刚者。”或对曰伸枨。子曰：“枨也欲，焉刚。”一被物质上无聊得嗜欲东拉西扯，那么百炼成刚也会变成绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。 自己作不起自己的主，还有什么事可做?受别人压制，做别人奴隶，自己只要肯奋斗，终必能恢复自由。自己的意志做了自己情欲的奴隶，那么，真是万劫沉沦，永无恢复自由的余地，终身畏首畏尾，成了个可怜人了。 孔子说：“和而不流，强哉矫;中立而不倚，强哉矫。国有道，不变塞焉，强哉矫;国无道，至死不变，强哉矫。”我老实告诉诸君说罢，做人不做到如此，决不会成一个人。但做到如此真是不容易，非时时刻刻做磨炼意志的功夫不可，意志磨炼得到家，自然是看着自己应做得事，一点不迟疑，扛起来便做，“虽千万人吾往矣。”这样才算顶天立地做一世人，绝不会有藏头躲尾左支右绌的丑态。这便是意育的目的，要教人做到“勇者不惧”。 我们拿这三件事作做人的标准，请诸君想想，我自己现时做到哪一件——哪一件稍微有一点把握。倘若连一件都不能做到，连一点把握都没有，嗳哟!那可真危险了，你将来做人恐怕做不成。讲到学校里的教育吗，第二层的情育，第三层的意育，可以说完全没有，剩下的只有第一层的知育。就算知育罢，又只有所谓常识和学识，至于我所讲的总体智慧靠来养成根本判断力的，却是一点儿也没有。 这种“贩卖知识杂货店”的育，把他前途想下去，真令人不寒而栗!现在这种教育，一时又改革不来，我们可爱的青年，除了他更没有可以受教育的地方。诸君啊!你到底还要做人不要?你要知道危险呀，非你自己抖擞精神方法自救，没有人救你呀! 诸君啊!你千万别要以为得些断片的智识，就算是有学问呀。我老实不客气告诉你罢;你如果做成一个人，知识自然是越多越好：你如果做不成一个人，知识却是越多越坏。你不信吗?试想想全国人所唾骂的卖国贼某人某人，是有智识的呀，还是没有智识的呢?试想想全国人所痛恨的官僚政客——专门助军阀作恶鱼肉良民的人，是有智识的呀，还是没有智识的呢?诸君须知道啊，这些人当十几年前在学校的时代，意气横历，天真烂漫，何尝不和诸君一样?为什么就会堕落到这样的田地呀? 屈原说：“何昔日之芳草兮，今直为此萧艾也!岂其有他故兮，莫好修之害也。”天下最伤心的事，莫过于看着一群好好的青年，一步一步的往坏路上走。诸君猛醒啊!现在你所厌所恨的人，就是你前车之鉴了。 诸君啊!你现在怀疑吗?沉闷吗?悲哀痛苦吗?觉得外边的压迫你不能抵抗吗?我告诉你：你怀疑和沉闷，便是你因不知才会惑;你悲哀痛苦，便是你因不仁才会忧;你觉得你不能抵抗外界的压迫，便是你因不勇才有惧。这都是你的知、情、意未经过修养磨炼，所以还未成个人。我盼望你有痛切的自觉啊!有了自觉，自然会成功。那么，学校之外，当然有许多学问，读一卷经，翻一不史，到处都可以发现诸君的良师呀! 诸君啊，醒醒罢!养足你的根本智慧，体验出你的人格人生观，保护好你的自由意志。你成人不成人，就看这几年哩!","link":"/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/"},{"title":"《苏菲的世界》读书笔记","text":"伊甸园 在某个时刻事物必然从无到有你是谁？世界从何处来？ 要么一直存在 要么从无到有 比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。 生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。 魔术师的礼帽 要成为一个优秀的哲学家只有一个条件：要有好奇心哲学是什么？天底下有没有一种东西是所有人都感兴趣的呢？有的！当人的基本需求（比如衣食住行，亲情爱情，爱与关怀等）满足之后，还有一些东西是人人都需要的，那就是明白我们是谁，我们为何在这里。宇宙，地球与生命是如何产生的？ 探讨哲学的最好方式就是问一些哲学性的问题，如：这世界是如何创造出来的？其背后是否有某种一直或者意义？人死后还有生命吗？我们如何能够解答这些问题呢？最重要的是，我们应该如何生活？我们无法从百科全书上得到这些答案，不过读一读别人的意见倒可以帮助我们建立自己对于生命的看法。 哲学家追求真理的过程很想一步侦探小说，对于案件，警方有时候可以侦破，但也有可能永远无法查出真相（虽然在某个地方一定有一个破案的办法）。因此，即使要回答一个问题很不容易，但无论如何总会有一个（且仅此一个）正确答案的。比如人死后要么就是透过某种形式存在，要不就是根本不在存在。 作者很好的比喻：许多人对于这个世界的种种也同样有种不可置信的感觉，就像我们看到魔术师突然从一顶原本空空如也的帽子里拉出一只小兔子一般。实际上我们就生活在这个世界上，是这个世界的一部分。形象的比喻一下，我们就是那只从礼帽里面变出的小兔子的一部分，小兔子可以比作是是整个宇宙，而我们则是寄居在小兔子身上的小小生物，但是我们和兔子不同的是，小兔子可不知道自己参与了一场魔术表演，而我们知道自己是某种神秘事物的一部分，我们想了解其中的奥秘；哲学家们总是试图沿着兔子的细毛往上爬，以便将魔术师的看个清楚； 神话 善与恶之间脆弱的平衡神话的世界观 北欧 （挪威）索尔和铁锤 北欧人相信人类居住的这部分是一部分岛屿，名为米德加德(Midgard)，也就是”中央王国“的意思，在这个中央王国内，有一个地方名叫阿斯加德（Asgard），乃是诸神的领地。中央王国之外，有一个叫乌特加德（Utgard），是狡猾的巨人居住的地方。 象征肥沃多产的额女神芙瑞雅 侍童洛奇 《史莱慕之诗》 巨人之王史莱慕希腊 公元前700左右，有一大部分希腊神话被荷马与赫西俄德（赫西俄德Hesiod以长诗《工作与时日》《神谱》闻名于后世，被称为“希腊训谕诗之父”。）记录下来。 赞诺芬尼司(Xnphans),古希腊哲学家。是早期批评荷马的神话的哲学家之一。 赞诺芬尼斯_百度百科 他指出人类按照自己的形象创造出这些天神。 随后这段期间，希腊人在希腊本土与意大利南部，小亚细亚等希腊殖民地建立了许多城市。在这些城市中，所有劳力工作由奴隶担任，因此市民有充分的闲暇，可以将所有的时间投注在政治与文化上；这时候的人们思考方式与以前大不相同，无需借助神话而提出一些哲学性的问题；我们称这样的现象为“从神话的思考模式发展到以经验与理性为基础的思考模式” 自然派哲学家 没有一件事物可以来自空无万事万物是否有一种基本的物质组成？哲学家的课题：每个人关注和质疑的事项是什么？了解了每一位哲学家的课题之后，我们就比较容易了解他的思想脉络，因为没有任何一位哲学家会企图探讨哲学的所有领域。 自然派哲学家关注的课题是“大自然与它的循环和变化”最重要的是，他们想要透过对大自然本身的研究来了解实际的变化过程，而不是借助神话来解释。这样，哲学逐渐脱离了宗教的范畴。自然派哲学家朝科学推理的方向迈出了第一步，成为后来科学的先驱。 米雷特斯的三位哲学家泰利斯安娜克西曼德安那西梅尼斯 没有任何事物会来自于虚无帕梅尼德斯（约公元前540年~公元前480年）他认为： 没有任何事物会改变。 因此我们的感官认知是不可靠的 理性主义：坚决相信人的理智的态度理性主义者：百分百相信人类的理智是时间所有知识源泉的人 所有的事物都是流动的赫拉克里德斯（约公元前540年~公元前480年）他认为： 万物都会改变（”一切事物都是流动的“） 我们的感官认知是可靠的 恩培窦克里斯（西西里）恩培窦克里斯认为帕梅尼德斯与赫拉克里德斯各有一点是对的，也各有一点是错的，造成这个根本性差异的原因是之前的两人都认定世间只有一种元素存在。恩培窦克里斯认为： 没有任何事物会改变。 我们的感官认知是可靠的 恩培窦克里斯的结论是：大自然不可能只有一种元素构成。 安纳萨格拉斯（约公元前500年~公元前428年） 德谟克里特斯 世界上最巧妙的玩具 积木为何是世界上最巧妙的玩具？ 原子理论德谟克里特斯（约公元前460年~公元前370年，来自爱琴海北部海岸的阿布拉德小镇） 唯物论者：只相信物质的东西。 命运 算命者试图预测某些事实上极不可测的事物古希腊的德尔菲（Delphi）神论与宿命论 现在看来都是迷信 历史与医学历史上最早的一批历史学家开始为历史事件寻求合理的解释。贺若多陀斯（约公元前484年~公元前424年）与修西德底斯（约公元前460年~公元前400年） 在希腊哲学、历史学发展的同时，希腊医学兴起，其目的是为了疾病与健康寻求合乎自然的解释。希波克拉底（约公元前460~公元前377年，生于寇斯岛，希腊医学始祖）比较出名的是希波克拉底誓言： 我将依照自身的能力与判断，采用对病人有利的疗法与处方，绝不施以有害或有毒之物。无论应何人之请，我也绝不给与致命药物或做此类之建议，也绝不协助妇女堕胎。进入病家访视时，我将以病人的福祉为念，不做任何贪渎害人之事，不受男女奴仆之引诱。我在执业时之所见所闻，反不应泄露者，我将严予保密。若我遵行此一誓言，不懈不怠，愿上苍使我乐享生命、精进医事并受世人敬重。若我违反誓言，愿我遭相反之命运。 苏格拉底 最聪明的是明白自己无知的人 是否有人天生就很害羞呢？最聪明的是明白自己无知的人。真正的智慧来自内心。明白是非者必能够进退合宜。 雅典的哲学以人为中心苏格拉底是谁？谈话的艺术 “苏格拉底式的反讽”神圣的声音雅典的小丑正确的见解导致正确的行动 雅典 废墟中升起了几栋高楼柏拉图 回归灵魂世界的渴望柏拉图学院永远的真善美理型的世界真正的知识不朽的灵魂走出黑暗的洞穴（洞穴神话）哲学之国（理想国） 少校的小木屋 镜中的女孩双眼眨了一眨亚力士多德 一位希望澄清我们观念的严谨的逻辑学家逻辑亚里士多德创立了逻辑学这门学科，他以实例显示我们在得出合乎逻辑的结论或证明时，必须遵循若干法则。 希腊文化 一丝火花生命与容忍的哲学宗教，哲学与科学 犬儒学派 斯多葛学派 伊比鸠鲁学派 新柏拉图派哲学神秘主义 明信片 我对自己实施严格的检查制度两种文化 避免在真空中飘浮的唯一方式印欧文化 闪族文化 中世纪 对了一部分并不等于错文艺复兴 啊！藏在凡俗身躯里的神明子孙哪实证法：以亲身的经验，而不是以古人的著作或凭空想象来作为知识的基础。 巴洛克时期 宛如梦中的事物笛卡尔 他希望清除工地上所有的瓦砾斯宾诺莎 上帝不是一个傀儡戏师傅洛克 赤裸、空虚一如教师来到教室前的黑板休姆 将它付之一炬如果我们手里有一本书，我们应该问：书里是否有包含任何与数量和数目有关的抽象思考？如果答案是没有，那么我们应该再问：书里是否包含任何与事实有关的经验性思考？如果答案是没有，那么我们还是将它付之一炬吧，因为这样的书纯粹是诡辩和幻想。 印象观念 不可知论者：不持肯定或否定的态度，持怀疑态度。 柏克莱 宛如燃烧的恒星旁一颗晕眩的行星柏客来 曾祖母向一名吉普赛妇人买的一面古老魔镜启蒙 从制针的技术到铸造大炮的方法康德 头上闪烁的星空与心中的道德规范浪漫主义 神秘之路通向内心黑格尔 可以站得住脚的就是有道理的祁克果 欧洲正迈向破产的地步主观的真理可以测算的真理我信因为荒谬个体主义者 马克思 在欧洲游荡的幽灵达尔文 满载基因航行过生命的一艘小船弗洛伊德 他内心出现那股令人讨厌的自大的冲动弗洛伊德发展了所谓的深度心理学或精神分析弗洛依德主张人和他的环境之间不断有一种紧张关系存在。这种紧张关系（也就是冲突）尤其存在于他的驱策力，需要和社会之间。基本需求可能会被伪装和升华；快乐原则/本我现实原则/自我这世界的道德规范已经成为我们内心的一部分/成为超我潜意识:我们并不一定能够意识到我们曾经有过的各种经验。但那些只要我们“用心想便可以记起来的想法或经验”通常是指被压抑的想法或经验。不错的比喻：演讲厅说话演讲厅称为”意识“，演讲厅之外称为“潜意识”；大声喧哗者被”压抑“，椅子堵住门口作为”防御“ 我们的感觉和行为会受到“潜意识的鼓动”这类机制有好几种：比如“说溜了嘴”“合理化”我们自己也不愿意承认，也不愿意告诉别人我们做一件事的真正动机，因为这个动机是让人无法接受的。–&gt;”两面式沟通“的经验“投射”把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较。如何对抗不愉快的经历呢？弗洛伊德发展出一个”自由联想“的技巧。梦的解析显梦 mainfest dream 潜梦意念把潜梦意念转换成显梦面向的工作，他称之为“梦的运作”超现实主义 灵感：潜意识的盖子被打开了，好像我们突然所想的东西是来自某种外部的源泉似的。创作的过程是想象与理性细密交织的时刻 想象力也许可以创造新的事物，但是却不能加以挑选，这时候理智就发挥作用了！ 我们这个时代 人是注定要受自由之苦的花园宴会 一只白色的乌鸦对位法 两首或多首旋律齐响那轰然一响 我们也是星尘","link":"/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"好用的chrome插件","text":"深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。 Awesome Autocomplete for GitHub增强github的搜索功能 Git History Browser Extension查看github的历史更新记录，超级好用，可以对比不同人对代码做的更新； octotree可以查看github的目录结构，并且下载单个的文件； Sourcegraph可以查看相关的代码，搜索代码，查找代码定义的地方 The Great Suspender休眠chrome不必要的标签页 Tab Resize - split screen layouts浏览器分屏 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/"},{"title":"学术论文的基本结构","text":"基本结构 标题 真实反应论文内容 简短明了 吸引人 大背景 小背景 技术特色 摘要 概括你的研究 假设或要研究的问题 研究方法 主要成果 引言 说明选题的背景，目的，意义 陈述研究的主要内容和论文的假说或研究问题 文章的研究方法与章节编排 文献综述 阐述前人的研究，展示文献批判能力，说明你对研究问题的掌握程度，表明你研究的创新之处。 研究方法 详细介绍相关信息，便于读者采取同样的方法能够重复此项研究。 研究性质 对象 步骤 工具 条件 … 研究结果 用文字和/或图表真实报告你获得的数据或结果。 讨论 基于你获得的数据论述对于研究问题可能得到的结论。 结论 简明总结所得到的数据，得出的结论及意义。 说明研究的价值，不足或局限性。 致谢 参考文献 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"title":"《练习的心态》读书笔记","text":"引言 人生就是漫长的练习第1章 学习开始当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种没有压力的愉快与平和的体验，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。 压力与焦虑主要来源于我们自己对目标的依恋。练习的心态这也是一种技能：尽可能迅速，最少的付出来发展任何一项技能的能力，以及在这个过程体验内心平和与愉悦的能力。 在不感到失败和焦虑的情况下去努力实现目标。学习的渴望仅仅是第一步，需要正确理解技术性细节与努力，否则会耗尽的 当今的文化是多任务的，比如开车时第一件事会习惯性打开收音机。 而滑冰正相反，滑冰时候不会注意边上嘈杂的声音！由于习惯于一心多用，我们大脑躁动不安，且具有极大惯性，没法安静下来。 练习的心态是安静的意识是第一位的：没法控制自己的思维，不管设立什么样的目标，都没有用。我们对自己要去的方向就像乘坐马车，必须要拉紧思维的缰绳才行啊！填补空虚是一个循环往复的过程 学会走路的过程并不会在心里让你压力倍增。我们要意识并掌控这个过程，学会从中享受！ 第2章 以过程为导向，不以结果为导向 人生的悖论：耐心与自律的问题是，要培养它们中的任何一个，需要同时具备它们两个。 简单法则 以过程为导向 重点关注当前 将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。 对自己想要做的事情刻意训练，带着意图训练，并且自始至终清醒的知道那种意图 第3章 关键是视角当我们试图理解自己以及我们对人生中各种努力的痛苦挣扎时，可以通过观察一朵鲜花来找到平和。问你自己：一朵鲜花的生命，从撒下种子到完全盛开，在什么时候可以达到完美？ 然后呢？ 达成目标之后，然后呢？然后又能干什么呢？？？？初学者心态鲜花的生命，自始至终都是完美的 他了解到，假如将自己的思绪集中在当前，并只专注了他在这一刻正在做的事情的过程，那便可以喜欢上他正在做的任何事情。 第4章 培养期望的习惯习惯是学来的。明智地选择它们。自己创造想要的习惯，不带情绪和判断的采取哪些行为，之后坚持下去。 就像一名优秀的老师，对待学生的错误不会情绪化，那种情绪化来源于自我期望，与结果和产物关联，如果你体验到这些情绪，就证明你没有专注于当前过程！！！ 怎么样阻止旧的习惯，采用一种例行行为来阻止，比如击球前例动作 第5章 感知变化，创造耐心！你需要的所有耐心，都已经处在你的内心了。知道什么时候内心疯狂奔走接受什么事情不会尽善尽美 放弃某种幸福和乐趣就在某个地方的徒劳想法 在探索的道路上，除了去追求，没有别的可以达到的目标了//我们20岁的目标肯定与18岁的不同，参照对象也是不一样的，不要指望能达到你的目标。探索本身就是一种目标。 对于没有费力得到的东西，那种兴奋感在得到东西早已烟消云散。 得到目标和实现目标是两种完全不同的概念真正的愉悦 第6章 4“S”方法力求简化，将征服大多数复杂的任务。 简化 细分 缩短 放慢 第7章 平静与DOC方法客观是通往宁静心灵之路！ 主观判断需要一个评估和对比的过程，这要求有一个相对的点，即理想状况判断有一个不利的地方，它不会以一种超然的方式运行，常常会包含着某些情绪，有趣的是，对事情我们感觉到的重要性越多，我们带的情绪越多将自我与观察者合并 。就像我们安慰他人时候带着的超然智慧一样。 怎么合并呢 冥想！ do observe correct就像射箭运动员一样，安静，不复杂完全没有心理的杂乱 第8章 教孩子，也从孩子身上学习智慧并不是年龄的副产物。从你身边所有的人身上学习，同时也用自己的行为影响身边的人。 第9章 你的技能在成长有了刻意的和反复的努力，进步便水到渠成。 如果说各种软件上的信息不能使你知识变得丰富，那么你就不需要它们 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"linux 性能分析，测试与调优工具","text":"静态性能分析工具(static performance analysis tools) dmesg 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。 blockdev 工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。 ldd （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。 lsblk (list block)即用于列出所有可用块设备的信息,而且还能显示他们之间的依赖关系,但是它不会列出RAM盘的信息 lsscsi 可以看到Raid卡信息和所有虚拟磁盘以及光驱的信息，如果没有硬件SCSI控制器，那就不会返回信息。 lspci 显示有关pci总线的信息以及连接到它们的设备。 lscpu (list cpu)显示CPU的详细信息，比如CPU的制造商、架构、CPU数量、型号、主频、缓存及支持的虚拟化技术等信息。 lstopo (list topology of the system)显示可视化的方式组成 CPU、缓存、内存和I/O设备的拓扑结构。这个命令用来识别处理器结构和系统的NUMA拓扑结构。 likwid (Like I Knew What I’m Doing) 是一个用来测量、配置并显示硬件相关特性的命令行收集工具。其中的likwid拓扑结构能显示CPU硬件(线程/缓存/NUMA)的拓扑结构信息，还能识别处理器家族(比如：Intel Core 2, AMD Shanghai)。 smartctl 查看硬盘的SMART信息。 fdisk 创建和维护分区表的程序(兼容DOS类型的分区表、BSD或SUN的磁盘列表） schedtool (scheduling tool)查询或设置CPU状态的工具。通过不同的参数可以查看或设置不同的属性。 numactl (Control NUMA policy)用于控制 进程与共享存储的 NUMA 技术机制。 cpuid 获取CPU的信息。该命令的底层是CPUID指令。它获取的内容比/proc/cpuinfo要详细很多。 MegaCli 管理维护硬件RAID的软件 App Config 观测工具(Observability Tools) iostat (input/output statistics)报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息。 vmstat (VirtualMeomoryStatistics,虚拟内存统计) 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。 dstat 用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具,是一个全能系统信息统计工具。 pidstat 是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。 mpstat (multiprocessor statistics)查看多核心的cpu中每个计算核心的统计数据。类似工具vmstat只能查看系统的整体cpu情况 netstat ( network statistics)显示当前的网络状态，包括传输控制协议层的连线状况、路由表、网络接口状态和网络协议的统计信息等。 iotop 用来监视磁盘I/O使用状况的top类工具 top (display Linux processes)实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。 htop top命令的升级版。交互式的进程浏览器，可以用来替换Linux下的top命令 gtop JavaScript 编写的开源系统资源监控实用程序,它是 Linux 系统自带 top 工具的替代品 tiptop 通过读取CPU硬件计数器的信息（比如cahche miss，executed instructions per cycle等等）了解程序执行效率 strace 可跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。 uptime 可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息 lsof (list open files)列出当前系统打开的文件，注意linux中设备也是文件 perf 性能分析工具，能够进行函数级与指令级的热点查找。 Flame Graphs 性能分析的利器,通过它可以快速定位性能瓶颈点。 测试工具(Benchmarking Tools) fio 开源的I/O压力测试工具，主要是用来测试磁盘/SSD的IO性能，也可测试cpu，nic的IO性能。 hdparm (hard disk parameters)用于显示与设定硬盘的参数 dd 用于读取、转换并输出数据。可从标准输入或文件中读取数据,根据指定的格式来转换数据,再输出到文件、设备或标准输出。 perf_events 网上很多叫法如perf_events , perf profiler , Performance Counters for Linux。叫法不同，都指perf perf-tools 基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集，能够收集ftrace和perf_events中乱七八糟的参数。 ktap Linux的基于脚本的动态跟踪工具 允许用户跟踪Linux内核动态。 sysbench 一个开源的、模块化的、跨平台的多线程性能测试工具,可以用来进行CPU、内存、磁盘I/O、线程、数据库的性能测试。 ab (apachebench) ab命令会创建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。 wrk 针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 jmeter Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试。 openssl 加解密能力也是CPU性能测试的一部分。 UnixBench 类unix系(Unix,BSD,Linux)统下的性能测试工具 lmbench 多平台软件，因此能够对同级别的系统进行比较测试，反映不同系统的优劣势，可用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能. perfbench perf下的工具 测试系统性能 hping3 面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。 iperf 网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 ping 向特定的目的主机发送 ICMP（Iternet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。 ttcp 传统的测试TCP性能的工具,它主要测试两个机器之间TCP的吞吐量(在应用层模拟消息传递的过程) traceroute 利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。 mtr 网络连通性判断工具，它结合了ping, traceroute,nslookup 的相关特性 pchar 沿Internet路径执行网络测量 调优工具(Tuning Tools) sysctl (System Administration)用来配置与显示在/proc/sys目录中的内核参数 swapon 用于激活Linux中的交换空间，Linux的内存管理必须使用交换区来建立虚拟内存。 env gnu的coreutils包内的一个软件，用来显示系统中已存在的环境变量,以及在定义的环境中执行指令。 tune2fs 允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。 ionice 获取或设置程序的IO调度与优先级。PRI(new)=PRI(default)+nice nice 调整程序运行的优先级，当前程序运行优先级基础之上调整指定值得到新的程序运行优先级。 renice 重新指定一个或多个进程的优先级 taskset 将某个进程与某个CPU核心绑定。 ulimit 为shell内建指令，可用来控制shell执行程序的资源 chcpu 修改cpu的状态,启用和关闭cpu，扫描新的CPU,改变底层虚拟机监控程序的CPU调度模式,并请求CPU的系统管理程序(配置)或返回CPU hypervisor numactl 用于控制进程与共享存储的 NUMA 技术机制。 sysctl 用于运行时配置内核参数,这些参数位于/proc/sys目录下。 ethtool 用于查询及设置网卡参数 stap (SystemTap) 内核开发者必须要掌握的一个工具,用于内核监控和跟踪，以及诊断性能或功能问题。 kpatch 给Linux内核动态打补丁但是不必重启系统 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"},{"title":"Linux系统目录结构","text":"/bin (binary)目录存放着最经常使用的命令 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 包括Linux内核文件，以及开机菜单与开机所需的配置文件 linux kernel常用的文件名为vmlinux /dev (device)该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc (Editable Text Configuration)可配置文件存放所有的系统管理所需要的配置文件和子目录。 /etc/init.d所有服务的默认启动脚本都是放置在这个目录内 /etc/xinetd.d所谓的super daemon管理的各项服务的配置文件目录 /etc/X11与X Windows有关的各种配置文件都在这里 /etc/securetty只有/etc/securetty中登记的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录 这个终端指tty1之类的 /etc/passwd保存的就是系统中所有的用户和用户的主要信息 /etc/shadow/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。 /home (home directory)用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 系统默认的用户主文件夹 比较重要的是 主文件夹有两者代号 ~ 代表目前这个用户的主文件夹 ~dmtsai 代表dmtsai的主文件夹 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 放置的是开机会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库而已 尤其重要的是/lib/modules/这个目录 放置内核相关的模块（驱动程序） /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 这个目录是使用标准的ext2/ext3文件系统格式才会产生的目录 /medialinux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 包括软盘，光盘，DVD等设备都暂时挂载于此 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，或者说是额外的设备 比较早的时候，这个目录的用途与/media相同。只是有了/media之后这个目录就暂时用来挂载用了 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 给第三方软件放置的目录 /proc (process)这个目录本身是一个虚拟的文件系统，放置的数据都是在内存中:例如，系统内核，进程，外部设备的状态及网络状态等 目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息 这个目录的内容不在硬盘上而是在内存里，本身不占用任何硬盘空间，我们也可以直接修改里面的某些文件 /root该目录为系统管理员，也称作超级权限者的用户主目录。 /run是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 这个目录的内容数据也是在内存中的信息，同样不会占用任何的硬盘容量 Secure Enhance Linux的执行目录 /srv (service) 该目录存放一些服务启动之后需要提取的数据。 一些网络服务启动之后，这些服务所取用的数据目录 存放服务启动后需要提取的数据（不用服务器就是空） /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 这个目录与/proc目录类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。包括目前已经加载的内核模块与内核检测到的硬件设备信息等。 这个目录同样不占用硬盘容量。 /tmp这个目录是用来存放一些临时文件的。 /usr (UNIX Software Resource,而不是user)是UNIX 操作系统软件资源所放置的目录，而不是用户的数据.这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。注意事项：FHS建议所有软件开发者将他们的数据合理地放置到这个目录下的子目录，而不要自行新建软件自己独立的目录有点像windows系统中C:\\Windows\\和C:\\Program files\\这两个目录的综合体 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 附注上面这些目录比较完备了 我主要是根据菜鸟教程，鸟哥的私房菜进行整理的 关于/run这个目录稍微特殊一点点，有的系统是二级目录，如果你的系统上有 /var/run 目录，应该让它指向 run。 可以用ls -l / 命令查看目录树 关于挂载开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"哈希表（散列表）详解","text":"基本概念散列方法（hashing）：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立起映射关系。散列表（hashtable）：逻辑上由一些列可存放词条（或者其引用）的单元（称作桶（bucket）或桶单元）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作桶数组（bucket array）地址空间（address space）：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。 散列函数（hash function）：用来描述散列方法，是从关键码空间到桶数组地址空间的函数。比如下面的hash()： 1hash() : key -&gt; hash(key) key的散列地址（hashing address）：也就是上面的hash(key) 。 完美散列（perfect hashing）：在时间和空间性能方面均达到最优的散列，也就是没有空余，没有重复的散列。 装填因子（load factor）：散列表中非空桶的数目与桶单元总数的比值。是散列表的空间利用率度量方法。 散列冲突（collision）：关键码不同的词条映射到同一个散列地址的情况。 词条的聚集（clustering）：词条集中到散列表内少数若干桶中（或附近）的现象。 综上散列表的基本构思概括为： 开辟物理地址连续的桶数组hba[],借助散列函数hash(),将词条关键码key映射为桶地址hash(key),从而快速确定待操作的词条的位置。 散列函数好的散列函数应该具备的条件： 确定性 ：也就是说词条E的映射地址hash(E.key)必须完全取决于E.key。 简单性 ：映射过程不能过于复杂 所有关键码经过映射后应该尽量覆盖整个地址空间。也就是说hash()最好是满射。 均匀性 ：最重要的原则，关键码映射到各个桶的概率是同等的，应该尽量为1/R ，R为散列表长度或容量。 直接定址法直接定址法：关键码就可以直接用作为散列地址 1hash(key)=key 除余法（devision method）除余法：选择一个适当的正整数R,用R去除关键码去除关键码,余数作为 散列地址.这个方法的关键是选取适当的R。一般R为素数，采用素数表长是是降低聚集发生概率的捷径。 1hash(key)=key mod R //R为散列表长度或容量。一般R为素数。 缺点：残留有某种连续性，比如相邻关键码所对应的散列的地址，总是彼此相邻。 MAD法（multiply-add-divide method）乘加除法乘加除法：需要依次执行乘法，加法，和除法运算得名。解决的问题：用来克服除余法的连续性缺陷。 12hash(key)=(a * key + b)mod R //a&gt;0，b&gt;0，且(a mod R) !=0//R为散列表长度或容量。一般R为素数。 数字分析法（selecting digits）数字分析法：从关键码key中特定进制的展开中抽出特定的若干位，构成一个整型地址。对关键码的各位进行分析（多种方法），丢下分布不均匀的位，留下均匀的位作为地址。数字分析法举例： 平方取中法（mid-square） 折叠法（folding） 一般折叠 往复折返式折叠 异或法（xor） 一般异或 往复折返式异或 伪随机数法越是随机，越是没有规律的就是好的散列函数。 1hash(key)=rand(key) mod R //R为散列表长度或容量。 冲突及其排解开散列策略/封闭定址开散列（open hashing）或封闭定址（closed addressing）： 开放基本的散列表结构，引入次级关联结构。 散列表中的地址只对特定的词条开放（每个桶可以只能能存放特定的一组词条）。 多槽位法（multiple slots）多槽位法：将每个桶细分为更小的称作槽位（slot）的若干单元，每一组槽位可以组织为向量或列表。//类似于二维数组 独立链法（separate chaining)（拉链法）拉链法：某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。//引入链表先计算哈希地址，然后搜索该地址的单链表。 公共溢出区法（overflow）在原有散列表hashA之外再设置一个公共溢出区（散列表hashB），如果抽入词条发生冲突，就将该词条转存至公共溢出区（散列表hashB）中。 //引入新的散列表可以说是一种递归形式的散列表。 闭散列策略/开放定址闭散列（open hashing）或开放定址（closed addressing）： 仅仅依靠基本的散列表结构，就地排解冲突。 散列表中的地址对所有的词条开放（每个桶可以都有可能存放任一词条）。 一个桶冲突了，只允许在散列表内部为其寻找另一空桶。 线性试探法（linear probing）线性试探法：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。被尝试的桶依次为： 1[(hash(key) + i)mod R ] ,i=1,2,3,... 平法试探法（二次探测法）被尝试的桶依次为： 1[(hash(key) + i^2)mod R ] ,i=1,2,3,... 伪随机试探法被尝试的桶依次为： 1[rand(i)mod R ] ,rand(i)为系统定义的第i个随机数。 再散列法（rehashing）再散列法：使用哈希函数去散列一个输入的时候，如果输出是同一个散列地址就再次散列，直至不发生冲突为止。缺点：每次冲突都要重新散列，计算时间增加。被尝试的桶依次为： 12//hash2为二级散列函数[(hash(key) + i*hash2(key) ] ,i=1,2,3,... 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"},{"title":"《别闹了费曼先生》读书笔记","text":"当科学大师碰上菜鸟 报告时间终于到了。我面前坐了这些科学大师，全在等我开口讲话！我生平第一次学术报告，却碰上这样的听众！我的意思是说，他们会问很多难题，我将会大大地出丑了！我还清楚记得，从牛皮纸袋抽出讲稿时，双手不住地发抖。但奇迹出现了——事实上我很幸运，类似的奇迹在我一生中一再发生——只要我开始思考物理、必须全神贯注于要说明的问题上，我的脑袋中就再没有其他杂念，完全不会紧张。因此当我开始报告以后，我根本不知道听众是谁了；我只不过在说明这些物理概念。事情就那么简单！ 向数学家挑战 我向他们挑战：“我跟你们打赌，随便你提出一个定理——只要你用我听得懂的方式告诉我，它假设些什么、定理是什么等等——我立刻可以告诉你，它是对的还是错的！” 其实，我也并不是随便乱猜的。我有一套方法，甚至到了今天，当别人对我说明一些什么，而我努力要弄明白时，我还在用这些方法：不断地举实例。譬如说，那些念数学的提出一个听起来很了不得的定理，大家都非常兴奋。当他们告诉我这个定理的各项条件时，我便一边构思符合这些条件的情况。当他们说到数学上的“集”时，我便想到一个球，两个不相容的集便是两个球。然后视情况而定，球可能具有不同的颜色、长出头发或发生其他千奇百怪的状况。最后，当他们提出那宝贝定理时，我只要想到那跟我长满头发的绿球不吻合时，便宣布：“不对！” 看怎样用些有趣、近代的数学观念来教数学。原先的目的，是要使那些觉得数学枯燥无味的学生提高兴趣。 费曼教授 20 世纪40 年代，我待在普林斯顿的期间，亲眼看到高等研究院内那些卓越心灵的下场。他们都具备了聪明绝顶的头脑，因此特别被选中，来到坐落在森林旁边的漂亮房子里，整天悠哉游哉地闲坐——不用教书，没有任何约束或负担。但等过了一段日子，他们想不出什么新东西来，每个人心里一定开始感到内疚或沮丧，更加担心提不出新想法。可是一切还是如旧，仍然没有灵感。会发生这种情况，完全是因为那里缺乏真正的活动和挑战：他们没有跟做实验的学者接触，也不必思索如何回答学生提出的问题，什么都没有！ 在任何思考过程中，当一切进行顺利、灵感源源不绝时，教书确实是一种妨碍，十分讨厌。但有更多的时候是脑袋空空的，如果既想不出什么、又没做什么，那真会教人疯狂！你甚至不能说：“我在教书呀！”。 不敢面对问题到弄明白 在罗彻斯特举行了一个会议——一年一度的罗彻斯特研讨会（Rochester Conference）。我还是事事落于人后，而李政道已在发表关于宇称不守恒的论文。他和杨振宁作出宇称并不守恒的结论，现在他正提出解释这现象的理论。会议期间，我住在我位于西瑞桥斯（Syracuse）的妹妹家。我把论文带回家跟她说：“我搞不懂李政道和杨振宁说的东西，这全都那么复杂！”“不，”她说，“你的意思并不是说你无法弄懂它，而是你没有发明它。你没有用你的方法，从听到线索开始做起，把它推演出来。你应该做的是想象自己重新在当学生，把这篇论文带到楼上去，逐字逐句地读，检查每一条方程式。然后你就什么都弄懂了。”我接受了她的建议，把那东西从头看到尾，发现它真的很明显简单。我只是一直害怕去读它，总觉得它太深奥。","link":"/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Linux常用命令整理（1）","text":"Linux命令基础知识 1234567891011$ command [-options] parameter1 parameter2 ... 命令 选项 参数(1) 参数(2) 说明： 1. 任何命令中第一个输入的部分绝对是『命令(command)』或者『可运行文件』 2. command 命令的名称 3. [-options] 选项并不存在于实际的命令中，而加入选项配置时，通常选项前会带 - 号（比如-h）。有时候会使用选项的完整全名，此时带有 -- 符号（比如--help） 4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数； 5. 命令, 选项, 参数等以空格来区分，但是不论空几格 ，shell 都同一视为一格； 6. [Enter]按键代表着一行命令的开始启动。 7. 命令太长的时候，可以使用反斜杠 (\\) 来跳脱[Enter]符号，使命令连续到下一行。反斜杠后需要立刻接特殊字符才行。8. 在 Linux 中，区分大小写。 基本查询查询所支持的语言123456$ echo $LANG zh_TW.UTF-8#修改为英文语系 $ LANG=en_US$ echo $LANG en_US 时间日历与计算器123$ date //date 时间$ cal //cal 日历$ bc //计算器 版本信息查询uname －a查看版本当前操作系统内核信息 cat /proc/version查看当前操作系统版本信息 cat /etc/issue 或 cat /etc/redhat-release查看版本当前操作系统发行版信息 cat /proc/cpuinfoLinux查看cpu相关信息，包括型号、主频、内核信息等 getconf LONG_BITLinux查看版本多少位 lsb_release -aCentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用 命令信息查询命令总数：[Tab][Tab]按下两个[Tab]按键，查看共有多少命令可以让用户使用用。 man page有时忘记了命令全称，也可以根据不完整的名称查出来，系统有哪些跟这个名词有关的说明文件 12 -f 查询以keyword开头所有相关帮助信息列表，只会找数据中的左边那个命令(或文件)的完整名称。$ man -f keyword 12 -k 将说明文件里面只要含有keyword的都列出来。$ man -k keyword 1234$ whatis [命令或者是数据] 相当于 man -f [命令或者是数据] $ apropos [命令或者是数据] 相当于 man -k [命令或者是数据] 两个特殊命令要能使用，必须要有创建 whatis 数据库才行！这个数据库的创建需要以 root 的身份下达如下的命令：[root@ ~]# makewhatis 关机/重新启动命令数据同步写入硬盘中： sync惯用的关机命令： shutdown重新启动，关机： reboot, halt, poweroff在默认的情况下， 这几个命令都会完成一样的工作！(因为halt会先呼叫shutdown，而shutdown最后会呼叫halt！)。 不过，shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt却能够在不理会目前系统状况下， 进行硬件关机的特殊功能 123[root@ ~]# reboot [root@ ~]# shutdown -h now [root@ ~]# poweroff -f halt若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。使用权限：系统管理者。 1[root@ ~]# halt 切换运行等级：initLinux共有七种运行等级run level 0：关机run level 3：纯文本模式run level 5：含有图形接口模式run level 6：重新启动可以使用init来关机 1[root@~]# init 0 文件处理命令目录相关：ls、pwd、mkdir、rmdir1234ls -l //列出当前目录下的文件详细信息pwd [-options] //查看”当前工作目录“的完整路径mkdir [-options] 目录名 //创建目录 rmdir [-options] 目录名 //删除空目录。 文件复制移动：touch、mv、cp、rm1234567mv [选项] 源文件或目录 目标文件或目录//mv命令将文件重命名或将其移至一个新的目录中``` ```bashcp [选项]… [-T] 源 目的//cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。 12touch [选项]… 文件…//touch命令可更改文档或目录的日期时间，包括存取时间和更改时间。 12rm [选项] 文件…rm命令删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。 取得路径的文件名与目录名：basename，dirname查看文件内容：more、less、head、tail、cat、tac、nl、diffmore：一页一页显示文件内容less：less与more类似，但是可以向前翻页head：查看文件时，只显示头几行tail：查看文件时，只显示尾几行【-f 循环读取文件，不断刷新】tac：从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 12345cat [选项] [文件]…主要的三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 1234nl [选项]… [文件]…\\\\可以用来显示文件\\\\nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！\\\\其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 123456789101112diff[参数][文件1或目录1][文件2或目录2]\\\\diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。root@ubuntu:~# diff /snap/ /usr/Only in /snap/: READMEOnly in /usr/: binOnly in /usr/: gamesOnly in /usr/: includeOnly in /usr/: libOnly in /usr/: localOnly in /usr/: sbinOnly in /usr/: shareOnly in /usr/: src 创建文件链接： ln123//ln (link)ln -s source dist # 建立软连接ln source dist # 建立硬连接 软链接(symbolic link)：软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。硬链接(hard link)：硬链接是已存在文件的另一个名字。【不允许给目录创建硬链接；只有在同一文件系统中的文件之间才能创建硬链接。】 硬链接：指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Number)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件,以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。软链接：文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 更改文件权限umask 档案预设权限chattr 配置文件档案隐藏属性lsattr 显示档案隐藏属性file 观察文件类型： chgrp改变所属群组, /etc/group里面可查询群组 1[root@~]# chgrp users code.log chown功能： 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。格式： chown [选项]… [所有者][:[组]] 文件… chmod功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。格式： chmod [-cfvR] [–help] [–version] mode file数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 压缩文件压缩文件和读取压缩文件：tar，gzip，zcat 磁盘占用与挂载dfdf命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。 1234root@ubuntu:~# df Filesystem 1K-blocks Used Available Use% Mounted onudev 491848 0 491848 0% /devtmpfs 100920 628 100292 1% /run du (disk usage)du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。该命令的功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出指定目录，则对当前目录进行统计。 mount在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等 文件查找which12which 可执行文件名称 //查找路径：PATH所含目录//which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 适用场合：查找命令/可执行文件所在的路径。有时候可能在多个路径下存在相同的命令，该命令可用于查找当前所执行的命令到底是哪一个位置处的命令。 whereis123whereis [-bmsu] [BMS 目录名 -f ] 文件名 //查找路径：索引数据库所含目录//whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于源文件，二进制文件，或是帮助文件。//whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 原理：首先会去掉文件名中的前缀空格和以.开头的任何字符，然后在数据库（var/lib/slocate/slocate.db）中查找与经过处理后的文件名相匹配的源文件，二进制文件，或是帮助文件。使用之前可以使用updatedb命令手动更新数据库。适用场合：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate12locate [选择参数] [样式] //查找路径：索引数据库所含目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 原理：默认情况下(文件名中不包含通配符时)，locate会给出所有与filename*相匹配的文件的路径。适用场合：没有文件类型性质的模糊查找 find1find pathname -options [-print -exec -ok …] //查找路径：当前目录/指定目录 适用场合：能用which、whereis和locate的时候尽量不要用find.功能： 用于在文件树种查找文件，并作出相应的处理原理：遍历当前工作目录及其子目录参数： 1.使用name选项，可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。2.按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。3.如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。4.使用type选项,根据不同的文件类型进行查找，如d(目录)、l(链接) find命令之exec-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。例如：find . -type f -exec ls -l {} ;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。find命令之xargsfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 网络管理命令Linux 查看端口占用情况 ip1ip [-option] [动作] [命令] option ：设定的参数，主要有-s显示出该设备的统计数据(statistics)，例如总接受封包数等；动作：就是是可以针对哪些网络参数进行动作，包括有： link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；route ：与路由有关的相关设定 ifconfig1ifconfig [网络设备] [参数] ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 digdig命令是一个功能强大的DNS查询命令。 一般格式： 1dig [@global-server] [domain] [q-type] [q-class] {q-opt} {d-opt} 参数说明：global-server：默认是以/etc/resolv.conf作为DNS查询的主机，这里可以填入其它DNS主机IP。domain：要查询的域名。q-type：查询记录的类型，例如a、any、mx、ns、soa、hinfo、axfr、txt等，默认查询a。q-class：查询的类别，相当于nslookup中的set class。默认值为in（Internet）。q-opt：查询选项，可以有好几种方式，比如：-f file为通过批处理文件解析多个地址；-p port指定另一个端口（缺省的DNS端口为53），等等。d-opt：dig特有的选项。使用时要在参数前加上一个“+”号。 d-opt常用选项：+vc：使用TCP协议查询。+time=###：设置超时时间。 netstat1netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。netstat命令(菜鸟教程) ss(Socket Statistics)12ss [参数]ss [参数] [过滤] 功能： ss命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。ss命令的参数及使用详解 ping1ping [参数] [主机名或IP地址] ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 tracertroute123traceroute[参数][主机]//具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 route1route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 功能： Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 Linux系统的route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 参考资料理解 Linux 的硬链接与软链接鸟哥的linux私房菜Linux下4个查找命令which、whereis、locate、find的总结Linux 命令大全","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/"},{"title":"Linux常用命令整理（2）","text":"统计与过滤 grep用于过滤/搜索的特定字符,可用正则表达式能多种命令配合使用。 1grep [-option] pattern file Linux grep 命令 wc统计指定文件中的行数、字数、字节数，并将统计结果显示输出。 1wc [-option] 文件… 该命令统计指定文件中的行数、字数、字节数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数 12$ wc testfile # testfile文件的统计信息 5 100 600 testfile # testfile文件的行数为5、单词数100、字节数600 Linux wc命令 进程相关进程的挂起1kill -stop PID //将进程挂起（redhat） 需要重新执行当前被挂起的任务时，使用 bg %num 即可将挂起的 job 的状态由 stopped 改为 running，仍在后台执行。需要改为在前台执行时，执行fg %num 即可。也可以使用[ctrl]+[z] pstree123pstree -p //可以显示进程树pstree -apnh //显示进程间的关系pstree -u //显示用户名称 Linux pstree命令 lsof （lists openfiles）1lsof [参数][文件] //需要root执行（因为要访问核心内存和各种文件） 功能： 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。 好用的系统监视工具（神器）。 有着最多开关的Linux/Unix命令之一 lsof打开的文件可以是：1.普通文件2.目录3.网络文件系统的文件4.字符或设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.网络文件（例如：NFS file、网络socket，unix域名socket）9.还有其它类型的文件，等等lsof 菜鸟教程Linux 命令神器：lsof ps(process status)1ps [options] [--help] //用来显示当前进程的状态 ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。如果想要动态的显示进程信息，就可以使用top命令。 1234root@ubuntu:~# ps PID TTY TIME CMD13777 pts/1 00:00:00 bash14564 pts/1 00:00:00 ps Linux ps命令 jobs12jobs[选项][参数] //用于显示Linux中的任务列表及任务状态，包括后台运行的任务。//jobs 的状态可以是 running, stopped, Terminated 该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。 12345678910root@ubuntu:~# jobs //后台没有进程，所以jobs命令的输出是空root@ubuntu:~# ping 192.168.0.1PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.^Z[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs -l //-l：显示进程号；[1]+ 14661 Stopped ping 192.168.0.1 jobs命令 fg、bg、jobs、&amp;、ctrl + z都是与系统任务有关的常用命令 12345command&amp; 或者 ctrl + z 让进程在后台运行 jobs 查看后台运行的进程 fg %jobnumber 让后台的进程jobnumber到前台到前台 bg %jobnumber 让进程jobnumber到后台去 //%jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid) kill1kill[参数][进程号] 功能： 发送指定的信号到相应进程。不指定信号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 1234//通过 jobs 命令查看 job 号（假设为 jobnumber）kill %jobnumber通过 ps 命令查看 job 的进程号（PID，假设为 pid）//kill pid killall1killall[参数][进程名] //用来结束同名的的所有进程（kill processes by name） killall命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。 系统监测top1top [参数] 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 free1free [参数] 功能： free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略 1234root@ubuntu:~# free total used free shared buff/cache availableMem: 1009176 136644 172116 628 700416 687996Swap: 0 0 0 vmstat (virtual memory statistics)功能： 用来显示虚拟内存的信息 1234root@ubuntu:~# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 172200 145008 555428 0 0 0 6 16 15 0 0 100 0 0 虚拟内存的原理：在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。 iostat (I/O statistics)1iostat[参数][时间][次数] 功能： 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。 Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 命令执行watch1watch[参数][命令] 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令（也就是说定个具体时间或者隔一段时间执行一次）watch命令 1watch -n 1 -d 'pstree|grep http' # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。 at1at[参数][时间] 功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on） crontab通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 Linux crontab命令详解 ##文件传输 rcp (remote file copy)1rcp [参数] [源文件] [目标文件] 功能：rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。 rcp（远程文件拷贝）命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。 scp (secure copy)1scp [参数] [源路径] [目标路径] 功能： scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 linux的scp命令可以在linux服务器之间复制文件和目录。 wget1wget [参数] [URL地址] 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。 支持断点下传功能 同时支持FTP和HTTP下载方式 支持代理服务器 参考资料Linux命令大全（手册）Linux 命令大全（菜鸟教程）","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/"},{"title":"Linux概述","text":"Linux设计目标Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。 设计Linux的基本方针： 每个程序只做一件事并且做好。 好的程序员追求的系统 简单，优雅， 一致性 （最小惊讶原理） 较强的功能性与灵活性 意味着系统有较小的一组基本元素，产生多种多样的组合来满足各种应用需要。 Linux的接口 Linux系统层次结构 所有版本的Linux必须提供大量的标准程序，其中一些是POSIX标准指定的，其他的根据Linux的版本而有所不同。它们包括： 命令处理器（shell） 编译器 编辑器 文本处理程序 文件操作工具等 Linux具有三种不同的接口 真正的系统调用接口 库函数接口 由标准应用程序构成的接口 shellshell中，后台运行一个程序的语法是在原本命令后加“&amp;”。 shell脚本：包含shell命令的文件。 可以包含参数，同时使用if、for、while和case等结构。 可以给变量赋值，然后过一段时间再读取这些变量。 linux应用程序应用程序分类Linux的命令行用户界面包含大量的标准应用程序。大致分为6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 过滤器过滤器有： grep、sort、head、tail cut和paste（文档剪切与粘贴） od：将输入（通常是二进制，也包括八，十和十六进制）转化为ASCII文档。 pr：打印机格式化输出 tr：字符大小写转换 编译器和程序设计工具编译器和程序设计工具： gcc ar：将库函数收集到存档文件中 make：维护程序，跟踪哪些头文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。 内核结构 Linux内核结构 内核最底层，负责中断处理程序，这是它们与设备交互的主要方式，以及底层的分派机制。分派在中断时发生。 底层的代码中止正在运行的进程，将其状态存储在内核进程结构中，然后启动相应的驱动程序。 进程分派，在内核完成某些操作并且需要再次启动一个用户进程时，发生。进程分派的代码是汇编代码，并且和进程调度的代码有很大不同。 内核子系统的三个主要部件 I/O部件 包含所有负责与设备交互以及实现联网和存储的I/O功能的内核部件 内存管理部件 维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法。并根据需要把需要的数据和代码页读入内存中。 进程管理部件 主要是进程的创建和中止。还有CPU调度和信号处理。 内核最顶层，是内核的系统调用接口。所有的调用都来自这里，其导致一个陷阱，将系统从用户态切换到受保护的内核态，继而将控制权交给上述的内核部件之一。 参考资料现代操作系统","link":"/2020/04/20/Linux%E6%A6%82%E8%BF%B0/"},{"title":"操作系统与文件系统简述","text":"操作系统 1940s，1950s的年代，计算机慢，一次只能运行一个程序，程序员在打孔纸上写程序，拿到一个计算机房间，交给操作员。操作员等计算机空下来后，将程序放入，然后运行，输出结果，停机。 计算机变快之后，放程序的时间比程序运行时间还长，我们需要计算机以一种方式自动运作——&gt;操作系统 到1950年代尾声，计算机已经变得非常快了，处理器经常闲着，等待慢的设备（比如打印机，读卡器等），也就是程序阻塞在I/O上 50年代后期，曼彻斯特大学研发了世界上第一台超级计算机，Atlas，想法设法最大限度利用它，1962年设计了atlas supervisor程序，能够在一个CPU上运行多个程序（这种能力也叫多任务处理）Atlas是世界上第一台同时支持虚拟内存和内存保护的电脑 同时运行多个程序会有一些问题 每个程序都会占一些内存，切换程序的时候不能丢失数据 解决办法是给每一个程序配置专属内存块 分配专属内存块到物理地址时候，可能物理地址不连续的，为了隐藏这种复杂性，把内存地址虚拟化，也就是虚拟内存机制 这种机制可以使程序内存大小灵活增减，也叫动态内存分配 内存保护：程序只能捣乱自己的内存，不会影响到其他的程序。 分时操作系统Multics 首次在设计时候考虑了安全机制，但是导致系统过于臃肿。 Dennis 和 Thompson 联手打造了Unix，将os分为两部分 操作系统的核心功能，比如内存管理，多任务和输入输出管理，称之为内核 一堆有用的工具，比如程序和运行库 Unix中并没有向multics这么多的错误处理代码-如果有错误产生，就让内核恐慌（kernel panic） 内核崩溃是没有办法恢复的，所以调用了一个pannic的函数，起初只是打印pannic一词，然后无限循环Unix成为1970-1980年代最流行的操作系统之一 1980年代，计算机降价到普通人买得起，这时候叫个人电脑。起初微软的操作系统没有内存保护，经常蓝屏,后来微软都加上了 我们现在用的ios，安卓，windows，macos基本上都有了内存保护，虚拟内存，多任务了； 文件系统文件格式：随机排列文件当然没有问题，但是随机排列会更好的 最简单的文件格式 文本文件（.txt） 元数据（meta data）：关于数据的数据元数据存在于文件开头，在实际的数据前面，因此也叫文件头（header） 早期计算机只做一件事，比如火炮射程表，这时候整个存储器就像一个文件（数据从头到尾直到占用满） 后期计算和存储能力的提升，可以存多个文件了，这时候最简单的方式是把文件连续存储，一个个在内存中连续存放但是存储器没有文件概念，只存储大量位，我们怎么直到文件的开头和结尾在哪呢？所以我们需要一个特殊文件，来记录其他文件存储的位置这个特殊文件有很多名字，这里泛称为“目录文件”,这个文件经常是存放在开头的 目录文件存放 其他文件的名字”文件名+”.“+扩展名“ 文件的元数据，比如创建时间(created)，最后修改时间(last modified)，文件所有者，是否能读写，最重要的是文件的起始位置和长度 就像书的目录意义，更改了书里面的内容，就需要更改对应的目录 目录文件和对目录文件的管理是一个非常简单的文件系统的例子 上面的例子是”平面文件系统“：文件都在同一个层次平面文件系统存在的问题：如果给某个文件加数据，会覆盖掉后面文件的一部分 所以现代的文件系统会做两件事 把空间预先分为一块块，并留一些“预留空间”可以方便改动和管理 （用这样的方案目录文件需要记录文件存放在哪些块里面） 拆分文件，存放在多个块里面，这样文件可以轻松增大和缩小（目录文件会记录不只一个块）//有点像虚拟内存 删除文件只需要在目录文件上删除那条记录即可。 碎片：文件存储在多个块里面，块之间是分开的，顺序也是乱的。//是增删改文件导致的，不可避免的 对很多存储技术来说，碎片是坏事，现实生活中大文件可能存放在数百个块里面，导致打开文件特别慢。如何解决？碎片整理！计算机把数据来回移动，排成正确的顺序 分层文件系统树状目录的形式 目录文件（根目录）不仅要指向文件，还要指向目录（is directory字段）//相对于平面文件系统的变化 无线深度的文件夹 可以轻松移动文件，只需要改动两个目录文件（一个删去一条记录，一个加一条记录） 存储介质如今存储技术正朝向固态前进，没有机械活动部件，里面是集成电路，不用像磁盘那样磁头等待磁盘旋转，ssd访问时间低于1/1000秒，但是仍然比RAM慢很多倍，所以现代计算机仍然用层次存储结构。第一个RAM出现于1972年，成本每比特一美分 参考资料Crash Course Computer Science","link":"/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/"},{"title":"常用数据结构简述","text":"算法处理的数据在内存中的格式是什么？我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构 数组array几乎所有的编程语言都自带了许多函数来处理数组，比如数组的排序 字符串string是数组的亲戚i = “love”虽然长得不像数组，但的确是数组，在计算机幕后的确是这样的字符放在内存中以/0结尾，不是”字符0“而是”二进制0“，这叫字符“null”，表示字符串结尾。 这个字符非常重要，如果调用print函数，会从开始位置逐个显示到屏幕，但是得直到什么时候停下来!否则会把内存中的所有内容输出。 矩阵matrix数组的数组 结构体struct多个变量打包在一起，在内存中会自动组织到一起的 节点node与指针struct可以构建复杂的数据结构，比如node 12345struct listnode{ int value; listnode * next;}; 链表linked list使用node来构建链表灵活性是通过每个节点指向下一个节点实现的循环链表（circular list）：尾部的next指向开头非循环链表：尾部节点指针值是null链表使用的时候很少看具体地址么，而是经常使用链表的抽象模型 链表的优点 容易重新排序，两端缩减，分割，倒序等 因为灵活很多数据结果可以用链表实现，比如队列和栈 队列queueFIFO队列的链表实现比方1-&gt;2-&gt;3-&gt;4-&gt;5可以让队列头指向1，队列尾部指向5 （也就是链表的节点连接是反向的）入队（enqueuing）出队（dequeuing） 栈stackLIFO入栈（push onto the stack）和出栈（pop from the stack） 树tree123456struct treenode{ int value; listnode * nextleft; listnode * nextright;}; 最重要的性质：树到根是单向的 二叉树 binary tree每个节点至多两个孩子 图graph顶点多对多 参考资料Crash Course Computer Science","link":"/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"},{"title":"软件工程简述","text":"为了写大型程序，程序员们使用了各种工具和方法，形成了软件工程这门学科。软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言： 这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。 对象尽管可以将大项目分解为小函数，每个人同时工作，不用关心整个项目，只关心自己的函数高效和正确就好啦，然而把代码打包成函数还是远远不够的。比如微软Office软件有近4000万行代码，打包成函数也还有几十万个，也还是也有点多。解决办法是，把函数再次打包成为层级，把相关的代码都放到一起，打包成对象（objects）。 面向对象编程（object oriented programming）把函数打包成为对象的思想叫做“面向对象编程”。对象可以包含对象，函数，变量。子对象也是同样的，所以会出现沿着对象层级一层层找执行函数的做法。 API软件工程的比喻：就像建造摩天大一样，有管道工配置管道，电工装电线，油漆工涂油漆，还有成败上千人做其他的事情。所以一个大团队中有许多小团队，不同小团队之间负责不同的功能，所以不同团队之间需要文档，才能帮助理解代码都在做什么，还需要定义好的程序编程接口（API）API帮助不同程序员合作，不需要直到细节，只要直到怎么使用就好了。 然后private与public提供不同的权限，哪些不让外部访问，哪些仅供内部访问。 面向对象的核心： 隐藏复杂度 选择性公布功能 IDE与调试（debugging）代码在编译之前只是文字，可以用任何文本处理程序写代码，但是一般来时，还是会用专门的工具来写比较好。IDE提供了许多有用功能，因为集成了所有的东西，所以叫IDE。 代码帮助，提示，整理，编译，测试 文档和注释（readme/comment）程序员另一项重要工作是给代码写文档文档一般放在readme中文档也可以写成注释，放在源代码中好的文档的作用： 能帮助开发者几个月后理解自己和他人的代码 还能提升复用性，与其让程序员一遍遍写已经有的东西，不如直接用别人写好的来解决问题。 版本控制源代码管理，帮助团队协作，也叫版本控制。弄懂git原理即可。 质量控制写代码与测试代码密不可分。测试也称为质量保证测试（QA，quality assurance testing）。严格测试软件的方方面面，看软件会不会出错，也就是找Bug。 Beta Alphabeta版软件（beta software）：意思是软件接近完成，但不是百分之一百通过测试过，公司有时会向公众发布beta版本，以帮助发现问题。alpha版软件（alpha version software）：一般很粗糙，错误多，只在公司内部测试。 参考资料Crash Course Computer Science","link":"/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"title":"文件系统（1）","text":"基础概念文件系统：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容 文件文件结构文件可以有多种构造方式。 字节序列（Windows，UNIX都采用这种文件模型） 记录序列（以前大型计算机系统中的常见模式，现在没多少了） 树（处理商业数据的大型计算机中获得广泛使用） 文件在这种结构中由一棵记录树构成，每个记录并不具有同样长度，记录的固定位置有一个键。树按键排序，从而对特定的键进行快速查找 文件类型Linux中分为 普通文件（regular）：存在于外部存储器中，用于存储普通文件。 目录文件（directory）：用于存放目录项，是文件系统管理的重要文件类型。 管道文件（pipe）：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件（socket）：一种用于网络间通信的特殊文件。 链接文件（link）；用于间接访问另外一个目标文件，相当于widows快捷方式。 字符设备文件（character）:字符设备在应用层的访问结构。 块设备文件（block）：块设备在应用层的访问接口。 文件存取 顺序存取文件（sequential access）：进程可以从头到尾顺序读取文件的全部字节或者记录，但不能跳过某一些内容，也不能不按顺序读取。可以返回到起点的。 随机存取文件（random access）：以任何次序读取其中字节或记录的文件。对很多应用程序来说是必不可少的，比如数据库系统 文件属性操作系统常用的文件属性 文件保护 属性 含义 备注 保护 谁可以存取文件，以什么方式 口令 存取文件需要的口令 有一些系统中，用户必须给出口令才能存取文件 创建者 创建文件者ID 所有者 当前所有者 标志 属性 含义 备注 只读标志 隐藏标志 系统标志 0表普通文件，1表示系统文件 存档标志 0表示已经备份，1表示需要备份 ASCII/二进制标志 0表示ASCII文件，1表示二进制文件 随机存取标志 0表示只允许顺序存取，1表示随机存取 临时标志 0表示正常，1表示进程退出时删除文件 加锁标志 0表示未加锁，非零表示加锁 查找读写相关 属性 含义 备注 记录长度 一个记录中的字节数 键的位置 每个记录中键的偏移量 键的长度 键字段的字节数 当前大小 文件字节数 最大长度 文件可能增长到的字节数 时间 属性 含义 备注 创建时间 最后一次存取时间 最后一次修改时间 文件操作最常用的一些系统调用（不限制系统的总结） create delete open close read write append：write的限制形式，智能在文件末尾读取数据 seek：对于随机存取文件，通常需要指定从何处读取数据，通常使用seek系统调用把当前位置指针指向文件中的特定位置。seek调用结束后，就可以从该位置开始读了。 get attributes set attributes rename Linux文件IO函数，通常包括 open,read,write,lseek,close这五个函数。 目录目录操作 create delete opendir closedir readdir rename link ulink 文件系统的实现文件系统布局文件系统存放：文件系统存放在外存上。多数磁盘划分为一个或者多个分区，每个而分区有一个独立的文件系统。主引导记录（master boot record，MBR）：磁盘的0号扇区称为主引导记录，用来引导计算机，MBR之后挨着的是分区表,该表给出了每一个分区的起始和结束地址。在计算机被引导时，BIOS读入并执行MBR。MBR执行的第一件事情是确定活动分区，读入活动分区的第一个块，称为引导块（boot block），并执行之。引导块中的程序将装载该分区中的操作系统。为了统一，每个分区都从一个启动块开始，即使它不含一个可以启动的操作系统。不过，在将来这个分区也许会有一个操作系统的。 文件的实现文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。不同的操作系统采用不同的方法。 连续分配最简单的分配方案：把每个文件座位一连串连续数据存储在磁盘上。所以，在块大小为1KB的磁盘上，50KB的文件要分配50个连续大小的块。优点 实现简单。记录每个文件用到的磁盘块简化为只需记住两个数字即可：第一块的磁盘地址和文件的块数。 读性能好。单个操作就可以从磁盘上读出整个文件。只需一次查找（对第一个块）。之后就不需要寻道和旋转延迟，所以数据以磁盘全带宽的速率输入。可见连续分配实现简单且具有较高的性能。 很适合DVD，CD-ROM等一次性光学介质的存储。 缺点 磁盘零碎问题。删除文件之后会留下空闲块，随着时间的推移会使得磁盘变得零碎，既有文件也有空洞 要么压缩磁盘。代价太高不可行。 要么重新使用空洞。需要维护一个空闲空间列表，但是为了挑选合适的空闲空间，需要知道该文件的最终大小。如果用户为了避免找到的空闲空间太小而提前给出一个不切实际的较大数字，则可能无法找到合适的空闲空间而导致失败。 链表分配链表分配：为每个文件构造磁盘块列表，每一个块的第一个字作为指向下一块的指针，块的其他部分存放数据。优点 可以充分利用每个磁盘块，不会因为磁盘碎片而浪费存储空间。 顺序读文件很方便 缺点 随机存取非常慢 由于指针占去了一些字节，每个磁盘块存储文件数据的字节数不再是2的整数次幂，这种怪异的大小会降低文件的存储效率。（类似于没有对齐） 很多程序都是以2的整数次幂来读写磁盘块的。因为上面论述的原因，要读出一个完整的2的整数次幂的块需要从两个磁盘中获得和接收信息，这就因为复制引发了额外的开销。 在内存中采用表的链表分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 可以取出每个磁盘块的指针字，把它放在内存的一个表里面，就可以解决链表分配的两个不足。 文件分配表（FAT,File Allocation Table）：这个表实现了链表的操作。文件分配表的每一个表项存放着文件数据的下一个块的块号 优点 磁盘文件块可以不用存放指针，这样整个块都是数据。 随机存取更加容易，整个文件分配表实现的链表都在内存中，不需要磁盘引用。 不管文件多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。 缺点 占用内存空间大。必须整个表都存放在内存中。 对于200GB的磁盘和1KB大小的块，这张表有2亿项，每一项至少三个字节，为了提高查找速度，有时需要4个字节。根据系统对空间和时间的优化方案，这张表需要600MB或者800MB，不实用。 i节点分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 既然整张文件分配表太大了，我们就拆分成小的放，实现一个新的数据结构i节点。 i节点（index-node）：每个文件都赋予了一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。优点： 只有在对应的文件打开时候，其i节点才在内存中 缺点与解决方案： 每个i节点只能存储固定数量的磁盘地址，那么当一个文件所包含的磁盘块的数目超出了i节点所能容纳的数目怎么办呢？ 一个解决方案，最后一个i节点中的磁盘地址不指向数据块，而是指向一个包含磁盘块地址的块的地址。 目录的实现每个目录项只引用i节点的目录 共享文件共享文件：当几个用户在同一个项目里面工作时候，他们常常需要共享文件。其结果是，如果一个共享文件同时出现在属于不同用户的不同目录下面，工作起来就很方便。连接（link）：原本属于C目录下的文件也出现在B目录下的话，B的目录与该共享文件的联系称为一个连接（link）。这样文件系统本身也成为了一个有向无环图（DAG）。 共享文件的问题： 如果目录包含磁盘地址，则当连接文件的时候，必须把C目录中的磁盘地址复制到B目录。如果B或者C之后又向文件中添加内容，则新的数据块只会列入添加工作的用户的目录中。其他用户是不知道的。这违背了共享的初衷 硬连接和软连接解决方案： i节点方法：磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中，目录指向这个数据结构(Linux中的i节点）（硬连接） 实现机制：需要有一个文件所有者计数机制，当B连接到共享文件时，i节点记录文件的所有者是C，建立一个连接并不会改变所有关系，但是它将i节点的连接技术加1，所以系统知道当前有多少目录项指向这个文件。 缺点：C删去这个文件之后，还有许多目录项指向它，其他硬连接会指向错误的文件。 改进：唯一能做的是只删除C的目录项，但是保留i节点，所有者计数减一。只有到计数为0的时候才会真正删除该文件。 符号链接方法（symbolic linking）：让系统建立一个类型为Link的新文件，并把该文件放在B目录下，使得B与C的一个文件存在链接。链接文件只包含了它所连接的文件的路径名。（软连接） 缺点：需要额外的开销。必须读取包含路径的文件，然后一个部分一个部分地扫描路径，直到找到i节点 缺点：每个符号链接需要额外的i节点和一个额外的磁盘块用于存储路径，如果路径很短，作为一种优化，系统可以将它存储在i节点中。 优点：只要简单提供一个机器的网络地址和文件在该机器上的路径，就可以连接全球任何地方的机器的文件。 tips：还有一个由连接带来的问题，在符号连接和其他方式中都存在。如果允许连接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被连接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被连接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被连接的文件将被两次复制到磁盘上，而不是只是被链接起来。 参考资料现代操作系统简直不要太硬了！一文带你彻底理解文件系统理解linux 的 inode解决inode耗尽问题","link":"/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/"},{"title":"C++内存分配与内存划分","text":"C/C++内存使用划分C/C++编译过的程序使用的内存划分： 栈区 是连续的内存区域。 由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。 栈区的变量通常是局部变量、函数参数等。 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 每次程序运行都会分配一个栈，main函数就在栈底，然后通过不同函数的调用顺序，依次进栈出栈。c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗 堆区（动态内存分配） 是不连续的内存区域。 自由存储区或堆：每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C 语言程序使用一对标准库函数malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和delete 表达式实现相同的功能。可以手动释放或者程序结束自动释放存储空间。优点：动态内存的生存期人为决定，使用灵活。缺点：是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 全局/静态存储区全局变量和静态变量的存储是放在一起。C语言中，全局变量又分为初始化的和未初始化的。C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统释放。 常量存储区这是一个比较特殊的存储区，里面存放的是常量，不允许修改。程序结束后由系统释放。 程序代码区存放函数的二进制代码。 堆存储/栈存储对象是存放在堆中还是栈中要看怎么去构造这个对象： 如果用new来生成的对象,是放在堆中的。 直接定义的局部变量内都是放在栈中的，全局和静态的对象（包括类的静态数据成员）是放在数据段的静态存储区 1234Class Test；Test p; //栈上分配内存Test* tTest； //指针在栈中tTest = new Test;，//new的在堆中 堆存储 因为没有专门的系统支持，效率很低； 可能引发用户态和核心态的切换，内存的申请代价变得更加昂贵。 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 因为找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 栈存储 用于存储占用空间小，生命周期短的数据（局部变量/参数变量等） 若栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出 出现栈内存溢出的常见原因有2个： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。 局部变量体积太大。 地址分配 堆，往下增长，向内存地址增加的方向增长 栈，往上增长，向内存地址减小的方向增长（对于小端存储，高位字节在高端地址、低位字节在低位地址，因此在压栈时先压高字节后压低字节） 可能会发生堆栈冲突(从堆中分配内存失败或者爆栈) 大端存储：数据高位在内存低位，低位在内存高位（如Freescale的PowerPC处理器） 小端存储：数据高位在内存高位，低位在内存低位（Intel的芯片一般是小端存储） 分配效率栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 堆、栈与大小端存储 数据存放基本数据类型： 直接存储在栈(stack)中的数据。（字符串、布尔值、未定义、数字、null） null只是一个空指针对象，没有数据。 引用类型： 将该对象引用地址存储在栈(stack)中，然后对象里面的数据存放在堆中。（数组、对象、函数） 存储的是该对象在栈中的引用，真实的数据存放在堆内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝与浅拷贝深拷贝既复制对象空间又复制资源在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值，然后同步复拷贝开辟空间的值。 浅拷贝只复制对象空间而不复制资源 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。default memberwise copy即称为浅拷贝。 即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝) 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值； 如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 C/C++内存分配的三种方式 静态存储区分配内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。 栈上分配在函数执行时，函数内的局部变量的存储单元在栈上创建，由操作系统自动分配，函数调用结束时内存也随之析构栈内存分配运算内置于处理器的指令集中，效率高，但栈容量小。 堆上分配堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放,在整个程序运行周期内都存在。 tips: 申请内存后立即判断指针是否为NULL确定内存是否分配成功，如果为NULL则立即用return终止此函数，或者用exit（1）终止整个程序的运行，为new和malloc设置异常处理函数； 为申请的内存赋初值，分配的是一段连续的内存空间的话，要防止指针下标越界； sizeof是操作符，不能用sizeof得到内存空间的大小，只能在申请时候记住申请的空间大小； 在内存使用结束后必须用free或delete释放内存，注意在内存使用中如果存在指针加1或减1 的操作应特别注意，释放的内存要和申请的内存一致，放置内存泄漏，释放内存后，应该立即将指针置为NULL，不要存在野指针。 参考资料[1]浅拷贝与深拷贝的区别[2]C++中数据存储的位置[3]C++经典面试之 内存分配的三种方式[4]堆、栈与大小端存储[5]c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗","link":"/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"},{"title":"C++特性及优缺点","text":"C++语言优缺点 优点 兼容性好，C++在保持了C语言简洁高效的特点的同时，还对C的类型系统进行改革性扩充，相比C语言，C++更安全，其编译系统也能检查出更多错误类型。 面向对象编程能力，可复用性好，可以让团队衍化出自己的的类库。 性能优势，程序效率高。 缺点 C++ 是 C 语言的一个超集，既有指针又有对象使它成为最复杂的语言，学习难度大。过分的精细和复杂了。C++的复杂度，超过了C和OO（面向对象）的复杂度之和 没有垃圾回收机制。 C++本质上说是提前编译的，Fortran也是。C#和Java大多时候是编译成字节码，运行的时候再 即使编译。Python和Ruby通常是解释型。这就产生了一个性能的分级：C++和Fortran比Java和C#快，Java和C#又比Python 和Ruby快。几种计算机语言的评价（修订版）为什么一些语言会比别的快？ C++特性C++面向对象的三个基本特征：封装、继承、多态。它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用在 C++ 中，用类进行封装（数据抽象），用类派生从一个类继承另一个：派生类继承基类的成员。多态（动态绑定）使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数继承和多态（动态绑定）在两个方面简化了我们的程序：能够容易地定义与其他类相似但又不相同的新类，能够更容易地编写忽略这些相似类型之间区别的程序。 封装（encapsulation）封装是一项低层次的元素组合起来的形成新的、高层次实体的技术。 函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。 类也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。 目的： 将抽象得到的数据和行为相结合，形成一个有机的整体（结合性） 将对象的使用者和设计者分开，以提高软件的可维护性和可修改性 实现代码重用 继承（inheritance）继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 通过继承关联起来的类型都共享共同的接口。当一个类继承另一个类时，这两个类通常可以使用相同的操作。更确切地说，如果两种类型存在继承关系，则可以说一个类“继承”了其父类的行为——接口。 C++ 中所提及的父类称为基类（base class），而继承而来的类则称为派生类（derived class）。 多态（polymorphism）多态：多态的基础是继承。多态下，子类重写父类的方法，实际使用过程中，用父类引用变量指向子类对象，此时父类引用调用的是子类重写后的方法，由于是父类引用变量，所有无法调用子类特有的方法。如果想调用子类特有的方法，必须强制类型转换到子类。多态性派生于一个希腊单词，意思是“许多形态”。之所以称通过继承而相关联的类型为多态类型，是因为在许多情况下可以互换地使用派生类型或基类型的“许多形态”。在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。多态性：指的是基于引用或指针的动态类型获得类型明确的行为的能力。 在C++中的主要表现是动态多态（动态绑定） 动态多态（动态绑定）：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。 在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。 引用和指针的静态类型与动态类型可以不同，这是 C++ 用以支持多态性的基石。 静态多态（编译期/早绑定）template（模板）：静态多态（编译时完成，效率高，适配性高，松耦合性），隐形接口overload（重载）：静态多态 同名函数，不同参数/函数返回值 相同范围，同一个类中 overwrite（重写）：静态多态，子类屏蔽父类的同名基函数 同名同参，无virtual 同名不同参 动态多态（运行期/晚绑定）override（覆盖重写）：动态多态（运行时完成，接口重用，编译器无法优化） 不同类中 同名，同参 基类函数有virtual 参考资料[1]C++ primer 第四版[2]几种计算机语言的评价（修订版）[3]为什么一些语言会比别的快？[4]C++ 特性及类（面试复习整理）[5]C++ 多态-菜鸟教程","link":"/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"设计模式总结","text":"设计模式是什么？ 基础概念设计模式（Design pattern）: 是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 GOF（Gang of Four）1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 为什么要用设计模式？ 为了重用代码 让代码更容易被他人理解 保证代码可靠性。 设计模式在软件开发中的两个主要用途： 开发人员的共同平台，提供了一个标准的术语系统，且具体到特定的情景。 例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式有哪些？共有 23 种设计模式，可以分为三类： 创建型模式（Creational Patterns） 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式（Structural Patterns） 用于在许多不同的对象之间形成大型对象结构,关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 行为型模式（Behavioral Patterns） 关注对象之间的通信,用于管理对象之间的算法、关系和职责。 创建型模式单例模式（Singleton Pattern）单例模式-菜鸟教程目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。何时使用：当您想控制实例数目，节省系统资源的时候。面临的问题：一个全局使用的类频繁地创建与销毁。解决方案判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。应用实例：1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。使用场景：1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。实现方式:《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 常见的单例模式分为两种：1、饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式2、懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式【C++】单例模式/工厂模式 工厂模式（Factory Pattern）设计模式之工厂模式（factory pattern）讲的很形象工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式。工厂模式-菜鸟教程提供了一种创建对象的最佳方式，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。目的：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程（类的实例化）延迟到子类进行。何时使用：我们明确地计划不同条件下创建不同实例时。面临的问题： 抽象工厂模式（Abstract Factory Pattern）根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者（生成器）模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 深拷贝与浅拷贝浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深拷贝：把要复制的对象所引用的对象都复制一遍。深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 结构型模式适配器模式（Adapter Pattern）作为两个不兼容的接口之间的桥梁。将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 装饰者模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。作为现有的类的一个包装。动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）用于减少创建对象的数量，以减少内存占用和提高性能。尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern）为其他对象提供一个代理以控制对这个对象的访问。 行为型模式模版方法模式（Template Method Pattern）设计模式 - 模板方法.定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。比如冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 命令模式（Command Pattern）设计模式 - 命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 观察者模式（Observer Pattern）当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。 中介者模式（Mediator Pattern）用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 备忘录模式 （Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 解释器模式（Interpreter Pattern）为语言创建解释器，通常由语言的语法和语法分析来定义。给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 状态模式（State Pattern）类的行为是基于它的状态改变的。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。 职责链模式 （Chain of Responsibility Pattern）为请求创建了一个接收者对象的链，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 访问者模式 （Visitor Pattern）使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 参考资料设计模式之工厂模式（factory pattern）《大话设计模式》读书笔记设计模式-菜鸟教程C++ 设计模式-CSDN【C++】单例模式/工厂模式C++中的单例模式和工厂模式","link":"/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"C++标准库容器类概述","text":"基础概念容器（container）： 容纳特定类型对象的集合。 C++中所有的容器都是类模板。 所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。容器默认构造函数不带参数。 为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。容器适配器（adaptors）： 适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。 STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。 什么是适配器，C++ STL容器适配器详解 顺序容器和关联容器关联容器和顺序容器的根本不同在于： 关联容器中的元素是按关键字来保存和访问的 顺序容器中的元素则是按它们在容器中的位置来顺序保存和访问的。 顺序容器顺序容器（sequential container）： 它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。 顺序容器不是排序的：元素排列次序与元素值无关。 而是由元素添加到容器里的次序决定。 主要的有三种：可变长动态数组 vector、双端队列 deque、双向链表 list。 汇总的有vector、deque、list、forward_list、array、string等。 表1. 顺序容器与顺序容器适配器: 顺序容器 用途 顺序容器适配器 用途 底层基础容器 vector 可变长动态数组，支持快速随机访问 stack 后进先出（LIFO）堆栈 默认使用deque。满足条件的基础容器有 vector、deque、list list 双向链表，支持快速插入/删除 queue 先进先出（FIFO）队列 默认使用deque。满足条件的基础容器有 deque、list deque 双端队列 priority_queue 有优先级管理的队列 默认使用vector。满足条件的基础容器有vector、deque。 除了上面的表格之外还存在forward_list顺序容器（单向链表，只支持单向顺序访问），请看文章链接 关联容器关联容器（Associative containers）： 支持通过键（key）来高效地查找和读取元素。 关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。虽然关联容器的大部分行为与顺序容器相同，但其独特之处在于支持键的使用。 关联容器支持很多顺序容器也提供的相同操作，此外，还提供管理或使用键的特殊操作。关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 有序关联容器有序关联容器有以下四种：set、multiset、map、multimap。 容器元素根据键的次序排列。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 在迭代遍历关联容器时，我们可确保按键的顺序的访问元素，而与元素在容器中的存放位置完全无关。 map 以键－值（key-value）对的形式组织：键(key)用作元素在 map 中的索引，而值(value)则表示所存储和读取的数据。 map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。 常用操作： map查询操作 操作 作用 m.count(k) 返回 m 中 k 的出现次数 m.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在: 123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 读取元素而不插入该元素: 12345//find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器：int occurs = 0;map&lt;string,int&gt;::iterator it = word_count.find(\"foobar\");if (it != word_count.end()) occurs = it-&gt;second; 更好的请参考：《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;map multimap 支持同一个键多次出现的 map 类型 set set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询。 适用条件： 如果希望有效地存储不同值的集合，那么使用 set 容器比较合适 当只想知道一个值是否存在时，使用 set 容器是最适合的。 set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。 set 容器存储的键也必须唯一，而且不能修改（也体现了 set 存储的元素仅仅是键，而没有所关联的值） multiset 支持同一个键多次出现的 map 类型 multimap和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和set 头文件。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。 无序关联容器unordered_mapunordered_multimapunordered_setunordered_multiset STL容器类库&lt;vector&gt;：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。&lt;list&gt;：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。&lt;deque&gt;：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。&lt;queue&gt;：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。&lt;stack&gt;：为堆栈(后进先出)数据结构定义序列适配器stack。&lt;map&gt;：map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。&lt;set&gt;：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。&lt;bitset&gt;：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。&lt;array&gt;：（TR1）固定大小数组，支持复制。&lt;forward_list&gt;：（c++11）单向列表，forward_list不提供随机访问，这一点跟list相同。forward_list是一个单向链表，只支持单向顺序访问，在链表的任何位置进行插入/删除操作都非常快。&lt;unordered_set&gt;：（TR1)无序容器set，其元素随机存放。唯一键的集合，按键散列。multiset类似于set，但是值不必是唯一的。&lt;unordered_map&gt;：（C++11）（TR1)无序容器map，其键值随机存放。键-值对的集合，由键散列，键是唯一的multimap类似于map，但键不是唯一的。完整的看C++中常用的std标准容器 STL容器类底层实现vector底层数据结构为数组 ，支持快速随机访问 list底层数据结构为双向链表，支持快速增删 deque 底层数据结构为一个中央控制器和多个缓冲区 支持首尾（中间不能）快速增删，也支持随机访问 STL源码分析146页 forward_list 顺序容器，底层数据结构为单向链表。 只支持单向顺序访问，支持快速增删 stack 底层一般用list和deque实现，封闭头部即可。 不用vector的原因应该是容量大小有限制，扩容耗时。 queue 底层一般用list和deque实现，封闭头部即可 不用vector的原因应该是容量大小有限制，扩容耗时 priority_queue底层数据结构：一般是vector为底层容器，堆heap为处理规则来管理底层容器实现 set底层数据结构为红黑树，有序，不重复 multiset底层数据结构为红黑树，有序，可重复 map 底层数据结构为红黑树，有序，不重复 multimap底层数据结构为红黑树，有序，可重复 hash_set 底层数据结构为hash表，无序，不重复 hash_multiset底层数据结构为hash表，无序，可重复 hash_map 底层数据结构为hash表，无序，不重复 hash_multimap底层数据结构为hash表，无序，可重复 C++STL的容器的底层实现详解 参考资料C++容器（STL容器）C++语言学习（九）——C++标准库简介Containers library(cppreference.com)C++中常用的std标准容器 //可以做查找表C++中容易忘的知识点——list和forward_list（四）//可做查寻表C++ STL 的底层实现C++标准模板库（STL）的容器的底层实现C++STL的容器的底层实现详解//可以做查找表","link":"/2020/05/10/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%A6%82%E8%BF%B0/"},{"title":"数据结构总结","text":"（未完待续） 基本概念数据结构： 是数据项的结构化集合。 结构性的表现 数据项之间的相互联系和作用 或者理解为定义于数据项之间的某种逻辑次序 依据逻辑次序的复杂程度划分： 线性结构 半线性结构 非线性结构 序列（sequence）序列（sequence）：最基本的线性结构的统称。序列（sequence）依据数据项之间的逻辑次序与其物理存储的对应关系不同，又可以进一步划分向量和列表： 向量（vector）向量（vector）:所有数据项之间物理存储位置与逻辑次序完全吻合。此时的逻辑次序也称为秩（rank） 循秩访问（call-by-rank），静态存储策略。 列表（list）列表（list）:所有数据项之间物理存储位置与逻辑次序不一定吻合。采用间接定址的方法通过封装后的位置（position）相互引用。 循位置访问（call-by-position）或者称为循链接访问（call-by-link），动态存储策略。 栈（stack）栈（stack）：线性数据结构的一种，视作向量与列表的特例。对象的插入和删除限制在栈的一端。禁止操作的一端称为盲端。栈顶（stack top）：可操作（插入和删除）的一端。入栈（push）与出栈（pop）。栈底（stack bottom）：无法直接操作的盲端。 栈与递归函数调用栈调用栈（call stack）和执行栈（execution）:大部分操作系统中，每个运行的二进制程序都都配有一个调用栈，用来跟踪属于同一个程序的所有函数，记录它们之间的调用关系，并保证在每一个调用实例执行完毕之后，可以准确返回。帧（frame）：调用栈的基本单位，每次函数调用时，都会相应的创建一帧： 记录了函数实例在二进制程序中的返回地址，局部变量，传入参数，还有上一帧的栈中地址。 逆序输出进制转换 递归嵌套栈混洗（stack permutation）：栈的数据从stackA——&gt;stackS——&gt;stackB。 括号匹配： 延迟缓冲： 逆波兰表达式（reverse Polish notation，RPN）： 试探回溯法剪枝试探回溯 八皇后迷宫寻径队列（queue）视作向量与列表的特例 基本概念队列（queue）：线性数据结构的一种，对象的插入和删除限制在队列的两端。队头（front）：允许取出元素的一端。出队（dequeue）:元素的删除操作。队尾（rear）：允许插入元素的一端。入队（enqueue）：元素的插入操作。 队列应用循环分配器银行服务模拟树 半线性结构（semi-linear structure） 其中的元素之间并不存在天然的直接后继或者直接前驱关系。但是只要附加某种约束（比如遍历），就可以在树的元素之间确定某种线性次序关系。因此树属于半线性结构 叶节点（leaf）：无孩子的节点。树的高度（height）:树的所有节点深度的最大值称作该树的高度。教材中约定，单个节点的树高度为0，空树的高度为-1。 如果根结点第0，层数=深度=高度-1 如果根结点第1，层数=深度=高度 节点的高度：任一节点V的高度对应于子树的高度subtree（V）。 多叉树（k-ary tree）k叉树（k-ary tree）：每个节点的孩子均不超过k个的有根树。 多叉树的表示法父节点表示法：一个向量表，存两个属性，一个是data，一个是parent孩子节点表示法：一个向量表，存两个属性，一个是data，一个是children（组织成vector或者list）父亲+孩子节点表示法：一个向量表，存三个属性，一个是data，一个是parent，最后一个是children（组织成vector或者list） 有序树（ordered tree）有序树（ordered tree）：同一节点的所有孩子之间必须具有某一线性次序。这个约束条件使得作为多叉树特例的二叉树有足够的能力表示任何一颗多叉树。 长子+兄弟转换法同一列的是长子，同一行的是兄弟 二叉树（binary tree）二叉树（binary tree）：每个节点的读书均不超过2。有序二叉树（ordered binary tree）：同一父节点的孩子都可以左右相互切分。真二叉树（proper binary tree）：不含一度节点的二叉树 完全二叉树（complete binary tree）完全二叉树（complete binary tree）： 对于使用队列操作的层次遍历，前(n/2向下取整）次迭代中都有左孩子入队，前(n/2向上取整然后-1）次迭代中都有右孩子入队 叶节点只出现在最底部的两层。 高度为：h=（log n）的向下取整 //根节点设置为高度0的情况下 规模介于2^h与2^(h+1)-1 根节点为1，左孩子编号等于2v,右孩子编号2v+1 满二叉树（full binary tree） 规模2^(h+1)-1 遍历递归式遍历迭代版先序遍历迭代版中序遍历迭代版后续遍历层次遍历 编码树编码解码前缀无歧义编码（PFC）huffman编码 二叉编码树根通路串（root path string） 搜索树对线性数据结构查找性能的改进。如果既要求对象集合的组成可以高效率地动态调整，同时也要求能够高效率的查找，对于向量和列表这类线性结构是难以胜任的。兼顾高效率的动态修改和高效率的静态查找，可以使用搜索树。理想平衡和适度平衡，引入平衡二叉树结构，比如AVL树即使在最坏情况下，单次动态查找和静态查找也均在O（log n）时间内完成。 理想平衡和适度平衡理想平衡：如果树的高度恰好为log n，向下取整，则成为理想平衡树 ，比如完全二叉树和满二叉树 适度平衡：渐进意义下适当放松标准的平衡性。渐进的不超过O(log n)下面介绍的红黑树，AVL树，伸展树，kd-树都是适度平衡的变种。也可以归入平衡二叉搜索树之列。 搜索树的局部性 刚刚被访问的节点，可能不久后就能访问到 将被访问的下一个顶点，极可能就在不久之前被访问的某个节点附近 二叉搜索树（BST）二叉搜索树（binary search tree）：处处都满足顺序性——任一节点r的左（右）子树中，所有节点均不大于（不小于）节点r二叉搜索树的判定:任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降。 复杂度分析：insert，remove，search时间：线性正比于查找路径的长度或者最终返回节点的深度。最坏情况下可能退化成为链表。 等价二叉搜索树若两个二叉搜索树的中序遍历相同，则称它们彼此等价。概括一下就是：上下可变，左右不乱。也就是说节点的左右相对关系是不变的，但是上下关系是可以改变的。局部性： 经过单词动态修改操作，至多只有O(log n)处局部不再满足限制条件。 可以在O(log n)时间内，使这O(log n)处局（乃至全树）重新满足限制条件。 旋转调整（修复）zig 顺时针旋转zag 逆时针旋转 平衡二叉搜索树（BBST）AVL树平衡因子(balance factor)：其左，右子树的高度差。各个节点的平衡因子绝对值不超过1。也就是各个节点左右子树高度差不超过1。 失重与重新平衡：单旋与双旋：统一重平衡算法： 伸展树（splay tree）伸展树（splay tree）： 无须时刻都保持全树的平衡，但是却能够在任何足够长的序列上，保持分摊意义上的效率。 不需要对基本的二叉树节点结构，做任何附加的要求或者改动，不需要记录平衡因子或者高度之类的额外信息，故适用范围更广 利用了数据局部性，将刚刚被访问的节点，转移至树根附近。 伸展（splaying）：随着节点e的不断上升，两侧子树的结构也在不断的调整，这种过程也形象地称为伸展。 单层伸展树节点e每次提升1层，直至成为树根 双层伸展树节点e每次提升2层，直至成为树根。 zig-zig/zag-zagzig-zig/zag-zagzig/zag 复杂度分析：分摊的情况下，O（log n） 红黑数（red-black tree）通过假想地引入外部节点（黑色），将二叉树真正扩展为真二叉树。 根节点始终为黑色 外部节点均为黑色 其余节点若为红色，其孩子节点必为黑色 从任一外部节点到根节点的沿途，黑节点的数目相等 由1，2可知，红节点属于内部节点，且红节点的父节点和左右孩子肯定存在 由3可知，红节点之父必为黑色，树的任一通路不会包含相邻的红节点。7 由4可知，所有外部节点的黑高度统一 所有外部节点的黑高度统一特别的，根节点的黑高度也称为全树的黑高度，在数值上与外部节点的黑高度相等。所有外部节点的黑高度为0. 双红修正双黑修正 平衡多路搜索树平衡二叉搜索树（BBST）的推广当数据规模大到内存已经不足以容纳时候，常规平衡二叉搜索树的效率会大打折扣。其原因在于查找过程对外存的访问次数过多。 外部存储适合于批量式访问，不妨通过时间成本较低的多次内存操作，来替代时间成本相对较高的单次外存操作。 结合上面的思想，我们可以将通常的二叉树搜索树，改造为多路搜索树（等价变换） 四路搜索树：每个大节点拥有四个外部的分支。 通常是将二叉搜索树以两层为间隔合并。 一个大节点包含3个关键码和4个外部分支. 多路搜索树（multi-way search tree）：一般地，以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树。 优点： 访问外存的方式相对于二叉搜索树已经发生了本质的变化，可以以大节点为单位读取一组（而不是一个）关键码。 这组关键码在逻辑上与物理上都彼此相邻，故可以以批量方式从外存一次性读出，且需要的时间与读取单个关键码几乎一样。 每组关键码的最佳数目，取决于不同外存的批量访问特性。可以根据扇区的容量等因素来计算。 B- 树平衡多路搜索树的典型代表B-树（B-tree）：m阶B-树，也就是m路平衡搜索树 所有外部节点的深度都相等，每个内部节点都存有不超过m-1个关键码，以及用以指示对应分支不超过m个引用。各个节点的分支数应该介于m/2（向上取整）与m之间，故也称为(m/2向上取整，m)-树B-树的外部节点：B-树的宽度B-树的叶节点 非常适合在相对较小的内存中，实现对大规模数据的高效操作。 复杂度：O(logmN) kd-树（k-dimensional tree）四叉树与八叉树的一般性推广递归定义的平衡二叉树一维范围查询（range query）：给定直线L上的点集P={p0,pn-1},对于任一区间R=[x1,x2],P中的哪些顶点落在其中？离线方式和在线方式输出敏感（output sensitive）的算法平衡二叉搜索树解决一维度范围i查询问题， 找到最低共同祖先，忽略分割成为矩形，举行左边底边开，右边和顶边封闭每次切分都在中位点（对应的坐标排序居中者）。 以保证全树的高度不超过O(log n)复杂度O（根号n） 图非线性结构 邻接矩阵邻接表BFSDFS拓扑排序优先级队列与堆二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。最大堆:，任何一个父节点的值，都大于或等于它左、右孩子节点的值。最小堆:，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 完全二叉堆上滤与下滤左式堆串字符串串匹配散列表看这篇文章即可：哈希表（散列表）详解 注解偏序只对部分元素成立关系R，全序对集合中任意两个元素都有关系R。 集合的包含关系是偏序，因为两个集合可以互不包含。 复数中的大小就是偏序，其中虚数不能比较大小。 实数中的大小关系是全序，两个实数必有一个大于等于另一个。 参考资料数据结构 邓俊辉","link":"/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"title":"环状链表判断算法","text":"判断该链表是否有环 采用两个指针，一个用来遍历，一个用来从头到当前遍历位置的数据对比。思想：比较元素是否出过；复杂度：时间O(n^2),空间O(1) hash表的方法，记录元素，一旦在hash表中出现过,就证明有环复杂度：时间O(n),空间O(n) 双指针类型方法：两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。思想：追及问题，让快的先跑，如果有环，快的绕一圈后肯定会追上慢的。复杂度：时间O(n),空间O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;struct node{ int value; node *next; node(int a):value(a),next(NULL){}};typedef node list;bool iscycle(list * head){ node *p1,*p2; p1 = head; p2= head; while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL) //因为p1每次走两步，所以需要判断一下最后两个是否为空，以便决定是否循环； { p1 = p1-&gt;next-&gt;next; p2 = p2-&gt;next; if(p1==p2) { return 1; } } return 0;}int main(){ node * node1 = new node(5); node * node2 = new node(3); node * node3 = new node(7); node * node4 = new node(2); node * node5 = new node(6); node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = node5; node5-&gt;next = node2; //cout &lt;&lt; node5-&gt;next &lt;&lt; endl; cout &lt;&lt; iscycle(node1) &lt;&lt; endl;} 如何求出环的长度？当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数也就是 环长=1×前进次数 如何求出入环节点？如果链表有环，如何求出入环节点？答：只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。以上答案根据一个走两步一个走一步计算出的。 参考资料漫画算法","link":"/2020/05/14/%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95/"},{"title":"无序数组排序后的最大相邻差","text":"解法1： 使用任意一种时间复杂度为O（nlogn）的排序算法（如快速排序）给原数组排序，然后遍历排好序的数组，并对每两个相邻元素求差。复杂度：时间O（nlogn），在不改变原数组的情况下，空间复杂度是O(n) 解法2：基数排序的思想 利用计数排序的思想，先求出原数组的最大值max与最小值min的区间长度k（k=max-min+1），以及偏移量d=min。 创建一个长度为k的新数组Array。 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1。例如原数组元素的值为n，则将Array[n-min]的值加1。遍历结束后，Array的一部分元素值变成了1或更高的数值，一部分元素值仍然是0。 遍历新数组Array，统计出Array中最大连续出现0值的次数+1，即为相邻元素最大差值。 解法3：桶排序的思想解法3： 利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。其中第1个桶从原数组的最小值min开始，区间跨度是（max-min）/（n-1）。 遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值。 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。时间复杂度是O（n），空间复杂度是O（n*k） 代码C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//获取数组中数字之间的最大差值#include&lt;iostream&gt;#include &lt;algorithm&gt;#include\"memory.h\"using namespace std;struct bucket{ int min; int max; bucket():min(NULL),max(NULL){}};int getmaxdtce(int *a,int n){ //1.找到数列的最大最下值 int *max = max_element(a,a+n); int *min = min_element(a,a+n); int d = *max - *min; if(d==0) { return 0; } //2.初始化桶 int bucketnum = n; bucket *buckets = new bucket[n]; //3.遍历原始数组，确定每个桶的最大最小值 //注意，最大点独占一个桶 //所以前面n-1个桶的间隙是(a[i] - *min) / (d / bucketnum - 1); for (int i = 0; i &lt; n;i++) { int index = (a[i] - *min) / (d / (bucketnum - 1)); if(buckets[index].min==NULL||buckets[index].min&gt;a[i]) { buckets[index].min = a[i]; } if(buckets[index].max==NULL||buckets[index].max&gt;a[i]) { buckets[index].max = a[i]; } } //4. 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。 int leftmax = buckets[0].max; int maxdistance = 0; for (int i = 1; i &lt; n;i++) { if(buckets[i].min==NULL){ continue; } if(buckets[i].min-leftmax&gt;maxdistance) { maxdistance = buckets[i].min - leftmax; } leftmax = buckets[i].max; } return maxdistance;}int main(int argc,char *argv[] ){ int *test = new int[5]; memset(test, 0, sizeof(int) * 5); test[0] = 1;test[1] = 6; test[2] = 3; test[3] = 8; test[4] = 0; cout &lt;&lt;getmaxdtce(test,5);}","link":"/2020/05/14/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B8%E9%82%BB%E5%B7%AE/"},{"title":"使用栈实现的队列","text":"算法思想 其中一个栈A作为队列的入口，用于插入新元素；另一个栈B作为队列的出口，用于移除老元素。 当B为空的时候需要及时将A中的数据转移进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;/* stack&lt;int&gt;q; q.push(1); //入栈 q.pop(); //出栈 q.top(); //返回栈顶成员 q.size(); //返回栈成员个数 q.empty(); //判断是否为空栈*/class stackqueue{ private: stack&lt;int&gt; stacka; stack&lt;int&gt; stackb; public: void enqueue(int a); int dequeue(); void transfer();};int stackqueue::dequeue(){if(!stackb.empty()){ int tmp = stackb.top(); stackb.pop(); return tmp;}else{ if(stacka.empty()) { return NULL; } transfer(); int tmp = stackb.top(); stackb.pop(); return tmp;}}void stackqueue::transfer(){ while(!stacka.empty()) { stackb.push(stacka.top()); stacka.pop(); }}void stackqueue::enqueue(int a){ stacka.push(a);}int main() { stackqueue *que = new stackqueue(); que-&gt;enqueue(1); que-&gt;enqueue(2); que-&gt;enqueue(3); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; que-&gt;enqueue(4); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl;}","link":"/2020/05/14/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%98%9F%E5%88%97/"},{"title":"vector常用操作","text":"vector初始化方法123vector&lt;int&gt; vec; 初始化size为0的vectorvector&lt;int&gt; vec(10); 初始化size为10，默认值都为0的vectorvector&lt;int&gt; vec(10,1); 初始化size为10，值都为1的vector 通过数组初始化通过数组a的地址初始化，注意地址是从0到5（左闭右开区间），类似迭代器 12int a[5] = {1,2,3,4,5};vector&lt;int&gt; vec(a, a+5); 通过vector初始化12vector&lt;int&gt; a(5,1);vector&lt;int&gt; b(a); 通过insert初始化insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中//助记，插入开始的地方 123vector&lt;int&gt; a(6,6);vecot&lt;int&gt; b;b.insert(b.begin(), a.begin(), a.begin() + 3); 将a[0]~a[2]插入到b中，b.size()由0变为3 insert还可以插入m个值为n的元素 12在b开始位置处插入6个6b.insert(b.begin(), 6, 6); 通过copy函数赋值//助记，拷贝到目标地 1234567vector&lt;int&gt; a(5,1);int a1[5] = {2,2,2,2,2};vector&lt;int&gt; b(10);将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间copy(a.begin(), a.end(), b.begin());拷贝区间也可以是数组地址构成的区间copy(a1, a1+5, b.begin() + 5); 常用操作注意：std::vector 不支持 push_front，，它的目的是为了O(1)的push_back(),对它来说O(n)次的insert()就能做到push_front。支持push_front()的是deque支持的是deque。 加入元素1234q.push_back(x); 尾部加入元素q.insert(iter,x); 在iter位置插入x，传回新数据位置q.insert(iter,n,x); 在iter位置插入n个x，无返回值q.insert(iter,l,r); 在iter位置插入[l,r)区间内的数据，无返回值 vector交换12q.swap(p); 交换p，q容器内元素q.assign(iter1,iter2); //将区间[iter1，iter2)内元素赋值给vector，并清空vector容器之前的内容。 删除元素123q.pop_back(); 删除最后一个元素q.erase(iter1); 删除iter位置元素，返回值是指向被删元素之后的那个元素(即下一个元素)的迭代器。q.erase(iter1,iter2); 删除[iter1，iter2)区间内的元素 清空/覆盖12q.clear(); //清空Vectorq.assign(n,x); //将n个x赋值到vector中，并清空vector容器之前的内容。 返回元素123q.front(); 返回第一个数据q.back(); 返回最后一个数据q.at(i); //返回第i个元素 vector元素个数/是否为空123q.size(); 返回容器内成员个数q.resize(x); //重新指定容器大小q.empty(); 判断Vector是否为空 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 vector内存容量12q.capacity(); //返回Vector可用空间的大小q.reserve(); //重新指定空间大小，小于当前capacity时保持为原本的capacity值 二维vector的初始化123456789vector&lt;vector&lt;int&gt;&gt; vec1;int row = 3;int col = 3;vec1.resize(row);for(int i=0;i&lt;vec1.size();i++) vec1[i].resize(col);for(int i=0;i&lt;row;i++) for(int j=0;j&lt;col;j++) vec1[i][j]=5; 或者 1vector&lt;vector&lt;int&gt; &gt;vec(row,vector&lt;char&gt;(col,5)); 参考资料C++ 给vector去重的两种方法vector的几种初始化及赋值方式STL中erase()的用法","link":"/2020/05/19/vector%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"stack常用操作","text":"stack初始化方法123std::stack&lt;int&gt; q;std::stack&lt;int&gt; second(first); std::stack&lt;int, std;:vector&lt;int&gt;&gt; third; 使用vector初始化stack 交换swap将两个 stack的内容交换。这两个 stack的模板参数 T和 Container必须都相同。 12void swap(stack&amp; x) 重载1：x.swap(y)void swap(stack&amp; x, stack&amp; y) 重载2: swap(x, y) 常用操作12345q.push(element); 入栈q.pop(); 出栈q.top(); 返回栈顶成员q.size(); 返回栈成员个数q.empty(); 判断是否为空栈 参考资料C++ STL容器——stack用法介绍","link":"/2020/05/19/stack%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"queue常用操作","text":"queue初始化方法1queue&lt;int&gt;q; 交换swap(queue&lt;T&gt; &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(queue&lt;T&gt; &amp;x, queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作123456q.push(1); 入队列，无返回值q.pop(); 出队列，无返回值q.front(); 返回最上面（最后进入）的成员的引用q.back() 返回 queue 中最后一个元素的引用，但不删除该元素。q.size(); 返回队列成员个数q.empty(); 判断是否为空队列，bool 参考资料C++ queue(STL queue)用法详解","link":"/2020/05/19/queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"priority_queue常用操作","text":"概念priority_queue容器适配器定义了一个元素有序排列的队列。 默认队列头部的元素优先级最高。 因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。 如何定义“优先级”完全取决于我们自己。 模板1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; priority_queue初始化方法123队列的排序，右边是出队列的地方priority_queue&lt;int&gt;q; 经常使用的，默认是less，元素大的优先级高。priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 元素小的优先级高。 交换swap(priority_queue&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 queue 中的元素和参数 priority_queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(priority_queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(priority_queue&lt;T&gt; &amp;x, priority_queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作12345q.push(element); 入优先级队列q.pop(); 出优先级队列q.top(); 返回优先级队列头成员q.size(); 返回优先级队列成员个数q.empty(); 是否为空 参考资料C++ priority_queue(STL priority_queue)用法详解","link":"/2020/05/19/priority-queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"set常用操作","text":"基本概念set是一个关联容器类型，用于以升序方式存储唯一值。 属于关联容器（关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。） 特性 遵循数学集合三特性，互异性、无序性、确定性。 底层数据结构为红黑树，有序，不重复 set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询 set 容器存储的键也必须唯一，而且不能修改 set 容器以升序方式存储唯一值 set 不支持下标操作符 和map一样，set无法存储无法比较大小的数据； 头文件1# include&lt;set&gt; 模板1set&lt;int,greater&lt;int&gt; &gt;q; set初始化方法12set&lt;int&gt;q;set&lt;int&gt; numbers {8, 7, 6, 5, 4, 3, 2, 1}; 小的在前（less）/大的在前（greater）默认的比较函数是 less，因此容器中的元素会升序排列。 12set&lt;int, less&lt;int&gt;&gt; set1; 小的在前（less），升序set&lt;int, greater&lt;int&gt;&gt; set1; 大的在前（greater），降序 参考：C++ STL set greater less详解 交换swap(set&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(set&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(set&lt;T&gt; &amp;x, set&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入1234567int a[] = {1,2,3,4,5};set&lt;int&gt;q;q.insert(elem)); 集合中插入元素q.insert(a,a+5); 插入数组a至a+5的元素q.insert(pos, elem); 在容器中插入元素elem的一份拷贝，并返回新元素的iterator位置； q.insert(beg, end); 在容器中插入[beg, end)范围中所有元素的拷贝，没有返回值。 删除与清空123456q.erase(iterator pos); 删除集合中的元素 无返回值删除后pos不会自动++！被删除元素的迭代器，在删除之后失效！这里是和vector的区别q.erase(iterator first, iterator last); 移除迭代区间[first,last)内的所有元素，无返回值q.erase(value); 移除set容器内元素值为value的所有元素，返回移除元素的个数(size_type类型)q.clear(); 删除set容器中的所有的元素，无返回值 大小/是否为空123q.size(); 返回当前set容器中的元素个数q.max_size(); 返回set容器可能包含的元素最大个数q.empty(); 判断set容器是否为空 find和count12q.find(element); 返回element值位置的迭代器，找不到返回q.end()q.count(); 返回某个值元素的个数(根据set的特性，就是判断这个元素在不在，返回0或1) 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器 注意是set&lt;int,greater&lt;int&gt;&gt;::reverse_iteratorq.rend(); //返回头部反向迭代器 大于等于元素的迭代器12q.lower_bound(); 返回指向大于（或等于）某值的第一个元素的迭代器q.upper_bound(); 返回大于某个值元素的迭代器 参考资料C++ set初始化（STL set初始化）详解C++标准库容器类概述C++ STL set greater less详解 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/19/set%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"pair常用操作","text":"基本概念pair pair 是一个比较简单的模板类型，它只有两个 public 数据成员 first 和 second。 pair 对象可以封装任意类型的对象，可以生成任何想生成的 pair&lt;T1,T2&gt; 对象，可以是数组对象或者包含 pair&lt;T1,T2&gt; 的 vector 容器。例如，pair 可以封装两个序列容器或两个序列容器的指针。pair&lt;T1，T2&gt; 模板定义在 utility 头文件中，如果不想使用 map 而只想使用 pair 对象，可以包含这个头文件。 头文件123# include&lt;utility&gt;或者# include&lt;map&gt; 模板1pair&lt;const K, T&gt; q; pair初始化方法123456789pair&lt;int,int&gt;q; 创建一个空对pair&lt;int,int&gt;p(2,3); 创建一个对p，并分别赋值2，3pair&lt;int,int&gt;s(p); 创建一个对s，拷贝p给spair&lt;string, string&gt; anon; // holds two stringspair&lt;string, int&gt; word_count; // holds a string and an intpair&lt;string, vector&lt;int&gt; &gt; line; // holds string and vector&lt;int&gt;赋值利用make_pair函数q = make_pair(1,2); 如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。int初始化为0，string初始化为空； 交换swap(pair&lt;T1,T2&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(pair&lt;T1,T2&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (pair&lt;T1,T2&gt;&amp; x, pair&lt;T1,T2&gt;&amp; y) 重载2: swap(x, y) 123std::pair&lt;int,char&gt; foo (10,'a');std::pair&lt;int,char&gt; bar (90,'z');swap (foo,bar); 常用操作查找1234访问pair内元素操作 q.first; 返回成员第一个数据 q.second; 返回成员第二个数据 比较1p1 == p2 如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑 参考资料STL之pair类型详细分析C++ set初始化（STL set初始化）详解C++标准库容器类概述","link":"/2020/05/19/pair%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"map常用操作","text":"基本概念map map不能直接修改关键字，只能通过修改关键字的值间接修改关键字。 底层数据结构为红黑树，有序，不重复 map&lt;K，T&gt; 类模板定义在 map 文件头中，它定义了一个保存 T 类型对象的 map，每个 T 类型的对象都有一个关联的 K 类型的键。容器内对象的位置是通过比较键决定的。 头文件1# include&lt;map&gt; 模板12345678910template &lt; class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt;class map{ ... typedef pair&lt; const Key, T &gt; value_type; ...};经常使用的，默认是lessmap&lt;int,double,less&lt;int&gt; &gt; MYMAP; 元素升序map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; 元素降序 pair初始化方法1234map&lt;int,int&gt; q;map&lt;k, v&gt; m; 创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 vmap&lt;k, v&gt; m(m2); 创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型map&lt;k, v&gt; m(b, e); 创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt; 交换swap(map&lt;K,V&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(map&lt;K,V&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (map&lt;K,V&gt;&amp; x, map&lt;K,V&gt;&amp; y) 重载2: swap(x, y) map定义的类型123map&lt;K,V&gt;::key_type 在 map 容器中，用做索引的键的类型map&lt;K,V&gt;::mapped_type 在 map 容器中，键所关联的值的类型map&lt;K,V&gt;::value_type 一个 pair 类型，它的first 元素具有 const map&lt;K,V&gt;::key_type 类型，而 second 元素则为 map&lt;K,V&gt;::mapped_type 类型 常用操作使用下标访问 map 对象123map &lt;string, int&gt; word_count; // empty map// insert default initialzed element with key Anna; then assign 1 to its valueword_count[\"Anna\"] = 1; 存在则改变，不存在则加入 查找123456map&lt;int,int&gt;q;q.insert(pair&lt;int,int&gt;(1,2)); //通过pair进行插入操作q.insert(map&lt;int,int&gt;::value_type (1,2));//通过value_type进行插入q[1] = 2; //用数组方式进行插入三者不同的是，当map存在这个关键字时数组方式会覆盖关键字的值，而insert操作无法插入。 123m.insert(e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素m.insert(beg,end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。(返回 void 类型)m.insert(iter,e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。(返回一个迭代器，指向 m 中具有给定键的元素)。 比较函数12q.key_comp(); 返回比较元素key的函数q.value_comp(); 返回比较元素value的函数 大小与是否为空123q.size(); 返回容器内元素个数q.empty(); 判断容器是否为空q.max_size(); 返回可以容纳的最大元素个数 删除1234q.erase(iter); 删除迭代器iter的元素q.erase(iter1,iter2);删除[iter1,iter2)区间内的元素q.erase(key); 删除关键字为key的元素q.clear(); 清空容器 查找和计数12q.count(k) 返回 m 中 k 的出现次数,（map中有则返回1，否则0）q.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 查找迭代器123m.lower_bound();返回键值&gt;=给定元素的第一个位置 返回一个迭代器m.upper_bound();返回键值&gt;给定元素的第一个位置 返回一个迭代器m.equal_range();返回一个迭代器的 pair 对象。它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k) 初始化为0使用C++中的map容器定义一个mp，当你执行if语句判断mp[3]是否为1时，那么如果mp[3]以前不存在，此时mp[3]就会被无参初始化，second赋值为0。 123456789101112int main(){ vector&lt;int&gt; numbers; int n = numbers.size(); map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; //这里原来元素是不存在的，但是却可以直接加1； if (count &gt; n/2) return numbers[i]; } return 0;} 参考资料关于map容器的元素被无参初始化《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;mapC++ map是什么C++标准库容器类概述","link":"/2020/05/19/map%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"list常用操作","text":"基本概念list 底层数据结构为双向链表，支持快速增删 缺点是无法通过位置来直接访问序列中的元素，也就是说，不能索引元素。为了访问 list 内部的一个元素，必须一个一个地遍历元素，通常从第一个元素或最后一个元素开始遍历。 节点对象维护了两个指针，一个指向前一个节点，另一个指向下一个节点。 第一个元素的前向指针总是为 null,因为它前面没有元素，尾部元素的后向指针也总为 null。 头文件1#include &lt;list&gt; 模板1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class list; list初始化方法12345list&lt;int&gt;q; //创建空Listlist&lt;int&gt;p(5); 创建拥有5个成员的Listlist&lt;int&gt;s(5,1); 创建拥有5个成员，且初始值为1的Listlist&lt;int&gt;s2(s); 创建s2，并拷贝s元素给s2list&lt;int&gt;s3(s.begin(),s.end()); 创建s3，拷贝s.begin()至s.end()中元素给s3 交换swap(list&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 123void swap(list&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap (list&lt;T&gt;&amp; x, list&lt;T&gt;&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个list 常用操作插入12345q.push_front(num) 返回值空 在list的头部添加一个元素 q.push_back(num) 返回值空 在list末尾增加一个元素。q.insert(iter,num) 在iter位置插入元素num。q.insert(iter,n,num) 在iter位置插入n个元素num。q.insert(iter,beg,end) 在iter位置插入区间为[beg,end)的元素。 大小与是否为空12345q.empty() 如果list是空的则返回trueq.max_size() 返回list能容纳的最大元素数量q.size() 返回list中的元素个数q.resize(n) 从新定义链表的长度,超出原始长度部分用0代替,小于原始部分删除。q.resize(n,num)从新定义链表的长度,超出原始长度部分用num代替。 删除与清空123456q.clear() 返回值空，删除所有元素 q.pop_back() 返回值空 删除最后一个元素q.pop_front() 返回值空 删除第一个元素q.erase(iter) 删除一个元素，并且返回下一个位置的迭代器q.remove(value) 从list删除元素 void remove ( const T&amp; value );q.remove_if(MATCH) 按指定条件删除元素 返回值为空void list::remove_if( MATCH ) 12iterator erase ( iterator position );iterator erase ( iterator first, iterator last ); list中remove和erase都是删除一个元素，其中remove参数类型和数据类型一致，而erase参数类型是迭代器。remove（aim）是删除链表中的aim元素，若有多个aim，都会删除，而erase（it）是删除迭代器指定位置的元素，并且返回下一个位置的迭代器来看例子。 查找12q.back() 返回最后一个元素 reference back ( );q.front() 返回第一个元素 reference front ( ); 迭代器1234q.begin() //返回指向第一个元素的迭代器q.end() //返回末尾的迭代器q.rbegin() //返回指向第一个元素的逆向迭代器q.rend() //指向list末尾的逆向迭代器 查找迭代器1q.get_allocator() //返回list的配置器 反转list1q.reverse() //把list的元素倒转 void reverse ( ); 合并两个listSTL list容器由于采用了双向迭代器，不支持随机访问，所以标准库的merge(), sort()等功能函数都不适用，list单独实现了merge()，sort()等函数。splice与merge 最大的不同:不用排序，也不要求原始链表有序。 相同点:被合并的链表或元素将消失。 123q.merge(p); 合并2个有序的链表并使之有序,从新放到q中,释放p。q.merge(p,comp); 合并2个有序的链表并使之按照自定义规则排序之后从新放到q中,释放p。q.splice() //合并两个list 12list1.merge(list2)在使用merge前，必须使list1和list2已经排好顺序。并且，合并之后list1仍然是有序的 splice是剪切，粘贴。用splice时当B与A合并后，B就为空。但是要记住：迭代器仍然指向原来的位置，即使原来的元素不存在了。 12345678将list2中的所有元素拷贝到list1中。在list1中的起始位置是it1.复制结束后，list2将为空。list1.splice(it1, list2); 将list2中的元素，从it2开始，剪切到list1的it1起始的地方。list1.splice(it1, list2, it2);将链表list2从开始到结束都合并到it1开始的位置。list1.splice(it1, list2, it2begin, it2end); 排序sort()1q.sort() 给list排序 返回值为空 一个自定义的类，那么如果想为这个类所生成的对象排序的话，因为list.sort()默认排序需要重载 &lt; 操作符。所以我们必须在类对象里重载这个操作符 删除list中重复的元素unique()1q.unique() 删除list中重复的元素 返回值为空 输出1copy(q.begin(),q.end(),ostream_iterator&lt;int&gt;(cout,\"\")); 参考资料STL 如何使用list::remove_if容器链表中splice()、merge()、insert()方法的区别c++ list 合并listSTL 中list的sort()方法使用总结(运算符重载)C++ list.merge()使用方法stl list中erase和remove区别std::list::sort()排序分析C++ list(STL list)使用、创建和初始化C++标准库容器类概述 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/20/list%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"C++运算符重载","text":"运算符重载重载的运算符是带有特殊名称的函数 函数名是由关键字 operator 和其后要重载的运算符符号构成的。 与其他函数一样，重载运算符有一个返回类型和一个参数列表。 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。 保持语义不变 不改变运算符的优先级 不改变运算符的结合性 不改变运算符需要的操作数 不能创建新的运算符 定义为类成员函数(令运算符重载函数作为类的成员函数)例子,这里是二元运算符，在类的内部，只需要传入一个外部元素。 1Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 定义为普通的非成员函数(令运算符重载函数作为类的友元函数)例子,这里是二元运算符，不在类里面，需要传入两个元素。 1Box operator+(const Box&amp;, const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 这时候，就需要作为友元函数来操作类的对象了； 两种方式的区别区别在于令运算符重载函数作为类的成员函数在调用时只需输入一个被操作数参数即可，另一个操作数参数则不需要输入；令运算符重载函数作为类的友元函数在调用时不仅要求输入被操作数参数，还要求输入被操作数参数。 产生了这个区别的原因在于令运算符重载函数作为类的成员函数和令运算符重载函数作为类的友元函数有本质区别： (1)调用作为类的成员函数的运算符重载函数时，类对象肯定已经被建立了，这时对象中对应的私有数据成员存在。 (2)调用作为类的友元函数的运算符重载函数时，类对象还未被建立，这时对象中对应私有数据成员不存在。运算符重载的方法步骤运算符重载函数的参数个数 等于 运算符操作数的个数。但要注意，用成员函数重载时，对应于运算符左操作数的参数是默认传递的。 参数的顺序和左右操作数的顺序是一样的，这一点看看&lt;&lt; 和 &gt;&gt; 的重载就知道了。 tips重载一元运算符，在类的内部，不需要传入元素，参数为0。 重载++和–运算符号int类型参数只是用来区别后置++与前置++，此外没有任何其他作用。 令运算符重载函数作为类的友元函数重载前置运算符和重载后置运算符分别如何实现？答：也是一样的，传入参数多加一个int即可了 参考资料C++的运算符重载C++ 重载运算符和重载函数STL 中list的sort()方法使用总结STL 如何使用list::remove_ifC++ list.merge()使用方法","link":"/2020/05/20/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"C++变量初始化","text":"声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。 静态成员类的静态成员（static member）必须在类内声明，在类外初始化比如： 12345class A{ private: static int count ; // 类内声明 }; int A::count = 0 ; 类外初始化，不必再加static关键字 为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 类内初始化的成员能在类中初始化的成员只有一种，那就是静态常量成员。 1234class A{ private: static const int count = 0; 静态常量成员可以在类内初始化 }; 静态成员和常量成员不能在类内初始化。比如const int count = 0; 和static int count = 0;是不能在类里面初始化的。 总结静态常量数据成员static const int count: 可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化。 不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化； 静态非常量数据成员static int count: 只能在类外，即类的实现文件中初始化 不能在构造函数中初始化 不能在构造函数的初始化列表中初始化 非静态的常量数据成员const int count: 不能在类内初始化，也不能在构造函数中初始化， 只能且必须在构造函数的初始化列表中初始化； 非静态的非常量数据成员int count: 不能在类内初始化,不能在类外。 可以在构造函数中初始化 可以在构造函数的初始化列表中初始化 在类外定义的成员变量肯定是有static 关键字的。 初始化规则系统如何初始化取决于变量的类型以及变量定义的位置。 内置类型变量初始化 内置类型变量是否自动初始化取决于变量定义的位置。 函数体外定义的变量初始成0；（注意是主函数外） 函数体内定义的变量不进行自动初始化。 类类型变量初始化类类型变量在定义时，如果没有提供初始化式，则会自动调用默认构造函数进行初始化（不论变量在哪里定义，都会被初始化，只不过初始化为什么样子由编译器决定了）。如果某类型没有默认构造函数，则定义该类型对象时必须提供显示初始化式。 参考资料C++中静态变量的声明与初始化详解C++中变量的初始化规则C++的变量初始化","link":"/2020/05/20/C-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"单例模式C++实现","text":"单例模式singleton patternpurpose：使得一个类只能有一个实例，并提供一个全局访问的位置probliem：遇到实例的频繁创建和销毁时，效率低solution：创建时候检测实例是否存在key code：构造函数是私有的 如何选择懒汉和饿汉模式：特点与选择：懒汉：在访问量较小时，采用懒汉实现。这是以时间换空间。饿汉：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。 懒汉式单例模式代码（线程不安全）顾名思义，该模式只在你需要对象时才会生成单例对象(意思是太懒了，懒汉不到万不得已就不会去实例化类)缺点： 懒汉式是以时间换空间的方式。（在getInstance中new instance然后返回） 适用于单线程的环境！ 不是线程安全的！ 它不是线程安全的。假设当前有N个线程同时调用getInstance（）方法，由于当前还没有对象生成，所以一部分同时都进入步骤 2,那么就会由多个线程创建多个多个singleton对象。 123456789101112131415161718192021222324252627282930313233343536373839懒汉式单例模式- 私有静态指针，指向单例- 私有构造函数- 公有获取实例的静态函数# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance() { if (instance == NULL) 步骤 1 { instance = new singleton(); 步骤 2 return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } } private: static singleton * instance ; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = NULL;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();}//输出//instance initialized//instance has already initialized 饿汉式单例模式代码（线程安全）顾名思义，该模式在类被加载时就会实例化一个对象。（意思是有就吃，有加载个类的话，饿汉就直接在类里面建立） 饿汉式是以空间换时间的方式。（在静态区初始化instance，然后通过getInstance返回） 该模式能简单快速的创建一个单例对象，而且是线程安全的(只在类加载时才会初始化，以后都不会)。 缺点，就是不管你要不要都会直接创建一个对象，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单) 1234567891011121314151617181920212223# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance(){ return instance; } private: static singleton *instance; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = new singleton(); //关键的一步int main(){ singleton *singleton1 = singleton::getinstance(); singleton *singleton2 = singleton::getinstance();} 注意，这个单例在主函数之前就已经加载了，比如下面主函数输出的结果就是instance initialized。 123int main(){return 0;} 线程安全的懒汉式单例模式代码加了一个互斥锁 12345678910111213141516171819202122232425262728293031323334353637383940# include &lt;iostream&gt;# include &lt;mutex&gt;# include &lt;pthread.h&gt;using namespace std;class singleton{ public: static pthread_mutex_t mutex; static singleton *getinstance() { pthread_mutex_lock(&amp;mutex); if (instance == NULL) { instance = new singleton(); return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } pthread_mutex_unlock(&amp;mutex); } private: static singleton * instance ; singleton() { pthread_mutex_init(&amp;mutex,NULL); //初始化为一个互斥锁 cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; } };singleton * singleton::instance = NULL;pthread_mutex_t singleton::mutex;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();} 注意：互斥变量使用特定的数据类型：pthread_mutex_t线程函数编译时需要添加特殊编译选项：gcc read.c -lpthread 比如最简单的编译命令，记住要在后加-lpthread选项，否则会出现undefined reference to ‘pthread_mutex_lock’报错。 参考资料饿汉式和懒汉式（单例模式详解)C++ 单例模式(懒汉、饿汉模式)C++关于锁的总结（一）windows下std 没有成员 thread、thread not member of stdc++线程中的几种锁 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"},{"title":"音标发音","text":"清辅音与浊辅音 分类 音标 清辅音 发音时声带不振动的辅音，有/p/ /t/ /k/ /f/ /θ/ /s/ /ʃ/ /h/ /tʃ/ /ts/ /tr/ 浊辅音 发音时声带振动的辅音，有/b/ /d/ /g/ /v/ /ð/ /z/ /ʒ/ /r/ /dʒ/ /dz/ /dr/ /j/ /w/ /m/ /n/ /ŋ/ /l/ 二者区别 读一下/v/和/f/感受一下就知道了 /ts/ 清辅音 声带不震动 发“次”的音 牙齿轻咬，舌端贴住齿龈，堵住气流。然后舌尖略微下降，气流泄出。 /ð/ 浊辅音，发音时声带要稍微振动，发出声来，但不要送气。 口型助记： 外形则像舌头顶在上下牙齿之间。 英语中只有字母组合“th”会发这个音。 容易把它发成舌尖齿龈摩擦音/z/；还有些人误把它发成舌端齿龈破擦音/dz/，其实只要记住轻轻舌头顶住，就不会错。 /θ/ 清辅音，发音时把舌尖放在上下齿之间，舌尖轻触上齿，略略露出齿外，气流由舌齿间泻出，摩擦成音 口型助记：外形像上下牙齿咬着舌头。 英语中只有字母组合“th”发这个音。 容易把它发成“舌尖齿龈摩擦音”/s/，其实只要记住轻轻咬住舌尖，就不会错。 音标中辅音并不难，发音基本和汉语一样，需要注意的是[θ]和[ð]这两个，因为这两个发音在汉语里是没有的。可以毫不客气地说，在中国，80%以上学英语的人这两个发音都是发成[s]和[z]的 相关资源清辅音/ts/的发音方法浊辅音/ð/的发音方法如何用英语48个音标发音用中文谐音标示","link":"/2020/05/24/%E9%9F%B3%E6%A0%87%E5%8F%91%E9%9F%B3/"},{"title":"STL排序相关库","text":"sort函数声明 12345template &lt;class RandomAccessIterator&gt; void sort (RandomAccessIterator first, RandomAccessIterator last); template &lt;class RandomAccessIterator, class Compare&gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); cmp()函数的返回值要是bool，核心要义也是比较。sort默认是从小到大，所以在cmp如果还是要从小到大，那就a &lt; b，返回值bool为true，不改变；如果想要从大到小排，那么就要return a &gt; b，因为默认a小于b，所以此时返回的bool就是false，要改变排序。也就是说， 返回的值是true的话，代表a先放，b后放 返回的值是false的话，代表b先放，a后放 stable_sort排序的时候保持相对位置，即相同的数字相对位置是不变的。 partition函数声明 12template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred); 作用：对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last stable_partition排序的时候保持相对位置，即相同的数字相对位置是不变的 参考资料C++ STL算法随记：C++ sort()函数，自定义cmp()的使用理解STL—–排序类——sort与partitionC++ stl算法——partition","link":"/2020/05/24/STL%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E5%BA%93/"},{"title":"多线程编程-按序打印（leetcode 1114）","text":"题目描述 提供了一个类： 12345public class Foo { public void one() { print(\"one\"); } public void two() { print(\"two\"); } public void three() { print(\"three\"); }} 三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法 线程 B 将会调用 two() 方法 线程 C 将会调用 three() 方法 请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 题目解析多个线程在cpu中执行，运行不同的程序段，但是这些程序之间有先后关系： one()方法如果不运行完毕啊，就不能运行two()方法。 two()方法如果不运行完毕啊，就不能运行three()方法。 也属于并发的问题：并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种： 竞态条件（Race Condition）：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。 死锁：并发程序等待一些必要资源，导致没有程序可以执行。 资源不足：进程被永久剥夺了运行所需的资源。 竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。（比如有一个if判断语句，多个线程都通过这个判断时候，下一步的执行可能造成各种奇怪的结果） 竞态条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。(可以将这种机制看做限制关键部分代码访问的锁) 在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。 如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。 这种机制还具有唤醒其他等待线程的功能。 总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制： 关键部分的访问控制。 通知阻塞线程。 代码实现方法1：使用 synchronization信号量和互斥锁(mutex)的区别：互斥锁只允许一个线程进入临界区，而信号量允许多个线程同时进入临界区。 12345678910111213141516171819202122232425262728293031#include &lt;semaphore.h&gt; 信号量Semaphore头文件class Foo {protected: sem_t firstJobDone; 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 sem_t secondJobDone;public: Foo() { sem_init(&amp;firstJobDone, 0, 0); sem_init(&amp;secondJobDone, 0, 0); } void first(function&lt;void()&gt; printFirst) { printFirst(); sem_post(&amp;firstJobDone); } void second(function&lt;void()&gt; printSecond) { sem_wait(&amp;firstJobDone); printSecond(); sem_post(&amp;secondJobDone); } void third(function&lt;void()&gt; printThird) { sem_wait(&amp;secondJobDone); printThird(); }}; semaphore是由操作系统提供的。 LINUX下，一般是＃include&lt;asm/semaphore.h&gt; 或 ＃include&lt;semaphore.h&gt; Windows下，一般是windows.h 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。sem_init：sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。 12345int sem_init(sem_t *sem, int pshared, unsigned int value);sem ：指向信号量对象pshared : 指明信号量的类型。不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享。value : 指定信号量值的大小sem_init() 成功时返回 0；错误时，返回 -1，并把 errno 设置为合适的值。 sem_post：sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的； 12int sem_post(sem_t *sem);sem_post() 成功时返回 0；错误时，信号量的值没有更改，-1 被返回，并设置 errno 来指明错误 sem_wait: sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。(也就是说是等于0时会阻塞操作) 1int sem_wait(sem_t *sem) 方法2：使用mutex加锁解锁1234567891011121314151617181920212223242526class Foo {public: Foo() { //构造函数先执行，将mutex变量进行加锁初始化。 m2.lock(); /首先给second()和third()上锁 m3.lock(); } void first(function&lt;void()&gt; printFirst) { printFirst(); m2.unlock(); /first()运行完了就解开second()的锁 } void second(function&lt;void()&gt; printSecond) { m2.lock(); 这里是锁的入口，如果已经上锁了，就不能执行了，如果没有，就可以执行下一步，并把锁值0置为1 printSecond(); m3.unlock(); //second()运行完了就解开third()的锁 } void third(function&lt;void()&gt; printThird) { m3.lock(); printThird(); m3.unlock(); }private: std::mutex m2, m3; }; 参考资料力扣（LeetCode）C++多线程同步之Semaphore(信号量)进程间通信方式——信号量（Semaphore）线程同步之信号量（sem_init,sem_post,sem_wait）","link":"/2020/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88leetcode-1114%EF%BC%89/"},{"title":"deque常用操作","text":"概念Deque（双向队列） 和Queue差不多 ,但是特殊的是Deque可是扩充内存。（实际上连续内存的容器不能随意扩充，所以Deque也不是真正意义上的扩充内存，而是封装了底层的表象。 Deque是由一段段构成的，当走到尾端时自动跳到下一段，（支持迭代器++操作）。 每次扩充，就会申请一个段，从而实现了内存连续的假象。 默认的stack 和 queue 都基于 deque 容器实现， priority_queue 则基于 vector 容器实现。对于给定的适配器，其关联的容器必须满足一定的约束条件。 stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在vector、list 或者 deque 容器之上。 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 或deque容器上，而不能建立在vector 容器上。 priority_queue 适配器要求提供随机访问功能，因此可建立在vector 或 deque 容器上，但不能建立在 list 容器上。 特性 deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。 deque 容器也可以根据需要修改自身的容量和大小。 缺点：频繁的插入删除时候，Deque并不适合。 Deque采用分块线型结构存储数据，两个迭代器分别指向首尾元素，而且拥有具有高效的push_back(),push_front()函数。 正因如此，所以Deque不易实现capacity和reverse函数。 头文件1#include &lt;deque&gt; 模板deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。 set初始化方法1234567int num[] = {1,2,3,4,5,6};deque&lt;int&gt; di{1,2,3,4,5};deque&lt;int&gt;q; 创建一个空双向队列 deque&lt;T&gt; deqT;默认构造形式deque&lt;int&gt;p(5); 创建一个具有5个成员的双向队列deque&lt;int&gt;s(5,1); 创建一个具有5个成员且初始值为1的双向队列 deque(n, elem);构造函数将n个elem拷贝给本身deque&lt;int&gt;s2(s); 创建一个双向队列s2，并拷贝s中所有成员 deque(const deque &amp;deq);拷贝构造函数。deque&lt;int&gt;n(num,num+5); 创建一个双向队列n，并拷贝num至num+5中元素入队 deque(beg, end);构造函数将[beg, end)区间中的元素拷贝给本身。 交换swap(deque&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 deque 中的元素和参数 deque 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(deque&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(deque&lt;T&gt; &amp;x, deque&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入操作123q.push_front(a); 头部入队q.push_back(b); 尾部入队q.insert(iter,x); 在iter位置插入x，iter为迭代器 覆盖12q.assign(n,x); 将n个x赋值到deque中，并清空deque容器之前的内容。q.assign(iter1,iter2); 将区间[iter1，iter2)内元素赋值给deque，并清空deque容器之前的内容。 删除与清空操作12345q.pop_front(); 头部出队q.pop_back(); 尾部出队q.clear(); 清空双向队列q.erase(iter); 删除iter元素，iter为迭代器q.erase(beg,end);删除[beg,end)区间的数据，返回下一个数据的位置。 deque数据存取1234q.front(); 返回头成员q.back(); 返回尾元素q.at(idx); 返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[]; 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 大小/是否为空123q.size(); 返回双向队列成员个数q.max_size(); 返回系统支持成员最大个数q.empty(); 判断双向队列是否为空 迭代器12345678q.begin(); 返回头部迭代器q.end(); 返回尾部迭代器q.rbegin(); 返回尾部反向迭代器q.rend(); 返回头部反向迭代器q.cbegin(); 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.cend(); 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crbegin();和rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crend(); 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 参考资料C++ STL deque容器底层实现原理（深度剖析）STL教程：C++ STL快速入门（非常详细）[C++ STL]deque使用详解C++ deque的用法与示例//解释的图片不错《C++Primer》第九章-顺序容器-学习笔记(3)-容器适配器&amp;栈&amp;队列","link":"/2020/06/01/deque%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"红黑树详解","text":"二叉查找树学习红黑树之前，先理解一下二叉查找树。 二叉查找树（BST）具备什么特性呢？ 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找和插入的过程类似于二分查找的思想，查找所需的最大次数等于二叉树的深度 二叉查找树（BST）缺点有哪些？主要体现在插入新的节点的时候假设初始的二叉查找树只有三个结点，根结点值为9，左孩子值为8，右孩子值为12：接下来我们依次插入如下五个结点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？最终的二叉查找树会非常的不平衡，左子树的深度为6，右边子树的深度为1（一棵好端端的树变成了瘸子，两边的子树不均衡了），这样会导致查找的性能大打折扣，几乎变成了线性查找； 二叉查找树的删除操作 待删除的结点没有子结点：节点没有孩子，因此直接删除即可。 待删除的结点有一个孩子：只有左孩子，于是我们让左孩子结点A取代被删除的结点，结点A以下的结点关系无需变动。（右孩子也是一样的） 待删除的结点有两个孩子：这种情况比较复杂。此时，我们需要选择与待删除结点最接近的结点来取代它。 AVL树与红黑树的差别AVL是严格平衡的二叉树，要求每个节点的左右子树高度差不超过1；红黑树更宽松一些，要求任一一条路径的长度都不超过其他路径长度的两倍。正因为这个差别AVL的查找效率更高，但是平衡调整的成本也更高。在需要频繁查找时，选用AVL树更合适，频繁插入删除时，选用红黑树更合适。 红黑树目的红黑树主要是为了解决上面的问题（可以说是一种策略，通过红黑树算法，让二叉查找树变成平衡二叉查找树） 概念红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。红黑树针对AVL树的不足（AVL树删除操作之后的重新平衡可能需要做到多达O(lon n)次旋转，从而频繁地导致全树的整体拓扑结构的大幅变化）进行了改进。红黑树保证：每次插入或者删除之后的重新平衡过程，全树拓扑结构的更新仅仅涉及常数个节点。尽管最坏情况下也需要对多达O(lon n)个节点重新染色，但是就分摊意义而言，仅仅为O(1)个。红黑树的适度平衡标准：任一节点左右子树的高度不得超过两倍。（由下面这五条规则来保证）除了符合二叉查找树的特性之外，还具体下列的特性： 结点是红色或者黑色 根结点是黑色 每个叶子的节点都是黑色的空结点（NULL）//这些是引入的外部节点，使得二叉树扩展为真二叉树 每个红色结点的两个子结点都是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色结点） 从任意结点到其每个叶子的所有路径都包含相同的黑色结点。 引申: 红节点都是树的内部结点，根节点和外部结点（叶结点）都是黑结点//由第(1)(2)两条规则可知 红节点的孩子不可能是红节点，也就是说红节点的父亲必为黑节点，从每个叶子到根的所有路径上不能有两个连续的红色结点//由第(3)两条规则可知 从根节点到任一节点的途中，黑节点都不少于红节点 从任一节点到其任一后代外部节点的沿途，黑节点的总数亦必相等。//由第(4)两条规则可知 //根节点深度解释为1，更好理解；解释为0，更好计算；我们在这里采用后者黑深度（black depth）从上向下描述： 从根节点到任一节点的途中，黑节点都不少于红节点，除去根节点本身，沿途所经过的黑节点的总数成为黑深度 所有外部节点的黑深度统一 黑高度（black height）从下向上描述： 从任一节点到其任一后代外部节点的沿途，除去外部节点（黑色），沿途所经过的黑节点的总数称为该节点的黑高度。 所有外部节点的黑高度统一，均为0 插入和删除当插入和删除节点的时候，红黑树的规则可能会被打破，这时候就需要做出一些调整，从而继续维持我们的规则什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子：这个例子去找一下图吧例如上面标准的红黑树，插入值为14的节点。插入之后发现仍然满足红黑树的要求！但是如果插入值为21的节点呢？由于父结点22是红色结点（插入的节点默认是红色是因为如果是黑色可能会影响规则5），因此这种情况打破了红黑树的规则4（每个红色结点的两个子结点都是黑色），必须进行调整，使之重新符合红黑树的规则。 调整红黑树的方法 开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也和玩魔方一样。红黑树有两大操作: recolor (重新标记黑色或红色) rotation (旋转，这是树达到平衡的关键)- 左旋转 - 右旋转 左旋的示意图逆时针旋转红黑树的两个结点，使得父结点被自己的右孩子取代，而自己成为自己的左孩子。 右旋的示意图顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己成为自己的右孩子。 示例为了符合红黑树的规则，会把节点红变黑或者黑变红。下图展示的是红黑树的部分，需要注意节点25并非根节点。因为21和22链接出现红色，不符合规则4，所以把22红变黑：但这样还是不符合规则5（但是，仅仅把一个结点变色，会导致相关路径凭空多出一个黑色结点，这样就打破了规则5。），所以需要把25黑变红，看下图：但是25和27仍然是红色，不满规则4，所以需要将27变为黑色但这只是局部结束了，全局仍然不能满足条件，15和17仍然是两个连续的红节点，不满足规则4，把17变黑也不行，因为13根节点为黑色，其子节点必为红色。只能进行旋转了！按照左旋转，对上边已经变色完成之后图进行左旋转。旋转之后，由于根节点是红色，需要变黑色但是仍然不满足规则5，接下来使用右旋转最后一个步骤，变色我晕，这也太复杂了！！！！ 红黑树插入节点的5种情况 新结点（A）位于树根，没有父结点。 //这种局面，直接让新结点变色为黑色， 新结点（B）的父结点是黑色。 //这种局面，新插入的红色结点B并没有打破红黑树的规则，所以不需要做任何调整。 新结点（D）的父结点和叔叔(父节点的兄弟)结点都是红色。 //参照下面的总结 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。 4.1 以结点B为轴，做一次左旋转，使得新结点D成为父结点，原来的父结点B成为D的左孩子,变成了局面5. 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。 5.1 我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子。接下来，我们让结点B变为黑色，结点A变为红色。 红黑树，超强动静图详解，简单易懂概括起来就是假设我们插入的新节点为 X 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1. 如果 X 的 uncle (叔叔) 是红色3.11. 将 parent 和 uncle 标记为黑色 3.12. 将 grand parent (祖父) 标记为红色 3.13. 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2. 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理。//刚刚说了 X 的 uncle 是红色的情况，接下来要说是黑色的情况3.21. 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.22. 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.23. 右右 (和 3.21镜像过来，恰好相反) 3.24. 右左 (和 3.22镜像过来，恰好相反) 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 红黑树删除节点的5种情况第一步：如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。 第二步：根据待删除结点和其唯一子结点的颜色，分情况处理。 自身是红色，子结点是黑色： 自身是黑色，子结点是红色： 自身是黑色，子结点也是黑色，或者子结点是空叶子结点： 第三步：遇到双黑结点，在子结点顶替父结点之后，分成6种子情况处理。 结点2是红黑树的根结点： 结点2的父亲、兄弟、侄子结点都是黑色： 结点2的兄弟结点是红色： 结点2的父结点是红色，兄弟和侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，左侄子结点是红色，右侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，右侄子结点是红色： 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 总结参考资料漫画：什么是红黑树？（完整版）漫画算法：5分钟搞明白红黑树到底是什么？30张图带你彻底理解红黑树红黑树(一)之 原理和算法详细介绍红黑树，超强动静图详解，简单易懂//这个讲的比较好数据结构 邓俊辉","link":"/2020/06/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"B树与B+树详解","text":"基本概念多路搜索树（multi-way search tree）： 将传统的二叉搜索树，改造为多路搜索树——在中序的遍历下，这也是一种等价变换 以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树，统称为多路搜索树。 多路搜索树同样支持查找等操作，而且效果与原来的二叉树完全等同；但是重要的是，其对外存的访问方式已经发生本质变化，是以大节点为单位从外存读取一组（而不是单个）关键码。 B树就是B-树： B-树就是B树，中间的横线不是减号，直接读成B树即可。 有的文章里出现的B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，而事实上是，B-tree就是指的B树。 B树是一种多路平衡搜索树，它的每一个节点最多包含K个孩子，k被称为B树的阶。 k的大小取决于磁盘页的大小 B树比较矮胖，扁平化，B-树的宽度往往大于其高度 B+树： 是应文件系统所需而产生的一种B-tree的变形树。 应用数据库索引主要基于什么数据结构？hash表和B+树 数据库索引为什么要用B+树结构来存储呢？树的查询效率高。而且可以保持有序。但是为什么不用二叉查找树呢？主要是因为磁盘I/O的影响，数据库索引是存储在磁盘上的，当数据量比较大的时候，索引的大小可能有几个G甚至更多。当我们利用索引查询时候，能把整个索引全部加载到内存吗？很显然不可能的，我们能做的是逐一加载每一个磁盘页，这里的磁盘页面对应着索引树的节点。这样的话，每遍历到一个节点就需要进行一次I/O操作。磁盘这种外部存储器适合批量式的访问，为了减少I/O，我们需要把原本瘦高的树结构变得矮胖，这就是B-树的特征之一。 大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的，如何减少树的深度？一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的） B-树主要应用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。 B-树（Balance Tree）所谓m阶B-树，即为m路平衡搜索树（m大于等于2）,除了根节点，各个节点的分支数目介于[M/2向上取整, M]。M为设定的非叶子结点最多子树个数，N为关键字总数。由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的利用率，其最底搜索性能为：O(log n) 根结点至少有两个子女。 子节点数：每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 关键字数：每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 所有的叶子结点都位于同一层。叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null（可以把这些null看成外部节点） 排序方式：每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B-树的特性 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制； 举一个B-树的例子，一个3阶的B-树，也就是(2,3)-树对于这颗树查询的过程比较次数不比二叉查找树少，尤其当单一节点中的元素数量很多的时候，可是相对于磁盘I/O，内存中的比较耗时几乎可以忽略，所以可以提升查找的性能。 B-树插入优势，自平衡遵循规则： 节点拆分规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须&lt;=3-1（这里关键字数&gt;2就要进行节点拆分，拆分的规则是把中间的元素提取出，放到父节点上，左边的单独构成一个节点，右边的单独构成一个节点）； 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则; 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 B-树删除遵循规则： 节点合并规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须大于等于ceil（3/2）（这里关键字数&lt;1就要进行节点合并）； 满足节点本身比左边节点大，比右边节点小的排序规则; 关键字数小于1时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 自顶向下查找元素11的节点位置。删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋 B-树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B-树中的卫星数据（Satellite Information）:无论是叶子节点还是中间节点都带有卫星数据。 B-树的范围查找过程比方对于上面的B-树，我们想查找3到11的元素，只能依靠繁琐的中序遍历。 B+树（ Tree）B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码； 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 一个m阶的B+树具有如下几个特征： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 示例 B+的特性 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； B+树插入 B+树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B+树中的卫星数据（Satellite Information）:只有叶子节点带有卫星数据。中间节点仅仅是索引，没有任何关联数据。需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树的范围查找过程相对于B-树要简单的多，只需要在链表上做遍历即可！ B树与B+树的优点B+树的优点：由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 B+树的层级更少：单一节点存储更多的元素，使得查询的IO次数更少，相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；。 B+树查询速度更稳定：所有查询都要查找到叶子节点，查询性能稳定。 B+树天然具备排序功能：所有叶子节点形成有序链表，便于范围查询。 B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树的优点: 由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B树和B+树的区别 B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这就意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时候的I/O次数也越少。 B+树的查询必须查到叶子节点，而B-树只要找到匹配元素即可。因此B-树的查找性能并不稳定，最坏情况是查找到叶子节点。而B+树的每一次查找都是稳定的。 为什么说B+树比B树更适合数据库索引？B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B+树的范围查询更加方便：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 总结 B-树和B+树都是很基础的概念，需要掌握好啊！ 二叉搜索树： 二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B（B-）树： 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树： 在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树： 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3 参考资料漫画：什么是B+树？从B树、B+树、B*树谈到R 树平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了漫画：什么是B-树？从二叉查找树到B+树中间的各种树 //写的相当不错B-树 百度百科阿里面试，问了B+树，这个回答让我通过了数据结构 邓俊辉","link":"/2020/06/03/B%E6%A0%91%E4%B8%8EB+%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"string常用操作","text":"基本概念标准库 string 类型：string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。size_type是一个依赖于实现的整型，是在string中定义的。string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。另外，使用缩写NBTS（null-terminated string）来表示以空字符结束的字符串。 头文件1#include &lt;string&gt; 模板123//The string class is an instantiation of the basic_string class template, defined in &lt;string&gt; as:typedef basic_string&lt;char&gt; string;string实际上是basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。 string初始化方法1234string s1; 默认构造函数 s1 为空串string s2(s1); 将 s2初始化为 s1 的一个副本string s3(“value”); 将 s3 初始化为一个字符串字面值副本string s4(n, ‘c’); 将 s4 初始化为字符 ‘c’ 的 n 个副本 注意！因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。 c-style字符转换1s.c_str(); 返回指向以null结尾的字符数组的指针，其数据与存储在字符串中的数据相同 交换swap(string&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 string中的元素和参数 string 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 1234void swap(string &amp;x) 重载1：x.swap(y)void swap (string&amp; x, string&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个string所有迭代器和引用都可能无效 常用操作读写操作对于string类型变量s的输入： 1cin &gt;&gt; s; 从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符： 读取并忽略开头所有的空白字符（如空格，换行符，制表符）。 读取字符直至再次遇到空白字符，读取终止。 读入未知数目的string 对象1234string word;程序将从标准输入读取一组 string 对象，然后在标准输出上逐行输出：while (cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl; 上例中，用输入操作符来读取 string 对象。该操作符返回所读的istream 对象，并在读取结束后，作为 while 的判断条件。如果输入流是有效的，即还未到达文件尾且未遇到无效输入，则执行 while 循环体，并将读取到的字符串输出到标准输出。如果到达了文件尾，则跳出 while 循环。 使用getline 读取整行文本123string line; // read line at time until end-of-filewhile (getline(cin, line)) //循环读取输入流 cout &lt;&lt; line &lt;&lt; endl; 赋值1234// st1 is an empty string, st2 is a copy of the literalstring st1, st2 = \"The expense of spirit\";st1 = st2; // replace st1 by a copy of st2它必须先把 st1 占用的相关内存释放掉，然后再分配给 st2 足够存放 st2 副本的内存空间，最后把 st2 中的所有字符复制到新分配的内存空间。 和字符串字面值的连接当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的： 1234567string s1 = \"hello\"; // no punctuationstring s2 = \"world\";string s3 = s1 + \", \"; // ok: adding a string and a literalstring s4 = \"hello\" + \", \"; // error: no string operand s4 的初始化试图将两个字符串字面值相加，因此是非法的string s5 = s1 + \", \" + \"world\"; // ok: each + has string operandstring s6 = \"hello\" + \", \" + s2; // error: can't add string literals s6 的初始化是非法的。依次来看每个子表达式，则第一个子表达式试图把两个字符串字面值连接起来。这是不允许的，因此这个语句是错误的。 大小与是否为空123456789s.empty(); true如果字符串为空, 否则返回falses.size(); 字符串中CharT元素的数量s.length(); 字符串中CharT元素的数量s.capacity(); 返回字符串当前为其分配空间的字符数s.max_size(); 返回string对象能够容纳的字符的最大数目s.resize(size_t n, char c); 用来改变string的大小，如果size小于原来string的size大小，则截取前面的size个字符，如果大于，则用空格填充。s.resize(size_t n); s.reserve(size_t res_arg=0);为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 s.shrink_to_fit() 请求删除未使用的容量 注意： resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 插入追加覆盖12345s.append(args); 将args追加到s.返回一个指向s的引用.s.assign(args); 将s中的字符替换为args指定的字符.返回一个指向s的引用.s.push_back(char c); 在末尾添加一个元素，返回值为空string&amp; insert ( size_t pos1, size_t n, char c ); 在字符串pos1位置，插入n次c字符。 size_t copy ( char* s, size_t n, size_t pos = 0) const; 从pos位置开始，复制n个字符到s指针指向的内存； insert1234567891011121314 string str=\"to be question\"; string str2=\"the \"; string str3=\"or not to be\"; string::iterator it; // used in the same order as described above: str.insert(6,str2); // to be (the )question str.insert(6,str3,3,4); // to be (not )the question str.insert(10,\"that is cool\",8); // to be not (that is )the question str.insert(10,\"to be \"); // to be not (to be )that is the question str.insert(15,1,':'); // to be not to be(:) that is the question it = str.insert(str.begin()+5,','); // to be(,) not to be: that is the question str.insert (str.end(),3,'.'); // to be, not to be: that is the question(...) str.insert (it+2,str3.begin(),str3.begin()+3); // (or )Output:to be, or not to be: that is the question... append()123456789101112 string str; string str2=\"Writing \"; string str3=\"print 10 and then 5 more\"; str.append(str2); // \"Writing \" str.append(str3,6,3); // \"10 \" str.append(\"dots are cool\",5); // \"dots \" str.append(\"here: \"); // \"here: \" str.append(10,'.'); // \"..........\" str.append(str3.begin()+8,str3.end()); // \" and then 5 more\" str.append&lt;int&gt;(5,0x2E); // \".....\"Output: Writing 10 dots here: .......... and then 5 more..... 查找12345s[index]; s.at(index); index是下标 size_t find (char c, size_t pos =0) const; 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置size_t rfind(char c, size_t pos = npos); 反向查找，从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置string substr(size_t pos = 0, size_t n= npos)const; 在str中从pos位置开始，截取n个字符，然后将其返回 删除与清空12345s.clear() 从字符串中删除所有字符, clear()只是将string中有效字符清空，不改变底层空间大小。s.erase(pos,len); 删除从位置pos开始的len个字符,如果len被省略,则删除从pos开始直至s末尾的所有字符.返回一个指向s的引用.iterator erase (const_iterator p); 删除源字符串中迭代器p指向的字符，返回删除后迭代器的位置。iterator erase (const_iterator first, const_iterator last); 删除源字符串迭代器范围为[first，last）内的所有字符，返回删除后迭代器的位置。s.pop_back(); 删除源字符串的最后一个字符，有效的减少它的长度。 数值转换为string1234567891011s=std::to_string(int/double/...);string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); 迭代器与指针12345678s.data(); 返回指向字符串第一个字符的指针s.begin(); 返回字符串第一个字符的迭代器,consts.cbegin(); 返回字符串第一个字符的迭代器s.end(); 返回字符串最后一个字符的后面一个位置的迭代器s.cend(); 返回字符串最后一个字符的后面一个位置的迭代器,consts.rbegin(); 反向迭代器s.rend(); 反向迭代器string::npos 相当于s.end() string 对象中字符的处理我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下表列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 cctype 头文件中定义。注意这里的”cctype”就是C++中使用C标准的头文件的写法，等价于”ctype.h” 操作 功能描述 isalnum( c ) 如果 c 是字母或数字，则为 True。 isalpha( c ) 如果 c 是字母，则为 true。 iscntrl( c ) 如果 c 是控制字符，则为 true isdigit( c ) 如果 c 是数字，则为 true。 isgraph( c ) 如果 c 不是空格，但可打印，则为 true。 islower( c ) 如果 c 是小写字母，则为 true。 isprint( c ) 如果 c 是可打印的字符，则为 true。 ispunct( c ) 如果 c 是标点符号，则 true。 isspace( c ) 如果 c 是空白字符，则为 true。 isupper( c ) 如果 c 是大写字母，则 true。 isxdigit( c ) 如果是 c 十六进制数，则为 true。 tolower( c ) 如果 c 大写字母，返回其小写字母形式，否则直接返回 c。 toupper( c ) 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c。 列出了各种字符操作函数 表中的大部分函数是测试一个给定的字符是否符合条件，并返回一个 int 作为真值。如果测试失败，则该函数返回 0 ，否则返回一个（无意义的）非 0 ，表示被测字符符合条件。 参考资料《C++Primer》第三章-标准库类型-学习笔记(1)-string&amp;vector&amp;迭代器C++ STL丨string 基本使用（一）STL string常用操作指令C++——string类和标准模板库【C++】String类、String类的常用接口说明及其使用、STL中的迭代器使用c/c++ reference","link":"/2020/06/06/string%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"《复杂》阅读笔记","text":"《复杂》简单讲述了复杂系统科学尝试去回答的迷人与令人费解的问题的一部分。 度量一个事物或过程的复杂性的三个维度描述它有多困难 产生它有多困难 其组织程度如何 物理学家克劳德 模型是什么？科学中是某种实在现象的简化表述模型是我们的思维方式 是用我们熟悉的思维概念解释观察到的现象； 无尺度特性《复杂性》这本书详细解释了什么是无尺度；改变图的尺度，图的形状是不变化的；例子：给定一个大型的样例网络，使用直方图来观察度的分布入度作为横轴，频率作为纵轴1000-1000010000-100000100000-1000000然上面几个图的分布情况曲线的形状几乎一样。这样的分布是自相似的，因为不管在哪种尺度下进行绘制，形状都是一样的——也就是在不同的尺度下具有不变性——就是无尺度一词的由来（无标度）无尺度网络对节点的随机删除具有稳健性，但是如果中心节点失效或是受到攻击就会非常脆弱。 如果你发现某种量遵循幂律分布，你就可以猜想这是某种自相似或分形系统导致的；尽可能填充空间的几何对象其实就是分形分支结构——在所有尺度上的自相似意味着空间在所有尺度上都被同等填充。 偏好依附（Preferential attachment）接下来一个很重要的概念是偏好依附。偏好依附（Preferential attachment）//一种网络生长机制巴拉巴西和艾伯特提出了一种他们称之为“偏好依附”的生成机制，用来解释幂律分布；其中的思想是：网络在生长的时候。连接度高的节点比连接度低的节点更有可能得到新的连接；//直观上说，朋友越多的人，越可能认识新的朋友。网页的入度越高，就越容易被找到； 连锁失效如果某个节点失效了，它的工作就会转移到其他节点，这有可能使得其他节点因为负荷过重而失效，它的工作就会转移到未失效的顶点~","link":"/2020/06/06/%E3%80%8A%E5%A4%8D%E6%9D%82%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"计算机网络教程-传输层概述","text":"传输层 传输层是客户程序和服务器程序之间的联络人，是一个进程到进程的连接。 传输层是TCP/IP 协议簇中的核心； 它是因特网上从一点到另一个点传输数据的端到端逻辑传输媒介。 传输层提供的一般服务进程到进程通信传输层协议的首要任务是提供进程到进程通信（process-to-process communication）。 主机间通信与进程间通信的不同:网络层负责计算机层次的通信（主机到主机通信）。网络层协议只把报文传递到目的计算机。然而，这是不完整的传递。报文仍然需要递交给正确的进程。这正是传输层接管的部分。传输层协议负责将报文传输到正确的进程。 寻址：端口号对通信来说，我们必须定义本地主机、本地进程、远程主机以及远程进程。IP 地址来定义本地主机和远程主机。端口号（port number）来定义进程。TCP/IP 协议簇中，端口号是在0 到65 535 之间的16 位整数。 客户程序用端口号定义它自己，这称为临时端口号（ephemeral port number）。临时这个词表示短期的（short-lived），它之所以被使用是因为客户的生命周期通常很短。为了客户-服务器程序能正常工作，临时端口号推荐值为大于1023。 服务器进程端口号不能随机选择。（因为随机分配的话导致客户端不知道端口号），TCP/IP 决定使用全局端口号，它们称为熟知端口号（well-known port number）。 ICANN 端口范围ICANN已经把端口号编码划分为三种范围：熟知的、注册的和动态的（或私有的） 熟知端口：端口号0~1023，由ICANN 分配和控制。这些是熟知端口号。 在 UNIX 中，熟知端口号存储在/etc/services 文件中，这个文件的每行给出服务器名和熟知端口号 注册端口：端口号1024~49151，ICANN 不分配也不控制。它们可在ICANN 注册以防重复。 动态端口：端口号49152~65535。这一范围内的端口号既不受控制又不需要注册，可以由任何进程使用。它们是临时或私有端口号。49152是2的14次方乘3 套接字地址在 TCP 协议簇中的传输层协议需要IP 地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来称为套接字地址（socket address）。客户套接字地址唯一定义了客户进程;服务器套接字地址唯一地定义了服务器进程;为了使用因特网中的传输层服务，我们需要一对套接字地址：客户套接字地址和服务器套接字地址。 多路复用和多路分解多路复用（multiplexing，多对一）： 多个数据项从多个源发出，一个实体接收它们，然后负责传输。； 指多个应用程序共享同一个传输层建立的连接进行数据的传送，在传输层是通过什么来区分不同的应用程序的（通过端口） 源端的传输层执行复用； 多路分解（demultiplexing，一对多）： 每当一个实体将数据项传递到一个以上的源时。 目的端的传输层执行多路分解 流量控制每当一个实体创建数据项并且有另一个实体消耗它们时，就存在生产速率和消费速率的平衡问题。 如果数据项生产比消费快，那么消费者可能被淹没并且可能要丢弃一些数据项。 如果数据项生产比消费慢，那么消费者必须等待，系统就会变得低效。 流量控制与第一种情况相关。我们需要在消费者端防止丢失数据项。 生产者到消费者消息传输两种方式推（push）:每当发送方生产数据项时，它无须事前获得消费者的请求就会发送它们——这种传递称为推。需要流量控制：当生产者推数据项时，消费者可能被淹没并需要相反方向的流量控制，以此来防止丢弃这些数据项。 拉（pull）:如果生产者在消费者请求这些数据项之后进行发送，这种传递称为拉。不需要流量控制：当消费者拉数据项，它会在自身做好准备时进行请求。在这种情况下，不需要流量控制。 传输层流量控制在传输层通信中，我们需要处理四个实体：发送方进程、发送方传输层、接收方传输层和接收方进程。应用层的发送方进程仅仅是一个生产者。它生产报文块，并把它们推到传输层。发送方传输层有两个作用：是消费者：它消费生产者推来的报文。也是生产者：它将报文封装进分组并传递到接收方传输层。接收方传输有两个作用：是消费者：消费从发送方那里接收来的分组；也是生产者：解封装报文并传递到应用层。然而，最后的传递通常是拉传递；传输层等待直到应用层进程请求报文。 我们至少需要两种流量控制： 从发送方传输层到发送方应用层的流量控制。 从接收方传输层到发送方传输层的流量控制。 这里看图即可： 缓冲区流量控制可以用多种方式实现，但通常的方式是使用两个缓冲区：一个位于发送方传输层，另一个位于接收方传输层。缓冲区是一组内存单元，它可以在发送端和接收端存储分组。消费者向生产者发送信号从而进行流量控制通信。 当发送方传输层的缓冲区已满，它就通知应用层停止传输报文块；当有空闲位置时，它通知应用层可以再次传输报文块。当接收方传输层的缓冲区已满，它就通知发送方传输层停止传输分组；当有空闲位置时，它通知发送方传输层可以再次传输分组。 传输层差错控制由于网络层（IP）是不可靠的，如果应用层需要可靠性，我们需要使传输层变得可靠。可靠性可以通过在传输层加入差错控制服务来实现。 传输层的差错控制负责以下几个方面： 发现并丢弃被破坏的分组。 记录丢失和丢弃的分组并重传它们。 识别重复分组并丢弃它们。 缓冲失序分组直到丢失的分组到达。 差错控制不像流量控制，它仅涉及发送方和接收方传输层。我们假设在应用层和传输层之间交换的报文块是不会产生差错的。 序号差错控制需要发送方传输层知道哪个分组要被重传并且接收方传输层需要知道哪个分组是重复的、哪个分组是失序的。如果分组是编号的，这个就可以实现。我们可以在传输层分组中加入一个字段来保存分组的序号（sequence number）。分组一般按序编号。然而，由于我们需要在头部包含每个分组的序号，因此需要设置一个界限。如果分组的头部允许序号最多为m 比特位，那么序号范围就是0 到2m−1。例如，如果m 是4，序号范围是0 到15 的闭区间。然而，我们可以回绕。序号是模2^m 的。对于差错控制，序号是模2m 的，这里m 是序号字段的大小，单位是比特。 确认接收方可以为每一组正确到达的分组发送一个确认（ACK）。接收方可以简单地丢弃被破坏的分组。发送方如果使用计时器，它就可以发现丢失分组。当一个分组被发送，发送方就开启一个计时器。如果ACK 在计时器超时之前没有到达，那么发送方重发这个分组。重复的分组可以被接收方默默丢弃。失序的分组既可以被丢弃（被发送方当做丢失报文对待），也可以存储直到丢失的那个分组到来。 流量和差错控制的组合流量控制要求使用两个缓冲区，一个在发送端另一个在接收端。差错控制要求两端均使用序号和确认号。流量和差错控制的组合：使用两个带序号的缓冲区：一个位于发送端，一个位于接收端，那么这两个需要可以结合起来。在发送端，当分组准备发送时，我们使用下一个缓冲区空闲位置号码x 作为分组的序号。当分组被发送，一个分组的备份存储在内存位置x，等待来自另一端的确认。当与被发送分组相关的确认到达时，分组被清除，内存位置空闲出来。在接收端，当带有序号y 的分组到达时，它被存储在内存位置y 上，直到应用层准备好接收它。这时发送一个确认表明分组y 的到达。 滑动窗口由于序号进行模2m 操作，因此一个环可以代表从0 到2m−1 的序号。缓冲区由一组片段代表，称为滑动窗口（sliding window），它随时占据环的一部分。在发送端，当一个报文被发送，相应的片段就被标记。当有所片段都被标记时，意味着缓冲区满且不能从应用层进一步接收报文。当确认到达时，相应片段被取消标记。如果从窗口开始处有一些连续的片段没有被标记，那么窗口滑过这些相应序号的范围，允许更多的片段进入窗口尾部。下图 给出发送方的滑动窗口。 序号以16 为模（m = 4）且窗口大小为7。请注意滑动窗口仅仅是一个抽象：实际情况是使用计算机变量来保存下一个和最后一个待发送的分组。大多数协议使用线性形式来表示滑动窗口。虽然想法是相同的，但是它通常占用更少的页面空间。下图给出这种表示方法。这两种表示方法告诉我们相同的事情。如果拿起下图每一幅图的两个端点，并且弯曲它们，我们就可以得到与圆形滑动窗口相同的图。 拥塞控制拥塞（congestion）:因特网之类的分组交换网络中存在一个重要问题，这就是拥塞。如果网络中的负载（load，即发送到网络的分组数）大于网络的容量（网络可以处理的分组数），那么网络就可能发生拥塞。拥塞控制（congestion control）指的是一种机制和技术，它控制拥塞并将负载保持在容量以内。 无连接和面向连接服务传输层协议就像网络层协议一样，可以提供两种类型的服务： 无连接服务 面向连接服务 然而，这些传输层服务的本质与网络层不同。 在网络层，无连接服务可能意味着属于同一个报文的不同数据报有不同路径。 在网络层，面向连接服务意味着两个终端主机以及这之间的所有路由器都进行协调。 在传输层，我们不关心分组的物理路径（我们假设两个传输层之间有一条逻辑连接）。 传输层的无连接服务意味着分组之间的独立；面向连接服务意味着依赖。 无连接服务在无连接服务中，源进程（应用程序）需要将报文分成传输层可接受大小的数据块，并把它们一个一个地传递到传输层。传输层将每一个数据块看做彼此没有关系的单元。当一个块从应用层到达时，传输层将其封装在分组中并发送。 为了展示分组的独立，我们假设客户进程有三个报文块要发送给服务器进程。这些块被按序交给无连接传输协议。然而，由于传输层的这些分组之间没有联系，分组可能失序到达目的地并且被失序传递给服务器进程在客户端，三个报文块按序传递给客户传输层（0、1 和2）。由于第二个分组在传输中的额外延迟，服务器报文的传递失序（0、2 和1）。如果这三个数据块属于同一个报文，那么服务器进程可能会收到一个奇怪的报文。如果一个分组丢了情况就更糟糕了。由于分组没有序号，接收方传输层不知道一个报文已经丢失。它仅仅将两个数据块传送到服务器进程。以上两个问题是由于双方传输层没有互相协调所致。接收方传输层不知道第一个分组将要到来，也不知道所有的分组已经到来。我们可以说，流量控制、差错控制以及拥塞控制都不能在无连接服务中有效实现。 无连接的服务是不可靠的服务，无法许诺不会出现的交付和重复的差错，但这种协议代价很小，更适应于某些服务，比如内部的数据采集、向外的数据分发、请求一响应，以及实时应用等。因此在运输层既有面向连接的位置，也有无连接的用武之地。每一个分组独立地建立和释放逻辑连接，也适合传送大量的数据。无连接的服务的通信线路不都是预设的。无连接的服务需要将目标地址信息加在每个发送的分组上，便于每个分组路由到达目的地。UDP在电路交换或租用专线网络上也能运行。 面向连接服务面向连接的服务中，首先需要建立客户和服务器之间的逻辑连接。只有连接建立之后才能进行数据交换。在数据交换之后，连接需要拆除 连接建立 数据传输 拆除阶段。 在面向连接协议中，我们可以实现流量控制、差错控制以及拥塞控制。面向连接的方式功能强大，允许流量控制、差错控制以及顺序交付等。 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"},{"title":"计算机网络教程-传输层协议-UDP","text":"传输层协议UDP ：不可靠的无连接传输层协议，由于在应用中简单高效而被使用，在那些应用中差错控制由应用层进程提供。TCP ：可靠的面向连接协议，可用于可靠性重要的任何应用。 TCP/IP协议簇协议示意图UDP 和TCP 使用的熟知端口 1234567891011121314151617端口 协议 UDP TCP 说明7 Echo √ 将接收到的数据报回送到发送方9 Discard √ 丢弃接收到的任何数据报11 Users √ √ 活跃的用户13 Daytime √ √ 返回日期和时间17 Quote √ √ 返回每日引用19 Chargen √ √ 返回一字符串20,21 FTP √ 文件传输协议23 TELNET √ 终端网络25 SMTP √ 简单邮件传输协议53 DNS √ √ 域名服务67 DHCP √ √ 动态主机设置协议69 TFTP √ 简单文件传输协议80 HTTP √ 超文本传输协议111 RPC √ √ 远程过程调用123 NTP √ √ 网络时间协议161,162 SNMP √ 简单网络管理协议 UDP(用户数据报协议)用户数据报协议（User Datagram Protocol，UDP）: 无连接不可靠传输层协议。 不提供主机到主机通信，它除了提供进程到进程之间的通信之外，就没有给IP 服务增加任何东西。 此外，它进行非常有限的差错检验。 如果UDP 功能是如此之差，那么为什么进程还要使用它？它有缺点也有优点。UDP 是一个非常简单的协议，开销最小。如果一个进程想发送很短的报文，而且不在意可靠性，就可以使用UDP。使用UDP 发送一个很短的报文，在发送方和接收方之间的交互要比使用TCP 时少得多。 用户数据报UDP 分组称为用户数据报（user datagram），有8 字节的固定头部，这个头部由4 个字段组成，每个字段2 字节（16 位）。8 字节的固定头部的四个字段：每个字段两个字节。头两个字段定义了源和目的端口号。第三个字段定义了用户数据报的总长，即头部加数据的长度。16 位可以定义的总长度范围是0 到65 535。然而，总长度需要更小一些，这是因为UDP数据报存储在总长度为65 535 的IP 数据报中。最后一个字段可以携带可选校验和。 UDP 服务进程到进程的通信UDP 使用套接字地址提供进程到进程通信，这是IP 地址和端口号的组合。 无连接服务 UDP 提供无连接服务。这就表示UDP 发送出去的每一个用户数据报都是一个独立的数据报。不同的用户数据报之间没有关系，即使它们都是来自相同的源进程并发送到相同的目的程序。 用户数据报不进行编号。此外，也没有像TCP 协议那样的连接建立和连接终止，这就表示每一个用户数据报可以沿着不同的路径传递。 无连接的一个结果就是使用UDP 的进程不能够向UDP 发送数据流，并期望它将这个数据流分割成许多不同的相关联的用户数据报。相反，每一个请求必须足够小，使其能够装入用户数据报中，只有那些发送短报文的进程才应当使用UDP。短报文小于65507字节（65535减去UDP头部的8字节再减去IP头部的20 字节）。 无流量控制UDP 是一个非常简单的协议。它没有流量控制（flow control），因而也没有窗口机制。如果到来的报文太多时，接收方可能会溢出。缺乏流量控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 差错控制（仅有校验和）除校验和外，UDP 也没有差错控制（error control）机制，这就表示发送方不知道报文是丢失还是重传。当接收方使用校验和检测出差错时，它就悄悄地将此用户数据报丢弃。缺乏差错控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 校验和UDP 校验和包含三部分：伪头部、UDP 头部和从应用层来的数据。伪头部（psedoheader）是IP 分组的头部的一部分（第4 章讨论），其中有些字段要填入0，用户数据报分装在IP分组中 如果校验和不包括伪头部，用户数据报也可能是安全完整地到达。但是，如果IP 头部受到损坏，那么它可能被提交到错误的主机。 协议字段可确保这个分组是属于UDP，而不是属于其他传输层协议。 如果一个进程既可用UDP 又可用TCP，则端口号可以是相同的。 UDP 的协议字段值是17。如果在传输过程中这个值改变了，在接收端计算校验和时就可检测出来，UDP 就可丢弃这个分组。这样就不会传递给错误的协议。 可选校验和UDP 分组的发送方可以选择不计算校验和。这种情况下，在发送前，校验和字段就全填入0。在发送方决定计算校验和的情况下，如果碰巧结果全是0，那么在发送前校验和全改为1。换言之，发送方填充两次校验和。注意，这不会产生混淆，因为校验和的值在正常情况下不会全为1。 无拥塞控制由于UDP 是无连接协议，它不提供拥塞控制。UDP 假设被发送的分组很小且零星，不会在网络中造成拥塞。今天当UDP 被用做音频和视频的交互实时传输时，这个假设可能对也可能不对。 封装和解封装要将报文从一个进程发送到另一个进程时，UDP 协议就要对报文进行封装和解封装。 排队我们已经讨论过端口，但是没有讨论端口的实际实现。在UDP 中，队列是与端口联系在一起的。在客户端，当进程启动时，它从操作系统请求一个端口号。有些实现是创建一个入队列和一个出队列与每一个进程相关联。而有些实现只创建与每一个进程相关的入队列。 多路复用与多路分解在运行TCP/IP 协议簇的主机上只有一个UDP，但可能有多个想使用UDP 服务的进程。处理这种情况，UDP 采用多路复用和多路分解。 UDP 和通用简单协议比较我们可以将UDP 与之前讨论的无连接简单协议进行比较。唯一的区别就是UDP 提供可选校验和来在接收端发现被破坏分组。如果校验和被加入分组，接收UDP 可以检测分组，如果分组被破坏可以丢弃它。然而，没有反馈被发向发送方。UDP 是我们之前讨论的无连接简单协议的一个例子，区别在于它为差错检测加入了可选校验和。 UDP应用 一位应用设计师有时需要折中来得到最佳情况。例如，在日常生活中，我们都知道一日递送包裹比三日递送要贵。尽管时间和代价在递送包裹中都是想要获取的特性，但是它们是彼此矛盾的。我们需要选择最佳值。 尽管UDP 不满足我们之前讨论的可靠传输层协议标准，但是，UDP 更适合某些应用,因为其他某些服务可能有副作用，这些副作用或许是不可接受的或许是不称心的 UDP特性 无连接服务：UDP 是无连接协议。同一个应用程序发送的UDP 分组之间是独立的。 例如，如果一个客户应用需要向服务器发送一个短的请求并接收一个短的响应，那么这就是优势。如果请求和响应各自可以填充进一个数据报，那么无连接服务可能更可取。在这种情况下，建立和关闭连接的开销可能很可观。在面向连接服务中，要达到以上目标，至少需要在客户和服务器之间交换9 个分组；在无连接服务中只需要交换2 个分组。无连接服务提供了更小的延迟；面向连接服务造成了更多的延迟。如果延迟是应用的重要问题，那么无连接服务更可取。 缺乏差错控制：它提供的是不可靠服务。 缺乏拥塞控制：UDP 不提供拥塞控制。然而，在倾向于出错的网络中UDP 没有创建额外的通信量。TCP 可能多次重发一个分组，因此这个行为促使拥塞发生或者使得拥塞状况加重。因此，在某些情况下，当拥塞是一个大问题时，UDP 中缺乏差错控制可以看做是一个优势 应用 DNS，它使用UDP 服务，因为客户需要向服务器发送一个短的请求，并从服务器接收快速响应。请求和响应可以填充进一个用户数据报。由于在每个方向上只交换一个报文，因此无连接特性不是问题；客户或服务器不担心报文会失序传递。 UDP 可用于某些路由选择更新协议，如路由选择信息协议（RIP） UDP 可用于管理进程，如SNMP UDP 适用于具有内部流量控制和差错控制机制的进程。例如，简单文件传输协议（TFTP）的进程就包含流量控制和差错控制。它可很容易地使用UDP。 UDP 适合于这样的进程：它需要简单的请求-响应通信，而较少考虑流量控制和差错控制。对于需要传送成块数据的进程（如FTP）则通常不使用UDP 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-UDP/"},{"title":"计算机网络教程-传输层协议-TCP(1)","text":"TCP(传输控制协议)传输控制协议（Transmission Control Protocol，TCP）是一个面向连接可靠的协议。 TCP 显式定义了连接建立、数据传输以及连接拆除阶段来提供面向连接服务。 TCP 使用GBN 和SR 协议的组合来提供可靠性。 为了实现这个目的，TCP 使用校验和（为差错发现）、丢失或被破坏分组重传、累积和选择确认以及计时器。 TCP 服务进程到进程的通信像UDP 一样，TCP 通过使用端口号来提供进程到进程通信。 流传递服务与UDP 不同，TCP 是一个面向流的协议。在UDP 中，进程发送一些具有预先规定边界的报文给UDP 进行传递。UDP 将它自己的头部添加到这些报文中并传递到IP 层进行传输。来自进程的每一个报文称为一个用户数据报，最后变成一个IP 数据报。IP 和UDP 都不认识这些数据之间的关系。 而TCP 允许发送进程以字节流形式传递数据，并且接收进程也以字节流形式接收数据。TCP 建立一种环境，在这种环境中，两个进程好像由一个假想的“管道”连接，这个管道通过因特网传送这些进程的数据。 这种假想的环境如图所示。发送进程产生（写入）字节流，而接收进程消费（读出）这些字节流。 发送和接收缓冲区因为发送和接收进程可能以不同的速度写入和读出数据，所以TCP 需要用于存储的缓冲区。 每一个方向都存在一个缓冲区：发送缓冲区和接收缓冲区。 这些缓冲区也用于TCP 流量和差错控制机制。 实现缓冲区的一种方法是使用以一字节为存储单元的循环数组。 实现缓冲区的方法如图所示。为了简化，我们只画出了两个缓冲区，每个缓冲区20个字节。通常情况下，缓冲区是数百甚至数千个字节，这取决于实现方法。这里给出的缓冲区是大小相同的，实际上并非总是如此。上图表示了在一个方向上数据的移动。在发送端，缓冲区有三种类型的存储单元。 白色的部分是空存储单元，可以由发送进程（生产者）填充。 灰色的部分用于保存已经发送但还没有得到确认的字节。TCP 在缓冲区中保留这些字节，直到收到确认为止。 灰色缓冲区是将要由TCP 发送的字节。但是，在本章的后面将会看到，TCP 可能只发送灰色部分。这可能是由于接收进程缓慢或者网络中可能发生的拥塞造成的。 灰色存储单元的字节被确认后，这些存储单元可以回收并且对发送进程可用，这就是我们给出一个环形缓冲区的原因。 接收端的缓冲区操作比较简单。环形缓冲区分成两个区域（表示为白色和灰色）。白色区域包含空存储单元，可以由从网络上接收的字节进行填充。灰色区域表示接收到的字节，可以由接收进程读出。当某个字节被接收进程读出以后，这个存储单元可被回收，并加入到空存储单元池中。 段尽管缓冲能够处理生产进程速度和消费进程速度之间的不相称问题，但在发送数据之前，还需要多个步骤。IP 层作为TCP 服务的提供者，需要以分组的方式而不是字节流的方式发送数据。在传输层，TCP 将多个字节组合在一起成为一个分组，这个分组称为段（segment）。TCP 给每个段添加头部（为了达到控制目的），并将该段传递给IP 层。段被封装到IP 数据报中，然后再进行传输。整个操作对接收进程是透明的。这些段可能被无序接收、丢失，或者损坏和重发。所有这些均由TCP 处理，接收进程不会察觉到任何操作。下图表示了在缓冲区中如何从字节生成段。注意，段的大小不必相同。为了简单起见，我们在图中只表示了一个包含3 个字节的段和另一个包含5 个字节的段。实际的段可能包含数百（或者数千）个字节。 全双工通信TCP 提供全双工服务（full-dupler service），即数据可以在同一时间双向流动。每一方向TCP都有发送和接收缓冲区，它们能在双向发送和接收段。 多路复用和多路分解与UDP 类似，TCP 在发送端执行多路复用，在接收端执行多路分解。然而，由于TCP 是一个面向连接协议，因此需要为每对进程建立连接。 面向连接的服务与UDP 不同，TCP 是一种面向连接的协议。位于站点A 的一个进程与站点B 的另外一个进程想要进行数据的发送和接收，步骤如下：1．在两个TCP 之间建立一个连接。2．在两个方向交换数据。3．连接终止。注意，这是一个逻辑连接，而不是一个物理连接。TCP 段封装成IP 数据段，并且可能被无序地发送，或丢失，或被破坏，然后重发。每个段都可以通过不同的路径到达目的端。TCP 建立一种面向字节流的环境，在这种环境中，TCP 能承担按顺序传递这些字节到其他站点的任务。 可靠的服务TCP 是一种可靠的传输协议。它使用确认机制来检查数据是否安全和完整地到达。 TCP与UDP基本区别 基于连接与无连接 TCP要求系统资源较多，UDP较少 UDP程序结构较简单 字节流模式（TCP）与数据报模式(UDP); TCP保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 TCP 的特点序号系统虽然TCP 软件能够记录发送或接收的段，但是在段的头部没有段序号字段。TCP 在段的头部采用称为序号（sequence number）和确认号（acknowledgment number）的两个字段。这两个字段指的是字节序号，而不是段序号。 字节序号TCP 为在一个连接中传输的所有数据字节（八位字节）编号。在每个方向上序号都是独立的。当TCP 接收来自进程的一些数据字节时，TCP 将它们存储在发送缓冲区中并给它们编号。不必从0 开始编码，TCP 在0到232−1 之间生成一个随机数作为第一个字节的序号，例如，如果随机数是1057，并且发送的全部字节个数是6000，那么这些字节序号是1057~7056。下面将会看到字节序号是用于流量和差错控制。 在每个连接中传送的字节都由TCP 编号，序号开始于一个随机产生的数。 序号字节被编号后，TCP 对发送的每一个段分配一个序号。在每一个方向上的序号定义如下：1．第一段的序号是初始序号（initial sequence number，ISN），这是一个随机数。2．其他段的序号是之前段的序号加之前段携带的字节数（实际上的或想象的）。之后，我们将给出一些控制段，它们被认为携带了一个想象字节。 一个段的序号字段的值定义了该段包含的第一个字节的序号。 当一个段携带数据和控制信息（捎带）时，它使用一个序号。如果一个段没有携带用户数据，那么它逻辑上不定义序号。虽然字段存在，但是值是无效的。然而，当有些段仅携带控制信息时也需要有一个序号用于接收方的确认。这些段用作连接建立、连接终止或连接废弃。这些段中的每一个好像携带一个字节那样使用一个序号，但都没有实际的数据。 确认号TCP 中的通信是全双工的；当建立一个连接时，双方同时都能发送和接收数据。 每一方为字节编号，每一方经常使用不同的起始字节号。 每一方向的序号表明了该段所携带的第一个字节的序号。 每一方也使用确认号来确认它已收到的字节。但是，确认号定义了该方预期接收的下一个字节的序号(也就是序号+1)。另外，确认号是累积的，这意味着接收方记下它已安全而且完整地接收到最后一个字节的序号，然后将它加1，并将这个结果作为确认号进行通告。在这里，术语“累积”指的是，如果一方使用5643 作为确认号，则表示它已经接收了所有从开始到序号为5 642 的字节。但要注意，这并不是指接收方已经接收了5 642 个字节，因为第一个字节的编号通常并不是从0 开始的。 参考资料计算机网络教程-自顶向下方法TCP与UDP的区别","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP/"},{"title":"计算机网络教程-传输层协议-TCP(2)","text":"TCP 连接在 TCP 中，面向连接的传输需要三个过程：连接建立、数据传输和连接终止。在TCP 中的分组称为段（segment） TCP段格式段包含20~60字节的头部，接着是来自应用程序的数据。如果没有选项，那么头部是20 字节；如果有选项，最多是60 字节。 源端口地址。这是一个16 位的字段，它定义了在主机中发送该段的应用程序的端口号。这与UDP 头部的源端口地址的作用一样。 目的端口地址。这是一个16 位的字段，它定义了在主机中接收该段的应用程序的端口号。这与UDP 头部的目的端口地址的作用一样。 序号。这个32 位的字段定义了一个数，它分配给段中数据的第一个字节。 TCP 是一种字节流传输协议。为了确保连通性，对要发送的每一个字节都进行编号。序号告诉目的端，在这个序列中哪一个字节是该段的第一个字节。 在连接建立时，每一方都使用随机数生成器产生一个初始序号（initial sequence number，ISN），通常每一个方向的ISN 都不同。 确认号。这个32 位的字段定义了段的接收方期望从对方接收的字节号。如果段的接收方成功地接收了对方发来的字节号x，它就将确认号定义为x + 1. 确认和数据可捎带一起发送。 头部长度。这个4 位的字段指明了TCP 头部中共有多少个4字节长的字。 头部的长度可以在20 字节到60 字节之间。因此，这个字段的值在5（5 × 4 = 20）到15（15 × 4 = 60）之间。 窗口大小。这个字段定义对方必须维持的窗口的大小（以字节为单位）。 注意，这个字段的长度是16 位，这意味着窗口的最大长度是65 535 字节。这个值通常称为接收窗口（rwnd）。 它由接收方确定。此时，发送方必须服从接收端的支配。 紧急指示符。这个16 位的字段只有当紧急标志置位时才有效，这个段包含了紧急数据。 它定义了一个数，将此数加到序号上就得出此段数据部分中最后一个紧急字节。 选项。在TCP 头部中可以有多达40 个字节的可选信息。 控制字段这个字段定义了6 种不同的控制位或标记，如图所示。 在同一时间可以设置一位或多位。 这些位用在TCP 的流量控制、连接建立和终止、连接失败和数据传送方式等方面。 校验和。这个16 位的字段包含了校验和。TCP 校验和的计算过程与前面描述的UDP 所采用的计算过程相同。但是，在UDP 数据报中校验和是可选的。 然而，对TCP 来说，将校验和包含进去是强制的。 起相同作用的伪头部被加到段上。对TCP 伪头部，协议字段的值是6。如图所示。 在 TCP 中使用校验和是强制的。 连接建立（三次握手）TCP 以全双工方式传输数据。当两个机器中的两个TCP 建立连接后，它们就能够同时向对方发送段。这就表示，在传输数据之前，每一方都必须对通信进行初始化，并得到对方的认可。三次握手（three-way handshaking）：客户的应用程序想要与另一个称为服务器的应用程序使用TCP 作为传输层协议建立连接。 该过程从服务器开始。服务器程序告诉它的TCP，它已准备好接收一个连接。这就称为被动打开（passive open）。虽然TCP 已经准备好接收从世界上任何一个机器发来的连接，但它自己并不能完成这个连接。客户程序发出请求进行主动打开（active open）。想要与服务器进行连接的客户告诉它的TCP，它需要连接到特定的服务器。 少数几个必须要知道的字段，如果序号、确认号、控制标记（仅仅是其中被置位的）和窗口大小等有值。三个步骤如下: 客户发送的第一个段，即SYN 段。这个段仅有SYN 标志被置位，它用于序号同步。它占用一个序号。当数据传输开始时，在我们的例子中，客户随机选择一个数字作为初始序号（ISN）。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。段也能包含一些稍后讨论的选项。 注意，SYN 段是一个控制段并且不携带数据。然而，它消耗一个序号，因为它需要被确认。我们可以说SYN 段携带了一个假想字节。 SYN 段不携带数据，但它占用一个序号。看下面的图就明白了。 服务器发送第二个段，即SYN +ACK 段。这个段有两个目的。 首先，它是另一方向通信的SYN 段。服务器使用这个段来初始化序号，这个序号用来给从服务器发向客户的字节编号。 其次，服务器也通过给ACK 置位并展示下一个序号来确认接收到来自客户的SYN 段，这里的下一个序号是服务器预期从客户接收的序号。 我们将在介绍流量控制那一节看到，因为它包含确认，它也需要定义接收窗口，即rwnd（客户使用）。因为这个段起到SYN段的作用，它需要被确认。因此，它占用一个序号。 SYN + ACK 段不携带数据，但它占用一个序号。 客户发送第三个段，即ACK 段。它使用ACK 标志和确认序号字段来确认收到了第二个段。 注意，如果不携带数据，ACK 段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据。在这种情况下，段消耗的序号与数据字节数相同。 ACK 段，如果不携带数据，则它不占用序号。 数据传输连接建立后，可进行双向数据传输，客户端与服务器双方都可发送数据和确认。数据捎带确认：在同一段内携带确认时，在同一方向上也可以传递数据。 图示在这个例子中，在连接建立后，客户端用两个段发送2000 个字节的数据。然后，服务器用一个段发送2000 个字节的数据。客户端发送另一个段。 前面三个段携带数据与确认，但是最后一个段仅携带确认，这是因为已没有数据发送了。 注意序号与确认号数值，客户端发送的数据段有PSH（推送）标志，所以服务器TCP 知道在接收到数据时立刻传递给服务器进程。 另一方面，来自服务器的段没有设置推送标志。大多数TCP 的实现都有可选标志，可设置或不设置。 推送数据发送方的TCP 使用缓冲区存储来自发送方应用程序的数据流。发送方的TCP 可以选择段的大小。接收方的TCP 在数据到达时也将数据进行缓存，并当应用程序准备就绪时或当接收端TCP 认为方便时将这些数据传递给应用程序。这种灵活性增加了TCP 的效率。 但是，在有些情况下，应用程序并不需要这种灵活性。例如，应用程序与另一方应用程序进行交互式通信。 一方的应用程序打算将其信息发给对方应用程序，并希望接收到立即响应。数据的延迟传输和延迟传递对这个应用程序来说是不可接受的。 TCP 可以处理这种情况。 在发送端的应用程序可请求推送操作。这就表示发送端的TCP 不必等待窗口被填满。 它创建一个段就立即将其发送。发送端的TCP 还必须设置推送位（PSH）以告诉接收端的TCP，这个段所包含的数据必须尽快地传递给接收应用程序，而不要等待更多数据的到来。 这意味着将面向字节的TCP 改为面向块的TCP，但是TCP 可以选择使用或不使用这个特性。 连接终止(四次挥手) 半关闭半关闭（half-close）：指在 TCP 中，一端可以停止发送数据后，还可以接续接收数据。（关闭发送但是不关闭接收）虽然任一端都可发出半关闭，但通常都是由客户端发起的。当服务器在开始处理之前需要接收到所有数据，这时就会出现半关闭。例如，排序是一个很好的例子。客户端发送数据给服务器进行排序，在开始排序之前，服务器需要接收到全部数据。 这就是说，客户端发送全部数据之后，它在客户到服务器方向可关闭连接。（客户端关闭发送） 但为了返回存储数据，服务器到客户方向必须保持打开。（客户端不关闭接收） 服务器在接收数据后还需要时间进行排序；它的向外方向必须保持打开。 从客户到服务器的数据传输停止。客户端通过发送FIN 段实现半关闭连接。服务器通过发送ACK 段确认半关闭。然而，服务器还可以发送数据。当服务器已经发送完被处理的数据时，它发送一个FIN 段。该FIN 段由客户端的ACK 来确认。连接半关闭后，数据可以从服务器传送给客户端，而确认可以从客户端传送给服务器。客户不能再向服务器发送任何数据。 连接重置在一端的TCP 可能拒绝连接请求，可能终止已存在的连接，也可能结束空闲连接。所有这些都通过RST（重置）标志完成。 参考资料详细分析TCP数据的传输过程【网络通信】TCP的通信过程图解TCP传输过程（三次握手、数据传输、四次挥手）TCP 的那些事儿（上）TCP 的那些事儿（下）一个TCP连接上能发起多少个HTTP请求吗？计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP-2/"},{"title":"计算机网络教程-HTTP协议","text":"HTTP（超文本传输协议）超文本传输协议（HyperText Transfer Protocol，HTTP）是一种用来定义客户服务器程序如何编写和如何从万维网获取网页的协议。 一个HTTP 客户发送一个请求；HTTP 服务器返回响应。 服务器使用80 端口号；客户使用一个临时端口号。 HTTP 使用TCP 服务。这意味着，在客户和服务器进行任何事务之前，它们之间必须建立连接。 在事务之后，连接应当终止。然而，客户和服务器不需要担心交换报文中的差错以及报文的丢失，因为TCP 是可靠的而且将处理这个问题。 非持续与持续连接嵌入到网页中的超文本概念可能需要多个请求和应答。 如果网页，这个被获取的对象，位于不同的服务器，那么我们没有其他选择只能每获取一个对象就要创建一个新的TCP 连接。 然而，如果某些对象是位于同一台服务器的，我们可以有两种选择： 一是每次使用一个新的TCP 连接获取一个对象。非持续连接（nonpersistent connection） 二是创建一个TCP 连接获取全部对象。持续连接（persistent connection） 在HTTP1.1 版之前指定的是非持续连接，持续连接在1.1 版中是默认的，但是可以被用户改变。 非持续连接在非持续连接中，一个TCP 连接被每一组请求/应答所创建。下面是这个策略的步骤：1．客户开启一个TCP 连接并发送请求。2．服务器发送响应并关闭连接。3．客户读取数据直到它遇到了文件结束标记，然后关闭连接。 在这种策略中，如果文件包含了N 个位于不同文件的图片连接（全都位于同一台服务器），那么必须开启和关闭连接N+1 (?)次。非持续策略给服务器带来了高额开销，因为每次连接被开启时服器都需要N+1个不同的缓冲区。 下图展示了一个非持续连接的例子。客户需要访问一个包含图片链接的文件。文本文件和图片位于同一台服务器上。这里我们需要两个连接。对于每一个连接，TCP 需要至少三个握手报文来建立连接，但是请求可以和第三个报文一起发送。在连接建立之后，请求对象可以被发送。在接收到一个对象之后，需要另外三次握手报文来结束连接 持续连接 在持续连接中服务器在发送一个响应后，为响应更多的请求而将连接置为打开状态。 服务器可以在客户的请求下或者在超时情况下将连接关闭。 文档发送方（通常是服务器）通常在每次响应中发送数据长度。然而，偶尔情况下发送方不知道数据的长度。这是创建动态文档或活动文档时的情形。在这种情形下，服务器通知客户长度未知并在发送数据后关闭连接，因此客户知道数据已接收完毕。 通过使用持续连接，可以节省时间和资源。每个站点只需要为连接设定一组缓冲区和变量。同时节省了连接建立和终止的往返时间。 报文格式HTTP 协议定义了请求报文和响应报文的格式。每一种报文由四个部分组成。 请求报文中的第一部分称为请求行； 响应报文的第一部分称为状态行。 其他三部分在请求报文和响应报文中有相同的名称。然而，这三部分只是名称相似，它们可能含有不同的内容。 请求报文 请求报文的第一行称为请求行。如图所示，这一行有三部分由空格分隔开并且被两个字符（回车和换行）终止。这些字段称为方法、URL 和版本。 第一个字段：方法字段定义了请求类型。如下所示，在HTTP1.1 版中定义了若干种方法。 第二个字段：URL，在本章的前面部分已经讨论过了。它定义了相关网页的地址和名称。 第三个字段：版本，给出了协议的版本，HTTP 最常用的版本是1.1。 12345678910111213141516171819HTTP请求报文中的方法--------------------------------------------------------------------------------------------GET 向服务器请求文档。绝大多数情况下，客户使用GET 方法发送一个请求。在这种情况下，报文的主体是空的。-------------------------------------------------------------------------------------------- HEAD 请求关于文档的信息，而不是文档本身。当客户仅需要从服务器获得关于网页的信息，如上次修改的时间，这时使用HEAD 方法。它也可以用来检测URL 的有效性。这种情况下的响应报文只有头部；主体是空的。 --------------------------------------------------------------------------------------------PUT 从客户端向服务器发送文档。PUT 方法与GET 方法是相反的；它允许客户将一个新的页面发送到服务器上（如果允许的话）。 --------------------------------------------------------------------------------------------POST 从客户端向服务器发送一些信息。POST 方法与PUT 方法类似，但是它用来发送一些信息到服务器上，这些信息被加入网页或用来修改网页--------------------------------------------------------------------------------------------TRACE 回送输入的请求。用来调试；客户要求服务器回送请求来检查服务器是否正在获得请求。DELETE 删除网页。如果客户获得许可，DELETE 方法允许客户删除一个服务器上的网页。CONNECT 预留。原先作为预留方法；后文会讨论到，这个方法可能被代理服务器使用。 OPTIONS 询问有关可用的选项。允许客户询问网页属性。 在请求行之后我们可以有一个或多个请求头部（request header）行。 每一个头部行都从客户端向服务器发送额外的信息。 例如，客户可以请求以某种特定格式发送文档。每个头部行有头部名字、一个冒号、一个空格和一个头部值（见图3）。下面列出了一些请求中常用的头部名字。 值字段定义了与每个头部名字相关的值。 值列表可以在相应的RFC 中查找到。 主体可以出现在请求报文中。通常，当使用POST 或PUT 方法时，它包含要发送的评论或要发布到网站上的文档。 12345678910111213请求头部名称-----------------------------------------------------------User-agent 标识客户端程序 Accept 给出客户端能够接受的媒体格式 Accept-charset 给出客户端可以处理的字符集 Accept-encoding 给出客户端可以处理的编码方案 Accept-language 给出客户端可以接受的语言Authorization 给出客户端有哪些许可 Host 给出主机及客户端的端口号Date 给出当前日期Upgrade 确定首选的通信协议Cookie 返回cookie 给服务器（稍后解释）If-Modified-Since 如果文档在指定的日期之后被更新，则发送文档 响应报文图3给出了响应报文的格式。响应报文包含状态行、头部行并且有时包含主体。 响应报文的第一行称为状态行。这一行有三个字段，它们由空格分隔开并且被两个字符（回车和换行）终止。 第一个字段：版本字段，定义了HTTP 协议的版本，通常为1.1。 第二个字段：状态码字段,定义了请求的状态。 它包含三个数字。在100 范围内的代码只代表一个报告 在200 范围内的代码表示这是一个成功的请求。 在300范围内的代码表示把客户端重定向到另一个URL 在400 范围内的代码表示在客户端发生错误。 最后，在500 范围内的代码表示错误发生在服务器端。 第二个字段：状态短语字段，以文本格式解释了状态码。 在状态行之后，我们可以有一个或多个响应头部行。每一个头部行都从服务器向客户端发送额外的信息。例如，发送方可以发送关于文档的额外信息。每个头部行都有一个头部名称、一个冒号、一个空格和一个头部值。下面列出了一些常用的头部名称。 12345678910111213响应头部名称------------------------------------------------------Date 给出当前日期 Upgrade 确定首选的通信协议 Server 给出服务器信息 Set-Cookie 服务器要求客户存储Content-Encoding 指定编码方案 Content-Language 指定语言Content-Length 给出文档长度Content-Type 指定媒体类型Location 指明新建或移动后文档的位置cookie Accept-Ranges 服务器将会接收的被请求的字节范围Last-modified 给出上次改变的日期和时间 主体包含了从服务器发送给客户的文档。除非响应是一个错误报文，否则主体是存在的。 示例客户要向服务器发送一个网页在这个例子中，客户要向服务器发送一个网页。我们使用PUT 方法。 请求行给出方法（PUT）、URL 以及HTTP 版本（1.1）。其头部有四行。请求主体包含要发送的网页。 响应报文包含状态行和四个头部行。被创建的文档是一个CGI 文档，它包含在响应报文的主体中 客户要向服务器获取一个文档使用GET 方法来获取一个路径为/usr/bin/image1 的图片。 请求行给出了使用的方法（GET）、URL 以及HTTP 版本（1.1）。 头部有两行，它们表示客户可以接收GIF 或JPEG 格式的图片。请求是没有主体的。 响应报文包含了状态行以及四个头部行。头部行定义了日期、服务器、内容编码（MIME 版本，在电子邮件部分将会描述）以及文档长度。文档主体在头部之后。 条件请求客户可以在请求中加入条件。在这种情况下，如果条件满足，服务器将会发送被请求的网页或者通知用户。 客户加入的最常见的一种条件是网页被修改的时间和日期。 客户可以在发送请求时附带头部行If-Modified-Since，这样来告知服务器客户只需要在指定日期之后更新的页面。 一个客户在请求中加入了修改日期和时间的条件。 123GET http://www.commonServer.com/information/file1 HTTP/1.1 请求行If-Modified-Since: Thu, Sept 04 00:00:00 GMT 头部行 空行 响应中的状态行表示在指定日期之后文档没有修改。所以响应报文的主体是空的。 12345HTTP/1.1 304 Not Modified 状态行Date: Sat, Sept 06 08 16:22:46 GMT 头部第一行Server: commonServer.com 头部第二行 空行(Empty Body) 空主体 HTTP 安全HTTP 本质上并不提供安全。然而，，HTTP 可以在安全套接层（SSL）上运行。在这种情况下，HTTP 称为HTTPS。HTTPS 提供保密性、客户和服务器鉴别，以及数据完整性。HTTPS 端口号443 状态码（Status-Code）1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 参考资料HTTP状态码-菜鸟教程HTTP 教程-菜鸟教程浅谈HTTP中GET、POST用法以及它们的区别 计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"计算机网络教程-TCP状态转换","text":"TCP状态表 状态 说明 状态 说明 CLOSED 没有连接存在 FIN-WAIT-2 首个FIN 的ACK 已被接收；等待第二个FIN LISTEN 接收到被动打开；等待SYN CLOSE-WAIT 首个FIN 被接收，ACK 被发送；等待应用关闭 SYN-SENT SYN已被发送；等待ACK TIME-WAIT 第二个FIN 被接收，ACK 被发送；等待2MSL 超时 SYN-RCVD SYN + ACK 已被发送；等待ACK LAST-ACK 第二个FIN 被发送；等待ACK ESTABLISHED 连接建立；数据传输正在进行 CLOSING 双端决定同时关闭 FIN-WAIT-1 首个FIN 已被发送；等待ACK 示例客户进程向它的TCP 发出主动打开命令来请求连接到特定套接字地址。 TCP 发送一个SYN 段并转移到SYN-SENT 状态。 在收到SYN + ACK 段后，TCP 发送了一个ACK 段并且进入ESTABLISHED状态。 数据被传输，可能是双向的，并且被确认。 当客户进程没有数据要发送了，它发出称为主动关闭的命令。 TCP 发送FIN 段并进入FIN-WAIT-1状态。 当它接收到ACK 段，它进入FIN-WAIT-2状态。 当客户接收到FIN 段时，它发送一个ACK 段并进入TIME-WAIT状态。 客户保持这种状态2MSL秒（TCP 计时器）。 当相应计时器超时，客户进入CLOSED状态。 服务器进程发出被动打开命令。 服务器TCP 进入LISTEN 状态并且保持这种状态直到它接收到一个SYN 段。 TCP 之后发送一个SYN + ACK 段并且进入SYN-RCVD 状态，等待客户发送ACK段。 在接收到ACK 段后，TCP 进入ESTABLISHED 状态，这就开始了数据传输。 TCP 保持这种状态直到它接收到一个来自客户的FIN 段，这表示没有其他数据要被交换且连接可以被关闭。 一旦服务器接收到FIN 段，那么它就向客户发送带有虚拟EOF 标记的排队中所有的数据，这意味连接必须被关闭。 它发送一个ACK 段且进入CLOSE-WAIT状态，但是推迟确认来自客户的FIN 段，直到它接收到来自进程的被动关闭命令。 在接收到被动关闭命令后，服务器向客户发送FIN 段并进入LAST-ACK状态，等待最终ACK。 当ACK 段从客户发送后被服务器接收，服务器进入CLOSE 状态。","link":"/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"},{"title":"计算机网络教程-套接字","text":"套接字的数据结构C 语言将套接字定义为一个结构（struct）。套接字结构由五个字段组成；每个套接字地址是一个由五部分构成的结构。 族。这个字段定义了协议簇（如何解释地址和端口号）。 通常值是PF_INET（用于当前因特网）、PF_INET6（用于下一代因特网）等等。我们在本节使用PF_INET。 类型。这个字段定义了四个套接字类型： SOCK_STREAM（用于TCP） SOCK_DGRAM（用于UDP）、 SOCK_SEQPACKET（用于SCTP） SOCK_RAW（用于直接使用ISP 服务的应用）。 协议。这个字段定义了族中特定协议。对于TCP/IP 协议簇这个字段设置为0，因为它是族中唯一的协议。 本地套接字地址。这个字段定义了本地套接字地址。 一个套接字地址是一个结构，它由长度字段、族字段（对于TCP/IP 协议簇，它被设置为常量AF_INET）、端口号字段（定义了进程）以及IP 地址字段（定义了正在运行的进程所在的主机）构成。它也包含未使用字段。 远程套接字地址。这个字段定义了远程套接字地址。它的结构与本地套接字地址相同。 头文件123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/innet.h&gt;#include &lt;sys/wait.h&gt; 使用 TCP 通信 TCP 是面向连接的协议。在发送或接收数据之前，需要在客户端和服务器之间建立连接。在连接建立之后，只要它们有数据要发送或接收，两端就可以彼此发送以及接收数据块。 TCP 连接可以是迭代的（一次服务一个客户）也可以是并发的（一次服务多个客户）。 TCP 中使用的套接字TCP 服务器使用两个不同的套接字: 一个用于连接建立。称为监听套接字（listen socket）。 一个用于数据传输。称为套接字（socket）。 设置两种套接字的目的是将建立阶段和数据交换阶段分开。 服务器使用监听套接字来监听试图建立连接的新客户。在连接建立之后，服务器创建一个用于和客户交换数据的套接字并且最终终止连接。客户只使用一个套接字用于连接建立以及数据交换。 通信流程图 服务器进程 TCP 服务器进程调用socket 和bind 函数，但是这两个函数创建监听套接字，它只在连接建立阶段被使用。 之后，服务器进程调用listen函数，允许操作系统开始接收客户、完成连接阶段并把他们放入等待被服务的列表。 这个函数也定义了被连接的客户等待列表的大小，这依赖于服务器进程的复杂性，但是通常值为5。 现在，服务器进程开始循环并且逐一对客户进行服务。 在每次循环中，服务器进程调用accept函数从已连接客户的等待列表中去除一个客户，对其进行服务。 如果列表是空的，那么accept 函数进入阻塞状态直到出现一个客户待服务。 当accept 函数返回，它创建一个新的与监听套接字一样的套接字。 监听套接字现在移入后台，并且新的套接字成为活动套接字。 服务器进程现在使用连接建立期间获得的客户套接字地址，用它来填充新建套接字的远程套接字地址。 此时，客户和服务器可以交换数据。我们没有给出数据传输的特定方式，因为这取决于特定的客户-服务器对。 TCP 使用send以及recv程序在它们之间传输数据字节。这两个函数比UDP 中使用的sendto 和recvfrom 函数更简单，因为它们不提供远程套接字地址；连接已经在客户和服务器之间建立。 然而，由于TCP 用于传输无边界报文，每个应用需要仔细设计数据传输部分。 send 和recv 函数可能被调用多次来处理大量数据传输。可以将上图的流程图当作一个通用流程图；如果是特殊用途，需要定义服务器数据传输（sever data-transfer）盒。 客户进程客户进程进行主动开启（active open）。换言之，它开启连接。它调用socket 函数来创建一个套接字并填充前三个字段。尽管某些实现要求客户进程也调用bind 函数来填充本地套接字，但通常这是由操作系统自动完成的，操作系统为客户选择一个临时端口号最终close 函数被调用以销毁套接字。客户流程图与UDP 版本类似，除了客户数据传输（client data-transfer）盒需要为每个特定情况定义。 套接字接口编程（TCP）编写客户和服务器程序来模拟使用TCP的标准回送应用——客户程序发送一个短的字符串给服务器；服务器将相同的字符串回送到客户。在我们这样做之前，需要为客户和服务器数据传输盒提供流程图 客户和服务器数据传输盒的流程图（发送消息和回送消息）对于发送和回送短的字符这个特定的情况，因为待发送的字符串很短（小于几个单词），我们可以在客户端调用send函数一次完成。然而，TCP 并不保证把整个报文在一个报文段内发送。因此，我们需要在服务器端调用一组recv（在一个循环内）来接收整个报文并将它们收集到缓冲区内，从而能一次性发送回去。当服务器向客户发送回送报文时，它也可能使用多个报文段，这意味着客户的recv 程序需要调用多少次就会被调用多少次。 缓冲区设置另一个有待解决的问题是设置缓冲区，缓冲区用于在每个站点接收数据。 我们需要控制接收的字节数以及下一个数据块存储的位置。 如图所示，程序设置了一些变量进行控制。 在每次迭代中，指针（ptr）移动指向下一个要接收的字节，接收字节的长度（len）呈增长趋势并且待接收的最大字节数（maxLen）呈减少趋势。 回送服务器程序程序遵循迭代TCP通信流程图。第 6 行到第16 行声明并定义了变量。第18 行到第21 行分配内存并且按UDP 情况下所述创建了本地（服务器）套接字地址。第23 行到第27 行创建了监听套接字。第29 行到第33 行将监听套接字绑定到第18 行到第21 行创建的服务器套接字地址上。第35 行到第39 行是TCP 通信中的新内容。调用 listen 函数让操作系统完成连接建立阶段并将客户置入等待列表。第44 行到第48 行调用accept 函数来移除等待列表中的第一个客户并开始为其服务。如果在等待列表中没有客户，那么这个函数处于阻塞状态。第50 行到第56 行对图2-63 中描述的数据传输部分进行编码。最大缓冲区大小与回送字符串长度都和图5中所示相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//回送服务器程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(){ //声明并定义 int ls; //监听套接字描述符（引用） int s; //套接字描述符（引用） char buffer[256]; //数据缓冲区 char *ptr=buffer; //数据缓冲区 int len=0; //等待接收或者发送的字节数 int maxLen=sizeof(buffer); //最大接收字节数 int n; //每次调用receive接收的字节数 int waitSize=16; //等待客户数量 struct sockaddr_in servAddr; //服务器地址 struct sockaddr_in clntAddr; //客户地址 int clntAddrLen; //客户地址长度 //创建本地（服务器）套接字地址 memset(&amp;servAddr,0,sieof(servAddr)); servAddr.sin_family=AF_INET; servAddr.sin_addr.s_addr=htonl(INADDR_ANY); //默认IP地址 servAddr.sin_port=htonl(SERV_PORT); //默认端口 //创建监听套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) //PF_INET族，SOCK_STREAM指套接字类型（tcp） { perror(\"Error:Listen socket failed!\"); exit(1); } //将套接字绑定到本地套接字地址 if(bind(ls,&amp;servAddr,sizeof(servAddr))&lt;0) { perror(\"Error:binding failed!\"); exit(1); } //创建连接请求 if(listen(ls,waitSize)&lt;0) { perror(\"Error:listening failed!\"); exit(1); } //处理连接 for(;;) //永远运行 { //接收来自客户的连接 if(s=accept(ls,&amp;clntAddr,&amp;clntAddrLen)&lt;0) { perror(\"Error:accepting failed!\"); exit(1); } //数据传输部分 while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } send(s,buffer,len,0); //发回（回送）所有接收的字节 //关闭套接字 close(s); }//循环结束}//回送服务器程序结束 tips: 在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到htonl(), ntohl(), ntohs()，htons()这4个函数。 htonl()–”Host to Network Long” ntohl()–”Network to Host Long” htons()–”Host to Network Short” ntohs()–”Network to Host Short” 回送客户程序TCP 的客户程序与UDP 的客户程序非常相似，只有些许不同。 因为TCP 是面向连接的协议第36 行到第40 行调用connect 函数连接服务器。 第42 行到第48 行使用图3中的思想完成数据传输。 按图5所示方式完成接收数据的长度调整和指针移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//回送客户程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(int argc,char *argv[]) //三个参数之后待检验{ //声明并定义 int s; //套接字描述符 int n; //每次调用recv接收的字节数 char servName; //服务器名 int servPort; //服务器名 char *string; //被回送的字符串 int len; //被回送的字符串的长度 char buffer[256+1]; //缓冲区 char *ptr=buffer; //在缓冲区上移动指针 struct sockaddr_in serverAddr; //服务器套接字地址 //检测并设置参数 if(argc!=3) { printf(\"Error:three arguments are needed!\"); exit(1); } servName=argv[1]; servPort=atoi(argv[2]); string=arg[3]; //创建远程（服务器）套接字地址 memset(&amp;serverAddr,0,sieof(serverAddr)); servAddr.sin_family=AF_INET; inet_pton(AF_INET,servName,&amp;serverAddr.sin_addr); //服务器IP地址 serverAddr.sin_port=htons(SERV_PORT); //默认端口 //创建套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) { perror(\"Error: socket creation failed!\"); exit(1); } //连接到服务器 if(connect(sd,(struct sockaddr*)&amp;serverAddr,sizeof(serverAddr))&lt;0) { perror(\"Error:connection failed!\"); exit(1); } //数据传输部分 send(s,string,strlen(string),0); while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } //打印并验证回送的字符串 buffer[len]='\\0'; printf(\"Echoed string received:\"); fputs(buffer,stdout); //关闭套接字 close(s); //停止程序 exit(0);}//回送客户程序结束 参考资料计算机网络-自顶向下方法TCP协议的无消息边界问题TCP网络传输“粘包”问题，经典解决（附代码）","link":"/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E5%A5%97%E6%8E%A5%E5%AD%97/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"演讲","slug":"演讲","link":"/tags/%E6%BC%94%E8%AE%B2/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"名著","slug":"名著","link":"/tags/%E5%90%8D%E8%91%97/"},{"name":"生产力","slug":"生产力","link":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"学术论文","slug":"学术论文","link":"/tags/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"基本结构","slug":"基本结构","link":"/tags/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"},{"name":"心态","slug":"心态","link":"/tags/%E5%BF%83%E6%80%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"性能分析","slug":"性能分析","link":"/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"目录结构","slug":"目录结构","link":"/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"费曼","slug":"费曼","link":"/tags/%E8%B4%B9%E6%9B%BC/"},{"name":"诺贝尔奖","slug":"诺贝尔奖","link":"/tags/%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96/"},{"name":"传记","slug":"传记","link":"/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux概述","slug":"Linux概述","link":"/tags/Linux%E6%A6%82%E8%BF%B0/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"简述","slug":"简述","link":"/tags/%E7%AE%80%E8%BF%B0/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"文档和注释","slug":"文档和注释","link":"/tags/%E6%96%87%E6%A1%A3%E5%92%8C%E6%B3%A8%E9%87%8A/"},{"name":"软连接","slug":"软连接","link":"/tags/%E8%BD%AF%E8%BF%9E%E6%8E%A5/"},{"name":"硬连接","slug":"硬连接","link":"/tags/%E7%A1%AC%E8%BF%9E%E6%8E%A5/"},{"name":"文件与目录","slug":"文件与目录","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"内存分配","slug":"内存分配","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"内存分区","slug":"内存分区","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"静态多态","slug":"静态多态","link":"/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"动态多态","slug":"动态多态","link":"/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"容器类","slug":"容器类","link":"/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"},{"name":"关联容器","slug":"关联容器","link":"/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"},{"name":"顺序容器","slug":"顺序容器","link":"/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"},{"name":"C++标准库","slug":"C-标准库","link":"/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"priority_queue","slug":"priority-queue","link":"/tags/priority-queue/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"pair","slug":"pair","link":"/tags/pair/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"运算符","slug":"运算符","link":"/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"重载","slug":"重载","link":"/tags/%E9%87%8D%E8%BD%BD/"},{"name":"初始化","slug":"初始化","link":"/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"音标","slug":"音标","link":"/tags/%E9%9F%B3%E6%A0%87/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"信号量","slug":"信号量","link":"/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"互斥锁","slug":"互斥锁","link":"/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"deque","slug":"deque","link":"/tags/deque/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"B-树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"B+树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","link":"/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"设计方法","slug":"设计方法","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"应用层","slug":"应用层","link":"/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"套接字","slug":"套接字","link":"/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"}],"categories":[{"name":"博客维护","slug":"博客维护","link":"/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"},{"name":"醒世通言","slug":"醒世通言","link":"/categories/%E9%86%92%E4%B8%96%E9%80%9A%E8%A8%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"效率工具","slug":"效率工具","link":"/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"学术论文","slug":"学术论文","link":"/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件工程","slug":"软件工程","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"英语学习","slug":"英语学习","link":"/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}