{"pages":[{"title":"关于","text":"关于博主博主是目前是一名在在校的计算机研究生（master student）,为未来而学习着，成长着。专业是计算机系统结构。目标是能够怀着求知与探索的品质，能够对社会有所贡献，在信息化浪潮中搏一番自己的精彩。 在此奉上牛顿的名言： 我好像是一个海边玩耍的孩子,不时为拾到比通常更光滑的石子或更美丽的贝壳而欢欣鼓舞,而展现在我面前的是完全未探明的真理之海。 关于博客博主搭建了这个博客主要是为了记录一些思考、经验、收藏和笔记。博客的内容可能倾向于记录博主的日常所学所思，当然也会有一些技术文章 在此奉上查理芒格的名言： 如果要变得聪明，不停地问：为什么为什么为什么。 在此奉上高德纳（Donald Knuth，现代计算机鼻祖，《计算机程序设计艺术》作者）的名言： “让我们改变一下对构建程序的态度：不要把我们的主要工作想象为教计算机怎么做，相反，让我们集中精力向人们解释我们想让机器做什么。” 在此奉上梭罗（Henry David Thoreau，《瓦尔登湖》作者）的名言： 所有对真理的认识都是通过类比得来！ 在此奉上艾伦·凯（Alan Kay，面向对象编程思想的创始人之一）的名言: 换一个角度看问题值80点智商。（A change of perspective is worth 80 IQ points.） 阿玛拉法则（Amara’s Law）: 短期内我们倾向于高估技术的影响，长期内我们低估技术的影响。（”We tend to overestimate the effect of a technology in the short run and underestimate the effect in the long run”） Hock原理： 简单、明确的目的和原则，会产生复杂而聪明的行为。复杂的规章制度会产生简单而愚蠢的行为。 研究就是需要不断的对抗藏在暗处的谬误，迟钝的头脑，虚假的证据，还有你自己~ 联系博主博客搭建了评论系统，直接用github授权评论即可，博主隔一段时间会看一下。","link":"/about/index.html"},{"title":"计算机经典语录/Computer Science Quotes","text":"任何足够先进的技术都与魔法无异。― Arthur C. Clark 名字有什么关系？我们把玫瑰叫成别的名字，闻起来还是一样的芬芳。—— 莎士比亚，《罗密欧与朱丽叶》 计算机应该由玻璃构成，因为它到都是瓶颈。― Alan Cleents 在这个世界上，我们身处何地并不重要，我们朝着什么方向前行才重要。― Oliver Wendell Holmes 瞄准是不够的，你必须命中。—— 德国谚语 ······计算机的硬件发展十分迅速。人类有史以来没有其他技术能够在30年中获得6个数量级的性能——价格收益。― Fred Brooks Jr 整体的效果大于各部分的总和。― Anon 我们像建设城市一样建造计算机系统时：耗时，没有规划和继承性。― Ellen Ullman 任何人都可以制造快速的CPU。关键是如何制造快速的系统。― Seymour Cray “尽管贪婪被认为是七种致命的罪行之一，但事实证明，贪婪的算法通常表现得很好。”― Stuart Russell， 人工智能：一种现代方法 “The question of whether a computer can think is no more interesting than the question of whether a submarine can swim.”― Edsger W. Dijkstra计算机是否可以思考的问题比潜水艇是否可以游泳的问题更有趣。—— 迪杰斯特拉 “All problems in computer science can be solved by another level of indirection”（计算机科学中的所有问题都可以通过间接的另一层次来解决）― David John Wheeler [link] “Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.”― Martin Golding “Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else”（伊格尔森定律）― Alan Eagleson","link":"/cs-quotes/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post点击展开代码 >folded1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 通知消除测试模块 document.addEventListener('DOMContentLoaded', () => { (document.querySelectorAll('.notification .delete') || []).forEach(($delete) => { $notification = $delete.parentNode; $delete.addEventListener('click', () => { $notification.parentNode.removeChild($notification); }); }); }); Primar lorem ipsum dolor sit amet, consectetur adipiscing elit lorem ipsum dolor. Pellentesque risus mi, tempus quis placerat ut, porta nec nulla. Vestibulum rhoncus ac ex sit amet fringilla. Nullam gravida purus diam, et dictum felis venenatis efficitur. Sit amet, consectetur adipiscing elit More info: Deployment 相关维护资料hexo 添加和取消live2d看板动画Hexo主题(Next)美化、配置、优化这一篇就够了 - DP2PX.COMHexo 博客优化之博客美化系列（持续更新）Icarus官方示例Hexo+Markdown在你自己的博客发布文章！博客源码分享-Icarus美化活用 Bulma 美化 Icarus 文章Hexo | 初识icarus主题中的Bulma框架-宽度调整Hexo&amp;icarus主题修改-三栏变两栏Icarus 主题自定义Bulma查询hexo创建自定义about页","link":"/2020/03/28/hello-world/"},{"title":"成为一个不惑、不忧、不惧的人","text":"说明:本文是梁启超于1922年应苏州学界邀请作的一场演讲。当时，他向在座者提出了一个问题：“为什么进学校？”。而后，他给出的答案是：进学校为的是求学问，求学问为的是学做人。而要成为一个人，总要具备三德：智、仁、勇，实现的状态便是“智者不惑，仁者不忧，勇者不惧”。演讲距今虽然已经过去快一个世纪，但是观点仍然具有很强的穿透力，值得大家好好读一读。 演讲全文诸君!我在南京讲学将近三个月了，这边苏州学界里，有好几回写信邀我，可惜我在南京是天天有功课的，不能分身前来。今天到这里，能够和全城各校诸君聚在一堂，令我感激的很，但有一件，还要请诸君原谅：因为我一个月以来，都带着些病，勉强支持，今天不能作很长的讲演，恐怕有负诸君期望哩。 问诸君“为什么进学校?” 我想人人都会众口一词的答道：“为的是求学问”。再问：“你为什么要求学问?”“你想学些什么?”恐怕各人的答案就很不相同，或者竟自答不出来了。诸君啊!我替你们回答一句罢：“为的是学做人。”你在学校里头学的什么数学、几何、物理、化学、生理、心理、历史、地理、国文、英语，乃至什么哲学、文学、科学、政治、法律、经济、教育、农业、工业、商业等等，不过是做人所需的一种手段，不能说专靠这些便达到做人的目的，任凭你把这些件件学的精通，你能够成个人不成个人还是个问题。 人类心理，有知、情、意三部分。这三部分圆满发达的状态，我们先哲名为三达德——智、仁、勇。为什么叫做“达德”呢?因为这三件事是人类普通道德的标准，总要三个具备，才能成一个人。三件的完成状态怎么样呢?孔子说：“知者不惑，仁者不忧，勇者不惧。”所以教育应分为知育、情育、意育三方面，——现在讲的智育、德育、体育不对，德育范围太笼统，体育范围太狭隘——知育要教到人不惑，情育要教到人不忧，意育到教到人不惧。教育家教育学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。 1. 怎么样才能不惑呢?最要紧的是养成我们的判断力。想要养成判断力，第一步，最少须有相当的常识，进一步，对于自己要做的事须有专门智识，再进一步，还要有遇事能断的智慧。 假如一个人连常识都没有，听见打雷，说是雷公发威，看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，碰到一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。学校里小学中学所教，就是要人有了许多基本的知识，免得凡事都暗中摸索。 但仅仅有点常识还不够，我们做人，总要各有一件专门职业。这门职业，也并不是我一人破天荒去做，从前已经许多人做过，他们积累了无数经验，发现出好些原理原则，这就是专门学识。我打算做这项职业，就应该有这项专门的学识。例如我想做农吗，怎么的改良土壤，怎么的改良种子，怎么的防御水旱病虫，等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。做工、做商等等都各有他的专门学识，也是如此。我想做财政家吗，何种租税可以生出何样结果，何种公债可以生出何样结果等等，都是前人经验有得成为学识的;我们有了这种学识，应用他来处置这些事，自然会不惑，反是则惑了。教育家、军事家等等，都各有他的专门学说，也是如此。 我们在高等以上学校所求的知识，就是这一类。但专靠这种常识和学识就够吗?还不能。宇宙和人生是活的不是呆的，我们每日碰见的事理是复杂的变化的，不是单纯的刻板的，倘若我们只是学过这一件，才懂这一件，那么，碰着一件没有学过的事来到跟前，便手忙脚乱了。 所以还要养成总体的智慧，才能有根本的判断力。这种总的智慧如何才能养成呢?第一件，要把我们向来粗浮的脑筋着实磨炼他，叫他变成细密而且踏实。那么，无论遇着如何繁难的事，我都可以彻头彻尾想清楚他的条理，自然不至于惑了。 第二件，要把我们向来浑浊的脑筋，着实将养他，叫他变成清明。那么，一件事理到跟前，我才能很从容很莹澈的去判断他，自然不至于惑了。以上所说常识学识和总体的智慧，都是知育的要件，目的是教人做到“知者不惑”。 2. 怎么样才能不忧呢?为什么仁者便会不忧呢?想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么?很难用言语说明，勉强下个解释，可以说是：“普遍人格之实现。”孔子说：“仁者人也。”意思是说人格完成就叫做“仁”。 但我们要知道，人格不是单独一个人可以表现的，要从人和人的关系上来看。所以仁字从二人，郑康成解他做“相人偶”。总而言之，要彼此交感互发，成为一体，然后我的人格才能实现。所以我们若不讲人格主义，那便无话可说;讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我们的人格，和宇宙无二区别，体验得这个道理，就叫做“仁者”。然则这种仁者为什么就会不忧呢?大凡忧之所从来，不外两端，一曰忧成败，二曰忧得失。我们得着“仁”的人生观，就不会忧成败。为什么呢?因为我们知道宇宙和人生是永远不会圆满的，所以《易经》六十四卦，始“乾”而终“未济”。正为在这永远不会圆满的宇宙中，才永远容得我们创造进化。 我们所做的事，不过在宇宙进化几万万里的长途中，往前挪一寸，两寸，那里配说成功呢?然则不做怎么样呢?不做便连这一寸都不往前挪，那可真是失败了。 “仁者”看透这种道理，信得过只有不做事才算失败，肯做事便不会失败。所以《易经》说：“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的几万万里路挪了一两寸，算成功吗?所以《论语》：“知其不可而为之。”你想，有这种人生观的人，还有什么成败可忧呢? 再者，我们得着“仁”的人生观，便不会忧得失。为什么呢?因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则哪里有东西可以为我们所得?既已没有东西为我所得，当然也没有东西为我所失。 我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等做手段来达某种目的——可以为我们“所得”得。所以老子说：“生而不有，为而不恃。”“既以为人已愈有，既以与人已愈多。”你想，有这种人生观的人，还有什么得失可忧呢?总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无人而不自得”。他的生活，纯然是趣味化艺术化。这是最高的情感教育，目的教人做到“仁者不忧”。 3. 怎么样才能不惧呢?有了不惑不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便会有丰富的智识，临时也会用不着，便有优美的情操，临时也会变了卦。然则意志怎么会才坚强呢?头一件须要心地光明，孟子说：“浩然之气，至大至刚。行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不惴焉;自反而缩，虽千万人，吾往矣。” 俗话说得好：“生平不作亏心事，夜半敲门心不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一着。第二件要不为劣等欲望之所牵制。 《论语》记：子曰：“吾未见刚者。”或对曰伸枨。子曰：“枨也欲，焉刚。”一被物质上无聊得嗜欲东拉西扯，那么百炼成刚也会变成绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。 自己作不起自己的主，还有什么事可做?受别人压制，做别人奴隶，自己只要肯奋斗，终必能恢复自由。自己的意志做了自己情欲的奴隶，那么，真是万劫沉沦，永无恢复自由的余地，终身畏首畏尾，成了个可怜人了。 孔子说：“和而不流，强哉矫;中立而不倚，强哉矫。国有道，不变塞焉，强哉矫;国无道，至死不变，强哉矫。”我老实告诉诸君说罢，做人不做到如此，决不会成一个人。但做到如此真是不容易，非时时刻刻做磨炼意志的功夫不可，意志磨炼得到家，自然是看着自己应做得事，一点不迟疑，扛起来便做，“虽千万人吾往矣。”这样才算顶天立地做一世人，绝不会有藏头躲尾左支右绌的丑态。这便是意育的目的，要教人做到“勇者不惧”。 我们拿这三件事作做人的标准，请诸君想想，我自己现时做到哪一件——哪一件稍微有一点把握。倘若连一件都不能做到，连一点把握都没有，嗳哟!那可真危险了，你将来做人恐怕做不成。讲到学校里的教育吗，第二层的情育，第三层的意育，可以说完全没有，剩下的只有第一层的知育。就算知育罢，又只有所谓常识和学识，至于我所讲的总体智慧靠来养成根本判断力的，却是一点儿也没有。 这种“贩卖知识杂货店”的育，把他前途想下去，真令人不寒而栗!现在这种教育，一时又改革不来，我们可爱的青年，除了他更没有可以受教育的地方。诸君啊!你到底还要做人不要?你要知道危险呀，非你自己抖擞精神方法自救，没有人救你呀! 诸君啊!你千万别要以为得些断片的智识，就算是有学问呀。我老实不客气告诉你罢;你如果做成一个人，知识自然是越多越好：你如果做不成一个人，知识却是越多越坏。你不信吗?试想想全国人所唾骂的卖国贼某人某人，是有智识的呀，还是没有智识的呢?试想想全国人所痛恨的官僚政客——专门助军阀作恶鱼肉良民的人，是有智识的呀，还是没有智识的呢?诸君须知道啊，这些人当十几年前在学校的时代，意气横历，天真烂漫，何尝不和诸君一样?为什么就会堕落到这样的田地呀? 屈原说：“何昔日之芳草兮，今直为此萧艾也!岂其有他故兮，莫好修之害也。”天下最伤心的事，莫过于看着一群好好的青年，一步一步的往坏路上走。诸君猛醒啊!现在你所厌所恨的人，就是你前车之鉴了。 诸君啊!你现在怀疑吗?沉闷吗?悲哀痛苦吗?觉得外边的压迫你不能抵抗吗?我告诉你：你怀疑和沉闷，便是你因不知才会惑;你悲哀痛苦，便是你因不仁才会忧;你觉得你不能抵抗外界的压迫，便是你因不勇才有惧。这都是你的知、情、意未经过修养磨炼，所以还未成个人。我盼望你有痛切的自觉啊!有了自觉，自然会成功。那么，学校之外，当然有许多学问，读一卷经，翻一不史，到处都可以发现诸君的良师呀! 诸君啊，醒醒罢!养足你的根本智慧，体验出你的人格人生观，保护好你的自由意志。你成人不成人，就看这几年哩!","link":"/2020/03/29/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%83%91%E3%80%81%E4%B8%8D%E5%BF%A7%E3%80%81%E4%B8%8D%E6%83%A7%E7%9A%84%E4%BA%BA/"},{"title":"《苏菲的世界》读书笔记","text":"伊甸园 在某个时刻事物必然从无到有你是谁？世界从何处来？ 要么一直存在 要么从无到有 比如空间是由某样东西变成的，那么那样东西必然也是由另外一样东西变成的。一直推下去，那么必然是在某一时刻，事物从无到有。 生死这两件事就像钱币的两面，被我们的思考翻来翻去的时候，当一面变得更清晰的时候，另外一面也随之变得更大而清晰。 魔术师的礼帽 要成为一个优秀的哲学家只有一个条件：要有好奇心哲学是什么？天底下有没有一种东西是所有人都感兴趣的呢？有的！当人的基本需求（比如衣食住行，亲情爱情，爱与关怀等）满足之后，还有一些东西是人人都需要的，那就是明白我们是谁，我们为何在这里。宇宙，地球与生命是如何产生的？ 探讨哲学的最好方式就是问一些哲学性的问题，如：这世界是如何创造出来的？其背后是否有某种一直或者意义？人死后还有生命吗？我们如何能够解答这些问题呢？最重要的是，我们应该如何生活？我们无法从百科全书上得到这些答案，不过读一读别人的意见倒可以帮助我们建立自己对于生命的看法。 哲学家追求真理的过程很想一步侦探小说，对于案件，警方有时候可以侦破，但也有可能永远无法查出真相（虽然在某个地方一定有一个破案的办法）。因此，即使要回答一个问题很不容易，但无论如何总会有一个（且仅此一个）正确答案的。比如人死后要么就是透过某种形式存在，要不就是根本不在存在。 作者很好的比喻：许多人对于这个世界的种种也同样有种不可置信的感觉，就像我们看到魔术师突然从一顶原本空空如也的帽子里拉出一只小兔子一般。实际上我们就生活在这个世界上，是这个世界的一部分。形象的比喻一下，我们就是那只从礼帽里面变出的小兔子的一部分，小兔子可以比作是是整个宇宙，而我们则是寄居在小兔子身上的小小生物，但是我们和兔子不同的是，小兔子可不知道自己参与了一场魔术表演，而我们知道自己是某种神秘事物的一部分，我们想了解其中的奥秘；哲学家们总是试图沿着兔子的细毛往上爬，以便将魔术师的看个清楚； 神话 善与恶之间脆弱的平衡神话的世界观 北欧 （挪威）索尔和铁锤 北欧人相信人类居住的这部分是一部分岛屿，名为米德加德(Midgard)，也就是”中央王国“的意思，在这个中央王国内，有一个地方名叫阿斯加德（Asgard），乃是诸神的领地。中央王国之外，有一个叫乌特加德（Utgard），是狡猾的巨人居住的地方。 象征肥沃多产的额女神芙瑞雅 侍童洛奇 《史莱慕之诗》 巨人之王史莱慕希腊 公元前700左右，有一大部分希腊神话被荷马与赫西俄德（赫西俄德Hesiod以长诗《工作与时日》《神谱》闻名于后世，被称为“希腊训谕诗之父”。）记录下来。 赞诺芬尼司(Xnphans),古希腊哲学家。是早期批评荷马的神话的哲学家之一。 赞诺芬尼斯_百度百科 他指出人类按照自己的形象创造出这些天神。 随后这段期间，希腊人在希腊本土与意大利南部，小亚细亚等希腊殖民地建立了许多城市。在这些城市中，所有劳力工作由奴隶担任，因此市民有充分的闲暇，可以将所有的时间投注在政治与文化上；这时候的人们思考方式与以前大不相同，无需借助神话而提出一些哲学性的问题；我们称这样的现象为“从神话的思考模式发展到以经验与理性为基础的思考模式” 自然派哲学家 没有一件事物可以来自空无万事万物是否有一种基本的物质组成？哲学家的课题：每个人关注和质疑的事项是什么？了解了每一位哲学家的课题之后，我们就比较容易了解他的思想脉络，因为没有任何一位哲学家会企图探讨哲学的所有领域。 自然派哲学家关注的课题是“大自然与它的循环和变化”最重要的是，他们想要透过对大自然本身的研究来了解实际的变化过程，而不是借助神话来解释。这样，哲学逐渐脱离了宗教的范畴。自然派哲学家朝科学推理的方向迈出了第一步，成为后来科学的先驱。 米雷特斯的三位哲学家泰利斯安娜克西曼德安那西梅尼斯 没有任何事物会来自于虚无帕梅尼德斯（约公元前540年~公元前480年）他认为： 没有任何事物会改变。 因此我们的感官认知是不可靠的 理性主义：坚决相信人的理智的态度理性主义者：百分百相信人类的理智是时间所有知识源泉的人 所有的事物都是流动的赫拉克里德斯（约公元前540年~公元前480年）他认为： 万物都会改变（”一切事物都是流动的“） 我们的感官认知是可靠的 恩培窦克里斯（西西里）恩培窦克里斯认为帕梅尼德斯与赫拉克里德斯各有一点是对的，也各有一点是错的，造成这个根本性差异的原因是之前的两人都认定世间只有一种元素存在。恩培窦克里斯认为： 没有任何事物会改变。 我们的感官认知是可靠的 恩培窦克里斯的结论是：大自然不可能只有一种元素构成。 安纳萨格拉斯（约公元前500年~公元前428年） 德谟克里特斯 世界上最巧妙的玩具 积木为何是世界上最巧妙的玩具？ 原子理论德谟克里特斯（约公元前460年~公元前370年，来自爱琴海北部海岸的阿布拉德小镇） 唯物论者：只相信物质的东西。 命运 算命者试图预测某些事实上极不可测的事物古希腊的德尔菲（Delphi）神论与宿命论 现在看来都是迷信 历史与医学历史上最早的一批历史学家开始为历史事件寻求合理的解释。贺若多陀斯（约公元前484年~公元前424年）与修西德底斯（约公元前460年~公元前400年） 在希腊哲学、历史学发展的同时，希腊医学兴起，其目的是为了疾病与健康寻求合乎自然的解释。希波克拉底（约公元前460~公元前377年，生于寇斯岛，希腊医学始祖）比较出名的是希波克拉底誓言： 我将依照自身的能力与判断，采用对病人有利的疗法与处方，绝不施以有害或有毒之物。无论应何人之请，我也绝不给与致命药物或做此类之建议，也绝不协助妇女堕胎。进入病家访视时，我将以病人的福祉为念，不做任何贪渎害人之事，不受男女奴仆之引诱。我在执业时之所见所闻，反不应泄露者，我将严予保密。若我遵行此一誓言，不懈不怠，愿上苍使我乐享生命、精进医事并受世人敬重。若我违反誓言，愿我遭相反之命运。 苏格拉底 最聪明的是明白自己无知的人 是否有人天生就很害羞呢？最聪明的是明白自己无知的人。真正的智慧来自内心。明白是非者必能够进退合宜。 雅典的哲学以人为中心苏格拉底是谁？谈话的艺术 “苏格拉底式的反讽”神圣的声音雅典的小丑正确的见解导致正确的行动 雅典 废墟中升起了几栋高楼柏拉图 回归灵魂世界的渴望柏拉图学院永远的真善美理型的世界真正的知识不朽的灵魂走出黑暗的洞穴（洞穴神话）哲学之国（理想国） 少校的小木屋 镜中的女孩双眼眨了一眨亚力士多德 一位希望澄清我们观念的严谨的逻辑学家逻辑亚里士多德创立了逻辑学这门学科，他以实例显示我们在得出合乎逻辑的结论或证明时，必须遵循若干法则。 希腊文化 一丝火花生命与容忍的哲学宗教，哲学与科学 犬儒学派 斯多葛学派 伊比鸠鲁学派 新柏拉图派哲学神秘主义 明信片 我对自己实施严格的检查制度两种文化 避免在真空中飘浮的唯一方式印欧文化 闪族文化 中世纪 对了一部分并不等于错文艺复兴 啊！藏在凡俗身躯里的神明子孙哪实证法：以亲身的经验，而不是以古人的著作或凭空想象来作为知识的基础。 巴洛克时期 宛如梦中的事物笛卡尔 他希望清除工地上所有的瓦砾斯宾诺莎 上帝不是一个傀儡戏师傅洛克 赤裸、空虚一如教师来到教室前的黑板休姆 将它付之一炬如果我们手里有一本书，我们应该问：书里是否有包含任何与数量和数目有关的抽象思考？如果答案是没有，那么我们应该再问：书里是否包含任何与事实有关的经验性思考？如果答案是没有，那么我们还是将它付之一炬吧，因为这样的书纯粹是诡辩和幻想。 印象观念 不可知论者：不持肯定或否定的态度，持怀疑态度。 柏克莱 宛如燃烧的恒星旁一颗晕眩的行星柏客来 曾祖母向一名吉普赛妇人买的一面古老魔镜启蒙 从制针的技术到铸造大炮的方法康德 头上闪烁的星空与心中的道德规范浪漫主义 神秘之路通向内心黑格尔 可以站得住脚的就是有道理的祁克果 欧洲正迈向破产的地步主观的真理可以测算的真理我信因为荒谬个体主义者 马克思 在欧洲游荡的幽灵达尔文 满载基因航行过生命的一艘小船弗洛伊德 他内心出现那股令人讨厌的自大的冲动弗洛伊德发展了所谓的深度心理学或精神分析弗洛依德主张人和他的环境之间不断有一种紧张关系存在。这种紧张关系（也就是冲突）尤其存在于他的驱策力，需要和社会之间。基本需求可能会被伪装和升华；快乐原则/本我现实原则/自我这世界的道德规范已经成为我们内心的一部分/成为超我潜意识:我们并不一定能够意识到我们曾经有过的各种经验。但那些只要我们“用心想便可以记起来的想法或经验”通常是指被压抑的想法或经验。不错的比喻：演讲厅说话演讲厅称为”意识“，演讲厅之外称为“潜意识”；大声喧哗者被”压抑“，椅子堵住门口作为”防御“ 我们的感觉和行为会受到“潜意识的鼓动”这类机制有好几种：比如“说溜了嘴”“合理化”我们自己也不愿意承认，也不愿意告诉别人我们做一件事的真正动机，因为这个动机是让人无法接受的。–&gt;”两面式沟通“的经验“投射”把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较。如何对抗不愉快的经历呢？弗洛伊德发展出一个”自由联想“的技巧。梦的解析显梦 mainfest dream 潜梦意念把潜梦意念转换成显梦面向的工作，他称之为“梦的运作”超现实主义 灵感：潜意识的盖子被打开了，好像我们突然所想的东西是来自某种外部的源泉似的。创作的过程是想象与理性细密交织的时刻 想象力也许可以创造新的事物，但是却不能加以挑选，这时候理智就发挥作用了！ 我们这个时代 人是注定要受自由之苦的花园宴会 一只白色的乌鸦对位法 两首或多首旋律齐响那轰然一响 我们也是星尘","link":"/2020/03/29/%E3%80%8A%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"好用的chrome插件","text":"深刻体会到工具的好用，有一些问题使用工具真的省力，关键是学会如何找到这些工具和如何描述自己的相关需求。 Awesome Autocomplete for GitHub增强github的搜索功能 Git History Browser Extension查看github的历史更新记录，超级好用，可以对比不同人对代码做的更新； octotree可以查看github的目录结构，并且下载单个的文件； Sourcegraph可以查看相关的代码，搜索代码，查找代码定义的地方 The Great Suspender休眠chrome不必要的标签页 Tab Resize - split screen layouts浏览器分屏 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6/"},{"title":"学术论文的基本结构","text":"基本结构 标题 真实反应论文内容 简短明了 吸引人 大背景 小背景 技术特色 摘要 概括你的研究 假设或要研究的问题 研究方法 主要成果 引言 说明选题的背景，目的，意义 陈述研究的主要内容和论文的假说或研究问题 文章的研究方法与章节编排 文献综述 阐述前人的研究，展示文献批判能力，说明你对研究问题的掌握程度，表明你研究的创新之处。 研究方法 详细介绍相关信息，便于读者采取同样的方法能够重复此项研究。 研究性质 对象 步骤 工具 条件 … 研究结果 用文字和/或图表真实报告你获得的数据或结果。 讨论 基于你获得的数据论述对于研究问题可能得到的结论。 结论 简明总结所得到的数据，得出的结论及意义。 说明研究的价值，不足或局限性。 致谢 参考文献 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/03/29/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"title":"《练习的心态》读书笔记","text":"引言 人生就是漫长的练习第1章 学习开始当你弄懂了练习的正确原理，学习某些新事物的任务将变成一种没有压力的愉快与平和的体验，变成一个适合你生活中各种领域的过程，并且促成你对生活中所有的艰辛与痛苦采用合适的视角来观察。 压力与焦虑主要来源于我们自己对目标的依恋。练习的心态这也是一种技能：尽可能迅速，最少的付出来发展任何一项技能的能力，以及在这个过程体验内心平和与愉悦的能力。 在不感到失败和焦虑的情况下去努力实现目标。学习的渴望仅仅是第一步，需要正确理解技术性细节与努力，否则会耗尽的 当今的文化是多任务的，比如开车时第一件事会习惯性打开收音机。 而滑冰正相反，滑冰时候不会注意边上嘈杂的声音！由于习惯于一心多用，我们大脑躁动不安，且具有极大惯性，没法安静下来。 练习的心态是安静的意识是第一位的：没法控制自己的思维，不管设立什么样的目标，都没有用。我们对自己要去的方向就像乘坐马车，必须要拉紧思维的缰绳才行啊！填补空虚是一个循环往复的过程 学会走路的过程并不会在心里让你压力倍增。我们要意识并掌控这个过程，学会从中享受！ 第2章 以过程为导向，不以结果为导向 人生的悖论：耐心与自律的问题是，要培养它们中的任何一个，需要同时具备它们两个。 简单法则 以过程为导向 重点关注当前 将过程确定为目标，并且运用总目标作为船舵，以指引自己的努力。 对自己想要做的事情刻意训练，带着意图训练，并且自始至终清醒的知道那种意图 第3章 关键是视角当我们试图理解自己以及我们对人生中各种努力的痛苦挣扎时，可以通过观察一朵鲜花来找到平和。问你自己：一朵鲜花的生命，从撒下种子到完全盛开，在什么时候可以达到完美？ 然后呢？ 达成目标之后，然后呢？然后又能干什么呢？？？？初学者心态鲜花的生命，自始至终都是完美的 他了解到，假如将自己的思绪集中在当前，并只专注了他在这一刻正在做的事情的过程，那便可以喜欢上他正在做的任何事情。 第4章 培养期望的习惯习惯是学来的。明智地选择它们。自己创造想要的习惯，不带情绪和判断的采取哪些行为，之后坚持下去。 就像一名优秀的老师，对待学生的错误不会情绪化，那种情绪化来源于自我期望，与结果和产物关联，如果你体验到这些情绪，就证明你没有专注于当前过程！！！ 怎么样阻止旧的习惯，采用一种例行行为来阻止，比如击球前例动作 第5章 感知变化，创造耐心！你需要的所有耐心，都已经处在你的内心了。知道什么时候内心疯狂奔走接受什么事情不会尽善尽美 放弃某种幸福和乐趣就在某个地方的徒劳想法 在探索的道路上，除了去追求，没有别的可以达到的目标了//我们20岁的目标肯定与18岁的不同，参照对象也是不一样的，不要指望能达到你的目标。探索本身就是一种目标。 对于没有费力得到的东西，那种兴奋感在得到东西早已烟消云散。 得到目标和实现目标是两种完全不同的概念真正的愉悦 第6章 4“S”方法力求简化，将征服大多数复杂的任务。 简化 细分 缩短 放慢 第7章 平静与DOC方法客观是通往宁静心灵之路！ 主观判断需要一个评估和对比的过程，这要求有一个相对的点，即理想状况判断有一个不利的地方，它不会以一种超然的方式运行，常常会包含着某些情绪，有趣的是，对事情我们感觉到的重要性越多，我们带的情绪越多将自我与观察者合并 。就像我们安慰他人时候带着的超然智慧一样。 怎么合并呢 冥想！ do observe correct就像射箭运动员一样，安静，不复杂完全没有心理的杂乱 第8章 教孩子，也从孩子身上学习智慧并不是年龄的副产物。从你身边所有的人身上学习，同时也用自己的行为影响身边的人。 第9章 你的技能在成长有了刻意的和反复的努力，进步便水到渠成。 如果说各种软件上的信息不能使你知识变得丰富，那么你就不需要它们 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/08/%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"linux 性能分析，测试与调优工具","text":"静态性能分析工具(static performance analysis tools) dmesg 用于显示开机信息，开机信息也保存在/var/log目录中，名为dmesg的文件里。 blockdev 工具允许从命令行调用区块设备控制程序。调用设备的ioctl函数。似乎Linux中对设备的直接操作只有ioctl函数。 ldd （List Dynamic Dependencies，意译为列出动态库依赖关系）是一款在类Unix系统的实用工具，负责在命令行内输出程序或共享库所依赖的函数库。 lsblk (list block)即用于列出所有可用块设备的信息,而且还能显示他们之间的依赖关系,但是它不会列出RAM盘的信息 lsscsi 可以看到Raid卡信息和所有虚拟磁盘以及光驱的信息，如果没有硬件SCSI控制器，那就不会返回信息。 lspci 显示有关pci总线的信息以及连接到它们的设备。 lscpu (list cpu)显示CPU的详细信息，比如CPU的制造商、架构、CPU数量、型号、主频、缓存及支持的虚拟化技术等信息。 lstopo (list topology of the system)显示可视化的方式组成 CPU、缓存、内存和I/O设备的拓扑结构。这个命令用来识别处理器结构和系统的NUMA拓扑结构。 likwid (Like I Knew What I’m Doing) 是一个用来测量、配置并显示硬件相关特性的命令行收集工具。其中的likwid拓扑结构能显示CPU硬件(线程/缓存/NUMA)的拓扑结构信息，还能识别处理器家族(比如：Intel Core 2, AMD Shanghai)。 smartctl 查看硬盘的SMART信息。 fdisk 创建和维护分区表的程序(兼容DOS类型的分区表、BSD或SUN的磁盘列表） schedtool (scheduling tool)查询或设置CPU状态的工具。通过不同的参数可以查看或设置不同的属性。 numactl (Control NUMA policy)用于控制 进程与共享存储的 NUMA 技术机制。 cpuid 获取CPU的信息。该命令的底层是CPUID指令。它获取的内容比/proc/cpuinfo要详细很多。 MegaCli 管理维护硬件RAID的软件 App Config 观测工具(Observability Tools) iostat (input/output statistics)报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息。 vmstat (VirtualMeomoryStatistics,虚拟内存统计) 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。 dstat 用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具,是一个全能系统信息统计工具。 pidstat 是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。 mpstat (multiprocessor statistics)查看多核心的cpu中每个计算核心的统计数据。类似工具vmstat只能查看系统的整体cpu情况 netstat ( network statistics)显示当前的网络状态，包括传输控制协议层的连线状况、路由表、网络接口状态和网络协议的统计信息等。 iotop 用来监视磁盘I/O使用状况的top类工具 top (display Linux processes)实时显示系统中各个进程的资源占用状况,类似于Windows的任务管理器。 htop top命令的升级版。交互式的进程浏览器，可以用来替换Linux下的top命令 gtop JavaScript 编写的开源系统资源监控实用程序,它是 Linux 系统自带 top 工具的替代品 tiptop 通过读取CPU硬件计数器的信息（比如cahche miss，executed instructions per cycle等等）了解程序执行效率 strace 可跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。 uptime 可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息 lsof (list open files)列出当前系统打开的文件，注意linux中设备也是文件 perf 性能分析工具，能够进行函数级与指令级的热点查找。 Flame Graphs 性能分析的利器,通过它可以快速定位性能瓶颈点。 测试工具(Benchmarking Tools) fio 开源的I/O压力测试工具，主要是用来测试磁盘/SSD的IO性能，也可测试cpu，nic的IO性能。 hdparm (hard disk parameters)用于显示与设定硬盘的参数 dd 用于读取、转换并输出数据。可从标准输入或文件中读取数据,根据指定的格式来转换数据,再输出到文件、设备或标准输出。 perf_events 网上很多叫法如perf_events , perf profiler , Performance Counters for Linux。叫法不同，都指perf perf-tools 基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集，能够收集ftrace和perf_events中乱七八糟的参数。 ktap Linux的基于脚本的动态跟踪工具 允许用户跟踪Linux内核动态。 sysbench 一个开源的、模块化的、跨平台的多线程性能测试工具,可以用来进行CPU、内存、磁盘I/O、线程、数据库的性能测试。 ab (apachebench) ab命令会创建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。 wrk 针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。 jmeter Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试。 openssl 加解密能力也是CPU性能测试的一部分。 UnixBench 类unix系(Unix,BSD,Linux)统下的性能测试工具 lmbench 多平台软件，因此能够对同级别的系统进行比较测试，反映不同系统的优劣势，可用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能. perfbench perf下的工具 测试系统性能 hping3 面向命令行的用于生成和解析TCP/IP协议数据包汇编/分析的开源工具。 iperf 网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 ping 向特定的目的主机发送 ICMP（Iternet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。 ttcp 传统的测试TCP性能的工具,它主要测试两个机器之间TCP的吞吐量(在应用层模拟消息传递的过程) traceroute 利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。 mtr 网络连通性判断工具，它结合了ping, traceroute,nslookup 的相关特性 pchar 沿Internet路径执行网络测量 调优工具(Tuning Tools) sysctl (System Administration)用来配置与显示在/proc/sys目录中的内核参数 swapon 用于激活Linux中的交换空间，Linux的内存管理必须使用交换区来建立虚拟内存。 env gnu的coreutils包内的一个软件，用来显示系统中已存在的环境变量,以及在定义的环境中执行指令。 tune2fs 允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。 ionice 获取或设置程序的IO调度与优先级。PRI(new)=PRI(default)+nice nice 调整程序运行的优先级，当前程序运行优先级基础之上调整指定值得到新的程序运行优先级。 renice 重新指定一个或多个进程的优先级 taskset 将某个进程与某个CPU核心绑定。 ulimit 为shell内建指令，可用来控制shell执行程序的资源 chcpu 修改cpu的状态,启用和关闭cpu，扫描新的CPU,改变底层虚拟机监控程序的CPU调度模式,并请求CPU的系统管理程序(配置)或返回CPU hypervisor numactl 用于控制进程与共享存储的 NUMA 技术机制。 sysctl 用于运行时配置内核参数,这些参数位于/proc/sys目录下。 ethtool 用于查询及设置网卡参数 stap (SystemTap) 内核开发者必须要掌握的一个工具,用于内核监控和跟踪，以及诊断性能或功能问题。 kpatch 给Linux内核动态打补丁但是不必重启系统 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"},{"title":"Linux系统目录结构","text":"/bin (binary)目录存放着最经常使用的命令 /boot这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 包括Linux内核文件，以及开机菜单与开机所需的配置文件 linux kernel常用的文件名为vmlinux /dev (device)该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc (Editable Text Configuration)可配置文件存放所有的系统管理所需要的配置文件和子目录。 /etc/init.d所有服务的默认启动脚本都是放置在这个目录内 /etc/xinetd.d所谓的super daemon管理的各项服务的配置文件目录 /etc/X11与X Windows有关的各种配置文件都在这里 /etc/securetty只有/etc/securetty中登记的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录 这个终端指tty1之类的 /etc/passwd保存的就是系统中所有的用户和用户的主要信息 /etc/shadow/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息. /etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。 /home (home directory)用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 系统默认的用户主文件夹 比较重要的是 主文件夹有两者代号 ~ 代表目前这个用户的主文件夹 ~dmtsai 代表dmtsai的主文件夹 /lib这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 放置的是开机会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库而已 尤其重要的是/lib/modules/这个目录 放置内核相关的模块（驱动程序） /lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 这个目录是使用标准的ext2/ext3文件系统格式才会产生的目录 /medialinux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 包括软盘，光盘，DVD等设备都暂时挂载于此 /mnt系统提供该目录是为了让用户临时挂载别的文件系统的，或者说是额外的设备 比较早的时候，这个目录的用途与/media相同。只是有了/media之后这个目录就暂时用来挂载用了 /opt 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 给第三方软件放置的目录 /proc (process)这个目录本身是一个虚拟的文件系统，放置的数据都是在内存中:例如，系统内核，进程，外部设备的状态及网络状态等 目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息 这个目录的内容不在硬盘上而是在内存里，本身不占用任何硬盘空间，我们也可以直接修改里面的某些文件 /root该目录为系统管理员，也称作超级权限者的用户主目录。 /run是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /sbins就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 这个目录的内容数据也是在内存中的信息，同样不会占用任何的硬盘容量 Secure Enhance Linux的执行目录 /srv (service) 该目录存放一些服务启动之后需要提取的数据。 一些网络服务启动之后，这些服务所取用的数据目录 存放服务启动后需要提取的数据（不用服务器就是空） /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 这个目录与/proc目录类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。包括目前已经加载的内核模块与内核检测到的硬件设备信息等。 这个目录同样不占用硬盘容量。 /tmp这个目录是用来存放一些临时文件的。 /usr (UNIX Software Resource,而不是user)是UNIX 操作系统软件资源所放置的目录，而不是用户的数据.这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。注意事项：FHS建议所有软件开发者将他们的数据合理地放置到这个目录下的子目录，而不要自行新建软件自己独立的目录有点像windows系统中C:\\Windows\\和C:\\Program files\\这两个目录的综合体 /usr/bin系统用户使用的应用程序。 /usr/sbin超级用户使用的比较高级的管理程序和系统守护程序 /usr/src内核源代码默认的放置目录。 /var这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 附注上面这些目录比较完备了 我主要是根据菜鸟教程，鸟哥的私房菜进行整理的 关于/run这个目录稍微特殊一点点，有的系统是二级目录，如果你的系统上有 /var/run 目录，应该让它指向 run。 可以用ls -l / 命令查看目录树 关于挂载开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续进行挂载的行为 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/Linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"哈希表（散列表）详解","text":"基本概念散列方法（hashing）：一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法。以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立起映射关系。散列表（hashtable）：逻辑上由一些列可存放词条（或者其引用）的单元（称作桶（bucket）或桶单元）组成。各桶单元按照其逻辑次序在物理上连续排列。通常直接使用数组进行排列，这时散列表也称作桶数组（bucket array）地址空间（address space）：如果桶数组的容量为R，则其中合法秩的区间[0,r)也称作为地址空间。 散列函数（hash function）：用来描述散列方法，是从关键码空间到桶数组地址空间的函数。比如下面的hash()： 1hash() : key -&gt; hash(key) key的散列地址（hashing address）：也就是上面的hash(key) 。 完美散列（perfect hashing）：在时间和空间性能方面均达到最优的散列，也就是没有空余，没有重复的散列。 装填因子（load factor）：散列表中非空桶的数目与桶单元总数的比值。是散列表的空间利用率度量方法。 散列冲突（collision）：关键码不同的词条映射到同一个散列地址的情况。 词条的聚集（clustering）：词条集中到散列表内少数若干桶中（或附近）的现象。 综上散列表的基本构思概括为： 开辟物理地址连续的桶数组hba[],借助散列函数hash(),将词条关键码key映射为桶地址hash(key),从而快速确定待操作的词条的位置。 散列函数好的散列函数应该具备的条件： 确定性 ：也就是说词条E的映射地址hash(E.key)必须完全取决于E.key。 简单性 ：映射过程不能过于复杂 所有关键码经过映射后应该尽量覆盖整个地址空间。也就是说hash()最好是满射。 均匀性 ：最重要的原则，关键码映射到各个桶的概率是同等的，应该尽量为1/R ，R为散列表长度或容量。 直接定址法直接定址法：关键码就可以直接用作为散列地址 1hash(key)=key 除余法（devision method）除余法：选择一个适当的正整数R,用R去除关键码去除关键码,余数作为 散列地址.这个方法的关键是选取适当的R。一般R为素数，采用素数表长是是降低聚集发生概率的捷径。 1hash(key)=key mod R //R为散列表长度或容量。一般R为素数。 缺点：残留有某种连续性，比如相邻关键码所对应的散列的地址，总是彼此相邻。 MAD法（multiply-add-divide method）乘加除法乘加除法：需要依次执行乘法，加法，和除法运算得名。解决的问题：用来克服除余法的连续性缺陷。 12hash(key)=(a * key + b)mod R //a&gt;0，b&gt;0，且(a mod R) !=0//R为散列表长度或容量。一般R为素数。 数字分析法（selecting digits）数字分析法：从关键码key中特定进制的展开中抽出特定的若干位，构成一个整型地址。对关键码的各位进行分析（多种方法），丢下分布不均匀的位，留下均匀的位作为地址。数字分析法举例： 平方取中法（mid-square） 折叠法（folding） 一般折叠 往复折返式折叠 异或法（xor） 一般异或 往复折返式异或 伪随机数法越是随机，越是没有规律的就是好的散列函数。 1hash(key)=rand(key) mod R //R为散列表长度或容量。 冲突及其排解开散列策略/封闭定址开散列（open hashing）或封闭定址（closed addressing）： 开放基本的散列表结构，引入次级关联结构。 散列表中的地址只对特定的词条开放（每个桶可以只能能存放特定的一组词条）。 多槽位法（multiple slots）多槽位法：将每个桶细分为更小的称作槽位（slot）的若干单元，每一组槽位可以组织为向量或列表。//类似于二维数组 独立链法（separate chaining)（拉链法）拉链法：某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。//引入链表先计算哈希地址，然后搜索该地址的单链表。 公共溢出区法（overflow）在原有散列表hashA之外再设置一个公共溢出区（散列表hashB），如果抽入词条发生冲突，就将该词条转存至公共溢出区（散列表hashB）中。 //引入新的散列表可以说是一种递归形式的散列表。 闭散列策略/开放定址闭散列（open hashing）或开放定址（closed addressing）： 仅仅依靠基本的散列表结构，就地排解冲突。 散列表中的地址对所有的词条开放（每个桶可以都有可能存放任一词条）。 一个桶冲突了，只允许在散列表内部为其寻找另一空桶。 线性试探法（linear probing）线性试探法：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。被尝试的桶依次为： 1[(hash(key) + i)mod R ] ,i=1,2,3,... 平法试探法（二次探测法）被尝试的桶依次为： 1[(hash(key) + i^2)mod R ] ,i=1,2,3,... 伪随机试探法被尝试的桶依次为： 1[rand(i)mod R ] ,rand(i)为系统定义的第i个随机数。 再散列法（rehashing）再散列法：使用哈希函数去散列一个输入的时候，如果输出是同一个散列地址就再次散列，直至不发生冲突为止。缺点：每次冲突都要重新散列，计算时间增加。被尝试的桶依次为： 12//hash2为二级散列函数[(hash(key) + i*hash2(key) ] ,i=1,2,3,... 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/04/14/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"},{"title":"《别闹了费曼先生》读书笔记","text":"当科学大师碰上菜鸟 报告时间终于到了。我面前坐了这些科学大师，全在等我开口讲话！我生平第一次学术报告，却碰上这样的听众！我的意思是说，他们会问很多难题，我将会大大地出丑了！我还清楚记得，从牛皮纸袋抽出讲稿时，双手不住地发抖。但奇迹出现了——事实上我很幸运，类似的奇迹在我一生中一再发生——只要我开始思考物理、必须全神贯注于要说明的问题上，我的脑袋中就再没有其他杂念，完全不会紧张。因此当我开始报告以后，我根本不知道听众是谁了；我只不过在说明这些物理概念。事情就那么简单！ 向数学家挑战 我向他们挑战：“我跟你们打赌，随便你提出一个定理——只要你用我听得懂的方式告诉我，它假设些什么、定理是什么等等——我立刻可以告诉你，它是对的还是错的！” 其实，我也并不是随便乱猜的。我有一套方法，甚至到了今天，当别人对我说明一些什么，而我努力要弄明白时，我还在用这些方法：不断地举实例。譬如说，那些念数学的提出一个听起来很了不得的定理，大家都非常兴奋。当他们告诉我这个定理的各项条件时，我便一边构思符合这些条件的情况。当他们说到数学上的“集”时，我便想到一个球，两个不相容的集便是两个球。然后视情况而定，球可能具有不同的颜色、长出头发或发生其他千奇百怪的状况。最后，当他们提出那宝贝定理时，我只要想到那跟我长满头发的绿球不吻合时，便宣布：“不对！” 看怎样用些有趣、近代的数学观念来教数学。原先的目的，是要使那些觉得数学枯燥无味的学生提高兴趣。 费曼教授 20 世纪40 年代，我待在普林斯顿的期间，亲眼看到高等研究院内那些卓越心灵的下场。他们都具备了聪明绝顶的头脑，因此特别被选中，来到坐落在森林旁边的漂亮房子里，整天悠哉游哉地闲坐——不用教书，没有任何约束或负担。但等过了一段日子，他们想不出什么新东西来，每个人心里一定开始感到内疚或沮丧，更加担心提不出新想法。可是一切还是如旧，仍然没有灵感。会发生这种情况，完全是因为那里缺乏真正的活动和挑战：他们没有跟做实验的学者接触，也不必思索如何回答学生提出的问题，什么都没有！ 在任何思考过程中，当一切进行顺利、灵感源源不绝时，教书确实是一种妨碍，十分讨厌。但有更多的时候是脑袋空空的，如果既想不出什么、又没做什么，那真会教人疯狂！你甚至不能说：“我在教书呀！”。 不敢面对问题到弄明白 在罗彻斯特举行了一个会议——一年一度的罗彻斯特研讨会（Rochester Conference）。我还是事事落于人后，而李政道已在发表关于宇称不守恒的论文。他和杨振宁作出宇称并不守恒的结论，现在他正提出解释这现象的理论。会议期间，我住在我位于西瑞桥斯（Syracuse）的妹妹家。我把论文带回家跟她说：“我搞不懂李政道和杨振宁说的东西，这全都那么复杂！”“不，”她说，“你的意思并不是说你无法弄懂它，而是你没有发明它。你没有用你的方法，从听到线索开始做起，把它推演出来。你应该做的是想象自己重新在当学生，把这篇论文带到楼上去，逐字逐句地读，检查每一条方程式。然后你就什么都弄懂了。”我接受了她的建议，把那东西从头看到尾，发现它真的很明显简单。我只是一直害怕去读它，总觉得它太深奥。","link":"/2020/04/18/%E3%80%8A%E5%88%AB%E9%97%B9%E4%BA%86%E8%B4%B9%E6%9B%BC%E5%85%88%E7%94%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Linux常用命令整理（1）","text":"Linux命令基础知识 1234567891011$ command [-options] parameter1 parameter2 ... 命令 选项 参数(1) 参数(2) 说明： 1. 任何命令中第一个输入的部分绝对是『命令(command)』或者『可运行文件』 2. command 命令的名称 3. [-options] 选项并不存在于实际的命令中，而加入选项配置时，通常选项前会带 - 号（比如-h）。有时候会使用选项的完整全名，此时带有 -- 符号（比如--help） 4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数； 5. 命令, 选项, 参数等以空格来区分，但是不论空几格 ，shell 都同一视为一格； 6. [Enter]按键代表着一行命令的开始启动。 7. 命令太长的时候，可以使用反斜杠 (\\) 来跳脱[Enter]符号，使命令连续到下一行。反斜杠后需要立刻接特殊字符才行。8. 在 Linux 中，区分大小写。 基本查询查询所支持的语言123456$ echo $LANG zh_TW.UTF-8#修改为英文语系 $ LANG=en_US$ echo $LANG en_US 时间日历与计算器123$ date //date 时间$ cal //cal 日历$ bc //计算器 版本信息查询uname －a查看版本当前操作系统内核信息 cat /proc/version查看当前操作系统版本信息 cat /etc/issue 或 cat /etc/redhat-release查看版本当前操作系统发行版信息 cat /proc/cpuinfoLinux查看cpu相关信息，包括型号、主频、内核信息等 getconf LONG_BITLinux查看版本多少位 lsb_release -aCentOS 6.9版本需要安装lsb，CentOS 7.0以上直接可以使用 命令信息查询命令总数：[Tab][Tab]按下两个[Tab]按键，查看共有多少命令可以让用户使用用。 man page有时忘记了命令全称，也可以根据不完整的名称查出来，系统有哪些跟这个名词有关的说明文件 12 -f 查询以keyword开头所有相关帮助信息列表，只会找数据中的左边那个命令(或文件)的完整名称。$ man -f keyword 12 -k 将说明文件里面只要含有keyword的都列出来。$ man -k keyword 1234$ whatis [命令或者是数据] 相当于 man -f [命令或者是数据] $ apropos [命令或者是数据] 相当于 man -k [命令或者是数据] 两个特殊命令要能使用，必须要有创建 whatis 数据库才行！这个数据库的创建需要以 root 的身份下达如下的命令：[root@ ~]# makewhatis 关机/重新启动命令数据同步写入硬盘中： sync惯用的关机命令： shutdown重新启动，关机： reboot, halt, poweroff在默认的情况下， 这几个命令都会完成一样的工作！(因为halt会先呼叫shutdown，而shutdown最后会呼叫halt！)。 不过，shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt却能够在不理会目前系统状况下， 进行硬件关机的特殊功能 123[root@ ~]# reboot [root@ ~]# shutdown -h now [root@ ~]# poweroff -f halt若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。使用权限：系统管理者。 1[root@ ~]# halt 切换运行等级：initLinux共有七种运行等级run level 0：关机run level 3：纯文本模式run level 5：含有图形接口模式run level 6：重新启动可以使用init来关机 1[root@~]# init 0 文件处理命令目录相关：ls、pwd、mkdir、rmdir1234ls -l //列出当前目录下的文件详细信息pwd [-options] //查看”当前工作目录“的完整路径mkdir [-options] 目录名 //创建目录 rmdir [-options] 目录名 //删除空目录。 文件复制移动：touch、mv、cp、rm1234567mv [选项] 源文件或目录 目标文件或目录//mv命令将文件重命名或将其移至一个新的目录中``` ```bashcp [选项]… [-T] 源 目的//cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。 12touch [选项]… 文件…//touch命令可更改文档或目录的日期时间，包括存取时间和更改时间。 12rm [选项] 文件…rm命令删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。 取得路径的文件名与目录名：basename，dirname查看文件内容：more、less、head、tail、cat、tac、nl、diffmore：一页一页显示文件内容less：less与more类似，但是可以向前翻页head：查看文件时，只显示头几行tail：查看文件时，只显示尾几行【-f 循环读取文件，不断刷新】tac：从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 12345cat [选项] [文件]…主要的三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file 1234nl [选项]… [文件]…\\\\可以用来显示文件\\\\nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！\\\\其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 123456789101112diff[参数][文件1或目录1][文件2或目录2]\\\\diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。root@ubuntu:~# diff /snap/ /usr/Only in /snap/: READMEOnly in /usr/: binOnly in /usr/: gamesOnly in /usr/: includeOnly in /usr/: libOnly in /usr/: localOnly in /usr/: sbinOnly in /usr/: shareOnly in /usr/: src 创建文件链接： ln123//ln (link)ln -s source dist # 建立软连接ln source dist # 建立硬连接 软链接(symbolic link)：软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。硬链接(hard link)：硬链接是已存在文件的另一个名字。【不允许给目录创建硬链接；只有在同一文件系统中的文件之间才能创建硬链接。】 硬链接：指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Number)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件,以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。软链接：文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 更改文件权限umask 档案预设权限chattr 配置文件档案隐藏属性lsattr 显示档案隐藏属性file 观察文件类型： chgrp改变所属群组, /etc/group里面可查询群组 1[root@~]# chgrp users code.log chown功能： 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。格式： chown [选项]… [所有者][:[组]] 文件… chmod功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。格式： chmod [-cfvR] [–help] [–version] mode file数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 压缩文件压缩文件和读取压缩文件：tar，gzip，zcat 磁盘占用与挂载dfdf命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。 1234root@ubuntu:~# df Filesystem 1K-blocks Used Available Use% Mounted onudev 491848 0 491848 0% /devtmpfs 100920 628 100292 1% /run du (disk usage)du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。该命令的功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出指定目录，则对当前目录进行统计。 mount在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等 文件查找which12which 可执行文件名称 //查找路径：PATH所含目录//which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 适用场合：查找命令/可执行文件所在的路径。有时候可能在多个路径下存在相同的命令，该命令可用于查找当前所执行的命令到底是哪一个位置处的命令。 whereis123whereis [-bmsu] [BMS 目录名 -f ] 文件名 //查找路径：索引数据库所含目录//whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于源文件，二进制文件，或是帮助文件。//whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 原理：首先会去掉文件名中的前缀空格和以.开头的任何字符，然后在数据库（var/lib/slocate/slocate.db）中查找与经过处理后的文件名相匹配的源文件，二进制文件，或是帮助文件。使用之前可以使用updatedb命令手动更新数据库。适用场合：定位可执行文件、源代码文件、帮助文件在文件系统中的位置 locate12locate [选择参数] [样式] //查找路径：索引数据库所含目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 原理：默认情况下(文件名中不包含通配符时)，locate会给出所有与filename*相匹配的文件的路径。适用场合：没有文件类型性质的模糊查找 find1find pathname -options [-print -exec -ok …] //查找路径：当前目录/指定目录 适用场合：能用which、whereis和locate的时候尽量不要用find.功能： 用于在文件树种查找文件，并作出相应的处理原理：遍历当前工作目录及其子目录参数： 1.使用name选项，可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。2.按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。3.如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。4.使用type选项,根据不同的文件类型进行查找，如d(目录)、l(链接) find命令之exec-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。例如：find . -type f -exec ls -l {} ;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。find命令之xargsfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 网络管理命令Linux 查看端口占用情况 ip1ip [-option] [动作] [命令] option ：设定的参数，主要有-s显示出该设备的统计数据(statistics)，例如总接受封包数等；动作：就是是可以针对哪些网络参数进行动作，包括有： link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；route ：与路由有关的相关设定 ifconfig1ifconfig [网络设备] [参数] ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 digdig命令是一个功能强大的DNS查询命令。 一般格式： 1dig [@global-server] [domain] [q-type] [q-class] {q-opt} {d-opt} 参数说明：global-server：默认是以/etc/resolv.conf作为DNS查询的主机，这里可以填入其它DNS主机IP。domain：要查询的域名。q-type：查询记录的类型，例如a、any、mx、ns、soa、hinfo、axfr、txt等，默认查询a。q-class：查询的类别，相当于nslookup中的set class。默认值为in（Internet）。q-opt：查询选项，可以有好几种方式，比如：-f file为通过批处理文件解析多个地址；-p port指定另一个端口（缺省的DNS端口为53），等等。d-opt：dig特有的选项。使用时要在参数前加上一个“+”号。 d-opt常用选项：+vc：使用TCP协议查询。+time=###：设置超时时间。 netstat1netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。netstat命令(菜鸟教程) ss(Socket Statistics)12ss [参数]ss [参数] [过滤] 功能： ss命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。ss命令的参数及使用详解 ping1ping [参数] [主机名或IP地址] ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 tracertroute123traceroute[参数][主机]//具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 route1route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 功能： Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 Linux系统的route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 参考资料理解 Linux 的硬链接与软链接鸟哥的linux私房菜Linux下4个查找命令which、whereis、locate、find的总结Linux 命令大全","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89/"},{"title":"Linux常用命令整理（2）","text":"统计与过滤 grep用于过滤/搜索的特定字符,可用正则表达式能多种命令配合使用。 1grep [-option] pattern file Linux grep 命令 wc统计指定文件中的行数、字数、字节数，并将统计结果显示输出。 1wc [-option] 文件… 该命令统计指定文件中的行数、字数、字节数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数 12$ wc testfile # testfile文件的统计信息 5 100 600 testfile # testfile文件的行数为5、单词数100、字节数600 Linux wc命令 进程相关进程的挂起1kill -stop PID //将进程挂起（redhat） 需要重新执行当前被挂起的任务时，使用 bg %num 即可将挂起的 job 的状态由 stopped 改为 running，仍在后台执行。需要改为在前台执行时，执行fg %num 即可。也可以使用[ctrl]+[z] pstree123pstree -p //可以显示进程树pstree -apnh //显示进程间的关系pstree -u //显示用户名称 Linux pstree命令 lsof （lists openfiles）1lsof [参数][文件] //需要root执行（因为要访问核心内存和各种文件） 功能： 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。 好用的系统监视工具（神器）。 有着最多开关的Linux/Unix命令之一 lsof打开的文件可以是：1.普通文件2.目录3.网络文件系统的文件4.字符或设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.网络文件（例如：NFS file、网络socket，unix域名socket）9.还有其它类型的文件，等等lsof 菜鸟教程Linux 命令神器：lsof ps(process status)1ps [options] [--help] //用来显示当前进程的状态 ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。如果想要动态的显示进程信息，就可以使用top命令。 1234root@ubuntu:~# ps PID TTY TIME CMD13777 pts/1 00:00:00 bash14564 pts/1 00:00:00 ps Linux ps命令 jobs12jobs[选项][参数] //用于显示Linux中的任务列表及任务状态，包括后台运行的任务。//jobs 的状态可以是 running, stopped, Terminated 该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。 12345678910root@ubuntu:~# jobs //后台没有进程，所以jobs命令的输出是空root@ubuntu:~# ping 192.168.0.1PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.^Z[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs[1]+ Stopped ping 192.168.0.1root@ubuntu:~# jobs -l //-l：显示进程号；[1]+ 14661 Stopped ping 192.168.0.1 jobs命令 fg、bg、jobs、&amp;、ctrl + z都是与系统任务有关的常用命令 12345command&amp; 或者 ctrl + z 让进程在后台运行 jobs 查看后台运行的进程 fg %jobnumber 让后台的进程jobnumber到前台到前台 bg %jobnumber 让进程jobnumber到后台去 //%jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid) kill1kill[参数][进程号] 功能： 发送指定的信号到相应进程。不指定信号将发送SIGTERM（15）终止指定进程。如果无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 1234//通过 jobs 命令查看 job 号（假设为 jobnumber）kill %jobnumber通过 ps 命令查看 job 的进程号（PID，假设为 pid）//kill pid killall1killall[参数][进程名] //用来结束同名的的所有进程（kill processes by name） killall命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。 系统监测top1top [参数] 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 free1free [参数] 功能： free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略 1234root@ubuntu:~# free total used free shared buff/cache availableMem: 1009176 136644 172116 628 700416 687996Swap: 0 0 0 vmstat (virtual memory statistics)功能： 用来显示虚拟内存的信息 1234root@ubuntu:~# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 172200 145008 555428 0 0 0 6 16 15 0 0 100 0 0 虚拟内存的原理：在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。 iostat (I/O statistics)1iostat[参数][时间][次数] 功能： 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。 Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 命令执行watch1watch[参数][命令] 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令（也就是说定个具体时间或者隔一段时间执行一次）watch命令 1watch -n 1 -d 'pstree|grep http' # 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加''将命令区域归整。 at1at[参数][时间] 功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on） crontab通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 Linux crontab命令详解 ##文件传输 rcp (remote file copy)1rcp [参数] [源文件] [目标文件] 功能：rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。 rcp（远程文件拷贝）命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。 scp (secure copy)1scp [参数] [源路径] [目标路径] 功能： scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 linux的scp命令可以在linux服务器之间复制文件和目录。 wget1wget [参数] [URL地址] 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。 支持断点下传功能 同时支持FTP和HTTP下载方式 支持代理服务器 参考资料Linux命令大全（手册）Linux 命令大全（菜鸟教程）","link":"/2020/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89/"},{"title":"Linux概述","text":"Linux设计目标Unix被设计成为一种能够同时处理多进程和多用户的交互式系统，Linux继承了Linux的设计目标。 设计Linux的基本方针： 每个程序只做一件事并且做好。 好的程序员追求的系统 简单，优雅， 一致性 （最小惊讶原理） 较强的功能性与灵活性 意味着系统有较小的一组基本元素，产生多种多样的组合来满足各种应用需要。 Linux的接口 Linux系统层次结构 所有版本的Linux必须提供大量的标准程序，其中一些是POSIX标准指定的，其他的根据Linux的版本而有所不同。它们包括： 命令处理器（shell） 编译器 编辑器 文本处理程序 文件操作工具等 Linux具有三种不同的接口 真正的系统调用接口 库函数接口 由标准应用程序构成的接口 shellshell中，后台运行一个程序的语法是在原本命令后加“&amp;”。 shell脚本：包含shell命令的文件。 可以包含参数，同时使用if、for、while和case等结构。 可以给变量赋值，然后过一段时间再读取这些变量。 linux应用程序应用程序分类Linux的命令行用户界面包含大量的标准应用程序。大致分为6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 过滤器过滤器有： grep、sort、head、tail cut和paste（文档剪切与粘贴） od：将输入（通常是二进制，也包括八，十和十六进制）转化为ASCII文档。 pr：打印机格式化输出 tr：字符大小写转换 编译器和程序设计工具编译器和程序设计工具： gcc ar：将库函数收集到存档文件中 make：维护程序，跟踪哪些头文件依赖于哪些头文件等，然后安排所有需要进行的编译自动进行。 内核结构 Linux内核结构 内核最底层，负责中断处理程序，这是它们与设备交互的主要方式，以及底层的分派机制。分派在中断时发生。 底层的代码中止正在运行的进程，将其状态存储在内核进程结构中，然后启动相应的驱动程序。 进程分派，在内核完成某些操作并且需要再次启动一个用户进程时，发生。进程分派的代码是汇编代码，并且和进程调度的代码有很大不同。 内核子系统的三个主要部件 I/O部件 包含所有负责与设备交互以及实现联网和存储的I/O功能的内核部件 内存管理部件 维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法。并根据需要把需要的数据和代码页读入内存中。 进程管理部件 主要是进程的创建和中止。还有CPU调度和信号处理。 内核最顶层，是内核的系统调用接口。所有的调用都来自这里，其导致一个陷阱，将系统从用户态切换到受保护的内核态，继而将控制权交给上述的内核部件之一。 参考资料现代操作系统","link":"/2020/04/20/Linux%E6%A6%82%E8%BF%B0/"},{"title":"操作系统与文件系统简述","text":"操作系统 1940s，1950s的年代，计算机慢，一次只能运行一个程序，程序员在打孔纸上写程序，拿到一个计算机房间，交给操作员。操作员等计算机空下来后，将程序放入，然后运行，输出结果，停机。 计算机变快之后，放程序的时间比程序运行时间还长，我们需要计算机以一种方式自动运作——&gt;操作系统 到1950年代尾声，计算机已经变得非常快了，处理器经常闲着，等待慢的设备（比如打印机，读卡器等），也就是程序阻塞在I/O上 50年代后期，曼彻斯特大学研发了世界上第一台超级计算机，Atlas，想法设法最大限度利用它，1962年设计了atlas supervisor程序，能够在一个CPU上运行多个程序（这种能力也叫多任务处理）Atlas是世界上第一台同时支持虚拟内存和内存保护的电脑 同时运行多个程序会有一些问题 每个程序都会占一些内存，切换程序的时候不能丢失数据 解决办法是给每一个程序配置专属内存块 分配专属内存块到物理地址时候，可能物理地址不连续的，为了隐藏这种复杂性，把内存地址虚拟化，也就是虚拟内存机制 这种机制可以使程序内存大小灵活增减，也叫动态内存分配 内存保护：程序只能捣乱自己的内存，不会影响到其他的程序。 分时操作系统Multics 首次在设计时候考虑了安全机制，但是导致系统过于臃肿。 Dennis 和 Thompson 联手打造了Unix，将os分为两部分 操作系统的核心功能，比如内存管理，多任务和输入输出管理，称之为内核 一堆有用的工具，比如程序和运行库 Unix中并没有向multics这么多的错误处理代码 如果有错误产生，就让内核恐慌（kernel panic） 内核崩溃是没有办法恢复的，所以调用了一个pannic的函数，起初只是打印pannic一词，然后无限循环Unix成为1970-1980年代最流行的操作系统之一 1980年代，计算机降价到普通人买得起，这时候叫个人电脑。起初微软的操作系统没有内存保护，经常蓝屏,后来微软都加上了 我们现在用的ios，安卓，windows，macos基本上都有了内存保护，虚拟内存，多任务了； 文件系统文件格式：随机排列文件当然没有问题，但是按格式排列会更好的 最简单的文件格式 文本文件（.txt） 元数据（meta data）：关于数据的数据元数据存在于文件开头，在实际的数据前面，因此也叫文件头（header） 早期计算机只做一件事，比如火炮射程表，这时候整个存储器就像一个文件（数据从头到尾直到占用满） 后期计算和存储能力的提升，可以存多个文件了，这时候最简单的方式是把文件连续存储，一个个在内存中连续存放但是存储器没有文件概念，只存储大量位，我们怎么直到文件的开头和结尾在哪呢？所以我们需要一个特殊文件，来记录其他文件存储的位置这个特殊文件有很多名字，这里泛称为“目录文件”,这个文件经常是存放在开头的 目录文件存放 其他文件的名字”文件名+”.“+扩展名“ 文件的元数据，比如创建时间(created)，最后修改时间(last modified)，文件所有者，是否能读写，最重要的是文件的起始位置和长度 就像书的目录意义，更改了书里面的内容，就需要更改对应的目录 目录文件和对目录文件的管理是一个非常简单的文件系统的例子 上面的例子是”平面文件系统“：文件都在同一个层次平面文件系统存在的问题：如果给某个文件加数据，会覆盖掉后面文件的一部分 所以现代的文件系统会做两件事 把空间预先分为一块块，并留一些“预留空间”可以方便改动和管理 （用这样的方案目录文件需要记录文件存放在哪些块里面） 拆分文件，存放在多个块里面，这样文件可以轻松增大和缩小（目录文件会记录不只一个块）//有点像虚拟内存 删除文件只需要在目录文件上删除那条记录即可。 碎片：文件存储在多个块里面，块之间是分开的，顺序也是乱的。//是增删改文件导致的，不可避免的 对很多存储技术来说，碎片是坏事，现实生活中大文件可能存放在数百个块里面，导致打开文件特别慢。如何解决？碎片整理！计算机把数据来回移动，排成正确的顺序 分层文件系统树状目录的形式 目录文件（根目录）不仅要指向文件，还要指向目录（is directory字段）//相对于平面文件系统的变化 无线深度的文件夹 可以轻松移动文件，只需要改动两个目录文件（一个删去一条记录，一个加一条记录） 存储介质如今存储技术正朝向固态前进，没有机械活动部件，里面是集成电路，不用像磁盘那样磁头等待磁盘旋转，ssd访问时间低于1/1000秒，但是仍然比RAM慢很多倍，所以现代计算机仍然用层次存储结构。第一个RAM出现于1972年，成本每比特一美分 参考资料Crash Course Computer Science","link":"/2020/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0/"},{"title":"常用数据结构简述","text":"算法处理的数据在内存中的格式是什么？我们希望数据是结构化的，方便读取，因此计算机科学家发明了数据结构 数组array几乎所有的编程语言都自带了许多函数来处理数组，比如数组的排序 字符串string是数组的亲戚i = “love”虽然长得不像数组，但的确是数组，在计算机幕后的确是这样的字符放在内存中以/0结尾，不是”字符0“而是”二进制0“，这叫字符“null”，表示字符串结尾。 这个字符非常重要，如果调用print函数，会从开始位置逐个显示到屏幕，但是得直到什么时候停下来!否则会把内存中的所有内容输出。 矩阵matrix数组的数组 结构体struct多个变量打包在一起，在内存中会自动组织到一起的 节点node与指针struct可以构建复杂的数据结构，比如node 12345struct listnode{ int value; listnode * next;}; 链表linked list使用node来构建链表灵活性是通过每个节点指向下一个节点实现的循环链表（circular list）：尾部的next指向开头非循环链表：尾部节点指针值是null链表使用的时候很少看具体地址么，而是经常使用链表的抽象模型 链表的优点 容易重新排序，两端缩减，分割，倒序等 因为灵活很多数据结果可以用链表实现，比如队列和栈 队列queueFIFO队列的链表实现比方1-&gt;2-&gt;3-&gt;4-&gt;5可以让队列头指向1，队列尾部指向5 （也就是链表的节点连接是反向的）入队（enqueuing）出队（dequeuing） 栈stackLIFO入栈（push onto the stack）和出栈（pop from the stack） 树tree123456struct treenode{ int value; listnode * nextleft; listnode * nextright;}; 最重要的性质：树到根是单向的 二叉树 binary tree每个节点至多两个孩子 图graph顶点多对多 参考资料Crash Course Computer Science","link":"/2020/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"},{"title":"软件工程简述","text":"为了写大型程序，程序员们使用了各种工具和方法，形成了软件工程这门学科。软件工程这个词由NASA工程师Margaret Hamilton创造。她帮助NASA在阿波罗计划中避免出现严重问题。她的经典名言： 这有点像牙齿的根管治疗：你总是拖到最后才做，但有些事情可以事先做好。有点像预防性体检，只不过是预防软件出错。 对象尽管可以将大项目分解为小函数，每个人同时工作，不用关心整个项目，只关心自己的函数高效和正确就好啦，然而把代码打包成函数还是远远不够的。比如微软Office软件有近4000万行代码，打包成函数也还有几十万个，也还是也有点多。解决办法是，把函数再次打包成为层级，把相关的代码都放到一起，打包成对象（objects）。 面向对象编程（object oriented programming）把函数打包成为对象的思想叫做“面向对象编程”。对象可以包含对象，函数，变量。子对象也是同样的，所以会出现沿着对象层级一层层找执行函数的做法。 API软件工程的比喻：就像建造摩天大一样，有管道工配置管道，电工装电线，油漆工涂油漆，还有成败上千人做其他的事情。所以一个大团队中有许多小团队，不同小团队之间负责不同的功能，所以不同团队之间需要文档，才能帮助理解代码都在做什么，还需要定义好的程序编程接口（API）API帮助不同程序员合作，不需要直到细节，只要直到怎么使用就好了。 然后private与public提供不同的权限，哪些不让外部访问，哪些仅供内部访问。 面向对象的核心： 隐藏复杂度 选择性公布功能 IDE与调试（debugging）代码在编译之前只是文字，可以用任何文本处理程序写代码，但是一般来时，还是会用专门的工具来写比较好。IDE提供了许多有用功能，因为集成了所有的东西，所以叫IDE。 代码帮助，提示，整理，编译，测试 文档和注释（readme/comment）程序员另一项重要工作是给代码写文档文档一般放在readme中文档也可以写成注释，放在源代码中好的文档的作用： 能帮助开发者几个月后理解自己和他人的代码 还能提升复用性，与其让程序员一遍遍写已经有的东西，不如直接用别人写好的来解决问题。 版本控制源代码管理，帮助团队协作，也叫版本控制。弄懂git原理即可。 质量控制写代码与测试代码密不可分。测试也称为质量保证测试（QA，quality assurance testing）。严格测试软件的方方面面，看软件会不会出错，也就是找Bug。 Beta Alphabeta版软件（beta software）：意思是软件接近完成，但不是百分之一百通过测试过，公司有时会向公众发布beta版本，以帮助发现问题。alpha版软件（alpha version software）：一般很粗糙，错误多，只在公司内部测试。 参考资料Crash Course Computer Science","link":"/2020/04/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%80%E8%BF%B0/"},{"title":"文件系统（1）","text":"基础概念文件系统：操作系统中处理文件的部分，有关文件的构造，命名，存取，使用，实现和管理都是操作系统文件系统设计的主要内容 文件文件结构文件可以有多种构造方式。 字节序列（Windows，UNIX都采用这种文件模型） 记录序列（以前大型计算机系统中的常见模式，现在没多少了） 树（处理商业数据的大型计算机中获得广泛使用） 文件在这种结构中由一棵记录树构成，每个记录并不具有同样长度，记录的固定位置有一个键。树按键排序，从而对特定的键进行快速查找 文件类型Linux中分为 普通文件（regular）：存在于外部存储器中，用于存储普通文件。 目录文件（directory）：用于存放目录项，是文件系统管理的重要文件类型。 管道文件（pipe）：一种用于进程间通信的特殊文件，也称为命名管道FIFO。 套接字文件（socket）：一种用于网络间通信的特殊文件。 链接文件（link）；用于间接访问另外一个目标文件，相当于widows快捷方式。 字符设备文件（character）:字符设备在应用层的访问结构。 块设备文件（block）：块设备在应用层的访问接口。 文件存取 顺序存取文件（sequential access）：进程可以从头到尾顺序读取文件的全部字节或者记录，但不能跳过某一些内容，也不能不按顺序读取。可以返回到起点的。 随机存取文件（random access）：以任何次序读取其中字节或记录的文件。对很多应用程序来说是必不可少的，比如数据库系统 文件属性操作系统常用的文件属性 文件保护 属性 含义 备注 保护 谁可以存取文件，以什么方式 口令 存取文件需要的口令 有一些系统中，用户必须给出口令才能存取文件 创建者 创建文件者ID 所有者 当前所有者 标志 属性 含义 备注 只读标志 隐藏标志 系统标志 0表普通文件，1表示系统文件 存档标志 0表示已经备份，1表示需要备份 ASCII/二进制标志 0表示ASCII文件，1表示二进制文件 随机存取标志 0表示只允许顺序存取，1表示随机存取 临时标志 0表示正常，1表示进程退出时删除文件 加锁标志 0表示未加锁，非零表示加锁 查找读写相关 属性 含义 备注 记录长度 一个记录中的字节数 键的位置 每个记录中键的偏移量 键的长度 键字段的字节数 当前大小 文件字节数 最大长度 文件可能增长到的字节数 时间 属性 含义 备注 创建时间 最后一次存取时间 最后一次修改时间 文件操作最常用的一些系统调用（不限制系统的总结） create delete open close read write append：write的限制形式，智能在文件末尾读取数据 seek：对于随机存取文件，通常需要指定从何处读取数据，通常使用seek系统调用把当前位置指针指向文件中的特定位置。seek调用结束后，就可以从该位置开始读了。 get attributes set attributes rename Linux文件IO函数，通常包括 open,read,write,lseek,close这五个函数。 目录目录操作 create delete opendir closedir readdir rename link ulink 文件系统的实现文件系统布局文件系统存放：文件系统存放在外存上。多数磁盘划分为一个或者多个分区，每个而分区有一个独立的文件系统。主引导记录（master boot record，MBR）：磁盘的0号扇区称为主引导记录，用来引导计算机，MBR之后挨着的是分区表,该表给出了每一个分区的起始和结束地址。在计算机被引导时，BIOS读入并执行MBR。MBR执行的第一件事情是确定活动分区，读入活动分区的第一个块，称为引导块（boot block），并执行之。引导块中的程序将装载该分区中的操作系统。为了统一，每个分区都从一个启动块开始，即使它不含一个可以启动的操作系统。不过，在将来这个分区也许会有一个操作系统的。 文件的实现文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块。不同的操作系统采用不同的方法。 连续分配最简单的分配方案：把每个文件座位一连串连续数据存储在磁盘上。所以，在块大小为1KB的磁盘上，50KB的文件要分配50个连续大小的块。优点 实现简单。记录每个文件用到的磁盘块简化为只需记住两个数字即可：第一块的磁盘地址和文件的块数。 读性能好。单个操作就可以从磁盘上读出整个文件。只需一次查找（对第一个块）。之后就不需要寻道和旋转延迟，所以数据以磁盘全带宽的速率输入。可见连续分配实现简单且具有较高的性能。 很适合DVD，CD-ROM等一次性光学介质的存储。 缺点 磁盘零碎问题。删除文件之后会留下空闲块，随着时间的推移会使得磁盘变得零碎，既有文件也有空洞 要么压缩磁盘。代价太高不可行。 要么重新使用空洞。需要维护一个空闲空间列表，但是为了挑选合适的空闲空间，需要知道该文件的最终大小。如果用户为了避免找到的空闲空间太小而提前给出一个不切实际的较大数字，则可能无法找到合适的空闲空间而导致失败。 链表分配链表分配：为每个文件构造磁盘块列表，每一个块的第一个字作为指向下一块的指针，块的其他部分存放数据。优点 可以充分利用每个磁盘块，不会因为磁盘碎片而浪费存储空间。 顺序读文件很方便 缺点 随机存取非常慢 由于指针占去了一些字节，每个磁盘块存储文件数据的字节数不再是2的整数次幂，这种怪异的大小会降低文件的存储效率。（类似于没有对齐） 很多程序都是以2的整数次幂来读写磁盘块的。因为上面论述的原因，要读出一个完整的2的整数次幂的块需要从两个磁盘中获得和接收信息，这就因为复制引发了额外的开销。 在内存中采用表的链表分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 可以取出每个磁盘块的指针字，把它放在内存的一个表里面，就可以解决链表分配的两个不足。 文件分配表（FAT,File Allocation Table）：这个表实现了链表的操作。文件分配表的每一个表项存放着文件数据的下一个块的块号 优点 磁盘文件块可以不用存放指针，这样整个块都是数据。 随机存取更加容易，整个文件分配表实现的链表都在内存中，不需要磁盘引用。 不管文件多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。 缺点 占用内存空间大。必须整个表都存放在内存中。 对于200GB的磁盘和1KB大小的块，这张表有2亿项，每一项至少三个字节，为了提高查找速度，有时需要4个字节。根据系统对空间和时间的优化方案，这张表需要600MB或者800MB，不实用。 i节点分配A：我们可以知道上面链表分配的不足，那么如何解决呢？B: 既然整张文件分配表太大了，我们就拆分成小的放，实现一个新的数据结构i节点。 i节点（index-node）：每个文件都赋予了一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。优点： 只有在对应的文件打开时候，其i节点才在内存中 缺点与解决方案： 每个i节点只能存储固定数量的磁盘地址，那么当一个文件所包含的磁盘块的数目超出了i节点所能容纳的数目怎么办呢？ 一个解决方案，最后一个i节点中的磁盘地址不指向数据块，而是指向一个包含磁盘块地址的块的地址。 目录的实现每个目录项只引用i节点的目录 共享文件共享文件：当几个用户在同一个项目里面工作时候，他们常常需要共享文件。其结果是，如果一个共享文件同时出现在属于不同用户的不同目录下面，工作起来就很方便。连接（link）：原本属于C目录下的文件也出现在B目录下的话，B的目录与该共享文件的联系称为一个连接（link）。这样文件系统本身也成为了一个有向无环图（DAG）。 共享文件的问题： 如果目录包含磁盘地址，则当连接文件的时候，必须把C目录中的磁盘地址复制到B目录。如果B或者C之后又向文件中添加内容，则新的数据块只会列入添加工作的用户的目录中。其他用户是不知道的。这违背了共享的初衷 硬连接和软连接解决方案： i节点方法：磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中，目录指向这个数据结构(Linux中的i节点）（硬连接） 实现机制：需要有一个文件所有者计数机制，当B连接到共享文件时，i节点记录文件的所有者是C，建立一个连接并不会改变所有关系，但是它将i节点的连接技术加1，所以系统知道当前有多少目录项指向这个文件。 缺点：C删去这个文件之后，还有许多目录项指向它，其他硬连接会指向错误的文件。 改进：唯一能做的是只删除C的目录项，但是保留i节点，所有者计数减一。只有到计数为0的时候才会真正删除该文件。 符号链接方法（symbolic linking）：让系统建立一个类型为Link的新文件，并把该文件放在B目录下，使得B与C的一个文件存在链接。链接文件只包含了它所连接的文件的路径名。（软连接） 缺点：需要额外的开销。必须读取包含路径的文件，然后一个部分一个部分地扫描路径，直到找到i节点 缺点：每个符号链接需要额外的i节点和一个额外的磁盘块用于存储路径，如果路径很短，作为一种优化，系统可以将它存储在i节点中。 优点：只要简单提供一个机器的网络地址和文件在该机器上的路径，就可以连接全球任何地方的机器的文件。 tips：还有一个由连接带来的问题，在符号连接和其他方式中都存在。如果允许连接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被连接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被连接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被连接的文件将被两次复制到磁盘上，而不是只是被链接起来。 参考资料现代操作系统简直不要太硬了！一文带你彻底理解文件系统理解linux 的 inode解决inode耗尽问题","link":"/2020/05/01/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89/"},{"title":"C++内存分配与内存划分","text":"C/C++内存使用划分C/C++编译过的程序使用的内存划分： 栈区 是连续的内存区域。 由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。 栈区的变量通常是局部变量、函数参数等。 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 每次程序运行都会分配一个栈，main函数就在栈底，然后通过不同函数的调用顺序，依次进栈出栈。c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗 堆区（动态内存分配） 是不连续的内存区域。 自由存储区或堆：每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C 语言程序使用一对标准库函数malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和delete 表达式实现相同的功能。可以手动释放或者程序结束自动释放存储空间。优点：动态内存的生存期人为决定，使用灵活。缺点：是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 全局/静态存储区全局变量和静态变量的存储是放在一起。C语言中，全局变量又分为初始化的和未初始化的。C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统释放。 常量存储区这是一个比较特殊的存储区，里面存放的是常量，不允许修改。程序结束后由系统释放。 程序代码区存放函数的二进制代码。 堆存储/栈存储对象是存放在堆中还是栈中要看怎么去构造这个对象： 如果用new来生成的对象,是放在堆中的。 直接定义的局部变量内都是放在栈中的，全局和静态的对象（包括类的静态数据成员）是放在数据段的静态存储区 1234Class Test；Test p; //栈上分配内存Test* tTest； //指针在栈中tTest = new Test;，//new的在堆中 堆存储 因为没有专门的系统支持，效率很低； 可能引发用户态和核心态的切换，内存的申请代价变得更加昂贵。 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 因为找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 栈存储 用于存储占用空间小，生命周期短的数据（局部变量/参数变量等） 若栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报异常提示栈溢出 出现栈内存溢出的常见原因有2个： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。 局部变量体积太大。 地址分配 堆，往下增长，向内存地址增加的方向增长 栈，往上增长，向内存地址减小的方向增长（对于小端存储，高位字节在高端地址、低位字节在低位地址，因此在压栈时先压高字节后压低字节） 可能会发生堆栈冲突(从堆中分配内存失败或者爆栈) 大端存储：数据高位在内存低位，低位在内存高位（如Freescale的PowerPC处理器） 小端存储：数据高位在内存高位，低位在内存低位（Intel的芯片一般是小端存储） 分配效率栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。 堆、栈与大小端存储 数据存放基本数据类型： 直接存储在栈(stack)中的数据。（字符串、布尔值、未定义、数字、null） null只是一个空指针对象，没有数据。 引用类型： 将该对象引用地址存储在栈(stack)中，然后对象里面的数据存放在堆中。（数组、对象、函数） 存储的是该对象在栈中的引用，真实的数据存放在堆内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝与浅拷贝深拷贝既复制对象空间又复制资源在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。因此，这种情况下不能简单地复制指针，而应该复制“资源”，也就是再重新开辟一块同样大小的内存空间。当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值，然后同步复拷贝开辟空间的值。 浅拷贝只复制对象空间而不复制资源 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会根据需要生成一个默认的拷贝构造函数，完成对象之间的位拷贝。default memberwise copy即称为浅拷贝。 即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝) 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值； 如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 C/C++内存分配的三种方式 静态存储区分配内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。 栈上分配在函数执行时，函数内的局部变量的存储单元在栈上创建，由操作系统自动分配，函数调用结束时内存也随之析构栈内存分配运算内置于处理器的指令集中，效率高，但栈容量小。 堆上分配堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放,在整个程序运行周期内都存在。 tips: 申请内存后立即判断指针是否为NULL确定内存是否分配成功，如果为NULL则立即用return终止此函数，或者用exit（1）终止整个程序的运行，为new和malloc设置异常处理函数； 为申请的内存赋初值，分配的是一段连续的内存空间的话，要防止指针下标越界； sizeof是操作符，不能用sizeof得到内存空间的大小，只能在申请时候记住申请的空间大小； 在内存使用结束后必须用free或delete释放内存，注意在内存使用中如果存在指针加1或减1 的操作应特别注意，释放的内存要和申请的内存一致，放置内存泄漏，释放内存后，应该立即将指针置为NULL，不要存在野指针。 参考资料[1]浅拷贝与深拷贝的区别[2]C++中数据存储的位置[3]C++经典面试之 内存分配的三种方式[4]堆、栈与大小端存储[5]c语言main函数中的变量和其他函数中的变量使用的是一个堆栈吗","link":"/2020/05/08/C++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"},{"title":"C++特性及优缺点","text":"C++语言优缺点 优点 兼容性好，C++在保持了C语言简洁高效的特点的同时，还对C的类型系统进行改革性扩充，相比C语言，C++更安全，其编译系统也能检查出更多错误类型。 面向对象编程能力，可复用性好，可以让团队衍化出自己的的类库。 性能优势，程序效率高。 缺点 C++ 是 C 语言的一个超集，既有指针又有对象使它成为最复杂的语言，学习难度大。过分的精细和复杂了。C++的复杂度，超过了C和OO（面向对象）的复杂度之和 没有垃圾回收机制。 C++本质上说是提前编译的，Fortran也是。C#和Java大多时候是编译成字节码，运行的时候再 即使编译。Python和Ruby通常是解释型。这就产生了一个性能的分级：C++和Fortran比Java和C#快，Java和C#又比Python 和Ruby快。几种计算机语言的评价（修订版）为什么一些语言会比别的快？ C++特性C++面向对象的三个基本特征：封装、继承、多态。它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用在 C++ 中，用类进行封装（数据抽象），用类派生从一个类继承另一个：派生类继承基类的成员。多态（动态绑定）使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数继承和多态（动态绑定）在两个方面简化了我们的程序：能够容易地定义与其他类相似但又不相同的新类，能够更容易地编写忽略这些相似类型之间区别的程序。 封装（encapsulation）封装是一项低层次的元素组合起来的形成新的、高层次实体的技术。 函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。 类也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。 目的： 将抽象得到的数据和行为相结合，形成一个有机的整体（结合性） 将对象的使用者和设计者分开，以提高软件的可维护性和可修改性 实现代码重用 继承（inheritance）继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 通过继承关联起来的类型都共享共同的接口。当一个类继承另一个类时，这两个类通常可以使用相同的操作。更确切地说，如果两种类型存在继承关系，则可以说一个类“继承”了其父类的行为——接口。 C++ 中所提及的父类称为基类（base class），而继承而来的类则称为派生类（derived class）。 多态（polymorphism）多态：多态的基础是继承。多态下，子类重写父类的方法，实际使用过程中，用父类引用变量指向子类对象，此时父类引用调用的是子类重写后的方法，由于是父类引用变量，所有无法调用子类特有的方法。如果想调用子类特有的方法，必须强制类型转换到子类。多态性派生于一个希腊单词，意思是“许多形态”。之所以称通过继承而相关联的类型为多态类型，是因为在许多情况下可以互换地使用派生类型或基类型的“许多形态”。在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。多态性：指的是基于引用或指针的动态类型获得类型明确的行为的能力。 在C++中的主要表现是动态多态（动态绑定） 动态多态（动态绑定）：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。 在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。 引用和指针的静态类型与动态类型可以不同，这是 C++ 用以支持多态性的基石。 静态多态（编译期/早绑定）template（模板）：静态多态（编译时完成，效率高，适配性高，松耦合性），隐形接口overload（重载）：静态多态 同名函数，不同参数/函数返回值 相同范围，同一个类中 overwrite（重写）：静态多态，子类屏蔽父类的同名基函数 同名同参，无virtual 同名不同参 动态多态（运行期/晚绑定）override（覆盖重写）：动态多态（运行时完成，接口重用，编译器无法优化） 不同类中 同名，同参 基类函数有virtual 参考资料[1]C++ primer 第四版[2]几种计算机语言的评价（修订版）[3]为什么一些语言会比别的快？[4]C++ 特性及类（面试复习整理）[5]C++ 多态-菜鸟教程","link":"/2020/05/08/C++%E7%89%B9%E6%80%A7%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"设计模式总结","text":"设计模式是什么？ 基础概念设计模式（Design pattern）: 是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 GOF（Gang of Four）1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 为什么要用设计模式？ 为了重用代码 让代码更容易被他人理解 保证代码可靠性。 设计模式在软件开发中的两个主要用途： 开发人员的共同平台，提供了一个标准的术语系统，且具体到特定的情景。 例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式有哪些？共有 23 种设计模式，可以分为三类： 创建型模式（Creational Patterns） 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式（Structural Patterns） 用于在许多不同的对象之间形成大型对象结构,关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 行为型模式（Behavioral Patterns） 关注对象之间的通信,用于管理对象之间的算法、关系和职责。 创建型模式单例模式（Singleton Pattern）单例模式-菜鸟教程目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点。何时使用：当您想控制实例数目，节省系统资源的时候。面临的问题：一个全局使用的类频繁地创建与销毁。解决方案判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。应用实例：1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。使用场景：1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。实现方式:《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 常见的单例模式分为两种：1、饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式2、懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式【C++】单例模式/工厂模式 工厂模式（Factory Pattern）设计模式之工厂模式（factory pattern）讲的很形象工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式。工厂模式-菜鸟教程提供了一种创建对象的最佳方式，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。目的：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程（类的实例化）延迟到子类进行。何时使用：我们明确地计划不同条件下创建不同实例时。面临的问题： 抽象工厂模式（Abstract Factory Pattern）根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者（生成器）模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 深拷贝与浅拷贝浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 深拷贝：把要复制的对象所引用的对象都复制一遍。深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 结构型模式适配器模式（Adapter Pattern）作为两个不兼容的接口之间的桥梁。将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 装饰者模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。作为现有的类的一个包装。动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）用于减少创建对象的数量，以减少内存占用和提高性能。尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy Pattern）为其他对象提供一个代理以控制对这个对象的访问。 行为型模式模版方法模式（Template Method Pattern）设计模式 - 模板方法.定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。比如冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 命令模式（Command Pattern）设计模式 - 命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 观察者模式（Observer Pattern）当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。 中介者模式（Mediator Pattern）用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 备忘录模式 （Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 解释器模式（Interpreter Pattern）为语言创建解释器，通常由语言的语法和语法分析来定义。给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 状态模式（State Pattern）类的行为是基于它的状态改变的。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 策略模式（Strategy Pattern）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。 职责链模式 （Chain of Responsibility Pattern）为请求创建了一个接收者对象的链，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 访问者模式 （Visitor Pattern）使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 参考资料设计模式之工厂模式（factory pattern）《大话设计模式》读书笔记设计模式-菜鸟教程C++ 设计模式-CSDN【C++】单例模式/工厂模式C++中的单例模式和工厂模式","link":"/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"C++标准库容器类概述","text":"基础概念容器（container）： 容纳特定类型对象的集合。 C++中所有的容器都是类模板。 所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。容器默认构造函数不带参数。 为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。容器适配器（adaptors）： 适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。 STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。 什么是适配器，C++ STL容器适配器详解 顺序容器和关联容器关联容器和顺序容器的根本不同在于： 关联容器中的元素是按关键字来保存和访问的 顺序容器中的元素则是按它们在容器中的位置来顺序保存和访问的。 顺序容器顺序容器（sequential container）： 它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。 顺序容器不是排序的：元素排列次序与元素值无关。 而是由元素添加到容器里的次序决定。 主要的有三种：可变长动态数组 vector、双端队列 deque、双向链表 list。 汇总的有vector、deque、list、forward_list、array、string等。 表1. 顺序容器与顺序容器适配器: 顺序容器 用途 顺序容器适配器 用途 底层基础容器 vector 可变长动态数组，支持快速随机访问 stack 后进先出（LIFO）堆栈 默认使用deque。满足条件的基础容器有 vector、deque、list list 双向链表，支持快速插入/删除 queue 先进先出（FIFO）队列 默认使用deque。满足条件的基础容器有 deque、list deque 双端队列 priority_queue 有优先级管理的队列 默认使用vector。满足条件的基础容器有vector、deque。 除了上面的表格之外还存在forward_list顺序容器（单向链表，只支持单向顺序访问），请看文章链接 关联容器关联容器（Associative containers）： 支持通过键（key）来高效地查找和读取元素。 关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。虽然关联容器的大部分行为与顺序容器相同，但其独特之处在于支持键的使用。 关联容器支持很多顺序容器也提供的相同操作，此外，还提供管理或使用键的特殊操作。关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 有序关联容器有序关联容器有以下四种：set、multiset、map、multimap。 容器元素根据键的次序排列。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 在迭代遍历关联容器时，我们可确保按键的顺序的访问元素，而与元素在容器中的存放位置完全无关。 map 以键－值（key-value）对的形式组织：键(key)用作元素在 map 中的索引，而值(value)则表示所存储和读取的数据。 map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。 常用操作： map查询操作 操作 作用 m.count(k) 返回 m 中 k 的出现次数 m.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在: 123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 读取元素而不插入该元素: 12345//find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器：int occurs = 0;map&lt;string,int&gt;::iterator it = word_count.find(\"foobar\");if (it != word_count.end()) occurs = it-&gt;second; 更好的请参考：《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;map multimap 支持同一个键多次出现的 map 类型 set set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询。 适用条件： 如果希望有效地存储不同值的集合，那么使用 set 容器比较合适 当只想知道一个值是否存在时，使用 set 容器是最适合的。 set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。 set 容器存储的键也必须唯一，而且不能修改（也体现了 set 存储的元素仅仅是键，而没有所关联的值） multiset 支持同一个键多次出现的 map 类型 multimap和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和set 头文件。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。 无序关联容器unordered_mapunordered_multimapunordered_setunordered_multiset STL容器类库&lt;vector&gt;：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。&lt;list&gt;：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。&lt;deque&gt;：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。&lt;queue&gt;：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。&lt;stack&gt;：为堆栈(后进先出)数据结构定义序列适配器stack。&lt;map&gt;：map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。&lt;set&gt;：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。&lt;bitset&gt;：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。&lt;array&gt;：（TR1）固定大小数组，支持复制。&lt;forward_list&gt;：（c++11）单向列表，forward_list不提供随机访问，这一点跟list相同。forward_list是一个单向链表，只支持单向顺序访问，在链表的任何位置进行插入/删除操作都非常快。&lt;unordered_set&gt;：（TR1)无序容器set，其元素随机存放。唯一键的集合，按键散列。multiset类似于set，但是值不必是唯一的。&lt;unordered_map&gt;：（C++11）（TR1)无序容器map，其键值随机存放。键-值对的集合，由键散列，键是唯一的multimap类似于map，但键不是唯一的。完整的看C++中常用的std标准容器 STL容器类底层实现vector底层数据结构为数组 ，支持快速随机访问 list底层数据结构为双向链表，支持快速增删 deque 底层数据结构为一个中央控制器和多个缓冲区 支持首尾（中间不能）快速增删，也支持随机访问 STL源码分析146页 forward_list 顺序容器，底层数据结构为单向链表。 只支持单向顺序访问，支持快速增删 stack 底层一般用list和deque实现，封闭头部即可。 不用vector的原因应该是容量大小有限制，扩容耗时。 queue 底层一般用list和deque实现，封闭头部即可 不用vector的原因应该是容量大小有限制，扩容耗时 priority_queue底层数据结构：一般是vector为底层容器，堆heap为处理规则来管理底层容器实现 set底层数据结构为红黑树，有序，不重复 multiset底层数据结构为红黑树，有序，可重复 map 底层数据结构为红黑树，有序，不重复 multimap底层数据结构为红黑树，有序，可重复 hash_set 底层数据结构为hash表，无序，不重复 hash_multiset底层数据结构为hash表，无序，可重复 hash_map 底层数据结构为hash表，无序，不重复 hash_multimap底层数据结构为hash表，无序，可重复 C++STL的容器的底层实现详解 参考资料C++容器（STL容器）C++语言学习（九）——C++标准库简介Containers library(cppreference.com)C++中常用的std标准容器 //可以做查找表C++中容易忘的知识点——list和forward_list（四）//可做查寻表C++ STL 的底层实现C++标准模板库（STL）的容器的底层实现C++STL的容器的底层实现详解//可以做查找表","link":"/2020/05/10/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%A6%82%E8%BF%B0/"},{"title":"数据结构总结","text":"（未完待续） 基本概念数据结构： 是数据项的结构化集合。 结构性的表现 数据项之间的相互联系和作用 或者理解为定义于数据项之间的某种逻辑次序 依据逻辑次序的复杂程度划分： 线性结构 半线性结构 非线性结构 序列（sequence）序列（sequence）：最基本的线性结构的统称。序列（sequence）依据数据项之间的逻辑次序与其物理存储的对应关系不同，又可以进一步划分向量和列表： 向量（vector）向量（vector）:所有数据项之间物理存储位置与逻辑次序完全吻合。此时的逻辑次序也称为秩（rank） 循秩访问（call-by-rank），静态存储策略。 列表（list）列表（list）:所有数据项之间物理存储位置与逻辑次序不一定吻合。采用间接定址的方法通过封装后的位置（position）相互引用。 循位置访问（call-by-position）或者称为循链接访问（call-by-link），动态存储策略。 栈（stack）栈（stack）：线性数据结构的一种，视作向量与列表的特例。对象的插入和删除限制在栈的一端。禁止操作的一端称为盲端。栈顶（stack top）：可操作（插入和删除）的一端。入栈（push）与出栈（pop）。栈底（stack bottom）：无法直接操作的盲端。 栈与递归函数调用栈调用栈（call stack）和执行栈（execution）:大部分操作系统中，每个运行的二进制程序都都配有一个调用栈，用来跟踪属于同一个程序的所有函数，记录它们之间的调用关系，并保证在每一个调用实例执行完毕之后，可以准确返回。帧（frame）：调用栈的基本单位，每次函数调用时，都会相应的创建一帧： 记录了函数实例在二进制程序中的返回地址，局部变量，传入参数，还有上一帧的栈中地址。 逆序输出进制转换 递归嵌套栈混洗（stack permutation）：栈的数据从stackA——&gt;stackS——&gt;stackB。 括号匹配： 延迟缓冲： 逆波兰表达式（reverse Polish notation，RPN）： 试探回溯法剪枝试探回溯 八皇后迷宫寻径队列（queue）视作向量与列表的特例 基本概念队列（queue）：线性数据结构的一种，对象的插入和删除限制在队列的两端。队头（front）：允许取出元素的一端。出队（dequeue）:元素的删除操作。队尾（rear）：允许插入元素的一端。入队（enqueue）：元素的插入操作。 队列应用循环分配器银行服务模拟树 半线性结构（semi-linear structure） 其中的元素之间并不存在天然的直接后继或者直接前驱关系。但是只要附加某种约束（比如遍历），就可以在树的元素之间确定某种线性次序关系。因此树属于半线性结构 叶节点（leaf）：无孩子的节点。树的高度（height）:树的所有节点深度的最大值称作该树的高度。教材中约定，单个节点的树高度为0，空树的高度为-1。 如果根结点第0，层数=深度=高度-1 如果根结点第1，层数=深度=高度 节点的高度：任一节点V的高度对应于子树的高度subtree（V）。 多叉树（k-ary tree）k叉树（k-ary tree）：每个节点的孩子均不超过k个的有根树。 多叉树的表示法父节点表示法：一个向量表，存两个属性，一个是data，一个是parent孩子节点表示法：一个向量表，存两个属性，一个是data，一个是children（组织成vector或者list）父亲+孩子节点表示法：一个向量表，存三个属性，一个是data，一个是parent，最后一个是children（组织成vector或者list） 有序树（ordered tree）有序树（ordered tree）：同一节点的所有孩子之间必须具有某一线性次序。这个约束条件使得作为多叉树特例的二叉树有足够的能力表示任何一颗多叉树。 长子+兄弟转换法同一列的是长子，同一行的是兄弟 二叉树（binary tree）二叉树（binary tree）：每个节点的读书均不超过2。有序二叉树（ordered binary tree）：同一父节点的孩子都可以左右相互切分。真二叉树（proper binary tree）：不含一度节点的二叉树 完全二叉树（complete binary tree）完全二叉树（complete binary tree）： 对于使用队列操作的层次遍历，前(n/2向下取整）次迭代中都有左孩子入队，前(n/2向上取整然后-1）次迭代中都有右孩子入队 叶节点只出现在最底部的两层。 高度为：h=（log n）的向下取整 //根节点设置为高度0的情况下 规模介于2^h与2^(h+1)-1 根节点为1，左孩子编号等于2v,右孩子编号2v+1 满二叉树（full binary tree） 规模2^(h+1)-1 遍历递归式遍历迭代版先序遍历迭代版中序遍历迭代版后续遍历层次遍历 编码树编码解码前缀无歧义编码（PFC）huffman编码 二叉编码树根通路串（root path string） 搜索树对线性数据结构查找性能的改进。如果既要求对象集合的组成可以高效率地动态调整，同时也要求能够高效率的查找，对于向量和列表这类线性结构是难以胜任的。兼顾高效率的动态修改和高效率的静态查找，可以使用搜索树。理想平衡和适度平衡，引入平衡二叉树结构，比如AVL树即使在最坏情况下，单次动态查找和静态查找也均在O（log n）时间内完成。 理想平衡和适度平衡理想平衡：如果树的高度恰好为log n，向下取整，则成为理想平衡树 ，比如完全二叉树和满二叉树 适度平衡：渐进意义下适当放松标准的平衡性。渐进的不超过O(log n)下面介绍的红黑树，AVL树，伸展树，kd-树都是适度平衡的变种。也可以归入平衡二叉搜索树之列。 搜索树的局部性 刚刚被访问的节点，可能不久后就能访问到 将被访问的下一个顶点，极可能就在不久之前被访问的某个节点附近 二叉搜索树（BST）二叉搜索树（binary search tree）：处处都满足顺序性——任一节点r的左（右）子树中，所有节点均不大于（不小于）节点r二叉搜索树的判定:任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降。 复杂度分析：insert，remove，search时间：线性正比于查找路径的长度或者最终返回节点的深度。最坏情况下可能退化成为链表。 等价二叉搜索树若两个二叉搜索树的中序遍历相同，则称它们彼此等价。概括一下就是：上下可变，左右不乱。也就是说节点的左右相对关系是不变的，但是上下关系是可以改变的。局部性： 经过单词动态修改操作，至多只有O(log n)处局部不再满足限制条件。 可以在O(log n)时间内，使这O(log n)处局（乃至全树）重新满足限制条件。 旋转调整（修复）zig 顺时针旋转zag 逆时针旋转 平衡二叉搜索树（BBST）AVL树平衡因子(balance factor)：其左，右子树的高度差。各个节点的平衡因子绝对值不超过1。也就是各个节点左右子树高度差不超过1。 失重与重新平衡：单旋与双旋：统一重平衡算法： 伸展树（splay tree）伸展树（splay tree）： 无须时刻都保持全树的平衡，但是却能够在任何足够长的序列上，保持分摊意义上的效率。 不需要对基本的二叉树节点结构，做任何附加的要求或者改动，不需要记录平衡因子或者高度之类的额外信息，故适用范围更广 利用了数据局部性，将刚刚被访问的节点，转移至树根附近。 伸展（splaying）：随着节点e的不断上升，两侧子树的结构也在不断的调整，这种过程也形象地称为伸展。 单层伸展树节点e每次提升1层，直至成为树根 双层伸展树节点e每次提升2层，直至成为树根。 zig-zig/zag-zagzig-zig/zag-zagzig/zag 复杂度分析：分摊的情况下，O（log n） 红黑数（red-black tree）通过假想地引入外部节点（黑色），将二叉树真正扩展为真二叉树。 根节点始终为黑色 外部节点均为黑色 其余节点若为红色，其孩子节点必为黑色 从任一外部节点到根节点的沿途，黑节点的数目相等 由1，2可知，红节点属于内部节点，且红节点的父节点和左右孩子肯定存在 由3可知，红节点之父必为黑色，树的任一通路不会包含相邻的红节点。7 由4可知，所有外部节点的黑高度统一 所有外部节点的黑高度统一特别的，根节点的黑高度也称为全树的黑高度，在数值上与外部节点的黑高度相等。所有外部节点的黑高度为0. 双红修正双黑修正 平衡多路搜索树平衡二叉搜索树（BBST）的推广当数据规模大到内存已经不足以容纳时候，常规平衡二叉搜索树的效率会大打折扣。其原因在于查找过程对外存的访问次数过多。 外部存储适合于批量式访问，不妨通过时间成本较低的多次内存操作，来替代时间成本相对较高的单次外存操作。 结合上面的思想，我们可以将通常的二叉树搜索树，改造为多路搜索树（等价变换） 四路搜索树：每个大节点拥有四个外部的分支。 通常是将二叉搜索树以两层为间隔合并。 一个大节点包含3个关键码和4个外部分支. 多路搜索树（multi-way search tree）：一般地，以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树。 优点： 访问外存的方式相对于二叉搜索树已经发生了本质的变化，可以以大节点为单位读取一组（而不是一个）关键码。 这组关键码在逻辑上与物理上都彼此相邻，故可以以批量方式从外存一次性读出，且需要的时间与读取单个关键码几乎一样。 每组关键码的最佳数目，取决于不同外存的批量访问特性。可以根据扇区的容量等因素来计算。 B- 树平衡多路搜索树的典型代表B-树（B-tree）：m阶B-树，也就是m路平衡搜索树 所有外部节点的深度都相等，每个内部节点都存有不超过m-1个关键码，以及用以指示对应分支不超过m个引用。各个节点的分支数应该介于m/2（向上取整）与m之间，故也称为(m/2向上取整，m)-树B-树的外部节点：B-树的宽度B-树的叶节点 非常适合在相对较小的内存中，实现对大规模数据的高效操作。 复杂度：O(logmN) kd-树（k-dimensional tree）四叉树与八叉树的一般性推广递归定义的平衡二叉树一维范围查询（range query）：给定直线L上的点集P={p0,pn-1},对于任一区间R=[x1,x2],P中的哪些顶点落在其中？离线方式和在线方式输出敏感（output sensitive）的算法平衡二叉搜索树解决一维度范围i查询问题， 找到最低共同祖先，忽略分割成为矩形，举行左边底边开，右边和顶边封闭每次切分都在中位点（对应的坐标排序居中者）。 以保证全树的高度不超过O(log n)复杂度O（根号n） 图非线性结构 邻接矩阵邻接表BFSDFS拓扑排序优先级队列与堆二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。最大堆:，任何一个父节点的值，都大于或等于它左、右孩子节点的值。最小堆:，任何一个父节点的值，都小于或等于它左、右孩子节点的值。 完全二叉堆上滤与下滤左式堆串字符串串匹配散列表看这篇文章即可：哈希表（散列表）详解 注解偏序只对部分元素成立关系R，全序对集合中任意两个元素都有关系R。 集合的包含关系是偏序，因为两个集合可以互不包含。 复数中的大小就是偏序，其中虚数不能比较大小。 实数中的大小关系是全序，两个实数必有一个大于等于另一个。 参考资料数据结构 邓俊辉","link":"/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"title":"环状链表判断算法","text":"判断该链表是否有环 采用两个指针，一个用来遍历，一个用来从头到当前遍历位置的数据对比。思想：比较元素是否出过；复杂度：时间O(n^2),空间O(1) hash表的方法，记录元素，一旦在hash表中出现过,就证明有环复杂度：时间O(n),空间O(n) 双指针类型方法：两个指针p1和p2，让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。思想：追及问题，让快的先跑，如果有环，快的绕一圈后肯定会追上慢的。复杂度：时间O(n),空间O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;struct node{ int value; node *next; node(int a):value(a),next(NULL){}};typedef node list;bool iscycle(list * head){ node *p1,*p2; p1 = head; p2= head; while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL) //因为p1每次走两步，所以需要判断一下最后两个是否为空，以便决定是否循环； { p1 = p1-&gt;next-&gt;next; p2 = p2-&gt;next; if(p1==p2) { return 1; } } return 0;}int main(){ node * node1 = new node(5); node * node2 = new node(3); node * node3 = new node(7); node * node4 = new node(2); node * node5 = new node(6); node1-&gt;next = node2; node2-&gt;next = node3; node3-&gt;next = node4; node4-&gt;next = node5; node5-&gt;next = node2; //cout &lt;&lt; node5-&gt;next &lt;&lt; endl; cout &lt;&lt; iscycle(node1) &lt;&lt; endl;} 如何求出环的长度？当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数也就是 环长=1×前进次数 如何求出入环节点？如果链表有环，如何求出入环节点？答：只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。以上答案根据一个走两步一个走一步计算出的。 参考资料漫画算法","link":"/2020/05/14/%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95/"},{"title":"无序数组排序后的最大相邻差","text":"解法1： 使用任意一种时间复杂度为O（nlogn）的排序算法（如快速排序）给原数组排序，然后遍历排好序的数组，并对每两个相邻元素求差。复杂度：时间O（nlogn），在不改变原数组的情况下，空间复杂度是O(n) 解法2：基数排序的思想 利用计数排序的思想，先求出原数组的最大值max与最小值min的区间长度k（k=max-min+1），以及偏移量d=min。 创建一个长度为k的新数组Array。 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1。例如原数组元素的值为n，则将Array[n-min]的值加1。遍历结束后，Array的一部分元素值变成了1或更高的数值，一部分元素值仍然是0。 遍历新数组Array，统计出Array中最大连续出现0值的次数+1，即为相邻元素最大差值。 解法3：桶排序的思想解法3： 利用桶排序的思想，根据原数组的长度n，创建出n个桶，每一个桶代表一个区间范围。其中第1个桶从原数组的最小值min开始，区间跨度是（max-min）/（n-1）。 遍历原数组，把原数组每一个元素插入到对应的桶中，记录每一个桶的最大和最小值。 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。时间复杂度是O（n），空间复杂度是O（n*k） 代码C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//获取数组中数字之间的最大差值#include&lt;iostream&gt;#include &lt;algorithm&gt;#include\"memory.h\"using namespace std;struct bucket{ int min; int max; bucket():min(NULL),max(NULL){}};int getmaxdtce(int *a,int n){ //1.找到数列的最大最下值 int *max = max_element(a,a+n); int *min = min_element(a,a+n); int d = *max - *min; if(d==0) { return 0; } //2.初始化桶 int bucketnum = n; bucket *buckets = new bucket[n]; //3.遍历原始数组，确定每个桶的最大最小值 //注意，最大点独占一个桶 //所以前面n-1个桶的间隙是(a[i] - *min) / (d / bucketnum - 1); for (int i = 0; i &lt; n;i++) { int index = (a[i] - *min) / (d / (bucketnum - 1)); if(buckets[index].min==NULL||buckets[index].min&gt;a[i]) { buckets[index].min = a[i]; } if(buckets[index].max==NULL||buckets[index].max&gt;a[i]) { buckets[index].max = a[i]; } } //4. 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的差，数值最大的差即为原数组排序后的相邻最大差值。 int leftmax = buckets[0].max; int maxdistance = 0; for (int i = 1; i &lt; n;i++) { if(buckets[i].min==NULL){ continue; } if(buckets[i].min-leftmax&gt;maxdistance) { maxdistance = buckets[i].min - leftmax; } leftmax = buckets[i].max; } return maxdistance;}int main(int argc,char *argv[] ){ int *test = new int[5]; memset(test, 0, sizeof(int) * 5); test[0] = 1;test[1] = 6; test[2] = 3; test[3] = 8; test[4] = 0; cout &lt;&lt;getmaxdtce(test,5);}","link":"/2020/05/14/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B8%E9%82%BB%E5%B7%AE/"},{"title":"使用栈实现的队列","text":"算法思想 其中一个栈A作为队列的入口，用于插入新元素；另一个栈B作为队列的出口，用于移除老元素。 当B为空的时候需要及时将A中的数据转移进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;/* stack&lt;int&gt;q; q.push(1); //入栈 q.pop(); //出栈 q.top(); //返回栈顶成员 q.size(); //返回栈成员个数 q.empty(); //判断是否为空栈*/class stackqueue{ private: stack&lt;int&gt; stacka; stack&lt;int&gt; stackb; public: void enqueue(int a); int dequeue(); void transfer();};int stackqueue::dequeue(){if(!stackb.empty()){ int tmp = stackb.top(); stackb.pop(); return tmp;}else{ if(stacka.empty()) { return NULL; } transfer(); int tmp = stackb.top(); stackb.pop(); return tmp;}}void stackqueue::transfer(){ while(!stacka.empty()) { stackb.push(stacka.top()); stacka.pop(); }}void stackqueue::enqueue(int a){ stacka.push(a);}int main() { stackqueue *que = new stackqueue(); que-&gt;enqueue(1); que-&gt;enqueue(2); que-&gt;enqueue(3); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; que-&gt;enqueue(4); cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl; cout &lt;&lt; que-&gt;dequeue() &lt;&lt; endl;}","link":"/2020/05/14/%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%98%9F%E5%88%97/"},{"title":"vector常用操作","text":"vector初始化方法123vector&lt;int&gt; vec; 初始化size为0的vectorvector&lt;int&gt; vec(10); 初始化size为10，默认值都为0的vectorvector&lt;int&gt; vec(10,1); 初始化size为10，值都为1的vector 通过数组初始化通过数组a的地址初始化，注意地址是从0到5（左闭右开区间），类似迭代器 12int a[5] = {1,2,3,4,5};vector&lt;int&gt; vec(a, a+5); 通过vector初始化12vector&lt;int&gt; a(5,1);vector&lt;int&gt; b(a); 通过insert初始化insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中//助记，插入开始的地方 123vector&lt;int&gt; a(6,6);vecot&lt;int&gt; b;b.insert(b.begin(), a.begin(), a.begin() + 3); 将a[0]~a[2]插入到b中，b.size()由0变为3 insert还可以插入m个值为n的元素 12在b开始位置处插入6个6b.insert(b.begin(), 6, 6); 通过copy函数赋值//助记，拷贝到目标地 1234567vector&lt;int&gt; a(5,1);int a1[5] = {2,2,2,2,2};vector&lt;int&gt; b(10);将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间copy(a.begin(), a.end(), b.begin());拷贝区间也可以是数组地址构成的区间copy(a1, a1+5, b.begin() + 5); 常用操作注意：std::vector 不支持 push_front，，它的目的是为了O(1)的push_back(),对它来说O(n)次的insert()就能做到push_front。支持push_front()的是deque支持的是deque。 加入元素1234q.push_back(x); 尾部加入元素q.insert(iter,x); 在iter位置插入x，传回新数据位置q.insert(iter,n,x); 在iter位置插入n个x，无返回值q.insert(iter,l,r); 在iter位置插入[l,r)区间内的数据，无返回值 vector交换12q.swap(p); 交换p，q容器内元素q.assign(iter1,iter2); //将区间[iter1，iter2)内元素赋值给vector，并清空vector容器之前的内容。 删除元素123q.pop_back(); 删除最后一个元素q.erase(iter1); 删除iter位置元素，返回值是指向被删元素之后的那个元素(即下一个元素)的迭代器。q.erase(iter1,iter2); 删除[iter1，iter2)区间内的元素 清空/覆盖12q.clear(); //清空Vectorq.assign(n,x); //将n个x赋值到vector中，并清空vector容器之前的内容。 返回元素123q.front(); 返回第一个数据q.back(); 返回最后一个数据q.at(i); //返回第i个元素 vector元素个数/是否为空123q.size(); 返回容器内成员个数q.resize(x); //重新指定容器大小q.empty(); 判断Vector是否为空 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 vector内存容量12q.capacity(); //返回Vector可用空间的大小q.reserve(); //重新指定空间大小，小于当前capacity时保持为原本的capacity值 二维vector的初始化123456789vector&lt;vector&lt;int&gt;&gt; vec1;int row = 3;int col = 3;vec1.resize(row);for(int i=0;i&lt;vec1.size();i++) vec1[i].resize(col);for(int i=0;i&lt;row;i++) for(int j=0;j&lt;col;j++) vec1[i][j]=5; 或者 1vector&lt;vector&lt;int&gt; &gt;vec(row,vector&lt;char&gt;(col,5)); 参考资料C++ 给vector去重的两种方法vector的几种初始化及赋值方式STL中erase()的用法","link":"/2020/05/19/vector%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"stack常用操作","text":"stack初始化方法123std::stack&lt;int&gt; q;std::stack&lt;int&gt; second(first); std::stack&lt;int, std;:vector&lt;int&gt;&gt; third; 使用vector初始化stack 交换swap将两个 stack的内容交换。这两个 stack的模板参数 T和 Container必须都相同。 12void swap(stack&amp; x) 重载1：x.swap(y)void swap(stack&amp; x, stack&amp; y) 重载2: swap(x, y) 常用操作12345q.push(element); 入栈q.pop(); 出栈q.top(); 返回栈顶成员q.size(); 返回栈成员个数q.empty(); 判断是否为空栈 参考资料C++ STL容器——stack用法介绍","link":"/2020/05/19/stack%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"queue常用操作","text":"queue初始化方法1queue&lt;int&gt;q; 交换swap(queue&lt;T&gt; &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(queue&lt;T&gt; &amp;x, queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作123456q.push(1); 入队列，无返回值q.pop(); 出队列，无返回值q.front(); 返回最上面（最后进入）的成员的引用q.back() 返回 queue 中最后一个元素的引用，但不删除该元素。q.size(); 返回队列成员个数q.empty(); 判断是否为空队列，bool 参考资料C++ queue(STL queue)用法详解","link":"/2020/05/19/queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"priority_queue常用操作","text":"概念priority_queue容器适配器定义了一个元素有序排列的队列。 默认队列头部的元素优先级最高。 因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。 如何定义“优先级”完全取决于我们自己。 模板1priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; priority_queue初始化方法123队列的排序，右边是出队列的地方priority_queue&lt;int&gt;q; 经常使用的，默认是less，元素大的优先级高。priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 元素小的优先级高。 交换swap(priority_queue&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 queue 中的元素和参数 priority_queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(priority_queue&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(priority_queue&lt;T&gt; &amp;x, priority_queue&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作12345q.push(element); 入优先级队列q.pop(); 出优先级队列q.top(); 返回优先级队列头成员q.size(); 返回优先级队列成员个数q.empty(); 是否为空 参考资料C++ priority_queue(STL priority_queue)用法详解","link":"/2020/05/19/priority-queue%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"set常用操作","text":"基本概念set是一个关联容器类型，用于以升序方式存储唯一值。 属于关联容器（关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。） 特性 遵循数学集合三特性，互异性、无序性、确定性。 底层数据结构为红黑树，有序，不重复 set 容器只是单纯的键的集合。每个元素仅包含一个键(key)，并有效地支持关于某个键是否存在的查询 set 容器存储的键也必须唯一，而且不能修改 set 容器以升序方式存储唯一值 set 不支持下标操作符 和map一样，set无法存储无法比较大小的数据； 头文件1# include&lt;set&gt; 模板1set&lt;int,greater&lt;int&gt; &gt;q; set初始化方法12set&lt;int&gt;q;set&lt;int&gt; numbers {8, 7, 6, 5, 4, 3, 2, 1}; 小的在前（less）/大的在前（greater）默认的比较函数是 less，因此容器中的元素会升序排列。 12set&lt;int, less&lt;int&gt;&gt; set1; 小的在前（less），升序set&lt;int, greater&lt;int&gt;&gt; set1; 大的在前（greater），降序 参考：C++ STL set greater less详解 交换swap(set&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(set&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(set&lt;T&gt; &amp;x, set&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入1234567int a[] = {1,2,3,4,5};set&lt;int&gt;q;q.insert(elem)); 集合中插入元素q.insert(a,a+5); 插入数组a至a+5的元素q.insert(pos, elem); 在容器中插入元素elem的一份拷贝，并返回新元素的iterator位置； q.insert(beg, end); 在容器中插入[beg, end)范围中所有元素的拷贝，没有返回值。 删除与清空123456q.erase(iterator pos); 删除集合中的元素 无返回值删除后pos不会自动++！被删除元素的迭代器，在删除之后失效！这里是和vector的区别q.erase(iterator first, iterator last); 移除迭代区间[first,last)内的所有元素，无返回值q.erase(value); 移除set容器内元素值为value的所有元素，返回移除元素的个数(size_type类型)q.clear(); 删除set容器中的所有的元素，无返回值 大小/是否为空123q.size(); 返回当前set容器中的元素个数q.max_size(); 返回set容器可能包含的元素最大个数q.empty(); 判断set容器是否为空 find和count12q.find(element); 返回element值位置的迭代器，找不到返回q.end()q.count(); 返回某个值元素的个数(根据set的特性，就是判断这个元素在不在，返回0或1) 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器 注意是set&lt;int,greater&lt;int&gt;&gt;::reverse_iteratorq.rend(); //返回头部反向迭代器 大于等于元素的迭代器12q.lower_bound(); 返回指向大于（或等于）某值的第一个元素的迭代器q.upper_bound(); 返回大于某个值元素的迭代器 参考资料C++ set初始化（STL set初始化）详解C++标准库容器类概述C++ STL set greater less详解 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/19/set%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"pair常用操作","text":"基本概念pair pair 是一个比较简单的模板类型，它只有两个 public 数据成员 first 和 second。 pair 对象可以封装任意类型的对象，可以生成任何想生成的 pair&lt;T1,T2&gt; 对象，可以是数组对象或者包含 pair&lt;T1,T2&gt; 的 vector 容器。例如，pair 可以封装两个序列容器或两个序列容器的指针。pair&lt;T1，T2&gt; 模板定义在 utility 头文件中，如果不想使用 map 而只想使用 pair 对象，可以包含这个头文件。 头文件123# include&lt;utility&gt;或者# include&lt;map&gt; 模板1pair&lt;const K, T&gt; q; pair初始化方法123456789pair&lt;int,int&gt;q; 创建一个空对pair&lt;int,int&gt;p(2,3); 创建一个对p，并分别赋值2，3pair&lt;int,int&gt;s(p); 创建一个对s，拷贝p给spair&lt;string, string&gt; anon; // holds two stringspair&lt;string, int&gt; word_count; // holds a string and an intpair&lt;string, vector&lt;int&gt; &gt; line; // holds string and vector&lt;int&gt;赋值利用make_pair函数q = make_pair(1,2); 如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。int初始化为0，string初始化为空； 交换swap(pair&lt;T1,T2&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 set 中的元素和参数 set 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(pair&lt;T1,T2&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (pair&lt;T1,T2&gt;&amp; x, pair&lt;T1,T2&gt;&amp; y) 重载2: swap(x, y) 123std::pair&lt;int,char&gt; foo (10,'a');std::pair&lt;int,char&gt; bar (90,'z');swap (foo,bar); 常用操作查找1234访问pair内元素操作 q.first; 返回成员第一个数据 q.second; 返回成员第二个数据 比较1p1 == p2 如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑 参考资料STL之pair类型详细分析C++ set初始化（STL set初始化）详解C++标准库容器类概述","link":"/2020/05/19/pair%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"map常用操作","text":"基本概念map map不能直接修改关键字，只能通过修改关键字的值间接修改关键字。 底层数据结构为红黑树，有序，不重复 map&lt;K，T&gt; 类模板定义在 map 文件头中，它定义了一个保存 T 类型对象的 map，每个 T 类型的对象都有一个关联的 K 类型的键。容器内对象的位置是通过比较键决定的。 头文件1# include&lt;map&gt; 模板12345678910template &lt; class Key, class T, class Pred = less&lt;Key&gt;, class A = allocator&lt;T&gt; &gt;class map{ ... typedef pair&lt; const Key, T &gt; value_type; ...};经常使用的，默认是lessmap&lt;int,double,less&lt;int&gt; &gt; MYMAP; 元素升序map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; 元素降序 pair初始化方法1234map&lt;int,int&gt; q;map&lt;k, v&gt; m; 创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 vmap&lt;k, v&gt; m(m2); 创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型map&lt;k, v&gt; m(b, e); 创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt; 交换swap(map&lt;K,V&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12template &lt;class T1, class T2&gt; void swap(map&lt;K,V&gt; &amp;x) 重载1：x.swap(y)template &lt;class T1, class T2&gt; void swap (map&lt;K,V&gt;&amp; x, map&lt;K,V&gt;&amp; y) 重载2: swap(x, y) map定义的类型123map&lt;K,V&gt;::key_type 在 map 容器中，用做索引的键的类型map&lt;K,V&gt;::mapped_type 在 map 容器中，键所关联的值的类型map&lt;K,V&gt;::value_type 一个 pair 类型，它的first 元素具有 const map&lt;K,V&gt;::key_type 类型，而 second 元素则为 map&lt;K,V&gt;::mapped_type 类型 常用操作使用下标访问 map 对象123map &lt;string, int&gt; word_count; // empty map// insert default initialzed element with key Anna; then assign 1 to its valueword_count[\"Anna\"] = 1; 存在则改变，不存在则加入 查找123456map&lt;int,int&gt;q;q.insert(pair&lt;int,int&gt;(1,2)); //通过pair进行插入操作q.insert(map&lt;int,int&gt;::value_type (1,2));//通过value_type进行插入q[1] = 2; //用数组方式进行插入三者不同的是，当map存在这个关键字时数组方式会覆盖关键字的值，而insert操作无法插入。 123m.insert(e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素m.insert(beg,end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。(返回 void 类型)m.insert(iter,e) e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。(返回一个迭代器，指向 m 中具有给定键的元素)。 比较函数12q.key_comp(); 返回比较元素key的函数q.value_comp(); 返回比较元素value的函数 大小与是否为空123q.size(); 返回容器内元素个数q.empty(); 判断容器是否为空q.max_size(); 返回可以容纳的最大元素个数 删除1234q.erase(iter); 删除迭代器iter的元素q.erase(iter1,iter2);删除[iter1,iter2)区间内的元素q.erase(key); 删除关键字为key的元素q.clear(); 清空容器 查找和计数12q.count(k) 返回 m 中 k 的出现次数,（map中有则返回1，否则0）q.find(k) 如果 m 容器中存在按 k 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器 使用 count 检查 map 对象中某键是否存在123int occurs = 0;if (word_count.count(\"foobar\")) occurs = word_count[\"foobar\"]; 迭代器1234q.begin(); //返回头位置迭代器q.end(); //返回尾位置迭代器q.rbegin(); //返回尾部反向迭代器q.rend(); //返回头部反向迭代器 查找迭代器123m.lower_bound();返回键值&gt;=给定元素的第一个位置 返回一个迭代器m.upper_bound();返回键值&gt;给定元素的第一个位置 返回一个迭代器m.equal_range();返回一个迭代器的 pair 对象。它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k) 初始化为0使用C++中的map容器定义一个mp，当你执行if语句判断mp[3]是否为1时，那么如果mp[3]以前不存在，此时mp[3]就会被无参初始化，second赋值为0。 123456789101112int main(){ vector&lt;int&gt; numbers; int n = numbers.size(); map&lt;int, int&gt; m; int count; for (int i = 0; i &lt; n; i++) { count = ++m[numbers[i]]; //这里原来元素是不存在的，但是却可以直接加1； if (count &gt; n/2) return numbers[i]; } return 0;} 参考资料关于map容器的元素被无参初始化《C++Primer》第十章-关联容器-学习笔记(1)-pair&amp;mapC++ map是什么C++标准库容器类概述","link":"/2020/05/19/map%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"list常用操作","text":"基本概念list 底层数据结构为双向链表，支持快速增删 缺点是无法通过位置来直接访问序列中的元素，也就是说，不能索引元素。为了访问 list 内部的一个元素，必须一个一个地遍历元素，通常从第一个元素或最后一个元素开始遍历。 节点对象维护了两个指针，一个指向前一个节点，另一个指向下一个节点。 第一个元素的前向指针总是为 null,因为它前面没有元素，尾部元素的后向指针也总为 null。 头文件1#include &lt;list&gt; 模板1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class list; list初始化方法12345list&lt;int&gt;q; //创建空Listlist&lt;int&gt;p(5); 创建拥有5个成员的Listlist&lt;int&gt;s(5,1); 创建拥有5个成员，且初始值为1的Listlist&lt;int&gt;s2(s); 创建s2，并拷贝s元素给s2list&lt;int&gt;s3(s.begin(),s.end()); 创建s3，拷贝s.begin()至s.end()中元素给s3 交换swap(list&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 map 中的元素和参数 map 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 123void swap(list&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap (list&lt;T&gt;&amp; x, list&lt;T&gt;&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个list 常用操作插入12345q.push_front(num) 返回值空 在list的头部添加一个元素 q.push_back(num) 返回值空 在list末尾增加一个元素。q.insert(iter,num) 在iter位置插入元素num。q.insert(iter,n,num) 在iter位置插入n个元素num。q.insert(iter,beg,end) 在iter位置插入区间为[beg,end)的元素。 大小与是否为空12345q.empty() 如果list是空的则返回trueq.max_size() 返回list能容纳的最大元素数量q.size() 返回list中的元素个数q.resize(n) 从新定义链表的长度,超出原始长度部分用0代替,小于原始部分删除。q.resize(n,num)从新定义链表的长度,超出原始长度部分用num代替。 删除与清空123456q.clear() 返回值空，删除所有元素 q.pop_back() 返回值空 删除最后一个元素q.pop_front() 返回值空 删除第一个元素q.erase(iter) 删除一个元素，并且返回下一个位置的迭代器q.remove(value) 从list删除元素 void remove ( const T&amp; value );q.remove_if(MATCH) 按指定条件删除元素 返回值为空void list::remove_if( MATCH ) 12iterator erase ( iterator position );iterator erase ( iterator first, iterator last ); list中remove和erase都是删除一个元素，其中remove参数类型和数据类型一致，而erase参数类型是迭代器。remove（aim）是删除链表中的aim元素，若有多个aim，都会删除，而erase（it）是删除迭代器指定位置的元素，并且返回下一个位置的迭代器来看例子。 查找12q.back() 返回最后一个元素 reference back ( );q.front() 返回第一个元素 reference front ( ); 迭代器1234q.begin() //返回指向第一个元素的迭代器q.end() //返回末尾的迭代器q.rbegin() //返回指向第一个元素的逆向迭代器q.rend() //指向list末尾的逆向迭代器 查找迭代器1q.get_allocator() //返回list的配置器 反转list1q.reverse() //把list的元素倒转 void reverse ( ); 合并两个listSTL list容器由于采用了双向迭代器，不支持随机访问，所以标准库的merge(), sort()等功能函数都不适用，list单独实现了merge()，sort()等函数。splice与merge 最大的不同:不用排序，也不要求原始链表有序。 相同点:被合并的链表或元素将消失。 123q.merge(p); 合并2个有序的链表并使之有序,从新放到q中,释放p。q.merge(p,comp); 合并2个有序的链表并使之按照自定义规则排序之后从新放到q中,释放p。q.splice() //合并两个list 12list1.merge(list2)在使用merge前，必须使list1和list2已经排好顺序。并且，合并之后list1仍然是有序的 splice是剪切，粘贴。用splice时当B与A合并后，B就为空。但是要记住：迭代器仍然指向原来的位置，即使原来的元素不存在了。 12345678将list2中的所有元素拷贝到list1中。在list1中的起始位置是it1.复制结束后，list2将为空。list1.splice(it1, list2); 将list2中的元素，从it2开始，剪切到list1的it1起始的地方。list1.splice(it1, list2, it2);将链表list2从开始到结束都合并到it1开始的位置。list1.splice(it1, list2, it2begin, it2end); 排序sort()1q.sort() 给list排序 返回值为空 一个自定义的类，那么如果想为这个类所生成的对象排序的话，因为list.sort()默认排序需要重载 &lt; 操作符。所以我们必须在类对象里重载这个操作符 删除list中重复的元素unique()1q.unique() 删除list中重复的元素 返回值为空 输出1copy(q.begin(),q.end(),ostream_iterator&lt;int&gt;(cout,\"\")); 参考资料STL 如何使用list::remove_if容器链表中splice()、merge()、insert()方法的区别c++ list 合并listSTL 中list的sort()方法使用总结(运算符重载)C++ list.merge()使用方法stl list中erase和remove区别std::list::sort()排序分析C++ list(STL list)使用、创建和初始化C++标准库容器类概述 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/20/list%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"C++运算符重载","text":"运算符重载重载的运算符是带有特殊名称的函数 函数名是由关键字 operator 和其后要重载的运算符符号构成的。 与其他函数一样，重载运算符有一个返回类型和一个参数列表。 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。 保持语义不变 不改变运算符的优先级 不改变运算符的结合性 不改变运算符需要的操作数 不能创建新的运算符 定义为类成员函数(令运算符重载函数作为类的成员函数)例子,这里是二元运算符，在类的内部，只需要传入一个外部元素。 1Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 定义为普通的非成员函数(令运算符重载函数作为类的友元函数)例子,这里是二元运算符，不在类里面，需要传入两个元素。 1Box operator+(const Box&amp;, const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。 这时候，就需要作为友元函数来操作类的对象了； 两种方式的区别区别在于令运算符重载函数作为类的成员函数在调用时只需输入一个被操作数参数即可，另一个操作数参数则不需要输入；令运算符重载函数作为类的友元函数在调用时不仅要求输入被操作数参数，还要求输入被操作数参数。 产生了这个区别的原因在于令运算符重载函数作为类的成员函数和令运算符重载函数作为类的友元函数有本质区别： (1)调用作为类的成员函数的运算符重载函数时，类对象肯定已经被建立了，这时对象中对应的私有数据成员存在。 (2)调用作为类的友元函数的运算符重载函数时，类对象还未被建立，这时对象中对应私有数据成员不存在。运算符重载的方法步骤运算符重载函数的参数个数 等于 运算符操作数的个数。但要注意，用成员函数重载时，对应于运算符左操作数的参数是默认传递的。 参数的顺序和左右操作数的顺序是一样的，这一点看看&lt;&lt; 和 &gt;&gt; 的重载就知道了。 tips重载一元运算符，在类的内部，不需要传入元素，参数为0。 重载++和–运算符号int类型参数只是用来区别后置++与前置++，此外没有任何其他作用。 令运算符重载函数作为类的友元函数重载前置运算符和重载后置运算符分别如何实现？答：也是一样的，传入参数多加一个int即可了 参考资料C++的运算符重载C++ 重载运算符和重载函数STL 中list的sort()方法使用总结STL 如何使用list::remove_ifC++ list.merge()使用方法","link":"/2020/05/20/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"C++变量初始化","text":"声明只是表明了变量的数据类型和属性，并不分配内存；定义则是需要分配内存的。 静态成员类的静态成员（static member）必须在类内声明，在类外初始化比如： 12345class A{ private: static int count ; // 类内声明 }; int A::count = 0 ; 类外初始化，不必再加static关键字 为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 类内初始化的成员能在类中初始化的成员只有一种，那就是静态常量成员。 1234class A{ private: static const int count = 0; 静态常量成员可以在类内初始化 }; 静态成员和常量成员不能在类内初始化。比如const int count = 0; 和static int count = 0;是不能在类里面初始化的。 总结静态常量数据成员static const int count: 可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化。 不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化； 静态非常量数据成员static int count: 只能在类外，即类的实现文件中初始化 不能在构造函数中初始化 不能在构造函数的初始化列表中初始化 非静态的常量数据成员const int count: 不能在类内初始化，也不能在构造函数中初始化， 只能且必须在构造函数的初始化列表中初始化； 非静态的非常量数据成员int count: 不能在类内初始化,不能在类外。 可以在构造函数中初始化 可以在构造函数的初始化列表中初始化 在类外定义的成员变量肯定是有static 关键字的。 初始化规则系统如何初始化取决于变量的类型以及变量定义的位置。 内置类型变量初始化 内置类型变量是否自动初始化取决于变量定义的位置。 函数体外定义的变量初始成0；（注意是主函数外） 函数体内定义的变量不进行自动初始化。 类类型变量初始化类类型变量在定义时，如果没有提供初始化式，则会自动调用默认构造函数进行初始化（不论变量在哪里定义，都会被初始化，只不过初始化为什么样子由编译器决定了）。如果某类型没有默认构造函数，则定义该类型对象时必须提供显示初始化式。 参考资料C++中静态变量的声明与初始化详解C++中变量的初始化规则C++的变量初始化","link":"/2020/05/20/C-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"单例模式C++实现","text":"单例模式singleton patternpurpose：使得一个类只能有一个实例，并提供一个全局访问的位置probliem：遇到实例的频繁创建和销毁时，效率低solution：创建时候检测实例是否存在key code：构造函数是私有的 如何选择懒汉和饿汉模式：特点与选择：懒汉：在访问量较小时，采用懒汉实现。这是以时间换空间。饿汉：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。 懒汉式单例模式代码（线程不安全）顾名思义，该模式只在你需要对象时才会生成单例对象(意思是太懒了，懒汉不到万不得已就不会去实例化类)缺点： 懒汉式是以时间换空间的方式。（在getInstance中new instance然后返回） 适用于单线程的环境！ 不是线程安全的！ 它不是线程安全的。假设当前有N个线程同时调用getInstance（）方法，由于当前还没有对象生成，所以一部分同时都进入步骤 2,那么就会由多个线程创建多个多个singleton对象。 123456789101112131415161718192021222324252627282930313233343536373839懒汉式单例模式- 私有静态指针，指向单例- 私有构造函数- 公有获取实例的静态函数# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance() { if (instance == NULL) 步骤 1 { instance = new singleton(); 步骤 2 return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } } private: static singleton * instance ; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = NULL;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();}//输出//instance initialized//instance has already initialized 饿汉式单例模式代码（线程安全）顾名思义，该模式在类被加载时就会实例化一个对象。（意思是有就吃，有加载个类的话，饿汉就直接在类里面建立） 饿汉式是以空间换时间的方式。（在静态区初始化instance，然后通过getInstance返回） 该模式能简单快速的创建一个单例对象，而且是线程安全的(只在类加载时才会初始化，以后都不会)。 缺点，就是不管你要不要都会直接创建一个对象，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单) 1234567891011121314151617181920212223# include &lt;iostream&gt;using namespace std;class singleton{ public: static singleton *getinstance(){ return instance; } private: static singleton *instance; singleton() { cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; }};singleton * singleton::instance = new singleton(); //关键的一步int main(){ singleton *singleton1 = singleton::getinstance(); singleton *singleton2 = singleton::getinstance();} 注意，这个单例在主函数之前就已经加载了，比如下面主函数输出的结果就是instance initialized。 123int main(){return 0;} 线程安全的懒汉式单例模式代码加了一个互斥锁 12345678910111213141516171819202122232425262728293031323334353637383940# include &lt;iostream&gt;# include &lt;mutex&gt;# include &lt;pthread.h&gt;using namespace std;class singleton{ public: static pthread_mutex_t mutex; static singleton *getinstance() { pthread_mutex_lock(&amp;mutex); if (instance == NULL) { instance = new singleton(); return instance; } else { cout &lt;&lt; \"instance has already initialized\" &lt;&lt; endl; return instance; } pthread_mutex_unlock(&amp;mutex); } private: static singleton * instance ; singleton() { pthread_mutex_init(&amp;mutex,NULL); //初始化为一个互斥锁 cout &lt;&lt; \"instance initialized\" &lt;&lt; endl; } };singleton * singleton::instance = NULL;pthread_mutex_t singleton::mutex;int main(){ singleton * singleton1 = singleton::getinstance(); singleton * singleton2 = singleton::getinstance();} 注意：互斥变量使用特定的数据类型：pthread_mutex_t线程函数编译时需要添加特殊编译选项：gcc read.c -lpthread 比如最简单的编译命令，记住要在后加-lpthread选项，否则会出现undefined reference to ‘pthread_mutex_lock’报错。 参考资料饿汉式和懒汉式（单例模式详解)C++ 单例模式(懒汉、饿汉模式)C++关于锁的总结（一）windows下std 没有成员 thread、thread not member of stdc++线程中的几种锁 本文许可证本文遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。","link":"/2020/05/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"},{"title":"音标发音","text":"清辅音与浊辅音 分类 音标 清辅音 发音时声带不振动的辅音，有/p/ /t/ /k/ /f/ /θ/ /s/ /ʃ/ /h/ /tʃ/ /ts/ /tr/ 浊辅音 发音时声带振动的辅音，有/b/ /d/ /g/ /v/ /ð/ /z/ /ʒ/ /r/ /dʒ/ /dz/ /dr/ /j/ /w/ /m/ /n/ /ŋ/ /l/ 二者区别 读一下/v/和/f/感受一下就知道了 /ts/ 清辅音 声带不震动 发“次”的音 牙齿轻咬，舌端贴住齿龈，堵住气流。然后舌尖略微下降，气流泄出。 /ð/ 浊辅音，发音时声带要稍微振动，发出声来，但不要送气。 口型助记： 外形则像舌头顶在上下牙齿之间。 英语中只有字母组合“th”会发这个音。 容易把它发成舌尖齿龈摩擦音/z/；还有些人误把它发成舌端齿龈破擦音/dz/，其实只要记住轻轻舌头顶住，就不会错。 /θ/ 清辅音，发音时把舌尖放在上下齿之间，舌尖轻触上齿，略略露出齿外，气流由舌齿间泻出，摩擦成音 口型助记：外形像上下牙齿咬着舌头。 英语中只有字母组合“th”发这个音。 容易把它发成“舌尖齿龈摩擦音”/s/，其实只要记住轻轻咬住舌尖，就不会错。 音标中辅音并不难，发音基本和汉语一样，需要注意的是[θ]和[ð]这两个，因为这两个发音在汉语里是没有的。可以毫不客气地说，在中国，80%以上学英语的人这两个发音都是发成[s]和[z]的 相关资源清辅音/ts/的发音方法浊辅音/ð/的发音方法如何用英语48个音标发音用中文谐音标示","link":"/2020/05/24/%E9%9F%B3%E6%A0%87%E5%8F%91%E9%9F%B3/"},{"title":"STL排序相关库","text":"sort函数声明 12345template &lt;class RandomAccessIterator&gt; void sort (RandomAccessIterator first, RandomAccessIterator last); template &lt;class RandomAccessIterator, class Compare&gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); cmp()函数的返回值要是bool，核心要义也是比较。sort默认是从小到大，所以在cmp如果还是要从小到大，那就a &lt; b，返回值bool为true，不改变；如果想要从大到小排，那么就要return a &gt; b，因为默认a小于b，所以此时返回的bool就是false，要改变排序。也就是说， 返回的值是true的话，代表a先放，b后放 返回的值是false的话，代表b先放，a后放 stable_sort排序的时候保持相对位置，即相同的数字相对位置是不变的。 partition函数声明 12template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred); 作用：对[first, last)元素进行处理，使得满足p的元素移到[first, last)前部，不满足的移到后部，返回第一个不满足p元素所在的迭代器，如果都满足的话返回last stable_partition排序的时候保持相对位置，即相同的数字相对位置是不变的 参考资料C++ STL算法随记：C++ sort()函数，自定义cmp()的使用理解STL—–排序类——sort与partitionC++ stl算法——partition","link":"/2020/05/24/STL%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E5%BA%93/"},{"title":"多线程编程-按序打印（leetcode 1114）","text":"题目描述 提供了一个类： 12345public class Foo { public void one() { print(\"one\"); } public void two() { print(\"two\"); } public void three() { print(\"three\"); }} 三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法 线程 B 将会调用 two() 方法 线程 C 将会调用 three() 方法 请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 题目解析多个线程在cpu中执行，运行不同的程序段，但是这些程序之间有先后关系： one()方法如果不运行完毕啊，就不能运行two()方法。 two()方法如果不运行完毕啊，就不能运行three()方法。 也属于并发的问题：并发主要为多任务情况设计。但如果应用不当，可能会引发一些漏洞。按照情况不同，可以分为三种： 竞态条件（Race Condition）：由于多进程之间的竞争执行，导致程序未按照期望的顺序输出。 死锁：并发程序等待一些必要资源，导致没有程序可以执行。 资源不足：进程被永久剥夺了运行所需的资源。 竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。最常见的竞态条件为：先检测后执行。（比如有一个if判断语句，多个线程都通过这个判断时候，下一步的执行可能造成各种奇怪的结果） 竞态条件的解决方案为：需要某些关键部分代码具有排他性，即在给定的时间内，只有一个线程可以进入关键部分代码。(可以将这种机制看做限制关键部分代码访问的锁) 在该机制下，一旦一个线程进入关键部分，它就可以阻止其他线程进入该关键部分。 如果该线程未被授权进入关键代码，可以认为该线程被阻塞或进入睡眠状态。 这种机制还具有唤醒其他等待线程的功能。 总之，为了防止出现并发竞争状态，需要一种具有两种功能的机制： 关键部分的访问控制。 通知阻塞线程。 代码实现方法1：使用 synchronization信号量和互斥锁(mutex)的区别：互斥锁只允许一个线程进入临界区，而信号量允许多个线程同时进入临界区。 12345678910111213141516171819202122232425262728293031#include &lt;semaphore.h&gt; 信号量Semaphore头文件class Foo {protected: sem_t firstJobDone; 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。 sem_t secondJobDone;public: Foo() { sem_init(&amp;firstJobDone, 0, 0); sem_init(&amp;secondJobDone, 0, 0); } void first(function&lt;void()&gt; printFirst) { printFirst(); sem_post(&amp;firstJobDone); } void second(function&lt;void()&gt; printSecond) { sem_wait(&amp;firstJobDone); printSecond(); sem_post(&amp;secondJobDone); } void third(function&lt;void()&gt; printThird) { sem_wait(&amp;secondJobDone); printThird(); }}; semaphore是由操作系统提供的。 LINUX下，一般是＃include&lt;asm/semaphore.h&gt; 或 ＃include&lt;semaphore.h&gt; Windows下，一般是windows.h 信号量的数据类型为结构sem_t，它本质上是一个长整型的数。sem_init：sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。 12345int sem_init(sem_t *sem, int pshared, unsigned int value);sem ：指向信号量对象pshared : 指明信号量的类型。不为0时此信号量在进程间共享，否则只能为当前进程的所有线程共享。value : 指定信号量值的大小sem_init() 成功时返回 0；错误时，返回 -1，并把 errno 设置为合适的值。 sem_post：sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的； 12int sem_post(sem_t *sem);sem_post() 成功时返回 0；错误时，信号量的值没有更改，-1 被返回，并设置 errno 来指明错误 sem_wait: sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。(也就是说是等于0时会阻塞操作) 1int sem_wait(sem_t *sem) 方法2：使用mutex加锁解锁1234567891011121314151617181920212223242526class Foo {public: Foo() { //构造函数先执行，将mutex变量进行加锁初始化。 m2.lock(); /首先给second()和third()上锁 m3.lock(); } void first(function&lt;void()&gt; printFirst) { printFirst(); m2.unlock(); /first()运行完了就解开second()的锁 } void second(function&lt;void()&gt; printSecond) { m2.lock(); 这里是锁的入口，如果已经上锁了，就不能执行了，如果没有，就可以执行下一步，并把锁值0置为1 printSecond(); m3.unlock(); //second()运行完了就解开third()的锁 } void third(function&lt;void()&gt; printThird) { m3.lock(); printThird(); m3.unlock(); }private: std::mutex m2, m3; }; 参考资料力扣（LeetCode）C++多线程同步之Semaphore(信号量)进程间通信方式——信号量（Semaphore）线程同步之信号量（sem_init,sem_post,sem_wait）","link":"/2020/05/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%88leetcode-1114%EF%BC%89/"},{"title":"deque常用操作","text":"概念Deque（双向队列） 和Queue差不多 ,但是特殊的是Deque可是扩充内存。（实际上连续内存的容器不能随意扩充，所以Deque也不是真正意义上的扩充内存，而是封装了底层的表象。 Deque是由一段段构成的，当走到尾端时自动跳到下一段，（支持迭代器++操作）。 每次扩充，就会申请一个段，从而实现了内存连续的假象。 默认的stack 和 queue 都基于 deque 容器实现， priority_queue 则基于 vector 容器实现。对于给定的适配器，其关联的容器必须满足一定的约束条件。 stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在vector、list 或者 deque 容器之上。 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 或deque容器上，而不能建立在vector 容器上。 priority_queue 适配器要求提供随机访问功能，因此可建立在vector 或 deque 容器上，但不能建立在 list 容器上。 特性 deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。 deque 容器也可以根据需要修改自身的容量和大小。 缺点：频繁的插入删除时候，Deque并不适合。 Deque采用分块线型结构存储数据，两个迭代器分别指向首尾元素，而且拥有具有高效的push_back(),push_front()函数。 正因如此，所以Deque不易实现capacity和reverse函数。 头文件1#include &lt;deque&gt; 模板deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。 set初始化方法1234567int num[] = {1,2,3,4,5,6};deque&lt;int&gt; di{1,2,3,4,5};deque&lt;int&gt;q; 创建一个空双向队列 deque&lt;T&gt; deqT;默认构造形式deque&lt;int&gt;p(5); 创建一个具有5个成员的双向队列deque&lt;int&gt;s(5,1); 创建一个具有5个成员且初始值为1的双向队列 deque(n, elem);构造函数将n个elem拷贝给本身deque&lt;int&gt;s2(s); 创建一个双向队列s2，并拷贝s中所有成员 deque(const deque &amp;deq);拷贝构造函数。deque&lt;int&gt;n(num,num+5); 创建一个双向队列n，并拷贝num至num+5中元素入队 deque(beg, end);构造函数将[beg, end)区间中的元素拷贝给本身。 交换swap(deque&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 deque 中的元素和参数 deque 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 12void swap(deque&lt;T&gt; &amp;x) 重载1：x.swap(y)void swap(deque&lt;T&gt; &amp;x, deque&lt;T&gt; &amp;y) 重载2: swap(x, y) 常用操作插入操作123q.push_front(a); 头部入队q.push_back(b); 尾部入队q.insert(iter,x); 在iter位置插入x，iter为迭代器 覆盖12q.assign(n,x); 将n个x赋值到deque中，并清空deque容器之前的内容。q.assign(iter1,iter2); 将区间[iter1，iter2)内元素赋值给deque，并清空deque容器之前的内容。 删除与清空操作12345q.pop_front(); 头部出队q.pop_back(); 尾部出队q.clear(); 清空双向队列q.erase(iter); 删除iter元素，iter为迭代器q.erase(beg,end);删除[beg,end)区间的数据，返回下一个数据的位置。 deque数据存取1234q.front(); 返回头成员q.back(); 返回尾元素q.at(idx); 返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[]; 返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 大小/是否为空123q.size(); 返回双向队列成员个数q.max_size(); 返回系统支持成员最大个数q.empty(); 判断双向队列是否为空 迭代器12345678q.begin(); 返回头部迭代器q.end(); 返回尾部迭代器q.rbegin(); 返回尾部反向迭代器q.rend(); 返回头部反向迭代器q.cbegin(); 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.cend(); 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crbegin();和rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。q.crend(); 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 参考资料C++ STL deque容器底层实现原理（深度剖析）STL教程：C++ STL快速入门（非常详细）[C++ STL]deque使用详解C++ deque的用法与示例//解释的图片不错《C++Primer》第九章-顺序容器-学习笔记(3)-容器适配器&amp;栈&amp;队列","link":"/2020/06/01/deque%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"红黑树详解","text":"二叉查找树学习红黑树之前，先理解一下二叉查找树。 二叉查找树（BST）具备什么特性呢？ 左子树上所有结点的值均小于或等于它的根结点的值。 右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 查找和插入的过程类似于二分查找的思想，查找所需的最大次数等于二叉树的深度 二叉查找树（BST）缺点有哪些？主要体现在插入新的节点的时候假设初始的二叉查找树只有三个结点，根结点值为9，左孩子值为8，右孩子值为12：接下来我们依次插入如下五个结点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？最终的二叉查找树会非常的不平衡，左子树的深度为6，右边子树的深度为1（一棵好端端的树变成了瘸子，两边的子树不均衡了），这样会导致查找的性能大打折扣，几乎变成了线性查找； 二叉查找树的删除操作 待删除的结点没有子结点：节点没有孩子，因此直接删除即可。 待删除的结点有一个孩子：只有左孩子，于是我们让左孩子结点A取代被删除的结点，结点A以下的结点关系无需变动。（右孩子也是一样的） 待删除的结点有两个孩子：这种情况比较复杂。此时，我们需要选择与待删除结点最接近的结点来取代它。 AVL树与红黑树的差别AVL是严格平衡的二叉树，要求每个节点的左右子树高度差不超过1；红黑树更宽松一些，要求任一一条路径的长度都不超过其他路径长度的两倍。正因为这个差别AVL的查找效率更高，但是平衡调整的成本也更高。在需要频繁查找时，选用AVL树更合适，频繁插入删除时，选用红黑树更合适。 红黑树目的红黑树主要是为了解决上面的问题（可以说是一种策略，通过红黑树算法，让二叉查找树变成平衡二叉查找树） 概念红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。红黑树针对AVL树的不足（AVL树删除操作之后的重新平衡可能需要做到多达O(lon n)次旋转，从而频繁地导致全树的整体拓扑结构的大幅变化）进行了改进。红黑树保证：每次插入或者删除之后的重新平衡过程，全树拓扑结构的更新仅仅涉及常数个节点。尽管最坏情况下也需要对多达O(lon n)个节点重新染色，但是就分摊意义而言，仅仅为O(1)个。红黑树的适度平衡标准：任一节点左右子树的高度不得超过两倍。（由下面这五条规则来保证）除了符合二叉查找树的特性之外，还具体下列的特性： 结点是红色或者黑色 根结点是黑色 每个叶子的节点都是黑色的空结点（NULL）//这些是引入的外部节点，使得二叉树扩展为真二叉树 每个红色结点的两个子结点都是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色结点） 从任意结点到其每个叶子的所有路径都包含相同的黑色结点。 引申: 红节点都是树的内部结点，根节点和外部结点（叶结点）都是黑结点//由第(1)(2)两条规则可知 红节点的孩子不可能是红节点，也就是说红节点的父亲必为黑节点，从每个叶子到根的所有路径上不能有两个连续的红色结点//由第(3)两条规则可知 从根节点到任一节点的途中，黑节点都不少于红节点 从任一节点到其任一后代外部节点的沿途，黑节点的总数亦必相等。//由第(4)两条规则可知 //根节点深度解释为1，更好理解；解释为0，更好计算；我们在这里采用后者黑深度（black depth）从上向下描述： 从根节点到任一节点的途中，黑节点都不少于红节点，除去根节点本身，沿途所经过的黑节点的总数成为黑深度 所有外部节点的黑深度统一 黑高度（black height）从下向上描述： 从任一节点到其任一后代外部节点的沿途，除去外部节点（黑色），沿途所经过的黑节点的总数称为该节点的黑高度。 所有外部节点的黑高度统一，均为0 插入和删除当插入和删除节点的时候，红黑树的规则可能会被打破，这时候就需要做出一些调整，从而继续维持我们的规则什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子：这个例子去找一下图吧例如上面标准的红黑树，插入值为14的节点。插入之后发现仍然满足红黑树的要求！但是如果插入值为21的节点呢？由于父结点22是红色结点（插入的节点默认是红色是因为如果是黑色可能会影响规则5），因此这种情况打破了红黑树的规则4（每个红色结点的两个子结点都是黑色），必须进行调整，使之重新符合红黑树的规则。 调整红黑树的方法 开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也和玩魔方一样。红黑树有两大操作: recolor (重新标记黑色或红色) rotation (旋转，这是树达到平衡的关键)- 左旋转 - 右旋转 左旋的示意图逆时针旋转红黑树的两个结点，使得父结点被自己的右孩子取代，而自己成为自己的左孩子。 右旋的示意图顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己成为自己的右孩子。 示例为了符合红黑树的规则，会把节点红变黑或者黑变红。下图展示的是红黑树的部分，需要注意节点25并非根节点。因为21和22链接出现红色，不符合规则4，所以把22红变黑：但这样还是不符合规则5（但是，仅仅把一个结点变色，会导致相关路径凭空多出一个黑色结点，这样就打破了规则5。），所以需要把25黑变红，看下图：但是25和27仍然是红色，不满规则4，所以需要将27变为黑色但这只是局部结束了，全局仍然不能满足条件，15和17仍然是两个连续的红节点，不满足规则4，把17变黑也不行，因为13根节点为黑色，其子节点必为红色。只能进行旋转了！按照左旋转，对上边已经变色完成之后图进行左旋转。旋转之后，由于根节点是红色，需要变黑色但是仍然不满足规则5，接下来使用右旋转最后一个步骤，变色我晕，这也太复杂了！！！！ 红黑树插入节点的5种情况 新结点（A）位于树根，没有父结点。 //这种局面，直接让新结点变色为黑色， 新结点（B）的父结点是黑色。 //这种局面，新插入的红色结点B并没有打破红黑树的规则，所以不需要做任何调整。 新结点（D）的父结点和叔叔(父节点的兄弟)结点都是红色。 //参照下面的总结 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。 4.1 以结点B为轴，做一次左旋转，使得新结点D成为父结点，原来的父结点B成为D的左孩子,变成了局面5. 新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。 5.1 我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子。接下来，我们让结点B变为黑色，结点A变为红色。 红黑树，超强动静图详解，简单易懂概括起来就是假设我们插入的新节点为 X 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1. 如果 X 的 uncle (叔叔) 是红色3.11. 将 parent 和 uncle 标记为黑色 3.12. 将 grand parent (祖父) 标记为红色 3.13. 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 3.2. 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理。//刚刚说了 X 的 uncle 是红色的情况，接下来要说是黑色的情况3.21. 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.22. 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.23. 右右 (和 3.21镜像过来，恰好相反) 3.24. 右左 (和 3.22镜像过来，恰好相反) 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 红黑树删除节点的5种情况第一步：如果待删除结点有两个非空的孩子结点，转化成待删除结点只有一个孩子（或没有孩子）的情况。 第二步：根据待删除结点和其唯一子结点的颜色，分情况处理。 自身是红色，子结点是黑色： 自身是黑色，子结点是红色： 自身是黑色，子结点也是黑色，或者子结点是空叶子结点： 第三步：遇到双黑结点，在子结点顶替父结点之后，分成6种子情况处理。 结点2是红黑树的根结点： 结点2的父亲、兄弟、侄子结点都是黑色： 结点2的兄弟结点是红色： 结点2的父结点是红色，兄弟和侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，左侄子结点是红色，右侄子结点是黑色： 结点2的父结点随意，兄弟结点B是黑色右孩子，右侄子结点是红色： 上面的描述过于复杂，还是看图解吧！漫画：什么是红黑树？（完整版） 总结参考资料漫画：什么是红黑树？（完整版）漫画算法：5分钟搞明白红黑树到底是什么？30张图带你彻底理解红黑树红黑树(一)之 原理和算法详细介绍红黑树，超强动静图详解，简单易懂//这个讲的比较好数据结构 邓俊辉","link":"/2020/06/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"B树与B+树详解","text":"基本概念多路搜索树（multi-way search tree）： 将传统的二叉搜索树，改造为多路搜索树——在中序的遍历下，这也是一种等价变换 以k层为间隔如此重组，可以将二叉搜索树转化为等价的2^k路搜索树，统称为多路搜索树。 多路搜索树同样支持查找等操作，而且效果与原来的二叉树完全等同；但是重要的是，其对外存的访问方式已经发生本质变化，是以大节点为单位从外存读取一组（而不是单个）关键码。 B树就是B-树： B-树就是B树，中间的横线不是减号，直接读成B树即可。 有的文章里出现的B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，而事实上是，B-tree就是指的B树。 B树是一种多路平衡搜索树，它的每一个节点最多包含K个孩子，k被称为B树的阶。 k的大小取决于磁盘页的大小 B树比较矮胖，扁平化，B-树的宽度往往大于其高度 B+树： 是应文件系统所需而产生的一种B-tree的变形树。 应用数据库索引主要基于什么数据结构？hash表和B+树 数据库索引为什么要用B+树结构来存储呢？树的查询效率高。而且可以保持有序。但是为什么不用二叉查找树呢？主要是因为磁盘I/O的影响，数据库索引是存储在磁盘上的，当数据量比较大的时候，索引的大小可能有几个G甚至更多。当我们利用索引查询时候，能把整个索引全部加载到内存吗？很显然不可能的，我们能做的是逐一加载每一个磁盘页，这里的磁盘页面对应着索引树的节点。这样的话，每遍历到一个节点就需要进行一次I/O操作。磁盘这种外部存储器适合批量式的访问，为了减少I/O，我们需要把原本瘦高的树结构变得矮胖，这就是B-树的特征之一。 大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的，如何减少树的深度？一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的） B-树主要应用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。 B-树（Balance Tree）所谓m阶B-树，即为m路平衡搜索树（m大于等于2）,除了根节点，各个节点的分支数目介于[M/2向上取整, M]。M为设定的非叶子结点最多子树个数，N为关键字总数。由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的利用率，其最底搜索性能为：O(log n) 根结点至少有两个子女。 子节点数：每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 关键字数：每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 所有的叶子结点都位于同一层。叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null（可以把这些null看成外部节点） 排序方式：每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B-树的特性 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制； 举一个B-树的例子，一个3阶的B-树，也就是(2,3)-树对于这颗树查询的过程比较次数不比二叉查找树少，尤其当单一节点中的元素数量很多的时候，可是相对于磁盘I/O，内存中的比较耗时几乎可以忽略，所以可以提升查找的性能。 B-树插入优势，自平衡遵循规则： 节点拆分规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须&lt;=3-1（这里关键字数&gt;2就要进行节点拆分，拆分的规则是把中间的元素提取出，放到父节点上，左边的单独构成一个节点，右边的单独构成一个节点）； 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则; 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 B-树删除遵循规则： 节点合并规则：当前是要组成一个3路查找树，那么此时m=3,关键字数必须大于等于ceil（3/2）（这里关键字数&lt;1就要进行节点合并）； 满足节点本身比左边节点大，比右边节点小的排序规则; 关键字数小于1时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 自顶向下查找元素11的节点位置。删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋 B-树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B-树中的卫星数据（Satellite Information）:无论是叶子节点还是中间节点都带有卫星数据。 B-树的范围查找过程比方对于上面的B-树，我们想查找3到11的元素，只能依靠繁琐的中序遍历。 B+树（ Tree）B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码； 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 一个m阶的B+树具有如下几个特征： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 示例 B+的特性 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； B+树插入 B+树中的卫星数据卫星数据（Satellite Information）:指的是索引元素所指向的数据记录，比如数据的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。B+树中的卫星数据（Satellite Information）:只有叶子节点带有卫星数据。中间节点仅仅是索引，没有任何关联数据。需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树的范围查找过程相对于B-树要简单的多，只需要在链表上做遍历即可！ B树与B+树的优点B+树的优点：由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 B+树的层级更少：单一节点存储更多的元素，使得查询的IO次数更少，相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；。 B+树查询速度更稳定：所有查询都要查找到叶子节点，查询性能稳定。 B+树天然具备排序功能：所有叶子节点形成有序链表，便于范围查询。 B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树的优点: 由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B树和B+树的区别 B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这就意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时候的I/O次数也越少。 B+树的查询必须查到叶子节点，而B-树只要找到匹配元素即可。因此B-树的查找性能并不稳定，最坏情况是查找到叶子节点。而B+树的每一次查找都是稳定的。 为什么说B+树比B树更适合数据库索引？B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B+树的范围查询更加方便：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。 总结 B-树和B+树都是很基础的概念，需要掌握好啊！ 二叉搜索树： 二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B（B-）树： 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树： 在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树： 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3 参考资料漫画：什么是B+树？从B树、B+树、B*树谈到R 树平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了漫画：什么是B-树？从二叉查找树到B+树中间的各种树 //写的相当不错B-树 百度百科阿里面试，问了B+树，这个回答让我通过了数据结构 邓俊辉","link":"/2020/06/03/B%E6%A0%91%E4%B8%8EB+%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"title":"string常用操作","text":"基本概念标准库 string 类型：string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。size_type是一个依赖于实现的整型，是在string中定义的。string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。另外，使用缩写NBTS（null-terminated string）来表示以空字符结束的字符串。 头文件1#include &lt;string&gt; 模板123//The string class is an instantiation of the basic_string class template, defined in &lt;string&gt; as:typedef basic_string&lt;char&gt; string;string实际上是basic_string&lt;char&gt;的一个typedef，同时省略了与内存管理相关的参数。 string初始化方法1234string s1; 默认构造函数 s1 为空串string s2(s1); 将 s2初始化为 s1 的一个副本string s3(“value”); 将 s3 初始化为一个字符串字面值副本string s4(n, ‘c’); 将 s4 初始化为字符 ‘c’ 的 n 个副本 注意！因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。 c-style字符转换1s.c_str(); 返回指向以null结尾的字符数组的指针，其数据与存储在字符串中的数据相同 交换swap(string&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同。：将当前 string中的元素和参数 string 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 1234void swap(string &amp;x) 重载1：x.swap(y)void swap (string&amp; x, string&amp; y) 重载2: swap(x, y)q.swap(p) //交换两个string所有迭代器和引用都可能无效 常用操作读写操作对于string类型变量s的输入： 1cin &gt;&gt; s; 从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符： 读取并忽略开头所有的空白字符（如空格，换行符，制表符）。 读取字符直至再次遇到空白字符，读取终止。 读入未知数目的string 对象1234string word;程序将从标准输入读取一组 string 对象，然后在标准输出上逐行输出：while (cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl; 上例中，用输入操作符来读取 string 对象。该操作符返回所读的istream 对象，并在读取结束后，作为 while 的判断条件。如果输入流是有效的，即还未到达文件尾且未遇到无效输入，则执行 while 循环体，并将读取到的字符串输出到标准输出。如果到达了文件尾，则跳出 while 循环。 使用getline 读取整行文本123string line; // read line at time until end-of-filewhile (getline(cin, line)) //循环读取输入流 cout &lt;&lt; line &lt;&lt; endl; 赋值1234// st1 is an empty string, st2 is a copy of the literalstring st1, st2 = \"The expense of spirit\";st1 = st2; // replace st1 by a copy of st2它必须先把 st1 占用的相关内存释放掉，然后再分配给 st2 足够存放 st2 副本的内存空间，最后把 st2 中的所有字符复制到新分配的内存空间。 和字符串字面值的连接当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的： 1234567string s1 = \"hello\"; // no punctuationstring s2 = \"world\";string s3 = s1 + \", \"; // ok: adding a string and a literalstring s4 = \"hello\" + \", \"; // error: no string operand s4 的初始化试图将两个字符串字面值相加，因此是非法的string s5 = s1 + \", \" + \"world\"; // ok: each + has string operandstring s6 = \"hello\" + \", \" + s2; // error: can't add string literals s6 的初始化是非法的。依次来看每个子表达式，则第一个子表达式试图把两个字符串字面值连接起来。这是不允许的，因此这个语句是错误的。 大小与是否为空123456789s.empty(); true如果字符串为空, 否则返回falses.size(); 字符串中CharT元素的数量s.length(); 字符串中CharT元素的数量s.capacity(); 返回字符串当前为其分配空间的字符数s.max_size(); 返回string对象能够容纳的字符的最大数目s.resize(size_t n, char c); 用来改变string的大小，如果size小于原来string的size大小，则截取前面的size个字符，如果大于，则用空格填充。s.resize(size_t n); s.reserve(size_t res_arg=0);为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小。 s.shrink_to_fit() 请求删除未使用的容量 注意： resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。 size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。 插入追加覆盖12345s.append(args); 将args追加到s.返回一个指向s的引用.s.assign(args); 将s中的字符替换为args指定的字符.返回一个指向s的引用.s.push_back(char c); 在末尾添加一个元素，返回值为空string&amp; insert ( size_t pos1, size_t n, char c ); 在字符串pos1位置，插入n次c字符。 size_t copy ( char* s, size_t n, size_t pos = 0) const; 从pos位置开始，复制n个字符到s指针指向的内存； insert1234567891011121314 string str=\"to be question\"; string str2=\"the \"; string str3=\"or not to be\"; string::iterator it; // used in the same order as described above: str.insert(6,str2); // to be (the )question str.insert(6,str3,3,4); // to be (not )the question str.insert(10,\"that is cool\",8); // to be not (that is )the question str.insert(10,\"to be \"); // to be not (to be )that is the question str.insert(15,1,':'); // to be not to be(:) that is the question it = str.insert(str.begin()+5,','); // to be(,) not to be: that is the question str.insert (str.end(),3,'.'); // to be, not to be: that is the question(...) str.insert (it+2,str3.begin(),str3.begin()+3); // (or )Output:to be, or not to be: that is the question... append()123456789101112 string str; string str2=\"Writing \"; string str3=\"print 10 and then 5 more\"; str.append(str2); // \"Writing \" str.append(str3,6,3); // \"10 \" str.append(\"dots are cool\",5); // \"dots \" str.append(\"here: \"); // \"here: \" str.append(10,'.'); // \"..........\" str.append(str3.begin()+8,str3.end()); // \" and then 5 more\" str.append&lt;int&gt;(5,0x2E); // \".....\"Output: Writing 10 dots here: .......... and then 5 more..... 查找12345s[index]; s.at(index); index是下标 size_t find (char c, size_t pos =0) const; 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置size_t rfind(char c, size_t pos = npos); 反向查找，从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置string substr(size_t pos = 0, size_t n= npos)const; 在str中从pos位置开始，截取n个字符，然后将其返回 删除与清空12345s.clear() 从字符串中删除所有字符, clear()只是将string中有效字符清空，不改变底层空间大小。s.erase(pos,len); 删除从位置pos开始的len个字符,如果len被省略,则删除从pos开始直至s末尾的所有字符.返回一个指向s的引用.iterator erase (const_iterator p); 删除源字符串中迭代器p指向的字符，返回删除后迭代器的位置。iterator erase (const_iterator first, const_iterator last); 删除源字符串迭代器范围为[first，last）内的所有字符，返回删除后迭代器的位置。s.pop_back(); 删除源字符串的最后一个字符，有效的减少它的长度。 数值转换为string1234567891011s=std::to_string(int/double/...);string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); 迭代器与指针12345678s.data(); 返回指向字符串第一个字符的指针s.begin(); 返回字符串第一个字符的迭代器,consts.cbegin(); 返回字符串第一个字符的迭代器s.end(); 返回字符串最后一个字符的后面一个位置的迭代器s.cend(); 返回字符串最后一个字符的后面一个位置的迭代器,consts.rbegin(); 反向迭代器s.rend(); 反向迭代器string::npos 相当于s.end() string 对象中字符的处理我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下表列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 cctype 头文件中定义。注意这里的”cctype”就是C++中使用C标准的头文件的写法，等价于”ctype.h” 操作 功能描述 isalnum( c ) 如果 c 是字母或数字，则为 True。 isalpha( c ) 如果 c 是字母，则为 true。 iscntrl( c ) 如果 c 是控制字符，则为 true isdigit( c ) 如果 c 是数字，则为 true。 isgraph( c ) 如果 c 不是空格，但可打印，则为 true。 islower( c ) 如果 c 是小写字母，则为 true。 isprint( c ) 如果 c 是可打印的字符，则为 true。 ispunct( c ) 如果 c 是标点符号，则 true。 isspace( c ) 如果 c 是空白字符，则为 true。 isupper( c ) 如果 c 是大写字母，则 true。 isxdigit( c ) 如果是 c 十六进制数，则为 true。 tolower( c ) 如果 c 大写字母，返回其小写字母形式，否则直接返回 c。 toupper( c ) 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c。 列出了各种字符操作函数 表中的大部分函数是测试一个给定的字符是否符合条件，并返回一个 int 作为真值。如果测试失败，则该函数返回 0 ，否则返回一个（无意义的）非 0 ，表示被测字符符合条件。 参考资料《C++Primer》第三章-标准库类型-学习笔记(1)-string&amp;vector&amp;迭代器C++ STL丨string 基本使用（一）STL string常用操作指令C++——string类和标准模板库【C++】String类、String类的常用接口说明及其使用、STL中的迭代器使用c/c++ reference","link":"/2020/06/06/string%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"《复杂》阅读笔记","text":"《复杂》简单讲述了复杂系统科学尝试去回答的迷人与令人费解的问题的一部分。 度量一个事物或过程的复杂性的三个维度描述它有多困难 产生它有多困难 其组织程度如何 物理学家克劳德 模型是什么？科学中是某种实在现象的简化表述模型是我们的思维方式 是用我们熟悉的思维概念解释观察到的现象； 无尺度特性《复杂性》这本书详细解释了什么是无尺度；改变图的尺度，图的形状是不变化的；例子：给定一个大型的样例网络，使用直方图来观察度的分布入度作为横轴，频率作为纵轴1000-1000010000-100000100000-1000000然上面几个图的分布情况曲线的形状几乎一样。这样的分布是自相似的，因为不管在哪种尺度下进行绘制，形状都是一样的——也就是在不同的尺度下具有不变性——就是无尺度一词的由来（无标度）无尺度网络对节点的随机删除具有稳健性，但是如果中心节点失效或是受到攻击就会非常脆弱。 如果你发现某种量遵循幂律分布，你就可以猜想这是某种自相似或分形系统导致的；尽可能填充空间的几何对象其实就是分形分支结构——在所有尺度上的自相似意味着空间在所有尺度上都被同等填充。 偏好依附（Preferential attachment）接下来一个很重要的概念是偏好依附。偏好依附（Preferential attachment）//一种网络生长机制巴拉巴西和艾伯特提出了一种他们称之为“偏好依附”的生成机制，用来解释幂律分布；其中的思想是：网络在生长的时候。连接度高的节点比连接度低的节点更有可能得到新的连接；//直观上说，朋友越多的人，越可能认识新的朋友。网页的入度越高，就越容易被找到； 连锁失效如果某个节点失效了，它的工作就会转移到其他节点，这有可能使得其他节点因为负荷过重而失效，它的工作就会转移到未失效的顶点~","link":"/2020/06/06/%E3%80%8A%E5%A4%8D%E6%9D%82%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"计算机网络教程-传输层概述","text":"传输层 传输层是客户程序和服务器程序之间的联络人，是一个进程到进程的连接。 传输层是TCP/IP 协议簇中的核心； 它是因特网上从一点到另一个点传输数据的端到端逻辑传输媒介。 传输层提供的一般服务进程到进程通信传输层协议的首要任务是提供进程到进程通信（process-to-process communication）。 主机间通信与进程间通信的不同:网络层负责计算机层次的通信（主机到主机通信）。网络层协议只把报文传递到目的计算机。然而，这是不完整的传递。报文仍然需要递交给正确的进程。这正是传输层接管的部分。传输层协议负责将报文传输到正确的进程。 寻址：端口号对通信来说，我们必须定义本地主机、本地进程、远程主机以及远程进程。IP 地址来定义本地主机和远程主机。端口号（port number）来定义进程。TCP/IP 协议簇中，端口号是在0 到65 535 之间的16 位整数。 客户程序用端口号定义它自己，这称为临时端口号（ephemeral port number）。临时这个词表示短期的（short-lived），它之所以被使用是因为客户的生命周期通常很短。为了客户-服务器程序能正常工作，临时端口号推荐值为大于1023。 服务器进程端口号不能随机选择。（因为随机分配的话导致客户端不知道端口号），TCP/IP 决定使用全局端口号，它们称为熟知端口号（well-known port number）。 ICANN 端口范围ICANN已经把端口号编码划分为三种范围：熟知的、注册的和动态的（或私有的） 熟知端口：端口号0~1023，由ICANN 分配和控制。这些是熟知端口号。 在 UNIX 中，熟知端口号存储在/etc/services 文件中，这个文件的每行给出服务器名和熟知端口号 注册端口：端口号1024~49151，ICANN 不分配也不控制。它们可在ICANN 注册以防重复。 动态端口：端口号49152~65535。这一范围内的端口号既不受控制又不需要注册，可以由任何进程使用。它们是临时或私有端口号。49152是2的14次方乘3 套接字地址在 TCP 协议簇中的传输层协议需要IP 地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来称为套接字地址（socket address）。客户套接字地址唯一定义了客户进程;服务器套接字地址唯一地定义了服务器进程;为了使用因特网中的传输层服务，我们需要一对套接字地址：客户套接字地址和服务器套接字地址。 多路复用和多路分解多路复用（multiplexing，多对一）： 多个数据项从多个源发出，一个实体接收它们，然后负责传输。； 指多个应用程序共享同一个传输层建立的连接进行数据的传送，在传输层是通过什么来区分不同的应用程序的（通过端口） 源端的传输层执行复用； 多路分解（demultiplexing，一对多）： 每当一个实体将数据项传递到一个以上的源时。 目的端的传输层执行多路分解 流量控制每当一个实体创建数据项并且有另一个实体消耗它们时，就存在生产速率和消费速率的平衡问题。 如果数据项生产比消费快，那么消费者可能被淹没并且可能要丢弃一些数据项。 如果数据项生产比消费慢，那么消费者必须等待，系统就会变得低效。 流量控制与第一种情况相关。我们需要在消费者端防止丢失数据项。 生产者到消费者消息传输两种方式推（push）:每当发送方生产数据项时，它无须事前获得消费者的请求就会发送它们——这种传递称为推。需要流量控制：当生产者推数据项时，消费者可能被淹没并需要相反方向的流量控制，以此来防止丢弃这些数据项。 拉（pull）:如果生产者在消费者请求这些数据项之后进行发送，这种传递称为拉。不需要流量控制：当消费者拉数据项，它会在自身做好准备时进行请求。在这种情况下，不需要流量控制。 传输层流量控制在传输层通信中，我们需要处理四个实体：发送方进程、发送方传输层、接收方传输层和接收方进程。应用层的发送方进程仅仅是一个生产者。它生产报文块，并把它们推到传输层。发送方传输层有两个作用：是消费者：它消费生产者推来的报文。也是生产者：它将报文封装进分组并传递到接收方传输层。接收方传输有两个作用：是消费者：消费从发送方那里接收来的分组；也是生产者：解封装报文并传递到应用层。然而，最后的传递通常是拉传递；传输层等待直到应用层进程请求报文。 我们至少需要两种流量控制： 从发送方传输层到发送方应用层的流量控制。 从接收方传输层到发送方传输层的流量控制。 这里看图即可： 缓冲区流量控制可以用多种方式实现，但通常的方式是使用两个缓冲区：一个位于发送方传输层，另一个位于接收方传输层。缓冲区是一组内存单元，它可以在发送端和接收端存储分组。消费者向生产者发送信号从而进行流量控制通信。 当发送方传输层的缓冲区已满，它就通知应用层停止传输报文块；当有空闲位置时，它通知应用层可以再次传输报文块。当接收方传输层的缓冲区已满，它就通知发送方传输层停止传输分组；当有空闲位置时，它通知发送方传输层可以再次传输分组。 传输层差错控制由于网络层（IP）是不可靠的，如果应用层需要可靠性，我们需要使传输层变得可靠。可靠性可以通过在传输层加入差错控制服务来实现。 传输层的差错控制负责以下几个方面： 发现并丢弃被破坏的分组。 记录丢失和丢弃的分组并重传它们。 识别重复分组并丢弃它们。 缓冲失序分组直到丢失的分组到达。 差错控制不像流量控制，它仅涉及发送方和接收方传输层。我们假设在应用层和传输层之间交换的报文块是不会产生差错的。 序号差错控制需要发送方传输层知道哪个分组要被重传并且接收方传输层需要知道哪个分组是重复的、哪个分组是失序的。如果分组是编号的，这个就可以实现。我们可以在传输层分组中加入一个字段来保存分组的序号（sequence number）。分组一般按序编号。然而，由于我们需要在头部包含每个分组的序号，因此需要设置一个界限。如果分组的头部允许序号最多为m 比特位，那么序号范围就是0 到2m−1。例如，如果m 是4，序号范围是0 到15 的闭区间。然而，我们可以回绕。序号是模2^m 的。对于差错控制，序号是模2m 的，这里m 是序号字段的大小，单位是比特。 确认接收方可以为每一组正确到达的分组发送一个确认（ACK）。接收方可以简单地丢弃被破坏的分组。发送方如果使用计时器，它就可以发现丢失分组。当一个分组被发送，发送方就开启一个计时器。如果ACK 在计时器超时之前没有到达，那么发送方重发这个分组。重复的分组可以被接收方默默丢弃。失序的分组既可以被丢弃（被发送方当做丢失报文对待），也可以存储直到丢失的那个分组到来。 流量和差错控制的组合流量控制要求使用两个缓冲区，一个在发送端另一个在接收端。差错控制要求两端均使用序号和确认号。流量和差错控制的组合：使用两个带序号的缓冲区：一个位于发送端，一个位于接收端，那么这两个需要可以结合起来。在发送端，当分组准备发送时，我们使用下一个缓冲区空闲位置号码x 作为分组的序号。当分组被发送，一个分组的备份存储在内存位置x，等待来自另一端的确认。当与被发送分组相关的确认到达时，分组被清除，内存位置空闲出来。在接收端，当带有序号y 的分组到达时，它被存储在内存位置y 上，直到应用层准备好接收它。这时发送一个确认表明分组y 的到达。 滑动窗口由于序号进行模2m 操作，因此一个环可以代表从0 到2m−1 的序号。缓冲区由一组片段代表，称为滑动窗口（sliding window），它随时占据环的一部分。在发送端，当一个报文被发送，相应的片段就被标记。当有所片段都被标记时，意味着缓冲区满且不能从应用层进一步接收报文。当确认到达时，相应片段被取消标记。如果从窗口开始处有一些连续的片段没有被标记，那么窗口滑过这些相应序号的范围，允许更多的片段进入窗口尾部。下图 给出发送方的滑动窗口。 序号以16 为模（m = 4）且窗口大小为7。请注意滑动窗口仅仅是一个抽象：实际情况是使用计算机变量来保存下一个和最后一个待发送的分组。大多数协议使用线性形式来表示滑动窗口。虽然想法是相同的，但是它通常占用更少的页面空间。下图给出这种表示方法。这两种表示方法告诉我们相同的事情。如果拿起下图每一幅图的两个端点，并且弯曲它们，我们就可以得到与圆形滑动窗口相同的图。 拥塞控制拥塞（congestion）:因特网之类的分组交换网络中存在一个重要问题，这就是拥塞。如果网络中的负载（load，即发送到网络的分组数）大于网络的容量（网络可以处理的分组数），那么网络就可能发生拥塞。拥塞控制（congestion control）指的是一种机制和技术，它控制拥塞并将负载保持在容量以内。 无连接和面向连接服务传输层协议就像网络层协议一样，可以提供两种类型的服务： 无连接服务 面向连接服务 然而，这些传输层服务的本质与网络层不同。 在网络层，无连接服务可能意味着属于同一个报文的不同数据报有不同路径。 在网络层，面向连接服务意味着两个终端主机以及这之间的所有路由器都进行协调。 在传输层，我们不关心分组的物理路径（我们假设两个传输层之间有一条逻辑连接）。 传输层的无连接服务意味着分组之间的独立；面向连接服务意味着依赖。 无连接服务在无连接服务中，源进程（应用程序）需要将报文分成传输层可接受大小的数据块，并把它们一个一个地传递到传输层。传输层将每一个数据块看做彼此没有关系的单元。当一个块从应用层到达时，传输层将其封装在分组中并发送。 为了展示分组的独立，我们假设客户进程有三个报文块要发送给服务器进程。这些块被按序交给无连接传输协议。然而，由于传输层的这些分组之间没有联系，分组可能失序到达目的地并且被失序传递给服务器进程在客户端，三个报文块按序传递给客户传输层（0、1 和2）。由于第二个分组在传输中的额外延迟，服务器报文的传递失序（0、2 和1）。如果这三个数据块属于同一个报文，那么服务器进程可能会收到一个奇怪的报文。如果一个分组丢了情况就更糟糕了。由于分组没有序号，接收方传输层不知道一个报文已经丢失。它仅仅将两个数据块传送到服务器进程。以上两个问题是由于双方传输层没有互相协调所致。接收方传输层不知道第一个分组将要到来，也不知道所有的分组已经到来。我们可以说，流量控制、差错控制以及拥塞控制都不能在无连接服务中有效实现。 无连接的服务是不可靠的服务，无法许诺不会出现的交付和重复的差错，但这种协议代价很小，更适应于某些服务，比如内部的数据采集、向外的数据分发、请求一响应，以及实时应用等。因此在运输层既有面向连接的位置，也有无连接的用武之地。每一个分组独立地建立和释放逻辑连接，也适合传送大量的数据。无连接的服务的通信线路不都是预设的。无连接的服务需要将目标地址信息加在每个发送的分组上，便于每个分组路由到达目的地。UDP在电路交换或租用专线网络上也能运行。 面向连接服务面向连接的服务中，首先需要建立客户和服务器之间的逻辑连接。只有连接建立之后才能进行数据交换。在数据交换之后，连接需要拆除 连接建立 数据传输 拆除阶段。 在面向连接协议中，我们可以实现流量控制、差错控制以及拥塞控制。面向连接的方式功能强大，允许流量控制、差错控制以及顺序交付等。 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"},{"title":"计算机网络教程-传输层协议-UDP","text":"传输层协议UDP ：不可靠的无连接传输层协议，由于在应用中简单高效而被使用，在那些应用中差错控制由应用层进程提供。TCP ：可靠的面向连接协议，可用于可靠性重要的任何应用。 TCP/IP协议簇协议示意图UDP 和TCP 使用的熟知端口 1234567891011121314151617端口 协议 UDP TCP 说明7 Echo √ 将接收到的数据报回送到发送方9 Discard √ 丢弃接收到的任何数据报11 Users √ √ 活跃的用户13 Daytime √ √ 返回日期和时间17 Quote √ √ 返回每日引用19 Chargen √ √ 返回一字符串20,21 FTP √ 文件传输协议23 TELNET √ 终端网络25 SMTP √ 简单邮件传输协议53 DNS √ √ 域名服务67 DHCP √ √ 动态主机设置协议69 TFTP √ 简单文件传输协议80 HTTP √ 超文本传输协议111 RPC √ √ 远程过程调用123 NTP √ √ 网络时间协议161,162 SNMP √ 简单网络管理协议 UDP(用户数据报协议)用户数据报协议（User Datagram Protocol，UDP）: 无连接不可靠传输层协议。 不提供主机到主机通信，它除了提供进程到进程之间的通信之外，就没有给IP 服务增加任何东西。 此外，它进行非常有限的差错检验。 如果UDP 功能是如此之差，那么为什么进程还要使用它？它有缺点也有优点。UDP 是一个非常简单的协议，开销最小。如果一个进程想发送很短的报文，而且不在意可靠性，就可以使用UDP。使用UDP 发送一个很短的报文，在发送方和接收方之间的交互要比使用TCP 时少得多。 用户数据报UDP 分组称为用户数据报（user datagram），有8 字节的固定头部，这个头部由4 个字段组成，每个字段2 字节（16 位）。8 字节的固定头部的四个字段：每个字段两个字节。头两个字段定义了源和目的端口号。第三个字段定义了用户数据报的总长，即头部加数据的长度。16 位可以定义的总长度范围是0 到65 535。然而，总长度需要更小一些，这是因为UDP数据报存储在总长度为65 535 的IP 数据报中。最后一个字段可以携带可选校验和。 UDP 服务进程到进程的通信UDP 使用套接字地址提供进程到进程通信，这是IP 地址和端口号的组合。 无连接服务 UDP 提供无连接服务。这就表示UDP 发送出去的每一个用户数据报都是一个独立的数据报。不同的用户数据报之间没有关系，即使它们都是来自相同的源进程并发送到相同的目的程序。 用户数据报不进行编号。此外，也没有像TCP 协议那样的连接建立和连接终止，这就表示每一个用户数据报可以沿着不同的路径传递。 无连接的一个结果就是使用UDP 的进程不能够向UDP 发送数据流，并期望它将这个数据流分割成许多不同的相关联的用户数据报。相反，每一个请求必须足够小，使其能够装入用户数据报中，只有那些发送短报文的进程才应当使用UDP。短报文小于65507字节（65535减去UDP头部的8字节再减去IP头部的20 字节）。 无流量控制UDP 是一个非常简单的协议。它没有流量控制（flow control），因而也没有窗口机制。如果到来的报文太多时，接收方可能会溢出。缺乏流量控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 差错控制（仅有校验和）除校验和外，UDP 也没有差错控制（error control）机制，这就表示发送方不知道报文是丢失还是重传。当接收方使用校验和检测出差错时，它就悄悄地将此用户数据报丢弃。缺乏差错控制意味着如果需要的话，使用UDP 的进程应该提供这个服务。 校验和UDP 校验和包含三部分：伪头部、UDP 头部和从应用层来的数据。伪头部（psedoheader）是IP 分组的头部的一部分（第4 章讨论），其中有些字段要填入0，用户数据报分装在IP分组中 如果校验和不包括伪头部，用户数据报也可能是安全完整地到达。但是，如果IP 头部受到损坏，那么它可能被提交到错误的主机。 协议字段可确保这个分组是属于UDP，而不是属于其他传输层协议。 如果一个进程既可用UDP 又可用TCP，则端口号可以是相同的。 UDP 的协议字段值是17。如果在传输过程中这个值改变了，在接收端计算校验和时就可检测出来，UDP 就可丢弃这个分组。这样就不会传递给错误的协议。 可选校验和UDP 分组的发送方可以选择不计算校验和。这种情况下，在发送前，校验和字段就全填入0。在发送方决定计算校验和的情况下，如果碰巧结果全是0，那么在发送前校验和全改为1。换言之，发送方填充两次校验和。注意，这不会产生混淆，因为校验和的值在正常情况下不会全为1。 无拥塞控制由于UDP 是无连接协议，它不提供拥塞控制。UDP 假设被发送的分组很小且零星，不会在网络中造成拥塞。今天当UDP 被用做音频和视频的交互实时传输时，这个假设可能对也可能不对。 封装和解封装要将报文从一个进程发送到另一个进程时，UDP 协议就要对报文进行封装和解封装。 排队我们已经讨论过端口，但是没有讨论端口的实际实现。在UDP 中，队列是与端口联系在一起的。在客户端，当进程启动时，它从操作系统请求一个端口号。有些实现是创建一个入队列和一个出队列与每一个进程相关联。而有些实现只创建与每一个进程相关的入队列。 多路复用与多路分解在运行TCP/IP 协议簇的主机上只有一个UDP，但可能有多个想使用UDP 服务的进程。处理这种情况，UDP 采用多路复用和多路分解。 UDP 和通用简单协议比较我们可以将UDP 与之前讨论的无连接简单协议进行比较。唯一的区别就是UDP 提供可选校验和来在接收端发现被破坏分组。如果校验和被加入分组，接收UDP 可以检测分组，如果分组被破坏可以丢弃它。然而，没有反馈被发向发送方。UDP 是我们之前讨论的无连接简单协议的一个例子，区别在于它为差错检测加入了可选校验和。 UDP应用 一位应用设计师有时需要折中来得到最佳情况。例如，在日常生活中，我们都知道一日递送包裹比三日递送要贵。尽管时间和代价在递送包裹中都是想要获取的特性，但是它们是彼此矛盾的。我们需要选择最佳值。 尽管UDP 不满足我们之前讨论的可靠传输层协议标准，但是，UDP 更适合某些应用,因为其他某些服务可能有副作用，这些副作用或许是不可接受的或许是不称心的 UDP特性 无连接服务：UDP 是无连接协议。同一个应用程序发送的UDP 分组之间是独立的。 例如，如果一个客户应用需要向服务器发送一个短的请求并接收一个短的响应，那么这就是优势。如果请求和响应各自可以填充进一个数据报，那么无连接服务可能更可取。在这种情况下，建立和关闭连接的开销可能很可观。在面向连接服务中，要达到以上目标，至少需要在客户和服务器之间交换9 个分组；在无连接服务中只需要交换2 个分组。无连接服务提供了更小的延迟；面向连接服务造成了更多的延迟。如果延迟是应用的重要问题，那么无连接服务更可取。 缺乏差错控制：它提供的是不可靠服务。 缺乏拥塞控制：UDP 不提供拥塞控制。然而，在倾向于出错的网络中UDP 没有创建额外的通信量。TCP 可能多次重发一个分组，因此这个行为促使拥塞发生或者使得拥塞状况加重。因此，在某些情况下，当拥塞是一个大问题时，UDP 中缺乏差错控制可以看做是一个优势 应用 DNS，它使用UDP 服务，因为客户需要向服务器发送一个短的请求，并从服务器接收快速响应。请求和响应可以填充进一个用户数据报。由于在每个方向上只交换一个报文，因此无连接特性不是问题；客户或服务器不担心报文会失序传递。 UDP 可用于某些路由选择更新协议，如路由选择信息协议（RIP） UDP 可用于管理进程，如SNMP UDP 适用于具有内部流量控制和差错控制机制的进程。例如，简单文件传输协议（TFTP）的进程就包含流量控制和差错控制。它可很容易地使用UDP。 UDP 适合于这样的进程：它需要简单的请求-响应通信，而较少考虑流量控制和差错控制。对于需要传送成块数据的进程（如FTP）则通常不使用UDP 参考资料计算机网络教程-自顶向下方法","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-UDP/"},{"title":"计算机网络教程-传输层协议-TCP(1)","text":"TCP(传输控制协议)传输控制协议（Transmission Control Protocol，TCP）是一个面向连接可靠的协议。 TCP 显式定义了连接建立、数据传输以及连接拆除阶段来提供面向连接服务。 TCP 使用GBN 和SR 协议的组合来提供可靠性。 为了实现这个目的，TCP 使用校验和（为差错发现）、丢失或被破坏分组重传、累积和选择确认以及计时器。 TCP 服务进程到进程的通信像UDP 一样，TCP 通过使用端口号来提供进程到进程通信。 流传递服务与UDP 不同，TCP 是一个面向流的协议。在UDP 中，进程发送一些具有预先规定边界的报文给UDP 进行传递。UDP 将它自己的头部添加到这些报文中并传递到IP 层进行传输。来自进程的每一个报文称为一个用户数据报，最后变成一个IP 数据报。IP 和UDP 都不认识这些数据之间的关系。 而TCP 允许发送进程以字节流形式传递数据，并且接收进程也以字节流形式接收数据。TCP 建立一种环境，在这种环境中，两个进程好像由一个假想的“管道”连接，这个管道通过因特网传送这些进程的数据。 这种假想的环境如图所示。发送进程产生（写入）字节流，而接收进程消费（读出）这些字节流。 发送和接收缓冲区因为发送和接收进程可能以不同的速度写入和读出数据，所以TCP 需要用于存储的缓冲区。 每一个方向都存在一个缓冲区：发送缓冲区和接收缓冲区。 这些缓冲区也用于TCP 流量和差错控制机制。 实现缓冲区的一种方法是使用以一字节为存储单元的循环数组。 实现缓冲区的方法如图所示。为了简化，我们只画出了两个缓冲区，每个缓冲区20个字节。通常情况下，缓冲区是数百甚至数千个字节，这取决于实现方法。这里给出的缓冲区是大小相同的，实际上并非总是如此。上图表示了在一个方向上数据的移动。在发送端，缓冲区有三种类型的存储单元。 白色的部分是空存储单元，可以由发送进程（生产者）填充。 灰色的部分用于保存已经发送但还没有得到确认的字节。TCP 在缓冲区中保留这些字节，直到收到确认为止。 灰色缓冲区是将要由TCP 发送的字节。但是，在本章的后面将会看到，TCP 可能只发送灰色部分。这可能是由于接收进程缓慢或者网络中可能发生的拥塞造成的。 灰色存储单元的字节被确认后，这些存储单元可以回收并且对发送进程可用，这就是我们给出一个环形缓冲区的原因。 接收端的缓冲区操作比较简单。环形缓冲区分成两个区域（表示为白色和灰色）。白色区域包含空存储单元，可以由从网络上接收的字节进行填充。灰色区域表示接收到的字节，可以由接收进程读出。当某个字节被接收进程读出以后，这个存储单元可被回收，并加入到空存储单元池中。 段尽管缓冲能够处理生产进程速度和消费进程速度之间的不相称问题，但在发送数据之前，还需要多个步骤。IP 层作为TCP 服务的提供者，需要以分组的方式而不是字节流的方式发送数据。在传输层，TCP 将多个字节组合在一起成为一个分组，这个分组称为段（segment）。TCP 给每个段添加头部（为了达到控制目的），并将该段传递给IP 层。段被封装到IP 数据报中，然后再进行传输。整个操作对接收进程是透明的。这些段可能被无序接收、丢失，或者损坏和重发。所有这些均由TCP 处理，接收进程不会察觉到任何操作。下图表示了在缓冲区中如何从字节生成段。注意，段的大小不必相同。为了简单起见，我们在图中只表示了一个包含3 个字节的段和另一个包含5 个字节的段。实际的段可能包含数百（或者数千）个字节。 全双工通信TCP 提供全双工服务（full-dupler service），即数据可以在同一时间双向流动。每一方向TCP都有发送和接收缓冲区，它们能在双向发送和接收段。 多路复用和多路分解与UDP 类似，TCP 在发送端执行多路复用，在接收端执行多路分解。然而，由于TCP 是一个面向连接协议，因此需要为每对进程建立连接。 面向连接的服务与UDP 不同，TCP 是一种面向连接的协议。位于站点A 的一个进程与站点B 的另外一个进程想要进行数据的发送和接收，步骤如下：1．在两个TCP 之间建立一个连接。2．在两个方向交换数据。3．连接终止。注意，这是一个逻辑连接，而不是一个物理连接。TCP 段封装成IP 数据段，并且可能被无序地发送，或丢失，或被破坏，然后重发。每个段都可以通过不同的路径到达目的端。TCP 建立一种面向字节流的环境，在这种环境中，TCP 能承担按顺序传递这些字节到其他站点的任务。 可靠的服务TCP 是一种可靠的传输协议。它使用确认机制来检查数据是否安全和完整地到达。 TCP与UDP基本区别 基于连接与无连接 TCP要求系统资源较多，UDP较少 UDP程序结构较简单 字节流模式（TCP）与数据报模式(UDP); TCP保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 TCP 的特点序号系统虽然TCP 软件能够记录发送或接收的段，但是在段的头部没有段序号字段。TCP 在段的头部采用称为序号（sequence number）和确认号（acknowledgment number）的两个字段。这两个字段指的是字节序号，而不是段序号。 字节序号TCP 为在一个连接中传输的所有数据字节（八位字节）编号。在每个方向上序号都是独立的。当TCP 接收来自进程的一些数据字节时，TCP 将它们存储在发送缓冲区中并给它们编号。不必从0 开始编码，TCP 在0到232−1 之间生成一个随机数作为第一个字节的序号，例如，如果随机数是1057，并且发送的全部字节个数是6000，那么这些字节序号是1057~7056。下面将会看到字节序号是用于流量和差错控制。 在每个连接中传送的字节都由TCP 编号，序号开始于一个随机产生的数。 序号字节被编号后，TCP 对发送的每一个段分配一个序号。在每一个方向上的序号定义如下：1．第一段的序号是初始序号（initial sequence number，ISN），这是一个随机数。2．其他段的序号是之前段的序号加之前段携带的字节数（实际上的或想象的）。之后，我们将给出一些控制段，它们被认为携带了一个想象字节。 一个段的序号字段的值定义了该段包含的第一个字节的序号。 当一个段携带数据和控制信息（捎带）时，它使用一个序号。如果一个段没有携带用户数据，那么它逻辑上不定义序号。虽然字段存在，但是值是无效的。然而，当有些段仅携带控制信息时也需要有一个序号用于接收方的确认。这些段用作连接建立、连接终止或连接废弃。这些段中的每一个好像携带一个字节那样使用一个序号，但都没有实际的数据。 确认号TCP 中的通信是全双工的；当建立一个连接时，双方同时都能发送和接收数据。 每一方为字节编号，每一方经常使用不同的起始字节号。 每一方向的序号表明了该段所携带的第一个字节的序号。 每一方也使用确认号来确认它已收到的字节。但是，确认号定义了该方预期接收的下一个字节的序号(也就是序号+1)。另外，确认号是累积的，这意味着接收方记下它已安全而且完整地接收到最后一个字节的序号，然后将它加1，并将这个结果作为确认号进行通告。在这里，术语“累积”指的是，如果一方使用5643 作为确认号，则表示它已经接收了所有从开始到序号为5 642 的字节。但要注意，这并不是指接收方已经接收了5 642 个字节，因为第一个字节的编号通常并不是从0 开始的。 参考资料计算机网络教程-自顶向下方法TCP与UDP的区别","link":"/2020/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP/"},{"title":"计算机网络教程-传输层协议-TCP(2)","text":"TCP 连接在 TCP 中，面向连接的传输需要三个过程：连接建立、数据传输和连接终止。在TCP 中的分组称为段（segment） TCP段格式段包含20~60字节的头部，接着是来自应用程序的数据。如果没有选项，那么头部是20 字节；如果有选项，最多是60 字节。 源端口地址。这是一个16 位的字段，它定义了在主机中发送该段的应用程序的端口号。这与UDP 头部的源端口地址的作用一样。 目的端口地址。这是一个16 位的字段，它定义了在主机中接收该段的应用程序的端口号。这与UDP 头部的目的端口地址的作用一样。 序号。这个32 位的字段定义了一个数，它分配给段中数据的第一个字节。 TCP 是一种字节流传输协议。为了确保连通性，对要发送的每一个字节都进行编号。序号告诉目的端，在这个序列中哪一个字节是该段的第一个字节。 在连接建立时，每一方都使用随机数生成器产生一个初始序号（initial sequence number，ISN），通常每一个方向的ISN 都不同。 确认号。这个32 位的字段定义了段的接收方期望从对方接收的字节号。如果段的接收方成功地接收了对方发来的字节号x，它就将确认号定义为x + 1. 确认和数据可捎带一起发送。 头部长度。这个4 位的字段指明了TCP 头部中共有多少个4字节长的字。 头部的长度可以在20 字节到60 字节之间。因此，这个字段的值在5（5 × 4 = 20）到15（15 × 4 = 60）之间。 窗口大小。这个字段定义对方必须维持的窗口的大小（以字节为单位）。 注意，这个字段的长度是16 位，这意味着窗口的最大长度是65 535 字节。这个值通常称为接收窗口（rwnd）。 它由接收方确定。此时，发送方必须服从接收端的支配。 紧急指示符。这个16 位的字段只有当紧急标志置位时才有效，这个段包含了紧急数据。 它定义了一个数，将此数加到序号上就得出此段数据部分中最后一个紧急字节。 选项。在TCP 头部中可以有多达40 个字节的可选信息。 控制字段这个字段定义了6 种不同的控制位或标记，如图所示。 在同一时间可以设置一位或多位。 这些位用在TCP 的流量控制、连接建立和终止、连接失败和数据传送方式等方面。 校验和。这个16 位的字段包含了校验和。TCP 校验和的计算过程与前面描述的UDP 所采用的计算过程相同。但是，在UDP 数据报中校验和是可选的。 然而，对TCP 来说，将校验和包含进去是强制的。 起相同作用的伪头部被加到段上。对TCP 伪头部，协议字段的值是6。如图所示。 在 TCP 中使用校验和是强制的。 连接建立（三次握手）TCP 以全双工方式传输数据。当两个机器中的两个TCP 建立连接后，它们就能够同时向对方发送段。这就表示，在传输数据之前，每一方都必须对通信进行初始化，并得到对方的认可。三次握手（three-way handshaking）：客户的应用程序想要与另一个称为服务器的应用程序使用TCP 作为传输层协议建立连接。 该过程从服务器开始。服务器程序告诉它的TCP，它已准备好接收一个连接。这就称为被动打开（passive open）。虽然TCP 已经准备好接收从世界上任何一个机器发来的连接，但它自己并不能完成这个连接。客户程序发出请求进行主动打开（active open）。想要与服务器进行连接的客户告诉它的TCP，它需要连接到特定的服务器。 少数几个必须要知道的字段，如果序号、确认号、控制标记（仅仅是其中被置位的）和窗口大小等有值。三个步骤如下: 客户发送的第一个段，即SYN 段。这个段仅有SYN 标志被置位，它用于序号同步。它占用一个序号。当数据传输开始时，在我们的例子中，客户随机选择一个数字作为初始序号（ISN）。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。段也能包含一些稍后讨论的选项。 注意，SYN 段是一个控制段并且不携带数据。然而，它消耗一个序号，因为它需要被确认。我们可以说SYN 段携带了一个假想字节。 SYN 段不携带数据，但它占用一个序号。看下面的图就明白了。 服务器发送第二个段，即SYN +ACK 段。这个段有两个目的。 首先，它是另一方向通信的SYN 段。服务器使用这个段来初始化序号，这个序号用来给从服务器发向客户的字节编号。 其次，服务器也通过给ACK 置位并展示下一个序号来确认接收到来自客户的SYN 段，这里的下一个序号是服务器预期从客户接收的序号。 我们将在介绍流量控制那一节看到，因为它包含确认，它也需要定义接收窗口，即rwnd（客户使用）。因为这个段起到SYN段的作用，它需要被确认。因此，它占用一个序号。 SYN + ACK 段不携带数据，但它占用一个序号。 客户发送第三个段，即ACK 段。它使用ACK 标志和确认序号字段来确认收到了第二个段。 注意，如果不携带数据，ACK 段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据。在这种情况下，段消耗的序号与数据字节数相同。 ACK 段，如果不携带数据，则它不占用序号。 数据传输连接建立后，可进行双向数据传输，客户端与服务器双方都可发送数据和确认。数据捎带确认：在同一段内携带确认时，在同一方向上也可以传递数据。 图示在这个例子中，在连接建立后，客户端用两个段发送2000 个字节的数据。然后，服务器用一个段发送2000 个字节的数据。客户端发送另一个段。 前面三个段携带数据与确认，但是最后一个段仅携带确认，这是因为已没有数据发送了。 注意序号与确认号数值，客户端发送的数据段有PSH（推送）标志，所以服务器TCP 知道在接收到数据时立刻传递给服务器进程。 另一方面，来自服务器的段没有设置推送标志。大多数TCP 的实现都有可选标志，可设置或不设置。 推送数据发送方的TCP 使用缓冲区存储来自发送方应用程序的数据流。发送方的TCP 可以选择段的大小。接收方的TCP 在数据到达时也将数据进行缓存，并当应用程序准备就绪时或当接收端TCP 认为方便时将这些数据传递给应用程序。这种灵活性增加了TCP 的效率。 但是，在有些情况下，应用程序并不需要这种灵活性。例如，应用程序与另一方应用程序进行交互式通信。 一方的应用程序打算将其信息发给对方应用程序，并希望接收到立即响应。数据的延迟传输和延迟传递对这个应用程序来说是不可接受的。 TCP 可以处理这种情况。 在发送端的应用程序可请求推送操作。这就表示发送端的TCP 不必等待窗口被填满。 它创建一个段就立即将其发送。发送端的TCP 还必须设置推送位（PSH）以告诉接收端的TCP，这个段所包含的数据必须尽快地传递给接收应用程序，而不要等待更多数据的到来。 这意味着将面向字节的TCP 改为面向块的TCP，但是TCP 可以选择使用或不使用这个特性。 连接终止(四次挥手) 半关闭半关闭（half-close）：指在 TCP 中，一端可以停止发送数据后，还可以接续接收数据。（关闭发送但是不关闭接收）虽然任一端都可发出半关闭，但通常都是由客户端发起的。当服务器在开始处理之前需要接收到所有数据，这时就会出现半关闭。例如，排序是一个很好的例子。客户端发送数据给服务器进行排序，在开始排序之前，服务器需要接收到全部数据。 这就是说，客户端发送全部数据之后，它在客户到服务器方向可关闭连接。（客户端关闭发送） 但为了返回存储数据，服务器到客户方向必须保持打开。（客户端不关闭接收） 服务器在接收数据后还需要时间进行排序；它的向外方向必须保持打开。 从客户到服务器的数据传输停止。客户端通过发送FIN 段实现半关闭连接。服务器通过发送ACK 段确认半关闭。然而，服务器还可以发送数据。当服务器已经发送完被处理的数据时，它发送一个FIN 段。该FIN 段由客户端的ACK 来确认。连接半关闭后，数据可以从服务器传送给客户端，而确认可以从客户端传送给服务器。客户不能再向服务器发送任何数据。 连接重置在一端的TCP 可能拒绝连接请求，可能终止已存在的连接，也可能结束空闲连接。所有这些都通过RST（重置）标志完成。 参考资料详细分析TCP数据的传输过程【网络通信】TCP的通信过程图解TCP传输过程（三次握手、数据传输、四次挥手）TCP 的那些事儿（上）TCP 的那些事儿（下）一个TCP连接上能发起多少个HTTP请求吗？计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE-TCP-2/"},{"title":"计算机网络教程-HTTP协议","text":"HTTP（超文本传输协议）超文本传输协议（HyperText Transfer Protocol，HTTP）是一种用来定义客户服务器程序如何编写和如何从万维网获取网页的协议。 一个HTTP 客户发送一个请求；HTTP 服务器返回响应。 服务器使用80 端口号；客户使用一个临时端口号。 HTTP 使用TCP 服务。这意味着，在客户和服务器进行任何事务之前，它们之间必须建立连接。 在事务之后，连接应当终止。然而，客户和服务器不需要担心交换报文中的差错以及报文的丢失，因为TCP 是可靠的而且将处理这个问题。 非持续与持续连接嵌入到网页中的超文本概念可能需要多个请求和应答。 如果网页，这个被获取的对象，位于不同的服务器，那么我们没有其他选择只能每获取一个对象就要创建一个新的TCP 连接。 然而，如果某些对象是位于同一台服务器的，我们可以有两种选择： 一是每次使用一个新的TCP 连接获取一个对象。非持续连接（nonpersistent connection） 二是创建一个TCP 连接获取全部对象。持续连接（persistent connection） 在HTTP1.1 版之前指定的是非持续连接，持续连接在1.1 版中是默认的，但是可以被用户改变。 非持续连接在非持续连接中，一个TCP 连接被每一组请求/应答所创建。下面是这个策略的步骤：1．客户开启一个TCP 连接并发送请求。2．服务器发送响应并关闭连接。3．客户读取数据直到它遇到了文件结束标记，然后关闭连接。 在这种策略中，如果文件包含了N 个位于不同文件的图片连接（全都位于同一台服务器），那么必须开启和关闭连接N+1 (?)次。非持续策略给服务器带来了高额开销，因为每次连接被开启时服器都需要N+1个不同的缓冲区。 下图展示了一个非持续连接的例子。客户需要访问一个包含图片链接的文件。文本文件和图片位于同一台服务器上。这里我们需要两个连接。对于每一个连接，TCP 需要至少三个握手报文来建立连接，但是请求可以和第三个报文一起发送。在连接建立之后，请求对象可以被发送。在接收到一个对象之后，需要另外三次握手报文来结束连接 持续连接 在持续连接中服务器在发送一个响应后，为响应更多的请求而将连接置为打开状态。 服务器可以在客户的请求下或者在超时情况下将连接关闭。 文档发送方（通常是服务器）通常在每次响应中发送数据长度。然而，偶尔情况下发送方不知道数据的长度。这是创建动态文档或活动文档时的情形。在这种情形下，服务器通知客户长度未知并在发送数据后关闭连接，因此客户知道数据已接收完毕。 通过使用持续连接，可以节省时间和资源。每个站点只需要为连接设定一组缓冲区和变量。同时节省了连接建立和终止的往返时间。 报文格式HTTP 协议定义了请求报文和响应报文的格式。每一种报文由四个部分组成。 请求报文中的第一部分称为请求行； 响应报文的第一部分称为状态行。 其他三部分在请求报文和响应报文中有相同的名称。然而，这三部分只是名称相似，它们可能含有不同的内容。 请求报文 请求报文的第一行称为请求行。如图所示，这一行有三部分由空格分隔开并且被两个字符（回车和换行）终止。这些字段称为方法、URL 和版本。 第一个字段：方法字段定义了请求类型。如下所示，在HTTP1.1 版中定义了若干种方法。 第二个字段：URL，在本章的前面部分已经讨论过了。它定义了相关网页的地址和名称。 第三个字段：版本，给出了协议的版本，HTTP 最常用的版本是1.1。 12345678910111213141516171819HTTP请求报文中的方法--------------------------------------------------------------------------------------------GET 向服务器请求文档。绝大多数情况下，客户使用GET 方法发送一个请求。在这种情况下，报文的主体是空的。-------------------------------------------------------------------------------------------- HEAD 请求关于文档的信息，而不是文档本身。当客户仅需要从服务器获得关于网页的信息，如上次修改的时间，这时使用HEAD 方法。它也可以用来检测URL 的有效性。这种情况下的响应报文只有头部；主体是空的。 --------------------------------------------------------------------------------------------PUT 从客户端向服务器发送文档。PUT 方法与GET 方法是相反的；它允许客户将一个新的页面发送到服务器上（如果允许的话）。 --------------------------------------------------------------------------------------------POST 从客户端向服务器发送一些信息。POST 方法与PUT 方法类似，但是它用来发送一些信息到服务器上，这些信息被加入网页或用来修改网页--------------------------------------------------------------------------------------------TRACE 回送输入的请求。用来调试；客户要求服务器回送请求来检查服务器是否正在获得请求。DELETE 删除网页。如果客户获得许可，DELETE 方法允许客户删除一个服务器上的网页。CONNECT 预留。原先作为预留方法；后文会讨论到，这个方法可能被代理服务器使用。 OPTIONS 询问有关可用的选项。允许客户询问网页属性。 在请求行之后我们可以有一个或多个请求头部（request header）行。 每一个头部行都从客户端向服务器发送额外的信息。 例如，客户可以请求以某种特定格式发送文档。每个头部行有头部名字、一个冒号、一个空格和一个头部值（见图3）。下面列出了一些请求中常用的头部名字。 值字段定义了与每个头部名字相关的值。 值列表可以在相应的RFC 中查找到。 主体可以出现在请求报文中。通常，当使用POST 或PUT 方法时，它包含要发送的评论或要发布到网站上的文档。 12345678910111213请求头部名称-----------------------------------------------------------User-agent 标识客户端程序 Accept 给出客户端能够接受的媒体格式 Accept-charset 给出客户端可以处理的字符集 Accept-encoding 给出客户端可以处理的编码方案 Accept-language 给出客户端可以接受的语言Authorization 给出客户端有哪些许可 Host 给出主机及客户端的端口号Date 给出当前日期Upgrade 确定首选的通信协议Cookie 返回cookie 给服务器（稍后解释）If-Modified-Since 如果文档在指定的日期之后被更新，则发送文档 响应报文图3给出了响应报文的格式。响应报文包含状态行、头部行并且有时包含主体。 响应报文的第一行称为状态行。这一行有三个字段，它们由空格分隔开并且被两个字符（回车和换行）终止。 第一个字段：版本字段，定义了HTTP 协议的版本，通常为1.1。 第二个字段：状态码字段,定义了请求的状态。 它包含三个数字。在100 范围内的代码只代表一个报告 在200 范围内的代码表示这是一个成功的请求。 在300范围内的代码表示把客户端重定向到另一个URL 在400 范围内的代码表示在客户端发生错误。 最后，在500 范围内的代码表示错误发生在服务器端。 第二个字段：状态短语字段，以文本格式解释了状态码。 在状态行之后，我们可以有一个或多个响应头部行。每一个头部行都从服务器向客户端发送额外的信息。例如，发送方可以发送关于文档的额外信息。每个头部行都有一个头部名称、一个冒号、一个空格和一个头部值。下面列出了一些常用的头部名称。 12345678910111213响应头部名称------------------------------------------------------Date 给出当前日期 Upgrade 确定首选的通信协议 Server 给出服务器信息 Set-Cookie 服务器要求客户存储Content-Encoding 指定编码方案 Content-Language 指定语言Content-Length 给出文档长度Content-Type 指定媒体类型Location 指明新建或移动后文档的位置cookie Accept-Ranges 服务器将会接收的被请求的字节范围Last-modified 给出上次改变的日期和时间 主体包含了从服务器发送给客户的文档。除非响应是一个错误报文，否则主体是存在的。 示例客户要向服务器发送一个网页在这个例子中，客户要向服务器发送一个网页。我们使用PUT 方法。 请求行给出方法（PUT）、URL 以及HTTP 版本（1.1）。其头部有四行。请求主体包含要发送的网页。 响应报文包含状态行和四个头部行。被创建的文档是一个CGI 文档，它包含在响应报文的主体中 客户要向服务器获取一个文档使用GET 方法来获取一个路径为/usr/bin/image1 的图片。 请求行给出了使用的方法（GET）、URL 以及HTTP 版本（1.1）。 头部有两行，它们表示客户可以接收GIF 或JPEG 格式的图片。请求是没有主体的。 响应报文包含了状态行以及四个头部行。头部行定义了日期、服务器、内容编码（MIME 版本，在电子邮件部分将会描述）以及文档长度。文档主体在头部之后。 条件请求客户可以在请求中加入条件。在这种情况下，如果条件满足，服务器将会发送被请求的网页或者通知用户。 客户加入的最常见的一种条件是网页被修改的时间和日期。 客户可以在发送请求时附带头部行If-Modified-Since，这样来告知服务器客户只需要在指定日期之后更新的页面。 一个客户在请求中加入了修改日期和时间的条件。 123GET http://www.commonServer.com/information/file1 HTTP/1.1 请求行If-Modified-Since: Thu, Sept 04 00:00:00 GMT 头部行 空行 响应中的状态行表示在指定日期之后文档没有修改。所以响应报文的主体是空的。 12345HTTP/1.1 304 Not Modified 状态行Date: Sat, Sept 06 08 16:22:46 GMT 头部第一行Server: commonServer.com 头部第二行 空行(Empty Body) 空主体 HTTP 安全HTTP 本质上并不提供安全。然而，，HTTP 可以在安全套接层（SSL）上运行。在这种情况下，HTTP 称为HTTPS。HTTPS 提供保密性、客户和服务器鉴别，以及数据完整性。HTTPS 端口号443 状态码（Status-Code）1xx：表示通知信息，如请求收到了或正在进行处理 100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 2xx：表示成功，如接收或知道了 200 OK: 请求成功 3xx：表示重定向，如要完成请求还必须采取进一步的行动 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替 4xx：表示客户的差错，如请求中有错误的语法或不能完成 400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时 5xx：表示服务器的差错，如服务器失效无法完成请求 500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求 参考资料HTTP状态码-菜鸟教程HTTP 教程-菜鸟教程浅谈HTTP中GET、POST用法以及它们的区别 计算机网络教程-自顶向下方法","link":"/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"计算机网络教程-TCP状态转换","text":"TCP状态表 状态 说明 状态 说明 CLOSED 没有连接存在 FIN-WAIT-2 首个FIN 的ACK 已被接收；等待第二个FIN LISTEN 接收到被动打开；等待SYN CLOSE-WAIT 首个FIN 被接收，ACK 被发送；等待应用关闭 SYN-SENT SYN已被发送；等待ACK TIME-WAIT 第二个FIN 被接收，ACK 被发送；等待2MSL 超时 SYN-RCVD SYN + ACK 已被发送；等待ACK LAST-ACK 第二个FIN 被发送；等待ACK ESTABLISHED 连接建立；数据传输正在进行 CLOSING 双端决定同时关闭 FIN-WAIT-1 首个FIN 已被发送；等待ACK 示例客户进程向它的TCP 发出主动打开命令来请求连接到特定套接字地址。 TCP 发送一个SYN 段并转移到SYN-SENT 状态。 在收到SYN + ACK 段后，TCP 发送了一个ACK 段并且进入ESTABLISHED状态。 数据被传输，可能是双向的，并且被确认。 当客户进程没有数据要发送了，它发出称为主动关闭的命令。 TCP 发送FIN 段并进入FIN-WAIT-1状态。 当它接收到ACK 段，它进入FIN-WAIT-2状态。 当客户接收到FIN 段时，它发送一个ACK 段并进入TIME-WAIT状态。 客户保持这种状态2MSL秒（TCP 计时器）。 当相应计时器超时，客户进入CLOSED状态。 服务器进程发出被动打开命令。 服务器TCP 进入LISTEN 状态并且保持这种状态直到它接收到一个SYN 段。 TCP 之后发送一个SYN + ACK 段并且进入SYN-RCVD 状态，等待客户发送ACK段。 在接收到ACK 段后，TCP 进入ESTABLISHED 状态，这就开始了数据传输。 TCP 保持这种状态直到它接收到一个来自客户的FIN 段，这表示没有其他数据要被交换且连接可以被关闭。 一旦服务器接收到FIN 段，那么它就向客户发送带有虚拟EOF 标记的排队中所有的数据，这意味连接必须被关闭。 它发送一个ACK 段且进入CLOSE-WAIT状态，但是推迟确认来自客户的FIN 段，直到它接收到来自进程的被动关闭命令。 在接收到被动关闭命令后，服务器向客户发送FIN 段并进入LAST-ACK状态，等待最终ACK。 当ACK 段从客户发送后被服务器接收，服务器进入CLOSE 状态。","link":"/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"},{"title":"计算机网络教程-套接字","text":"套接字的数据结构C 语言将套接字定义为一个结构（struct）。套接字结构由五个字段组成；每个套接字地址是一个由五部分构成的结构。 族。这个字段定义了协议簇（如何解释地址和端口号）。 通常值是PF_INET（用于当前因特网）、PF_INET6（用于下一代因特网）等等。我们在本节使用PF_INET。 类型。这个字段定义了四个套接字类型： SOCK_STREAM（用于TCP） SOCK_DGRAM（用于UDP）、 SOCK_SEQPACKET（用于SCTP） SOCK_RAW（用于直接使用ISP 服务的应用）。 协议。这个字段定义了族中特定协议。对于TCP/IP 协议簇这个字段设置为0，因为它是族中唯一的协议。 本地套接字地址。这个字段定义了本地套接字地址。 一个套接字地址是一个结构，它由长度字段、族字段（对于TCP/IP 协议簇，它被设置为常量AF_INET）、端口号字段（定义了进程）以及IP 地址字段（定义了正在运行的进程所在的主机）构成。它也包含未使用字段。 远程套接字地址。这个字段定义了远程套接字地址。它的结构与本地套接字地址相同。 头文件123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/innet.h&gt;#include &lt;sys/wait.h&gt; 使用 TCP 通信 TCP 是面向连接的协议。在发送或接收数据之前，需要在客户端和服务器之间建立连接。在连接建立之后，只要它们有数据要发送或接收，两端就可以彼此发送以及接收数据块。 TCP 连接可以是迭代的（一次服务一个客户）也可以是并发的（一次服务多个客户）。 TCP 中使用的套接字TCP 服务器使用两个不同的套接字: 一个用于连接建立。称为监听套接字（listen socket）。 一个用于数据传输。称为套接字（socket）。 设置两种套接字的目的是将建立阶段和数据交换阶段分开。 服务器使用监听套接字来监听试图建立连接的新客户。在连接建立之后，服务器创建一个用于和客户交换数据的套接字并且最终终止连接。客户只使用一个套接字用于连接建立以及数据交换。 通信流程图 服务器进程 TCP 服务器进程调用socket 和bind 函数，但是这两个函数创建监听套接字，它只在连接建立阶段被使用。 之后，服务器进程调用listen函数，允许操作系统开始接收客户、完成连接阶段并把他们放入等待被服务的列表。 这个函数也定义了被连接的客户等待列表的大小，这依赖于服务器进程的复杂性，但是通常值为5。 现在，服务器进程开始循环并且逐一对客户进行服务。 在每次循环中，服务器进程调用accept函数从已连接客户的等待列表中去除一个客户，对其进行服务。 如果列表是空的，那么accept 函数进入阻塞状态直到出现一个客户待服务。 当accept 函数返回，它创建一个新的与监听套接字一样的套接字。 监听套接字现在移入后台，并且新的套接字成为活动套接字。 服务器进程现在使用连接建立期间获得的客户套接字地址，用它来填充新建套接字的远程套接字地址。 此时，客户和服务器可以交换数据。我们没有给出数据传输的特定方式，因为这取决于特定的客户-服务器对。 TCP 使用send以及recv程序在它们之间传输数据字节。这两个函数比UDP 中使用的sendto 和recvfrom 函数更简单，因为它们不提供远程套接字地址；连接已经在客户和服务器之间建立。 然而，由于TCP 用于传输无边界报文，每个应用需要仔细设计数据传输部分。 send 和recv 函数可能被调用多次来处理大量数据传输。可以将上图的流程图当作一个通用流程图；如果是特殊用途，需要定义服务器数据传输（sever data-transfer）盒。 客户进程客户进程进行主动开启（active open）。换言之，它开启连接。它调用socket 函数来创建一个套接字并填充前三个字段。尽管某些实现要求客户进程也调用bind 函数来填充本地套接字，但通常这是由操作系统自动完成的，操作系统为客户选择一个临时端口号最终close 函数被调用以销毁套接字。客户流程图与UDP 版本类似，除了客户数据传输（client data-transfer）盒需要为每个特定情况定义。 套接字接口编程（TCP）编写客户和服务器程序来模拟使用TCP的标准回送应用——客户程序发送一个短的字符串给服务器；服务器将相同的字符串回送到客户。在我们这样做之前，需要为客户和服务器数据传输盒提供流程图 客户和服务器数据传输盒的流程图（发送消息和回送消息）对于发送和回送短的字符这个特定的情况，因为待发送的字符串很短（小于几个单词），我们可以在客户端调用send函数一次完成。然而，TCP 并不保证把整个报文在一个报文段内发送。因此，我们需要在服务器端调用一组recv（在一个循环内）来接收整个报文并将它们收集到缓冲区内，从而能一次性发送回去。当服务器向客户发送回送报文时，它也可能使用多个报文段，这意味着客户的recv 程序需要调用多少次就会被调用多少次。 缓冲区设置另一个有待解决的问题是设置缓冲区，缓冲区用于在每个站点接收数据。 我们需要控制接收的字节数以及下一个数据块存储的位置。 如图所示，程序设置了一些变量进行控制。 在每次迭代中，指针（ptr）移动指向下一个要接收的字节，接收字节的长度（len）呈增长趋势并且待接收的最大字节数（maxLen）呈减少趋势。 回送服务器程序程序遵循迭代TCP通信流程图。第 6 行到第16 行声明并定义了变量。第18 行到第21 行分配内存并且按UDP 情况下所述创建了本地（服务器）套接字地址。第23 行到第27 行创建了监听套接字。第29 行到第33 行将监听套接字绑定到第18 行到第21 行创建的服务器套接字地址上。第35 行到第39 行是TCP 通信中的新内容。调用 listen 函数让操作系统完成连接建立阶段并将客户置入等待列表。第44 行到第48 行调用accept 函数来移除等待列表中的第一个客户并开始为其服务。如果在等待列表中没有客户，那么这个函数处于阻塞状态。第50 行到第56 行对图2-63 中描述的数据传输部分进行编码。最大缓冲区大小与回送字符串长度都和图5中所示相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//回送服务器程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(){ //声明并定义 int ls; //监听套接字描述符（引用） int s; //套接字描述符（引用） char buffer[256]; //数据缓冲区 char *ptr=buffer; //数据缓冲区 int len=0; //等待接收或者发送的字节数 int maxLen=sizeof(buffer); //最大接收字节数 int n; //每次调用receive接收的字节数 int waitSize=16; //等待客户数量 struct sockaddr_in servAddr; //服务器地址 struct sockaddr_in clntAddr; //客户地址 int clntAddrLen; //客户地址长度 //创建本地（服务器）套接字地址 memset(&amp;servAddr,0,sieof(servAddr)); servAddr.sin_family=AF_INET; servAddr.sin_addr.s_addr=htonl(INADDR_ANY); //默认IP地址 servAddr.sin_port=htonl(SERV_PORT); //默认端口 //创建监听套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) //PF_INET族，SOCK_STREAM指套接字类型（tcp） { perror(\"Error:Listen socket failed!\"); exit(1); } //将套接字绑定到本地套接字地址 if(bind(ls,&amp;servAddr,sizeof(servAddr))&lt;0) { perror(\"Error:binding failed!\"); exit(1); } //创建连接请求 if(listen(ls,waitSize)&lt;0) { perror(\"Error:listening failed!\"); exit(1); } //处理连接 for(;;) //永远运行 { //接收来自客户的连接 if(s=accept(ls,&amp;clntAddr,&amp;clntAddrLen)&lt;0) { perror(\"Error:accepting failed!\"); exit(1); } //数据传输部分 while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } send(s,buffer,len,0); //发回（回送）所有接收的字节 //关闭套接字 close(s); }//循环结束}//回送服务器程序结束 tips: 在C/C++写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。这是就可能用到htonl(), ntohl(), ntohs()，htons()这4个函数。 htonl()–”Host to Network Long” ntohl()–”Network to Host Long” htons()–”Host to Network Short” ntohs()–”Network to Host Short” 回送客户程序TCP 的客户程序与UDP 的客户程序非常相似，只有些许不同。 因为TCP 是面向连接的协议第36 行到第40 行调用connect 函数连接服务器。 第42 行到第48 行使用图3中的思想完成数据传输。 按图5所示方式完成接收数据的长度调整和指针移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//回送客户程序# include\"headerFiles.h\" //也就是我上面写的那些头文件的集合int main(int argc,char *argv[]) //三个参数之后待检验{ //声明并定义 int s; //套接字描述符 int n; //每次调用recv接收的字节数 char servName; //服务器名 int servPort; //服务器名 char *string; //被回送的字符串 int len; //被回送的字符串的长度 char buffer[256+1]; //缓冲区 char *ptr=buffer; //在缓冲区上移动指针 struct sockaddr_in serverAddr; //服务器套接字地址 //检测并设置参数 if(argc!=3) { printf(\"Error:three arguments are needed!\"); exit(1); } servName=argv[1]; servPort=atoi(argv[2]); string=arg[3]; //创建远程（服务器）套接字地址 memset(&amp;serverAddr,0,sieof(serverAddr)); servAddr.sin_family=AF_INET; inet_pton(AF_INET,servName,&amp;serverAddr.sin_addr); //服务器IP地址 serverAddr.sin_port=htons(SERV_PORT); //默认端口 //创建套接字 if(ls=socket(PF_INET,SOCK_STREAM,0)&lt;0) { perror(\"Error: socket creation failed!\"); exit(1); } //连接到服务器 if(connect(sd,(struct sockaddr*)&amp;serverAddr,sizeof(serverAddr))&lt;0) { perror(\"Error:connection failed!\"); exit(1); } //数据传输部分 send(s,string,strlen(string),0); while((n=recv(s,ptr,maxLen,0))&gt;0) { ptr+=n; //在缓冲区上移动指针 maxLen-=n; //调整待接收的最大字节数 len+=n; //更新已经接收的字节数 } //打印并验证回送的字符串 buffer[len]='\\0'; printf(\"Echoed string received:\"); fputs(buffer,stdout); //关闭套接字 close(s); //停止程序 exit(0);}//回送客户程序结束 Linux下的socket()函数inux中的一切都是文件，每个文件都有一个整数类型的文件描述符；socket也是一个文件，也有文件描述符。使用socket()函数创建套接字以后，返回值就是一个 int类型的文件描述符。在 Linux 下使用 &lt;sys/socket.h&gt; 头文件中 socket()函数来创建套接字，原型为： 1int socket(int af, int type, int protocol); 1) af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。 AF 是“Address Family”的简写，INET是“Inetnet”的简写。 AF_INET 表示 IPv4 地址，例如 127.0.0.1； AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。 也可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。 需要记住127.0.0.1，它是一个特殊IP地址，表示本机地址 2) type 为数据传输方式/套接字类型， 常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） SOCK_DGRAM（数据报套接字/无连接的套接字） 3) protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？ 正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。 本教程使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用 socket() 函数： 1int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //IPPROTO_TCP表示TCP协议 这种套接字称为 TCP 套接字。 如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket() 函数： 1int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPPROTO_UDP表示UDP协议 这种套接字称为 UDP 套接字。 上面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示： 12int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP套接字 Windows下的socket()函数Windows 会区分 socket 和普通文件，它把 socket 当做一个网络连接来对待，调用 socket() 以后，返回值是 SOCKET 类型，用来表示一个套接字。Windows 下也使用 socket() 函数来创建套接字，原型为： 1SOCKET socket(int af, int type, int protocol); 除了返回值类型不同，其他都是相同的。Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。 参考资料计算机网络-自顶向下方法bind()和connect()函数：绑定套接字并建立连接listen()和accept()函数：让套接字进入监听状态并响应客户端请求send()/recv()和write()/read()：发送数据和接收数据TCP协议的无消息边界问题TCP协议的粘包问题（数据的无边界性）TCP网络传输“粘包”问题，经典解决（附代码）socket()函数用法详解：创建套接字","link":"/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B-%E5%A5%97%E6%8E%A5%E5%AD%97/"},{"title":"数据库常用概念","text":"基本概念 实体（entity）：客观存在并可相互区别的事物称为实体。实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。实体集（entity set）：同一实体型的集合称为实体集。 术语对比 关系模型的数据结构术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或者行 属性 列 属性名 列名 分量 一条记录中的一个列值 域 值的集合，值的取值范围 非规范关系 表中有表 关系关系模型（relational model） 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 主属性（prime attribute）：候选码的诸属性 码（key）：表中可以唯一确定一个元组的某个属性组，也可以说是主码。 候选码（candidate key）：关系的某一属性组的值能唯一地标识一个元组，但是子集不能 主码（primary key）：若一个关系有多个候选码，选定其中一个为主码 域（domain）：一组具有相同数据类型的值的集合 笛卡尔积：域之间的排列组合。 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, …, 属性n) 关系的三种类型基本表：实际存在的表，实际存储数据的逻辑表示查询表：查询结果对应的表视图表：由基本表或其他视图导出来的表，是虚表，不对应实际存储的数据。 关系的完整性实体完整性 主属性不能取空值 参照完整性：指的是关系之间存在着属性的引用，比如学生（学号，姓名，专业号），专业（专业号，专业名）。学生这个表参照了专业表里的专业号 上面学生表的专业号可以看作是专业表的专业号的引用，也就是专业表的外码 外码只有两种情况 为空值 专业未确定 非空值 专业确定 用户定义的完整性用户自己设置的规则，比如某个属性的范围，某个属性必须取为唯一值等。 关系代数并 差 交 笛卡儿积称为集合运算.(1) 并(Union)并是抽取两个表格中所有行的运算,经过并运算后能够抽取两个表格中的所有数据.(2) 差(difference)能够调取两张表中其中一张表独有的数据,这种运算叫做差,以不同的表格为基准会获得不同的运算结果.(3) 交(intersection)能够调取两张表格共有数据的这种运算叫做交.(4) 笛卡儿积(Cartesian product)笛卡儿积是一种可以将两个表格中所有数据排列组合的方法 (5) 投影(projection)抽取列的运算叫做投影.投影是调取表中某一列.(6) 选择(Selection)选择是调取表中某一行的运算.(7) 连接(join)连接就是将表格连接起来.外键参照其他表中的主键,通过连接,将两个表格粘合起来. 笛卡尔集中选取合适的；等值连接 选取某些属性的值相等的那些元组自然连接 重复的属性列去掉(8) 除除就是从’被除表格’中调取’除表格’中包含的所有行,然后再从中去掉’除表格’中所有行的运算. 常用 SQL 操作 对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE SCHEMA，ALTER TABLE 视图 CREATE VIEW 索引 CREATE INDEX 数据 基本表和视图 SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES 属性列 SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES 一些最重要的 SQL 命令SELECT - 从数据库中提取数据UPDATE - 更新数据库中的数据DELETE - 从数据库中删除数据INSERT INTO - 向数据库中插入新数据CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 范式一个低一级范式的关系模式通过模式分解可以转换为若干高一级范式的关系模式的集合，这个过程叫规范化 。//通俗的说，就是为了方便增删改查才转为为各种范式。第一范式（1NF）：属性（字段）是最小单位不可再分。 //不可以一个属性里面的值还可以再分为多个值第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键 （消除 1NF 非主属性对码的部分函数依赖）。 //第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性 （消 除 2NF 非主属性对码的传递函数依赖）。 //鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖 （消除 3NF 主属性对码的部分和传递函数依赖）。第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖 （消除 3NF 非平凡且非函数依赖的多值依赖）。 关系模式的简化三元组 R&lt;U,F&gt; F是属性组上面的一组数据依赖。 数据依赖 函数依赖（function dependency）：类似于y=f(x) x一旦确定，y就确定了 非平凡的函数依赖 比如(Sno,Cno)-&gt;Grade //Grade不属于码 平凡的函数依赖 (Sno,Cno)-&gt;Cno //Cno属于码 部分函数依赖 Sno-&gt;Sdept,(Sno,Cno)-&gt;Sdept //Sdept依赖(Sno,Cno)，但是还可以再细分，Sdept依赖于Sdept 传递函数依赖 多值依赖（multi-value dependency）： // X Y Z 由X Z的值可以确定一组Y的值。而且Z变一下，还是可以确定一组相同的Y的值，这组Y的值只和X有关的 事务事务：用户定义的一个数据库操作序列，这些操作要么做，要么不做，是一个不可分割的工作单位一个程序包含多个事务 事务的开始可以由用户显式控制。如果用户没有显式义，由DBMS按照默认规定自动划分事务。在SQL中，定义事务的语句一般是三条 123BEGIN TRANSCTION; COMMIT; //提交事务ROLLBACK; //回滚，之前完成的操作撤销，回滚到事务开始的状态 事务的ACID特性原子性：事务要么做要么不做一致性：事务前后数据的完整性必须保持一致。隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。 并发控制事务是并发控制的基本单位。并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。活锁死锁：活锁：事务永远处于等待状态，可通过先来先服务的策略避免。死锁：事物永远不能结束预防：一次封锁法、顺序封锁法；诊断：超时法、等待图法；解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则 SQL语言简洁，易学易用 完成核心功能只用了9个动词。 SQL的动词 1234数据查询 SELECT 数据定义 CREATE,DROP,ALTER数据操纵 INSERT,UPDATE,DELETE数据控制 GRANT,REVOKE //grant 授予 revoke 撤销废除 综合统一 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体 基本操作对象有：模式、表、视图和索引 数据定义123456操作对象| 创建 | 删除 | 修改----------------------------------------------------模式 CREATE SCHEMA DROP SCHEMA -表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW - 索引 CREATE INDEX DROP INDEX ALTER INDEX SQL不提供修改模式定义和修改视图定义的操作，如果想修改就只能删除然后重建；示例 1234567CREATE SCHEMA test AUTHORIZATION zhangCREATE TABLE tab1(COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2) ); 1234删除模式DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; //CASCADE和RESTRICT必选1个CASCADE表示级联，删除模式的时候把模式中的所有数据对象都删除RESTRICT只有在模式没有任何数据对象的时候才能执行 索引的建立和删除表太大的时候，查询操作会比较耗时，可以用索引来加快。在基本表上建立一个或者多个索引，加快查找速度 数据库索引类型 顺序文件上的索引 按属性值降序或者升序的形式建立一个顺序索引文件 B+树索引 叶节点为属性值和相应的元组指针 动态平衡的优点 散列索引 hash桶存放相应的索引属性值和元组的指针 位图索引 用位向量记录索引属性值中可能出现的值，每个位向量对应一个可能值； 建立索引和删除索引由数据库管理员或者表的建立者负责完成。但是查询时候是由数据库管理系统自动选择合适的索引，用户不能显式选择。 数据字典是数据库管理系统中的一组系统表，记录了数据库所有的定义信息关系数据库执行SQL相关的数据定义语句的时候，实际上就是在更新数据字典表中的信息。 数据查询12345SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [&lt;目标列表达式 &gt;]... //DISTINCT 取消重复值，ALL 不取消重复值FROM &lt;表名或者视图名&gt; [WHERE &lt;条件表达式&gt;] //代表限制条件[GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;] ] //Group分组，比方一个表课程号，选课的人，可以根据课程和分组，作用有点像按某个属性来拆分成多个表。HAVING指定筛选条件[ORDER BY &lt;列名2&gt; [ASC|DESC]]; //结果按照列名2的值升序或者降序 数据更新插入数据123INSERT INTO student(Sno,Sname,Ssex,Sdept,Sage)VALUES('201215128','陈','男','IS',18) 修改数据123UPDATE studentSET Sage=22WHERE Sno='201215121'; //WHERE可以省略，省略时候表示修改表中所有的元组 删除数据1234//只能删除元组DELETE FROM studentWHERE Sno='201215128'; 视图操作123456CREATE VIEW IS_STUDENTASSELECT Sno,Sname,SageFROM studentWHERE Sdept='IS'WITH CHECK OPTION //可以省略，带上这条语句表示对视图插入修改删除时候会满足where中的条件 1DROP VIEW &lt;视图名&gt;[CASCADE] //级联代表删除相关联的视图 参考资料数据库系统概论 王珊 萨师煊SQL 语法数据库篇（每位开发者必备）","link":"/2020/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/"},{"title":"STL 堆常用操作","text":"基本概念 STL中并没有把heap作为一种容器组件，heap的实现亦需要更低一层的容器组件（诸如list,array,vector）作为其底层机制。 Heap是一个类属算法，包含在&lt; algorithm &gt;中。 STL中关于heap默认调整成的是大顶堆，可以用自定义的compare_fuction函数实现大顶堆或小顶堆。 heap的低层机制vector本身就是一个类模板，heap基于vector便实现了对各种数据类型（无论基本数据类型还是用户自定义的数据类型）的堆排（前提是用户自定义的数据类型要提供比较机制compare_fuction函数）。 堆是一棵树完全二叉树，对于该完全二叉树中的每一个结点x，其关键字大于等于(或小于等于）其左右孩子结点，而其左右子树均为一个二叉堆。 在上述的定义中，若堆中父亲结点关键字的值大于等于孩子结点，则称该堆为大顶堆；若堆中父亲结点关键子的值小于等于孩子结点，则称该堆为小顶堆。 由于堆是一棵完全二叉树，所以我们可以很轻易地用一个数组存储堆中的每一个元素，并且由子结点访问到其父亲结点和由父亲结点访问到其子结点。 头文件1# include &lt; algorithm &gt; STL堆操作STL里面的堆操作一般用到的只有4个。 1234make_heap Make heap from range (function template)push_heap Push element into heap range (function template) pop_heap Pop element from heap range (function template) sort_heap Sort elements of heap (function template) make_heap12345template &lt;class RandomAccessIterator&gt; void make_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void make_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 一个参数是数组或向量的头指针，第二个向量是尾指针。第三个参数是比较函数的名字。在缺省的时候，默认是大跟堆。作用 ：以[ begin,end )内元素建立堆。 push_heap向堆中插入元素分为两个步骤： 先将待插入的元素插入到底层容器的末端，通过push_back函数实现。 再调用push_heap(b,e,cmp)函数堆新插入的元素做向上调整。 所以，调用push_heap函数之前，先要保证待插入的元素已经放到了原容器的末尾，否则push_heap就做了无用功。 12345template &lt;class RandomAccessIterator&gt; void push_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void push_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 假设由[first,last-1)是一个有效的堆，然后，再把堆中的新元素加进来（新元素放到最后一个位置），做成一个堆。 sort_heap12345template &lt;class RandomAccessIterator&gt; void sort_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void sort_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); sort_heap对[first,last)中的序列进行排序。它假设这个序列是有效堆。（当然，经过排序之后就不是一个有效堆了） pop_heap12345template &lt;class RandomAccessIterator&gt; void pop_heap ( RandomAccessIterator first, RandomAccessIterator last );template &lt;class RandomAccessIterator, class Compare&gt; void pop_heap ( RandomAccessIterator first, RandomAccessIterator last, Compare comp ); 不是真的把最大（最小）的元素从堆中弹出来,而是重新排序堆，使得第一个和最后一个进行交换，但是并不弹出最大值。它把first和last交换，然后将[first,last-1)的数据再做成一个堆。需要手动删除最后一个元素（a.pop_back()）; 示例1234567891011121314151617181920212223242526272829303132// range heap example#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main () { int myints[] = {10,20,30,5,15}; vector&lt;int&gt; v(myints,myints+5); vector&lt;int&gt;::iterator it; make_heap (v.begin(),v.end()); 建立堆 cout &lt;&lt; \"initial max heap : \" &lt;&lt; v.front() &lt;&lt; endl; pop_heap (v.begin(),v.end()); v.pop_back(); cout &lt;&lt; \"max heap after pop : \" &lt;&lt; v.front() &lt;&lt; endl; v.push_back(99); 添加元素 push_heap (v.begin(),v.end()); cout &lt;&lt; \"max heap after push: \" &lt;&lt; v.front() &lt;&lt; endl; sort_heap (v.begin(),v.end()); 排序堆中元素 cout &lt;&lt; \"final sorted range :\"; for (unsigned i=0; i&lt;v.size(); i++) cout &lt;&lt; \" \" &lt;&lt; v[i]; cout &lt;&lt; endl; return 0;} 输出： 1234initial max heap : 30max heap after pop : 20max heap after push: 99final sorted range : 5 10 15 20 99 参考资料C++ primerC++ Library ReferenceSTL 堆heap的用法 C++ STL 常见算法(比较详细)STL之heap相关操作算法 //写的详细","link":"/2020/06/21/STL-%E5%A0%86%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"STL 算法整理","text":"标准库中常见的函数与头文件 1234567891011121314151617181920212223242526272829&lt;cstdlib&gt;: abort,&lt;numeric&gt;: accumulate, inner_product,&lt;memory&gt;: allocator, auto_ptr, uninitialized_copy,&lt;iterator&gt;: back_inserter, front_inserter, inserter, istream_iterator, ostream_iterator, reverse_iterator,&lt;new&gt;: bad_alloc,&lt;typeinfo&gt;: bad_cast, type_info,&lt;functional&gt;: bind2nd, less_equal, negate, not1, plus,&lt;bitset&gt;: bitset,&lt;iostream&gt;: boolalpha, cerr, cin, cout, dec, endl, ends, fixed, flush, hex, internal, istream, left, noboolalpha, noshowbase, noskipws, nounitbuf, nouppercase, oct, ostream, right, scientific, showbase, sowpoint, skippws, unitbuf, uppercase&lt;algorithm&gt;: copy, count, count_if, equal_range, fill, fill_n, find, find_end, find_first_of, for_each, max, main, nth_element, partial_sort, replace, replace_copy, set_difference, set_intersection, set_union, sort, stable_sort, unique, unique_copy, upper_bound,&lt;deque&gt;: deque,&lt;exception&gt;: exception, unexpected,&lt;fstream&gt;: fstream, ifstream, ofstream,&lt;string&gt;: getline, string,&lt;ios_base&gt;: ios_base,&lt;cctype&gt;: isalpha, islower, ispunct, isspace, isupper,&lt;sstream&gt;: istringstream, ostringstream, stringstream,&lt;list&gt;: list,&lt;stdexcept&gt;: logic_error, out_of_range, range_error, runtime_error,&lt;utility&gt;: make_pair, pair,&lt;map&gt;: map, multimap&lt;set&gt;: multiset, set&lt;queue&gt;: priority_queue, queue&lt;cstddef&gt;: ptrdiff_t, size_t,&lt;iomanip&gt;: setfill, setprecision, setw,&lt;cmath&gt;: sqrt,&lt;stack&gt;: stack,&lt;cstring&gt;: strcmp, strcpy, strlen, strncpy,&lt;vector&gt;: vector 标准库定义了 100多个算法，要学习如何使用它们，需要理解它们的结构，而不是记住每个算法的细节。 beg和end表示元素范围的迭代器 beg2表示第二个序列开始位置迭代器，end2表示第二个序列末尾迭代器(如果有)。如没有则假定系列2至少与beg end表示的范围一样大。beg和beg2类型不必匹配，但必须保证两个序列中的元素可以执行特性操作或调用给定的可调用对象。 des表示目的序列的迭代器，目的序列保证有足够的空间存放算法生成的元素。 unaryPred和binaryPred是一元和二元谓词，分别接受来自输入序列的元素，两个谓词都返回可用作条件的类型。 comp是一个二元谓词，满足关联容器中对关键字序的要求 unaryOp和binaryOp是可调用对象，分别使用来自输入序列的一个和两个实参来调用。 查找对象的算法：find12find(beg,end,val); 在迭代区间[begin,end)内查找等于val的元素，找到返回相应的迭代器，否则返回end。find_if(beg,end,unaryPred); 函数find的带一个函数参数的_if版本，条件：使函数unaryPred返回true。 find_first_of/find_end123find_first_of(beg1,end1,beg2,end2);find_first_of(beg1,end1,beg2,end2,binaryPred); 依次遍历元素,在[beg1, end1)中查找首次出现[beg2, end2)中的任一元素,使用==或unarypred相匹配。//注意是任意一个匹配即可。 例：vec1 –{1,2,3,4,5}, vec2{3,2,4}, vec3{8,6,7}在vec1中查找vec2，则返回元素2在vec1中的迭代器。在vec1中查找vec3，则返回vec1.end()迭代器。 1234find_end(beg1,end1,beg2,end2);find_end(beg1,end1,beg2,end2,binaryPred);在[beg1,end1)范围内查找[beg2,end2)最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回end1。依次遍历元素，在[beg1, end1）中查找最后一个匹配的子序列[beg2, end2），若存在，则返回beg2在[beg1, end1）中对应的迭代器，否则返回end1。[beg2, end2)中序列必须完全匹配。 例：vec1 –{1,2,3,4,5}, vec2{2,3,4}, vec3{3,2,4}在vec1中查找vec2，则返回元素2在vec1中的迭代器。在vec1中查找vec3，则返回vec1.end()迭代器。 adjacent_find12adjacent_find(beg,end);adjacent_find(beg,end,binaryPred); 依次遍历元素，查范围内相邻元素，使用==或unarypred相匹配，若存在，返回第一个元素对应的迭代器，否则返回end. search1234567search(beg1,end1,beg2,end2);search(beg1,end1,beg2,end2,binaryPred);依次遍历元素，在[beg1, end1）中查找第一个匹配的子序列[beg2, end2）。若存在，则返回beg2在[beg1, end1）中对应的迭代器，否则返回end1。[beg2, end2)中序列必须完全匹配。search_n(beg,end,count,val); //找第n个匹配的search_n(beg,end,count,val,binaryPred);依次遍历元素，在[beg1, end1）中查找匹配val的元素，使用==或unarypred匹配。若存在，返回count指定的第count个元素所对应的迭代器，否则返回end1。若count指定值为负数或0，则返回beg1。 count123count(beg,end,val);count_if(beg,end,unaryPred);依次遍历元素，查找范围内与val相匹配或使unarypred为真的元素个数。 其他只读算法：for_each12for_each(beg,end,f); 将[beg,end)范围内所有元素依次调用函数func，返回func。不修改序列中的元素。 mismatch1234mismatch(beg1,end1,beg2);mismatch(beg1,end1,beg2,binaryPred);并行比较[beg1,end1)与[beg2,end2)，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的end。 equal123判断[beg1,end1)与[beg2,end2)内元素都相等equal(beg1,end1,beg2); equal(beg1,end1,beg2,binaryPred); 二分查找算法：lower_bound/upper_boundlower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。 123456789lower_bound(beg,end,val);lower_bound(beg,end,val,comp);从[beg,end)位置二分查找第一个大于或等于val的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound(beg,end,val);upper_bound(beg,end,val,comp);从[beg,end)位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 equal_range返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 12equal_range(beg,end,val);equal_range(beg,end,val,comp); binary_search在[beg,end)中查找val，找到返回true。 12binary_search(beg,end,val);binary_search(beg,end,val,comp); 写容器元素的算法：fill_n/fill12fill_n(dest,cnt,val); 将值val赋给[beg,beg+n)范围内的所有元素。fill(beg,end,val); 将值val赋给[beg,end)范围内的所有元素。 generate_n/generate连续调用函数func填充[beg,end)范围内的所有元素。 12generate_n(dest,cnt,Gen);generate(beg,end,Gen); copy/copy_n复制[beg,end)到res 123copy(beg,end,dest);copy_backward(beg,end,dest);dest是输出序列的尾后迭代器。输入范围内的元素被拷贝或移动到目的序列的尾元素，然后是倒数第二个，类推。返回从beg拷贝或移动的元素的位置。如范围为空则返回dest transform1234将[beg,end)范围内所有元素依次调用函数unary，结果放入res中。transform(beg,end,dest,unaryOp); transform(beg,end,beg2,dest,binaryOp);将[beg,end)范围内所有元素与[beg2,beg2+end-beg)中所有元素依次调用函数unary，结果放入res中。 replace_copy将[beg,end)内所有等于oval的元素都用nval代替.将结果写入res。 12replace_copy(beg,end,dest,old_val,new_val);replace_copy_if(beg,and,dest,unaryPred,new_val); replace_if/replace将[beg,end)内所有等于old_val的元素都用nval代替 12replace(beg,end,old_val,new_val);replace_if(beg,end,unaryPred,new_val); merge12merge(beg1,end1,beg2,end2,dest); 合并[beg1,end1)与[beg2,end2)存放到res。merge(beg1,end1,beg2,end2,dest,comp); swap/swap_ranges123swap(elem1,elem2);swap_ranges(beg1,end1,beg2);iter_swap(iter1,iter2); inplace_merge合并[beg,mid)与[mid,end)，结果覆盖[beg,end)。 12inplace_merge(beg,mid,end);inplace_merge(beg,mid,end,comp); 划分与排序算法：partial_sort和nth_element只进行部分排序，速度比整体排序算法更快。 partition12stable_partition(beg,end,unaryPred); 与partition()类似，保留容器中的相对顺序。partition(beg,end,unaryPred); 元素重新排序，使用pred函数，把结果为true的元素放在结果为false的元素之前。 sort/stable_sort1234sort(beg,end); 默认升序重新排列元素sort(beg,end,comp);stable_sort(beg,end); 与sort()类似，保留相等元素之间的顺序关系。stable_sort(beg,end,comp); partial_sort/partial_sort_copy123456partial_sort(beg,mid,end); 排序mid-beg个元素。排序后，从beg到mid中的元素都是有序的，mid到end中的元素顺序未指定。partial_sort(beg,mid,end,comp);partial_sort_copy(beg,end,destBeg,destEnd);partial_sort_copy(beg,end,destBeg,destEnd,comp);排序输入范围内的元素，并将足够多的元素拷贝到destBeg和destEnd所指示的序列中。如果目的序列大于等于输入范围则排序整个输入序列并存入输出序列，若目的序列小于输入范围，则拷贝输入序列中与目的范围一样多的元素。返回一个迭代器，指向目的范围中已排序部分的尾后迭代器。如目的序列小于等于输入范围，则返回destEnd(此时是否整个输入序列排序？？？)。 nth_element单个元素序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。 12nth_element(beg,nth,end);nth_element(beg,nth,end,comp); 通用重新排序算法：remove/remove_copy1234567删除[beg,end)内所有等于val的元素。注意，该函数不是真正删除函数。采用的办法是:用保留的元素覆盖要删除的元素。算法返回一个迭代器，指向最后一个保留元素的尾后位置。remove(beg,end,val); remove_if(beg,end,unaryPred);remove_copy(beg,end,dest,val);remove_copy_if(beg,end,dest,unaryPred);将所有不等于val元素复制到res，返回OutputIterator指向被拷贝的末元素的下一个位置。 unique123456重排序列，对于相邻的满足条件的元素，通过覆盖来进行删除，返回一个迭代器，指向最后一个保留元素的尾后位置。unique(beg,end);unique(beg,end,binaryPred);unique_copy(beg,end,dest);unique_copy(beg,end,dest,binaryPred);与unique类似，不过把结果输出到dest。 rotate围绕mid指向的元素进行元素转动。元素mid成为首元素，随后是mid+1-&gt;end之间的之前的元素，再接着是beg到mid之前的元素。返回一个迭代器，指向原来beg位置的元素。 12rotate(beg,mid,end);rotate_copy(beg,mid,end,dest); reverse翻转序列中的元素。reverse返回void，reverse_copy返回一个迭代器，指向拷贝到目的序列的元素的尾后位置。 12reverse(beg,end);reverse_copy(beg,end,dest); random_shuffle使用随机访问迭代器的重排算法 12random_shuffle(beg,end); 元素随机调整次序。random_shuffle(beg,end,rand); 使用函数gen代替随机生成函数执行random_shuffle()。 排列算法：这些算法假定序列中的元素都是唯一的。要求双向迭代器。 is_permutation判断两个序列是否为同一元素集的不同排列 12is_permutation(beg1, end1, beg2)is_permutation(beg1, end1, beg2, binaryPred) next_permutation生成序列的字典序排列中的下一个,返回要给bool指出是否还有下一个如果序列已经是最后一个排序，则本函数将序列重排为最小的序列，返回false。否则将输入序列转为字典序的下一个排列，返回true。 12next_permutation(beg,end);next_permutation(beg,end,comp); 123456int a[6]={1,2,3,4,5,6};do{ for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl;}while(next_permutation(a,a+6)); prev_permutation生成序列的字典序排列中的前一个,返回要给bool指出是否还有前一个。若序列已经是第一个排序，则本函数将序列重排为最大的序列，返回false。否则将序列转为字典序的上一个排序，返回true。 12prev_permutation(beg,end);prev_permutation(beg,end,comp); 有序序列的集合算法：includes判断[beg1,end1)是否包含[beg2,end2)，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 12includes(beg,end,beg2,end2);includes(beg,end,beg2,end2,comp); set_union取[beg1,end1)与[beg2,end2)元素并集存放到dest。 12set_union(beg,end,beg2,end2,dest);set_union(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符，执行set_union() set_intersection取[beg1,end1)与[beg2,end2)元素交集存放到res。 12set_intersection(beg,end,beg2,end2,dest);set_intersection(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符 set_difference取[beg1,end1)与[beg2,end2)元素内差集存放到res。 12set_difference(beg,end,beg2,end2,dest);set_difference(beg,end,beg2,end2,dest,comp); 将函数comp代替&lt;操作符 set_symmetric_difference取[beg1,end1)与[beg2,end2)元素外差集存放到res。 12set_symmetric_difference(beg,end,beg2,end2,dest);set_symmetric_difference(beg,end,beg2,end2,dest,comp); 最大值和最小值算法：min/max1234min(va1,va2); 返回两个元素中较小一个。min(val1,val2,comp);max(val1,val2);max(val1,val2,comp); 返回两个元素中较大一个。 min_element/max_element1234min_element(beg,end); 返回一个ForwardIterator，指出[beg,end)中最大的元素。min_element(beg,end,comp);max_element(beg,end); 返回一个ForwardIterator，指出[beg,end)中最小的元素。max_element(beg,end,comp); lexicographical_compare12lexicographical_compare(beg1,end1,beg2,end2); 按字典序判断[beg1,end1)是否小于[beg2,end2)lexicographical_compare(beg1,end1,beg2,end2,comp); 将函数comp代替&lt;操作符 算术算法：&lt; numeric &gt;accumulate1234对[beg,end)内元素之和，加到初始值val上。accumulate(beg,end,init);accumulate(beg,end,init,BinaryOp);将函数BinaryOp代替加法运算，执行accumulate()。 partial_sum123将[beg,end)内该位置前所有元素之和放进dest中。partial_sum(beg,end,dest);partial_sum(beg,end,dest,BinaryOp); inner_product123对两个序列做内积(对应元素相乘，再求和)并将内积加到初始值init上。inner_product(beg1,end1,beg2,init);inner_product(beg1,end1,beg2,init,BinOp1,BinOp2); adjacent_difference将新序列写入dest，每个新元素(除了首元素)的值都为输入范围中当前位置和前一个位置元素之差。第一个版本使用-，第二个版本使用binaryOp。 12adjacent_difference(beg,end,dest);adjacent_difference(beg,end,dest,BinaryOp); 参考资料C++ primer 附录C++ STL 常见算法(比较详细)C++进阶：STL算法总结C/C++基础—算法概览关于lower_bound( )和upper_bound( )的常见用法","link":"/2020/06/21/STL-%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"},{"title":"Linux内核驱动","text":"设备文件类Unix操作系统都是基于文件概念的。 可以直接把I/O设备当作设备文件（device file）来处理。 操作普通文件的系统调用也可以直接用于I/O设备。 设备文件划分根据设备驱动程序的基本特性划分 块设备：块设备的数据可以被随机访问。 字符设备：字符设备的数据不可以随机访问（声卡）。或者可以随机访问但是随机访问数据时间很大程度上依赖于数据在设备内的位置（磁带）。 网卡是例外，网卡是不直接与设备文件相对应的硬件设备。 设备文件属性设备文件的索引节点： 设备文件是存放在文件系统中的实际文件。它的索引节点并不包含指向磁盘数据块的指针，因为它们是空的。 它的索引节点必须包含硬件设备的一个标识符，它对应字符或者块设备文件。 设备标识符: 由设备文件的类型（字符或者块）和一对参数组成（主设备号，从设备号）。 主设备号：标识了设备的类型。通常，具有相同主设备号和类型的所有设备文件共享相同的文件操作集合，因为它们是由同一个设备驱动程序处理的。 从设备号：标识了主设备号相同的设备组中的一个特定设备。例如相同磁盘控制器下的一组磁盘，有相同的主设备号，但是拥有不同的从设备号码。 创建设备文件:mknod()系统调用用来创建设备文件。参数有设备文件名，设备类型，主设备号以及次设备号。 设备文件通常在/dev下。 设备文件通常与硬件设备（比如硬盘/dev/hda）,或者硬件设备的某一个物理或者逻辑分区（比如磁盘分区/dev/hda2）对应。 有些情况下，设备文件不会和任何的实际硬件对应，而仅仅标识一个虚拟的逻辑设备。 比如 /dev/null 。 黑洞 注意:块设备的编号（3，0）不等同与字符设备的（3，0） 设备文件的用户态处理早期的Unix系统中，设备的主设备号和次设备号是8位长，并不够用。 真正的问题是设备文件被分配一次并且永远保留在/dev中；系统中的每个逻辑设备都应该有一个与其相对应的，明确定义了设备号的设备文件。 Documentation/devices.txt 存放了官方注册的已经分配的设备号和/dev目录节节点 include/linux/major.h 文件也可能包含了设备的主设备号对应的宏。 为了解决上述问题：从linux2.6开始，增加了设备号码的大小； 主设备号为12位 从设备号为20位 通常把两个参数合并为一个32位的dev_t变量； MAJOR宏和 MINOR宏 可以从dev_t中分别提取主设备号和次设备号 MKDEV宏把主设备号和次设备号合并称为一个dev_t值 动态分配设备号分配设备号和创建设备文件来说，倾向做法是高度动态地处理设备文件。 每个设备驱动程序在注册阶段都会指定它将要处理的设备号范围，驱动程序可以只指定设备号的分配范围，无需指定精确值，在这种情况下，内核会分配一个合适的设备号范围给驱动程序。 因此，新的硬件设备驱动程序不再需要从官方注册表中分配的一个设备号；它们可以仅仅使用当前系统中空闲的设备号。 然而这种情形下，就不能永久的创建设备文件，它只在设备驱动程序初始化一个主设备号和次设备号时才创建。 因此，这就需要一个标准的方法将每个驱动程序所使用的设备号输出到用户态应用程序中，为此，设备驱动程序模型提供了一个非常好的解决办法：把主设备号和次设备号存放在/sys/class子目录下的dev属性中。 概括来说就是，动态分配设备号给设备文件，也就是说设备文件不能永久创建，设备文件的设备号在创建的时候才能确定。那么用户态的应用程序如何才能知道动态分配给设备文件的设备号是什么呢？Linux中通过文件（/sys/class子目录下的dev属性）来传递这个信息给用户态应用程序 动态创建设备文件Linux内核可以动态地创建设备文件：它无需把每一个可能想到的硬件设备的设备文件都填充到/dev目录下，因为设备文件可以按照需要来创建。由于设备驱动程序模型的存在，在Linux2.6内核提供了一个简单的方法来处理：系统中必须安装一组udev工具集的用户态程序。 系统启动时，/dev目录是清空的，这时udev程序将扫描/sys/class子目录来寻找dev文件。 对每一个这样的文件（主设备号和次设备号的组合表示一个内核所支持的逻辑设备文件），udev程序都会在/dev目录下为它创建一个相应的设备文件。udev程序也会根据配置文件为其分配一个文件名并创建一个符号链接，该方法类似于Unix设备文件的传统命名模式。 最后，/dev目录里只存放了系统中内核所支持的所有设备的设备文件，而没有任何其他的文件。 通常在系统初始化后才创建设备文件。它要么发生在加载设备驱动程序所在的模块时，要么发生在一个热插拔的设备加入系统中时。udev工具集可以自动地创建相应的设备文件，因为设备驱动程序模型支持设备的热插拔。当发现一个新的设备时，内核会产生一个新的进程来执行用户态shell脚本文件/sbin/hotplug，并将新设备上的有用信息作为环境变量传递给shell脚本，用户态脚本文件读取配置文件信息并关注完成新设备初始化所必需的任何操作。如果安装了udev工具集，脚本文件也会在/dev目录下创建适当的设备文件。 设备文件的 VFS处理虽然设备文件也在系统的目录树中，但是它们和普通文件及目录文件有根本的不同: 进程访问普通文件时，它会通过文件系统访问磁盘分区中的一些数据块。 进程访问设备文件时，它只要驱动硬件设备就可以了。 隐藏设备文件和普通文件之间的差异就是vfs的责任： 为了做到这点，VFS在设备文件打开时改变其缺省文件操作；因此，可把设备文件的每个系统调用都转换成与设备相关的函数的调用，而不是对主文件系统相应函数的调用。 与设备相关的函数对硬件设备进行操作以完成进程所请求的操作。（注意：在路径名查找中，指向设备文件的符号链接与设备文件的作用相同）。 例子：假定open()一个设备文件，从本质上来说，相应的服务例程解析到设备文件的路径名，并建立相应的索引节点对象、目录项对象和文件对象。通过适当的文件系统函数（通常为ext2_read_inode()或ext3_read_inode()）读取磁盘上的相应的索引节点来对索引节点对象进行初始化。当这个函数确定磁盘索引节点与设备文件对应时，则调用init_special_inode()，该函数把索引节点对象的i_rdev字段初始化为设备文件的主设备号和次设备号，而把索引节点对象的i_fop字段设置为def_blk_fops或者def_chr_fops文件操作表的地址。因此，open()系统调用的服务例程也调用dentry_open()函数，后者分配一个新的文件对象并把其f_op字段设置为i_fop中存放的地址，即再一次指向def_blk_fops或者def_chr_fops的地址。正是这两个表的引入，才使得在设备文件上所发出的任何系统调用都将激活设备驱动程序的函数而不是基本文件系统的函数。 设备驱动程序设备驱动程序是内核例程的集合，它使硬件设备响应控制设备的编程接口。该编程接口是一组规范的VFS函数集合（open read lseek ioctl）。这些函数的实际实现由设备驱动程序全权负责。每一个设备都有自己的I/O控制器，因此就有唯一的命令和唯一的状态信息，所以大部分I/O设备都有自己的驱动程序。 设备驱动程序的组成？ 使用驱动设备有几个活动肯定是要发生的。 注册设备驱动程序 初始化设备驱动程序 监控I/O操作 访问I/O共享存储器 注册设备驱动程序为什么要注册设备驱动程序？ 在设备文件上发出的系统调用都由内核转化为相应设备驱动程序的对应函数的调用。 为了完成这个操作，设备驱动程序必须注册自己。设备驱动程序注册的过程注册一个设备驱动程序意味着分配一个新的device_driver描述符，将其插入到设备驱动程序模型的数据结构中，并把它对应的设备文件（可能多个）连接起来。如果设备文件对应的驱动程序以前没有注册，则对该设备文件的访问会返回错误码-ENODEV。 如果设备驱动程序是静态编译到内核的，则它的注册在内核初始化阶段进行。 如果是作为一个内核模块来编译的，则它的注册在模块装入的时候进行，而且在模块卸载的时候也会注销自己。 通用PCI设备的注册示例：该设备必须分配一个pci_driver类型的描述符，pci内核层使用该描述符来处理设备。初始化描述符的一些字段，设备驱动程序调用pci_regester_driver()函数。 pci_driver描述符包括一个内嵌的device_driver描述符 pci_regester_driver()函数仅仅初始化内嵌的驱动程序描述符中的字段，然后调用device_register()函数把驱动程序插入设备驱动程序模型的数据结构中。 注册设备驱动程序的时候 内核会寻找可能由该驱动程序处理但是尚未获得支持的硬件设备: 主要依靠bus_type的match方法以及device_driver对象的probe方法。如果探测到可被驱动程序处理的硬件设备，内核会分配一个设备对象，然后调用device_register()函数把设备插入设备驱动模型中。 初始化设备驱动程序设备驱动程序的注册和初始化是不同的。设备驱动程序应该尽快被注册，以便用户态应用程序能够通过相应的设备文件来使用它。设备驱动程序在最后可能的时刻才会被初始化。因为，初始化驱动程序意味着分配宝贵的系统资源，这些资源因此就对其他驱动程序不可用了。 监控I/O操作I/O操作的持续时间通常不可预知。在任何情况下，启动I/O操作的设备驱动程序都必须依靠一种监控技术在I/O操作终止或超时时候发出信号。 终止操作的情况下：设备驱动程序读取I/O接口状态寄存器的内容来确定I/O操作是否成功执行。 超时的情况下：时间过了，驱动程序就知道出了什么问题了。 轮询模式CPU依靠这种技术重复检查（轮询）设备的状态寄存器，直到寄存器的值表明I/O操作完成。有点类似于自旋锁。 如果完成I/O操作需要的时间相对较多，比如说毫秒级别，那么这种模式就变得低效，因为CPU花费宝贵的机器周期去等待I/O操作的完成。 轮询的简单例子： 1234567for(;;){ if(read_status(device)&amp;DEVICE_END_OPERATION) break; if(--count==0) //粗略的超时机制，精确的可以使用jiffies break;} 中断模式如果I/O控制器能够控制IRQ总线发出I/O操作结束的信号，那么中断模式才能被使用。 例子：实现一个简单的输入字符设备的驱动程序。 用户在相应的设备文件上发出read()系统调用，一条输入命令被发往设备的控制寄存器。 在一个不可预知的长时间间隔后，设备把一个字节的数据放进控制寄存器。 设备驱动程序然后将这个字节作为read()系统调用的结果返回。 驱动程序包含两个函数： 实现文件对象read方法的foo_read()函数。 处理中断的foo_interrupt()函数。 用户读设备文件，foo_read()函数就触发，foo_read()函数主要操作如下： 12345678910111213//参数filp是设备文件，buf是输入数据缓存，count是输入数据长度，ppos当前位置ssize_t foo_read(struct file *filp, char *buf, size_t count, loff_t *ppos){ foo_dev_t * foo_dev = filp-&gt;private_data; //foo_dev_t 自定义描述符 if (down_interruptible(&amp;foo_dev-&gt;sem) //获取foo_dev-&gt;sem信号量 return -ERESTARTSYS; foo_dev-&gt;intr = 0; //清intr标志 outb(DEV_FOO_READ, DEV_FOO_CONTROL_PORT); //对I/O设备发出读命令 wait_event_interruptible(foo_dev-&gt;wait, (foo_dev-&gt;intr = =1)); //执行wait_event_interruptible以挂起进程，直到intr标志变为1 if (put_user(foo_dev-&gt;data, buf)) return -EFAULT; up(&amp;foo_dev-&gt;sem); return 1; 设备驱动程序依赖类型为foo_dev_t的自定义描述符； 包含信号量sem（保护硬件设备免受并发访问） 等待队列wait 标志intr（当设备发出一个中断时设置） 单个字节缓冲区data（由中断处理程序写入且由read方法读取）。 一般而言，所有使用中断的I/O驱动程序都依赖中断处理程序及read和write方法均访问的数据结构。foo_dev_t描述符的地址通常存放在设备文件的文件对象的private_data字段中或一个全局变量中。 foo_read()函数的主要操作如下： 获取foo_dev-&gt;sem信号量，因此确保没有其他进程访问该设备。 清intr标志。 对I/O设备发出读命令。 执行wait_event_interruptible以挂起进程，直到intr标志变为1。 一定时间后，我们的设备发出中断信号以通知I/O操作已经完成，数据已经放在适当的DEV_FOO_DATA_PORT数据端口。中断处理程序置intr标志并唤醒进程。当调度程序决定重新执行这个进程时，foo_read()的第二部分被执行，步骤如下： 把准备在foo_dev-&gt;data变量中的字符拷贝到用户地址空间。 释放foo_dev-&gt;sem信号量后终止。 为了简单起见，没有包含任何超时控制。一般来说，超时控制是通过静态或动态定时器实现的；定时器必须设置为启动I/O操作后正确的时间，并在操作结束时删除。 foo_interrupt()函数的代码： 1234567irqreturn_t foo_interrupt(int irq, void *dev_id, struct pt_regs *regs){ foo-&gt;data = inb(DEV_FOO_DATA_PORT);//从设备的输入寄存器中读字符 foo-&gt;intr = 1; //设置intr标志 wake_up_interruptible(&amp;foo-&gt;wait); //调用`wake_up_interruptible()函数`唤醒在`foo-&gt;wait等待队列上`阻塞的进程。 return 1;} 中断处理程序从设备的输入寄存器中读字符，并把它存放在foo全局变量指向的驱动程序描述符foo_dev_t的data字段中。然后设置intr标志，并调用wake_up_interruptible()函数唤醒在foo-&gt;wait等待队列上阻塞的进程。注意：三个参数中没有一个被中断处理程序使用，这是其实是相当普遍的情况。 访问I/O共享存储器（内存映射）根据设备和总线的类型，现代PC体系结构里的I/O共享存储器可以被映射到不同的物理地址范围。主要有： 对于连接到ISA总线上的大多数设备 I/O共享存储器通常被映射到Oxa0000一Oxfffff的16位物理地址范围；这就在640 KB和1 MB之间留出了一段空间。 对连接到PCI总线上的设备 I/O共享存储器被映射到接近4GB的32位物理地址范围。这种类型的设备更加容易处理。 I/O共享存储器机制是极其重要的，因为建立好这些映射以后，访问设备接口中的存储器如同访问内存一样简单，就不需要那么多纷繁复杂的I/O交换了，大大提升了系统I/O处理的效率。 设备驱动程序如何访问一个I/O共享存储器单元？让我们从比较简单的PC体系结构开始人手，之后再扩展到其他体系结构。 不要忘了内核程序作用于线性地址，因此I/O共享存储器单元必须表示成大于PAGE_OFFSET的地址（？？？），这样，才有利于对I/O共享存储器单元的物理地址进行映射。我们假设PAGE_OFFSET等于Oxc0000000（在x86的32为体系中，实际上也是这样干的），也就是说，内核线性地址是在第4个GB。 设备驱动程序必须把I/O共享存储器单元的物理地址转换成内核空间的线性地址: 在PC体系结构中，这可以简单地把32位的物理地址和Oxc0000000常量进行或运算得到。 例如，假设内核需要把物理地址为Ox000b0fe4的I/O单元的值存放在t1中，把物理地址为Oxfc000000的I/O单元的值存放在t2中。你可能认为使用下面的表达式就可以完成这项工作： 12 t1 = *((unsigned char *)(0xc00b0fe4)); //括号里面的是线性地址 t2 = *((unsigned char *)(0xfc000000)); //强制转换为指针类型，也就是地址，然后再进行取地址所存的值 在初始化阶段，内核已经把可用的RAM物理地址映射到线性地址空间第4个GB的开始部分。因此，分页单元把出现在第一个语句中的线性地址OXCOObOfe4映射回到原来的I/O物理地址OXOOObOfe4，这正好落在从640KB到IMB的这段“ISA洞”中。这工作得很好。 但是，对于第二个语句来说，这里有一个问题，因为其I/O物理地址超过了系统RAM的最大物理地址（加上Oxc0000000常量会超过32位）。因此，线性地址Oxfc000000就不需要与物理地址Oxfc000000相对应。在这种情况下，为了在内核页表中包括对这个I/O物理地址进行映射的线性地址，必须对页表进行修改。这可以通过调用ioremap()或ioremap_nocache()函数来实现，第一个函数与vmalloc()函数类似，都调用get_vm_area()为所请求的I/O共享存储区的大小建立一个新的vm_struct描述符。然后，这两个函数适当地更新常规内核页表中的对应页表项。ioremap_nocache()不同于ioremap()，因为前者在适当地引用再映射的线性地址时还使硬件高速缓存内容失效。 因此，第二个语句的正确形式应该为： 12 io_mem = ioremap(0xfb000000, 0x200000); t2 = *((unsigned char *)(io_mem + 0x100000)); 第一条语句建立一个2MB的新的线性地址区间，该区间映射了从Oxfb000000开始的物理地址，第二条语句读取地址为Oxfc000000的内存单元。设备驱动程序以后要取消这种映射，就必须使用iounmap()函数。 在其他体系结构（PC之外的体系结构）上，简单地间接引用物理内存单元的线性地址并不能正确访问I/O共享存储器。因此，Linux定义了下列依赖于体系结构的函数，当访问I/O共享存储器时来使用它们： readb(), readw(), readl()：分别从一个I/O共享存储器单元读取1、2或者4个字节writeb(), writew(), writel()：分别向一个I/O共享存储器单元写入1、2或者4个字节memcpy_fromio(), memcpy_toio()：把一个数据块从一个I/O共享存储器单元拷贝到动态内存中，另一个函数正好相反memset_io()：用一个固定的值填充一个I/O共享存储器区域 最后，对于Oxfc000000 I/O单元的访问推荐使用这样的方法： 12 io_mem = ioremap(0xfb000000, 0x200000); t2 = readb(io_mem + 0x100000); 正是由于这些函数，就可以隐藏不同平台访问I/O共享存储器所用方法的差异。 //上面这一段话实在是太复杂了，现在总结一下； 一些概念IO空间与内存空间在X86处理器才存在IO空间，是相对于内存空间的概念。目前大多数嵌入式处理器（如ARM、PowerPC等）并不提供IO空间。所以内存空间是必须的，IO空间是可选的。嵌入式开发只关心内存空间即可。IO空间和内存空间是彼此独立的地址空间，在32位的X86处理器中，IO空间大小为64K ，内存空间为4G。 参考资料深入理解LINUX内核Linux下对IO内存的访问 //一些概念的介绍Linux内核开发之内存与I/O访问(一)","link":"/2020/06/29/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"},{"title":"Linux 设备驱动概述","text":"同类的东西，学习起来找共性就好了。学习Linux设备驱动，需要寻找各种驱动程序与系统的共性，探索其中的规律； 设备驱动的作用驱动程序的作用主要是实现硬件对软件工程师的隐形。 详细作用解释： 驱使硬件设备行动。 驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备记录文件和数据。 设备驱动充当了硬件和应用软件之间的纽带，它使得应用软件只需要调用系统软件的应用编程接口（API）就可以让硬件去完成要求的工作。 没有操作系统的情况，工程师可以根据硬件设备的特点自行定义接口，如对串口定义SerialSend()、SerialRecv()；对 LED 定义LightOn()、LightOff()；以及对 Flash 定义FlashWrite()、FlashRead()等。 有操作系统的情况，设备驱动的架构则由相应的操作系统定义，驱动工程师必须按照相应的架构设计设备驱动，这样，设备驱动才能良好地整合到操作系统的内核中。 无操作系统时的设备驱动对于功能比较单一、控制并不复杂的系统，如公交车刷卡机、电冰箱、微波、简单的手机和小灵通等，并不需要多任务调度、文件系统、内存管理等复杂功能，单任务架构完全可以很好地支持它们的工作。一个无限循环中夹杂对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构。 单任务软件典型架构 1234567891011121314151617181920212223int main(int argc,char* avgv[]){ while(1) { if(serialInt==1) // 有串口中断 { ProcessSerialInt(); //处理串口中断 serialInt=0; //中断标志变量清0 } if(keyInt==1) //有按键中断 { ProcessKeyInt(); //处理按键中断 keyInt=0; //中断标志标量清0 } status=CheckXXX(); switch(status) { . . . } . . . } } 这样的系统中，虽然不存在操作系统，但是设备驱动是必须存在的。 一般情况下，对每一种设备驱动都会定义为一个软件模块，包含.h文件和.c文件。 .h文件定义该设备驱动的数据结构并声明外部函数，.c文件进行设备驱动的具体实现。 举例：一个串口驱动serial.c serial.h，主要是配置GPIO，串口控制寄存器，以及串口的收发（读写）寄存器，而这几个配置都是自定义函数实现的，比如串口的写（发）SerialSend 函数等。 12345678910111213141516171819202122232425262728293031/***********************serial.h 文件**********************/extern void SerialInit(void);extern void SerialSend(const char buf*,int count);extern void SerialRecv(char buf*,int count);/***********************serial.c 文件**********************//* 初始化串口 */void SerialInit(void){...}/* 串口发送 */void SerialSend(const char buf*,int count){...}/* 串口接收 */void SerialRecv(char buf*,int count){...}/* 串口中断处理函数 */void SerialIsr(void){...serialInt = 1;} 其他模块需要使用这个设备的时候，只需要包含设备驱动的头文件 serial.h，然后调用其中的外部接口函数即可。如我们要从串口上发送字符串“Hello World”，使用函数SerialSend( “ Hello World “,11)即可。 这样子，在没有操作系统的情况下，设备驱动的接口被直接提交给了应用软件工程师， 应用软件没有跨越任何层次就直接访问了设备驱动的接口。 设备驱动包含的接口函数也与硬件的功能直接吻合， 没有任何附加功能。 有的工程师把单任务系统设计成设备驱动和具体的应用软件模块处于同一层次（即应用程序也在比如serial.c中实现），这显然是不合理的，不符合软件设计中高内聚低耦合的要求。另一种不合理的设计是直接在应用中操作硬件的寄存器（单独一个main.c，所有功能都在一个函数中实现，不采用其他任何接口/函数），而不单独设计驱动模块，这种设计意味着系统中不存在或未能充分利用可被重用的驱动代码。 有操作系统时的设备驱动当系统中包含操作系统后，设备驱动会变得怎样？ 首先，无操作系统时设备驱动的硬件操作工作仍然是必不可少的， 没有这一部分，设备驱动不可能与硬件打交道。 其次，我们还需要将设备驱动融入内核。为了实现这种融合，必须在所有的设备驱动中设计面向操作系统内核的接口。 这样的接口由操作系统规定，对一类设备而言结构一致，独立于具体的设备。 由此可见，当系统中存在操作系统的时候，设备驱动变成了连接硬件和内核的桥梁。 操作系统的存在势必要求设备驱动附加更多的代码和功能（主要是提供了很多结构），把单一的“驱使硬件设备行动”变成了操作系统内与硬件交互的模块，它对外呈现为操作系统的API，不再给应用软件工程师直接提供接口。 有了操作系统之后，设备驱动反而变得复杂，那要操作系统干什么？ 首先，一个复杂的软件系统需要处理多个并发的任务，没有操作系统，想完成多任务并发是很困难的。 其次，操作系统给我们提供内存管理机制。一个典型的例子是，对于多数含 MMU的处理器而言，Windows、Linux 等操作系统可以让每个进程都独立地访问 4GB的内存空间。 上述优点似乎并没有体现在设备驱动身上，操作系统的存在给设备驱动究竟带来了什么好处呢？ 简而言之，操作系统通过给设备驱动制造麻烦来达到给上层应用提供便利的目的。 如果设备驱动都按照操作系统给出的独立于设备的接口而设计，应用程序将可使用统一的系统调用接口来访问各种设备。 对于类UNIX的VxWorks、Linux等操作系统而言，应用程序通过write()、read()等函数读写文件就可以访问各种字符设备和块设备，而不用管设备的具体类型和工作方式，是非常方便的。 不管有无操作系统，不管是SerialSend，或者write，访问设备都需要对寄存器进行读写操作，比如串口，在dev目录下有个ttys0结点，我们可以通过ioctl函数对其进行读写操作，当然，write、read更为直接咯。而上层的应用可以对这些函数进行封装，定义不同的接口，从而实现更多的功能 Linux设备的分类及特点驱动针对的对象是存储器和外设（包括CPU 内部集成的存储器和外设），而不是针对CPU 内核。 多说一点，以前的通过总线挂载到cpu的一些设备，正在被逐渐集成到CPU上。随着IC 制作工艺的发展，目前，芯片的集成度越来越高，往往在CPU 内部就集成了存储器和外设适配器。譬如，相当多的ARM、PowerPC、MIPS 等处理器都集成了UART、I2C 控制器、SPI 控制器、USB 控制器、SDRAM 控制器等，有的处理器还集成了GPU（图形处理器）、视频编解码器等。 Linux 将存储器和外设分为3 个基础大类。 字符设备 字符设备指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等。 块设备 块设备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC 等。 网络设备 网络设备面向数据包的接收和发送而设计，它并不倾向于对应于文件系统的节点。内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，前者主要还是使用套接字接口。 Linux设备驱动与整个软硬件系统的关系如图所示，除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open()、write()、read()、close()等即可访问字符设备和块设备。所有字符设备和块设备都统一呈现给用户。 Linux的块设备有两种访问方法： 类似dd命令对应的原始块设备，如“/dev/sdb1”等； 在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径如“/home/barry/hello.txt”的形式进行访问。 在Linux中，针对NOR、NAND等提供了独立的内存技术设备（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡能力的文件系统。 针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。 应用程序可以使用Linux的系统调用接口编程，但也可使用C库函数，出于代码可移植性的目的，后者更值得推荐。 C库函数本身也通过系统调用接口而实现，如C库函数fopen()、fwrite()、fread()、fclose()分别会调用操作系统的API open()、write()、read()、close()。 Linux 设备驱动学习的重点、难点 好的硬件基础:懂得 SRAM、Flash、SDRAM、磁盘的读写方式，UART、I2C、USB 等设备的接口以及轮询、中断、DMA 的原理，PCI 总线的工作方式以及CPU 的内存管理单元（MMU）等。 好的 C 语言基础: 能灵活地运用 C 语言的结构体、指针、函数指针及内存动态申请和释放等。 一定的 Linux 内核基础:至少要明白驱动与内核的接口。尤其是对于块设备、网络设备、Flash 设备、串口设备等复杂设备，内核定义的驱动体系结构本身就非常复杂。 非常好的多任务并发控制和同步的基础:在驱动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。 资源与工具 类似http://lxr.free-electrons.com/、http://lxr.oss.org.cn/ 这样的网站提供了Linux 内核源代码的交叉索引，在其中输入Linux 内核中的函数、数据结构或变量的名称就可以直接得到以超链接形式给出的定义和引用它的所有位置。 一些网站也提供了Linux 内核中函数、变量和数据结构的搜索功能，在google 中搜索“linux identifier search ”可得。 Linux 主机上阅读和编辑Linux 源码的常用方式是vim + cscope 或者vim + ctags，vim是一个文本编辑器，而cscope 和ctags 则可建立代码索引 LED驱动示例（选看）无操作系统时的LED 驱动在嵌入式系统的设计中，LED 一般直接由CPU 的GPIO（通用可编程I/O）口控制。GPIO 一般由两组寄存器控制，即一组控制寄存器和一组数据寄存器。 控制寄存器可设置GPIO 口的工作方式为输入或者输出。 当引脚被设置为输出时，向数据寄存器的对应位写入1和0 会分别在引脚上产生高电平和低电平； 当引脚设置为输入时，读取数据寄存器的对应位可获得引脚上的电平为高或低。 假设: 在GPIO_REG_CTRL 物理地址中控制寄存器处的第n 位写入1 可设置GPIO 口为输出 在地址GPIO_REG_DATA 物理地址中数据寄存器的第n 位写入1 或0 可在引脚上产生高或低电平 则在无操作系统的情况下，设备驱动见代码3。 123456789101112131415161718192021//代码3#def ine reg_gpio_ctrl *(volatile int *)(ToVirtual(GPIO_REG_CTRL))#def ine reg_gpio_data *(volatile int *)(ToVirtual(GPIO_REG_DATA))// 程序中ToVirtual() 的作用是当系统启动了硬件MMU 之后，根据物理地址和虚拟地址的映射关系，将寄存器的物理地址转化为虚拟地址。/* 初始化LED */void LightInit(void){reg_gpio_ctrl |= (1 &lt;&lt; n); /* 设置GPIO 为输出 */}/* 点亮LED */void LightOn(void){reg_gpio_data |= (1 &lt;&lt; n); /* 在GPIO 上输出高电平 */}/* 熄灭LED */void LightOff(void){reg_gpio_data &amp;= ～ (1 &lt;&lt; n); /* 在GPIO 上输出低电平 */} 上述程序中的LightInit()、LightOn()、LightOff() 都直接作为驱动提供给应用程序的外部接口函数。 Linux 下的LED驱动在Linux 下，可以使用字符设备驱动的框架来编写对应于代码3的LED 设备驱动（这里仅仅是为了方便讲解，内核中实际实现了一个提供sysfs 节点的GPIO LED 驱动，位于drivers/leds/leds-gpio.c 中），操作硬件的LightInit()、LightOn()、LightOff() 函数仍然需要，但是，遵循Linux 编程的命名习惯，重新将其命名为light_init()、light_on()、light_off()。这些函数将被LED 设备驱动中独立于设备并针对内核的接口进行调用。 代码4，Linux 操作系统下的LED 驱动: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include .../* 包含内核中的多个头文件 *//* 设备结构体 */struct light_dev { struct cdev cdev; /* 字符设备cdev 结构体 */ unsigned char vaule; /* LED 亮时为1，熄灭时为0，用户可读写此值 */};struct light_dev *light_devp;int light_major = LIGHT_MAJOR;MODULE_AUTHOR(\"Barry Song &lt;21cnbao@gmail.com&gt;\");MODULE_LICENSE(\"Dual BSD/GPL\");/* 打开和关闭函数 */int light_open(struct inode *inode, struct file *filp){ struct light_dev *dev; /* 获得设备结构体指针 */ dev = container_of(inode-&gt;i_cdev, struct light_dev, cdev); /* 让设备结构体作为设备的私有信息 */ filp-&gt;private_data = dev; return 0;}int light_release(struct inode *inode, struct file *filp){ return 0;}/* 读写设备: 可以不需要 */ssize_t light_read(struct file *filp, char __user *buf, size_t count,loff_t *f_pos){ struct light_dev *dev = filp-&gt;private_data; /* 获得设备结构体 */ if (copy_to_user(buf, &amp;(dev-&gt;value), 1)) return -EFAULT; return 1;}ssize_t light_write(struct file *filp, const char __user *buf, size_t count,loff_t *f_pos){ struct light_dev *dev = filp-&gt;private_data; if (copy_from_user(&amp;(dev-&gt;value), buf, 1)) return -EFAULT; /* 根据写入的值点亮和熄灭LED */ if (dev-&gt;value == 1) light_on(); else light_off(); return 1;}/* ioctl 函数 */int light_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,unsigned long arg){ struct light_dev *dev = filp-&gt;private_data; switch (cmd) { case LIGHT_ON: dev-&gt;value = 1; light_on(); break; case LIGHT_OFF: dev-&gt;value = 0; light_off(); break; default: /* 不能支持的命令 */ return -ENOTTY; } return 0;}struct file_operations light_fops = { .owner = THIS_MODULE, .read = light_read, .write = light_write, .ioctl = light_ioctl, .open = light_open, .release = light_release,};/* 设置字符设备cdev 结构体 */static void light_setup_cdev(struct light_dev *dev, int index){ int err, devno = MKDEV(light_major, index); cdev_init(&amp;dev-&gt;cdev, &amp;light_fops); dev-&gt;cdev.owner = THIS_MODULE; dev-&gt;cdev.ops = &amp;light_fops; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE \"Error %d adding LED%d\", err, index);}/* 模块加载函数 */int light_init(void){ int result; dev_t dev = MKDEV(light_major, 0); /* 申请字符设备号 */ if (light_major) result = register_chrdev_region(dev, 1, \"LED\"); else { result = alloc_chrdev_region(&amp;dev, 0, 1, \"LED\"); light_major = MAJOR(dev); } if (result &lt; 0) return result;/* 分配设备结构体的内存 */ light_devp = kmalloc(sizeof(struct light_dev), GFP_KERNEL); if (!light_devp) { result = -ENOMEM; goto fail_malloc; } memset(light_devp, 0, sizeof(struct light_dev)); light_setup_cdev(light_devp, 0); light_gpio_init(); return 0; fail_malloc: unregister_chrdev_region(dev, light_devp); return result;}/* 模块卸载函数 */void light_cleanup(void){ cdev_del(&amp;light_devp-&gt;cdev); /* 删除字符设备结构体 */ kfree(light_devp); /* 释放在light_init 中分配的内存 */ unregister_chrdev_region(MKDEV(light_major, 0), 1); /* 删除字符设备 */}module_init(light_init);module_exit(light_cleanup); 除了代码3 中的硬件操作函数仍然需要外，代码4 中还包含了大量暂时陌生的元素，如结构体file_operations、cdev，Linux 内核模块声明用的MODULE_AUTHOR、MODULE_LICENSE、module_init、module_exit，以及用于字符设备注册、分配和注销的函数register_chrdev_region()、alloc_chrdev_region()、unregister_chrdev_region() 等。我们也不能理解为什么驱动中要包含light_init ()、light_cleanup ()、light_read()、light_write() 等函数。此时，我们只需要有一个感性认识，那就是，上述暂时陌生的元素都是Linux 内核为字符设备定义的，以实现驱动与内核接口而定义的。Linux 对各类设备的驱动都定义了类似的数据结构和函数。 概括来说： 没有操作系统的时候，设备驱动编写的函数可以自己定义，对外提供给应用程序调用。 有了操作系统之后，设备驱动的内容就变多了，除了之前没有操作系统时候写的一些，还需要根据操作系统内核进行适配。这时候的驱动程序并不能直接和应用程序打交道了，而是和操作系统内核打交道，对外呈现出操作系统的API。 设备驱动都按照操作系统给出的独立于设备的接口而设计，应用程序将可使用统一的系统调用接口来访问各种设备。 也就是说这些接口的形式都是操作系统给出的，操作系统会对一类设备给出一致的接口，不会针对一个特定的设备给接口。 注解C 语言结构体，以点号开头： C99标准中的结构体初始化方法 ，结构体的乱许赋值，好像是GCC的扩展。 和linux无关，是一个C的问题，初始化的时候指定成员的名字，即使在结构体增加，插入字段的时候代码也可以正常工作。 参考资料《Linux设备驱动开发详解：基于最新的Linux 4.0内核》","link":"/2020/06/29/Linux-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A6%82%E8%BF%B0/"},{"title":"Linux程序的执行过程","text":"我们需要知道什么？ 进程的概念在UNIX中的表现就是一组程序竞争系统资源的行为。内核是如何通过程序文件的内容建立进程的执行上下文？一个程序执行的上下文到底是什么呢？ 虽然将一组指令装入内存让 CPU 执行看起来不是大问题，但内核还必须处理以下几方面的问题： 不同的可执行文件格式。Linux 可在 64 位版本的机器上执行 32 位可执行代码。 共享库。很多可执行文件并不包含执行程序所需的所有代码，而是期望内核在运行时从共享库中加载函数。 执行上下文的其它信息。这包括命令行参数与环境变量。 程序是以可执行文件(executable file)的形式存放在磁盘上的，可执行文件既包括被执行函数的目标代码，也包括这些函数所使用的数据。程序中的很多函数是所有程序员都可使用的服务例程，它们的目标代码包含在所谓“库”的特殊文件中: 实际上，一个库函数的代码或被静态地拷贝到可执行文件(静态库) 或在运行时被连接到进程(共享库，因为它们的代码由很多独立的进程所共享)。 当装入并运行一个程序时，用户可以提供影响程序执行方式的两种信息： 命令行参数：用户在shell提示符下紧跟文件名输入的就是命令行参数。 环境变量：环境变量(例如HOME和PATH)是从shell继承来的，但用户在装入并运行程序前可以修改任何环境变量。 接下来各部分的内容可执行文件：解释一个程序的执行上下文是什么。可执行格式：提及一些 Linux 所支持的可执行格式，并说明 Linux 如果改变它的“个性”以执行其它操作系统所编译的程序。exec 函数：描述执行一个新程序的进程所需的系统调用。 可执行文件进程可以定义为执行上下文。这也意味着进行特定的计算需要收集必要的信息，包括所访问的页，打开的文件，硬件寄存器的内容等。可执行文件是一个普通文件，描述了如何初始化一个新的执行上下文，也就是如何开始一个新的计算。 执行过程示例假如一位用户想在当前目录下面显示文件（我们知道用ls命令就可以），用户在shell提示符下只需要简单的敲出外部命令/bin/ls就可以了。这时候具体会发生什么呢？ 命令shell会创建一个新的进程，新的进程又会调用系统调用execve(),其中传递的一个参数就是ls可执行文件的全路径名（本例子中是/bin/ls） sys_exec()找到相应的文件，检查可执行的格式，并根据存放在其中的信息修改当前进程的上下文。 因此，当这个系统调用中止的时候，新的进程开始执行存放在可执行文件中的代码。本例子中是执行目录显示。 当一个进程开始新的程序的时候，它的执行上下文会发生很大的变化。因为进程的前一个计算执行期间所获得的大部分资源会被抛弃，但是进程的 PID 不改变，并且新的计算从前一个计算继承所有打开的文件描述符。 比方上面的示例，当进程开始执行/bin/ls时候，它用execve()系统调用传递来的新参数代替shell的参数，并获得一个新的shell环境。 然后从父进程继承来的所有的页（并通过写时复制机制实现共享）被释放，以便在一个新的用户态空间执行新的计算，甚至进程的特权都可能改变。 当前进程的PID是不会改变的，而且新的计算会继承从之前计算所有打开的文件描述符，当然这些文件描述符是之前执行execve()系统调用时还没有自动关闭的描述符。 进程的信任状和权能进程的信任状作用 信任状把进程与一个特定的用户或用户组捆绑在一起。 信任状在多用户系统上特别重要，因为信任状可以决定每个进程能做什么，不能做什么，保证了用户个人数据的完整性，也保证了系统整体上的稳定性。 信任状的使用需要进程数据结构方面给予支持，也需要被保护的资源方面给与支持。 比如文件，当某个进程试图访问一个文件，VFS总是根据文件的拥有者和进程的信任状所建立的许可权检查访问的合法性。 进程描述符中的信任状字段进程的信任状存放在进程描述符的几个字段中： 12345uid,gid 用户和组的实际标识符euid,egid 用户和组的有效标识符 fsuid,fsgid 文件访问的用户和组的有效标识符 groups 补充的组标识符suid,sgid 用户和组保存的标识符 说明： euid(effective user ID):当进程执行时间, 操作系统会对euid进行识别, 以此来判断到底用什么权限来执行这个进程. 值为0的uid指定给root用户，值为0的gid指定给root超级组。只要有关进程的信任状存放了一个零值，则内核将放弃权限检查，始终允许这个进程做任何事情，如涉及系统管理或硬件处理的那些操作，而这些操作对于非特权进程是不允许的。 setuid是类unix系统提供的一个标志位， 其实际意义是set一个process的euid为这个可执行文件或程序的拥有者(比如root)的uid， 也就是说当setuid位被设置之后， 当文件或程序(统称为executable)被执行时, 操作系统会赋予文件所有者的权限, 因为其euid是文件所有者的uid. setuid的方法是使用Linux的chmod指令，我们都习惯给予一个文件类似“0750” “0644” 之类的权限，它们的最高位0就是setuid的位置 比如 chmod 4750 文件名 当一个进程被创建时，总是继承父进程的信任状。 不过，这些信任状以后可以被修改，这发生在当进程开始执行一个新程序时，或者当进程发出合适的系统调用时。 通常情况下，进程的uid, euid, fsuid及suid字段具有相同的值。然而，当进程执行setuid程序时，即可执行文件的setuid标志被设置时，euid和fsuid字段被置为这个文件拥有者的标识符。几乎所有的检查都涉及这两个字段中的一个：fsuid用于与文件相关的操作，而euid用于其他所有的操作。这也同样适用于组标识符的gid、egid、fsgid及sgid字段。 如何使用fsuid字段考虑一下当用户想改变口令时的情况。所有的口令都存放在一个公共文件中，但用户不能直接编辑这样的文件，因为它是受保护的。因此使用如下操作： 户调用一个名为/usr/bin/passwd的系统程序，它可以设置setuid标志，而且它的拥有者是超级用户。 当shell创建的进程执行这样一个程序时，进程的euid和fsuid字段被置为0，即超级用户的PID。 现在，这个进程可以访问这个文件，因为当内核执行访问控制表时在fsuid字段发现了值。 当然，/usr/bin/passwd程序除了让用户改变自己的口令外，并不允许做其他任何事情。 系统调用怎样影响进程信任状从Unix的历史发展可以得出一个教训，即setuid程序是相当危险的：恶意用户可以以这样的方式触发代码中的一些bug，从而强迫setuid程序执行程序的最初设计者从未安排的操作。这可能常常危及整个系统的安全。为了减少这样的风险，Linux与所有现代Unix操作系统一样，让进程只有在必要时才获得setuid特权，并在不需要时取消它们。可以证明，当使用数个保护级别来实现用户应用程序时，这种特点是很有用的。进程描述符包含一个suid字段，在setuid程序执行以后在该字段中正好存放有效标识符(euid和fsuid)的值。进程可以通过setuid()、setresuid()、setfsuid()和setreuid()系统调用改变有效标识符。 下表显示了这些系统调用是怎样影响进程的信任状的。如果调用进程还没有超级用户特权，即它的euid字段不为0，那么，只能用这些系统调用来设置在这个进程的信任状字段已经有的值。例如，一个普通用户进程可以通过调用系统调用setfsuid()强迫它的fsuid值为500，但这只有在其他信任状字段中有一个字段已经有相同的值500时才行。 设置信任状的系统调用 setuid(e) setuid(e) 字段 euid = 0 euid != 0 setresuid(u,e,s) setresuid(u,e) setresuid(f) uid 设置为e 不改变 设置为u 设置为u 不改变 euid 设置为e 设置为e 设置为e 设置为e 不改变 fsuid 设置为e 设置为e 设置为e 设置为e 设置为f suid 设置为e 不改变 设置为s 设置为e 不改变 为了理解四个用户ID字段之间的关系，考虑setuid()系统调用的效果。 这些操作是不同的，这取决于调用者进程的euid字段是否被置为0(即进程有超级用户特权)或被置为一个正常的UID。 如果euid字段为0，这个系统调用就把调用进程的所有信任状字段(uid, euid, fsuid及suid)置为参数e的值。超级用户进程因此就可以删除自己的特权而变为由普通用户拥有的一个进程。 例如，在用户登录时，系统以超级用户特权创建一个新进程，但这个进程通过调用setuid()系统调用删除自己的特权，然后开始执行用户login shell程序。 如果euid字段不为0，那么这个系统调用只修改存放在euid和fsuid中的值，让其他两个字段保持不变。 当运行setuid程序来提高和降低进程有效权限时(这些权限存放在euid和fsuid字段)，该系统调用的这种功能是非常有用的。 进程的权能（可选看）这个在linux中不怎么用。“权能(capability )”一词引人进程信任状的另一种模型。Linux内核支持POSIX权能，一种权能仅仅是一个标志，它表明是否允许进程执行一个特定的操作或一组特定的操作。这个模型不同于传统的“超级用户VS普通用户”模型，在后一种模型中，一个进程要么能做任何事情，要么什么也不能做，这取决于它的有效UID。在Linux内核中已包含了很多权能。权能的主要优点是，任何时候每个进程只需要有限种权能。因此，即使有恶意的用户发现一种利用有潜在错误的程序的方法，他也只能非法地执行有限个操作类型。 命令含参数和 shell 环境当用户键入一个命令时，为满足这个请求而装入的程序可以从shell接收一些命令行参数(command-line argument)。例如: 当用户键入命令:$ ls -l /usr/bin以获得/usr/bin目录下的全部文件列表时，shell进程创建一个新进程执行这个命令。 这个新进程装入/bin/ls可执行文件。在这样做的过程中，从shell继承的大多数执行上下文被丢弃，但三个单独的参数ls、-l和/usr/bin依然保持。 一般情况下，新进程可以接收任意多个参数。传递命令行参数的约定依赖于所用的高级语言。 传递命令行参数在C语言中，程序的main()函数把传递给程序的参数个数和指向字符串指针数组的地址作为参数。下列原型形式化地表示了这种标准格式: 1int main(int argc，char *argv[]) 回到前面的例子: 当/bin/ls程序被调用时，argc的值为3, argv[0]指向”ls”字符串，argv[1]指向”-l”字符串，而argv[2]指向”/usr/bin”字符串。 argv数组的末尾处总以空指针来标记，因此，argv[3]为NULL。 在C语言中，传递给main()函数的第三个可选参数是包含环境变量的参数。 传递环境变量参数环境变量用来定制进程的执行上下文，由此为用户或其他进程提供通用的信息，或者允许进程在执行execve()系统调用的过程中保持一些信息。为了使用环境变量，main ()可以声明如下： 1int main(int argc，char *argv()，char *envp[]) envp参数指向环境串的指针数组，形式如下： 1VAR_NAME=something 说明： VAR_NAME表示一个环境变量的名字，而“=”后面的子串表示赋给变量的实际值。 envp数组的结尾用空指针标记，就像argv数组。envp数组的地址存放在C库的environ全局变量中。 命令行参数和环境串都存放在用户态堆栈中，正好位于返回地址之前。 下图显示了用户态堆栈的底部单元。环境变量位于栈底附近正好在一个长整数0(即图中的NULL)之后。 库每个高级语言的源码文件都是经过几个步骤才转化为目标文件的（.o文件），目标文件中包含的是汇编语言指令的机器代码，它们和相应的高级语言指令对应。 目标文件并不能被执行，因为它不包含源代码文件所用的全局外部符号名的线性地址，例如库函数或同一程序中的其他源代码文件。 这些地址的分配或解析是由链接程序完成的，链接程序把程序所有的目标文件收集起来并构造可执行文件。 链接程序还分析程序所用的库函数，并以本章后面所描述的方式把它们粘合成可执行文件。 大多数程序，甚至是最小的程序都会利用C库。 例如下面只有一行的C程序： 1void main(void){} 尽管这个程序没有做任何事情，但还是需要做很多工作来建立执行环境，并在程序终止时杀死这个进程。尤其当main()函数终止时，C编译程序把exit_group()函数插入到目标代码中。程序通常通过C库中的封装例程调用系统调用，C编译器亦如此。 任何可执行文件除了包括对程序的语句进行编译所直接产生的代码外，还包括一些“粘合”代码来处理用户态进程与内核之间的交互。这样的粘合代码有一部分存放在C库中。除了C库，Unix系统中还包含很多其他的函数库。一般的Linux系统通常就有几百个不同的库。 传统Unix系统中的所有可执行文件都是基于静态库(static library)的。这意味着链接程序所产生的可执行文件不仅包括原程序的代码，还包括程序所引用的库函数的代码。静态库的一大缺点是它们占用大量的磁盘空间。因为每个静态链接的可执行文件都复制库代码的某些部分。现代Unix系统利用共享库(shared library)。可执行文件不用再包含库的目标代码，而仅仅指向库名。当程序被装入内存执行时，一个名为动态链接器(dynamic linker，也叫ld.so)的程序就专注于分析可执行文件中的库名，确定所需库在系统目录树中的位置，并使执行进程可以使用所请求的代码。进程也可以使用dlopen()库函数在运行时装入额外的共享库。 共享库的优点： 共享库对提供文件内存映射的系统尤为方便，因为它们减少了执行一个程序所需的主内存量。 当动态链接程序必须把某一共享库链接到进程时，并不拷贝目标代码，而是仅仅执行一个内存映射，把库文件的相关部分映射到进程的地址空间中。这就允许共享库机器代码所在的页框被使用同一代码的所有进程共享。如果程序是静态链接的，那么共享是不可能的。 共享库的缺点: 动态链接的程序启动时间通常比静态链接的程序长。 动态链接的程序的可移植性也不如静态链接的好，因为当系统中所包含的库版本发生变化时，动态链接的程序运行时就可能出现问题。 如何编译的时候只使用静态链接： 用户可以始终请求一个程序被静态地链接。例如，GCC编译器提供-static选项，即告诉链接程序使用静态库而不是共享库。程序段和进程的线性区从逻辑上说，Unix程序的线性地址空间传统上被划分为几个叫做段(segment)的区间： 正文段 包含程序的可执行代码。 己初始化数据段 包含已初始化的数据，也就是初值存放在可执行文件中的所有静态变量和全局变量(因为程序在启动时必须知道它们的值)。 未初始化数据段(bss段) 包含未初始化的数据，也就是初值没有存放在可执行文件中的所有全局变量，因为程序在引用它们之前才赋值，历史上把这个段叫做bss段。 堆栈段 包含程序的堆栈，堆栈中有返回地址、参数和被执行函数的局部变量。 每个mm_struct内存描述符都包含一些字段来标识相应进程特定线性区的作用：start_code，end_code：程序的源代码所在线性区的起始和终止线性地址，即可执行文件中的代码。start_data，end_data：程序的初始化数据所在线性区的起始和终止线性地址，正如在可执行文件中所指定的那样。这两个字段指定的线性区大体上与数据段对应。start_brk，brk：存放线性区的起始和终止线性地址，该线性区包含动态分配给进程的内存区。有时把这部分线性区叫做堆。start_stack：正好在main()的返回地址之上的地址。更高的地址被保留(栈向低地址增长)。arg_start，arg_end：命令行参数所在的堆栈部分的起始地址和终止地址。env_start，env_end：环境串所在的堆栈部分的起始地址和终止地址。 可执行格式Linux标淮的可执行格式是ELF(Executable and Linking Format)，它由Unix系统实验室开发并在Unix世界相当流行。著名的Unix操作系统都把ELF作为它们的主要可执行格式。Linux的旧版支持另一种名叫Assembler OUTput Format (a.out)的格式。因为现在ELF非常实用，因此已经很少用a.out格式。 Linux支持很多其他不同格式的可执行文件。 在这种方式下，Linux能运行为.其他操作系统所编译的程序，如MS-DOS的EXE程序。 有几种可执行格式，如Java或bash脚本，是与平台无关的。 由类型为linux_binfmt的对象所描述的可执行格式实质上提供以下三种方法： load_binary 通过读存放在可执行文件中的信息为当前进程建立一个新的执行环境。 load_shlib 用于动态地把一个共享库捆绑到一个已经在运行的进程，这是由uselib()系统调用激活的。 core_dump 在名为core的文件中存放当前进程的执行上下文。这个文件通常在进程接收到缺省操作为“dump”的信号时被创建，格式取决于被执行程序的可执行类型。 所有的linux binfmt对象都处于一个单向链表中。 链表第一个元素的地址：存放在formats变量中。 插入和删除元素：通过调用register_binfmt()和unregister_binfmt()函数在链表中插入和删除元素。 在系统启动期间，为每个编译进内核的可执行格式都执行register_binfmt()函数。 当实现了一个新的可执行格式的模块正被装载时，也执行这个函数，当模块被卸载时，执行unregister_binfmt()函数。 在formats链表中的最后一个元素:是对解释脚本的可执行格式进行描述的一个对象。 这种格式只定义了load_binary方法。其相应的load_script()函数检查这种可执行文件是否以两个#!字符开始。如果是，这个函数就把第一行的其余部分解释为另一个可执行文件的路径名，并把脚本文件名作为参数传递以执行它。 自定义的可执行格式Linux允许用户注册自己定义的可执行格式: 对这种格式的识别或者通过存放在文件前128字节的魔数，或者通过表示文件类型的扩展名。例如，MS-DOS的扩展名由“.”把三个字符从文件名中分离出来：.exe扩展名标识可执行文件，而.bat扩展名标识shell脚本。 如何执行当内核确定可执行文件是自定义格式时，它就启动相应的解释程序。解释程序运行在用户态，读入可执行文件的路径名作为参数，并执行计算。例如，包含Java程序的可执行文件就由Java虚拟机(如//usr/lib/Java/bin/Java)来解释。 建立自定义可执行格式这种机制与脚本格式类似，但功能更加强大，这是因为它对自定义格式不加任何限制。要注册一个新格式，就必须在binfmt_misc文件系统的注册文件内写人一个字符串，其格式为： 1 name:type:offset:string:mask:interpreter:flags 每个字段的含义如下： 1234567name: 新格式的标识符。type: 识别类型(M表示魔数，E表示扩展)。offset: 魔数在文件中的起始偏移量。string: 以魔数或者以扩展名匹配的字节序列。mask: 用来屏蔽掉string中的一些位的字符串。interpreter: 解释程序的完整路径名。flags: 可选标志，控制必须怎样调用解释程序。 例如，超级用户执行的下列命令将使内核识别出Microsoft Windows的可执行格式: 1echo :DOSWin:M:O:MZ:Oxff:/usr/bin/wine:’&gt;/proc/sys/fs/binfmt misc/register Windows可执行文件的前两个字节是魔数MZ，由解释程序/usr/bin/wine执行这个可执行文件。 执行域Linux的一个巧妙的特点就是能执行其他操作系统所编译的程序。当然，只有内核运行的平台与可执行文件包含的机器代码对应的平台相同时这才是可能的。对这些“外来”程序提供两种支持： 模拟执行(emulated execution)：程序中包含的系统调用与POSIX不兼容时才有必要执行这种程序。 原样执行(native execution)：只有程序中所包含的系统调用完全与POSIX兼容时才有效。 模拟执行的例子Microsoft MS-DOS和Windows程序是被模拟执行的，因为它们包含的API不能被Linux所认识，因此不能原样执行。像DOSemu或Wine这样的模拟程序被调用来把每个API调用转换为一个模拟的封装函数调用，而封装函数调用又使用现有的Linux系统调用。 原样执行的例子另一方面，不用太费力就可以执行为其他操作系统编译的与POSIX兼容的程序，因为与POSIX兼容的操作系统都提供了类似的API。 内核必须消除的细微差别通常涉及如何调用系统调用或如何给各种信号编号。这种信息存放在类型为exec_domain的执行域描述符中。 进程可以指定它的执行域： 通过设置进程描述符的personality字段，以及把相应exec_domain数据结构的地址存放到thread_info结构的exec_domain字段来实现的。 进程可以通过发布一个personality()系统调用来改变它的个性(personality)。 程序员通常不希望直接改变其程序的个性;相反，应该通过建立进程的执行上下文的“粘合”代码来发出personality()系统调用。//待定 灵活线性布局(可选看)灵活线性区布局(flexible memory region lagout)在内核版本2.6.9中引人。实际上，每个进程均是按照用户态堆栈预期的增长量来进行内存布局的。但是仍然可以使用老的经典布局(主要用于当内核无法限制进程用户态堆栈的大小时)。 下表是80x86结构的默认用户态地址空间为例描述了这两种布局，地址空间最大可以到3GB。布局之间只在文件内存映射与匿名映射时线性区的位置上有区别。 x86结构的线性布局: 线性区种类 经典布局 灵活布局 正文段(ELF) 开始于：0x08048000 开始于：0x08048000 数据与bss段 开始于：紧接正文段之后 开始于：紧接正文段之后 堆 开始于：紧接数据与bss段之后 开始于：紧接数据与bss段之后 文件内存映射与匿名线性区 开始于：0x40000000(该地址对应整个用户地址空间的1/3)，库连续往高地址追加 开始于：紧接用户态堆栈尾(最小地址)，库连续往低地址追加 用户态堆栈 开始于：OxC0000000并向低地址增长 开始于：OxC0000000并向低地址增长 在经典布局下，这些区域从整个用户态地址空间的1/3开始，通常在地址0x40000000。新的区域往更高线性地址追加，因此，这些区域往用户态堆栈方向扩展。相反的是，在灵活布局中，文件内存映射与匿名映射的线性区是紧接用户态堆栈尾的。新的区域往更低线性地址追加，因此，这些区域往堆的方向扩展。因为堆栈也是连续往低地址追加的。 当内核能通过RLIMIT_STACK资源限制来限定用户态堆栈的大小时，通常使用灵活布局这个限制确定了为堆栈保留的线性地址空间大小。但是这个空间大小不能小于128MB或大于2.5GB。另外，如果RLIMIT_STACK资源限制设为无限(infinity)，或者系统管理员将sysctl_legacy_va_layout变量设为1(通过修改/proc/sys/vm/legacy_va_layout文件或调用相应的sysctl()系统调用实现)，内核无法确定用户态堆栈的上限，就仍然使用经典线性区布局。 引入灵活布局的主要优点在于：可以允许进程更好地使用用户态线性地址空间。 在经典布局中，堆的限制是小于1GB，而其他线性区可以使用到约2GB(减去堆栈大小)。 在灵活布局中，没有这些限制，堆和其他线性区可以自由扩展，可以使用除了用户态堆栈和程序用固定大小的段以外的所有线性地址空间。 参考资料深入理解Linux内核中文版（第三版）linux内核学习之七 可执行程序的装载和运行Linux中的setuid简介进程的虚拟内存，物理内存，共享内存进程虚拟内存空间—线性区的数据结构linux下的三种可执行文件格式的比较linux 如何运行一个可执行文件深入理解Linux内核(完整版)-笔记","link":"/2020/07/04/Linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"title":"Linux程序执行相关函数-exec函数","text":"类Unix系统提供了一系列函数，这些函数能用可执行文件所描述的新上下文代替进程的上下文。这样的函数名以前缀exec开始，后跟一个或两个字母。 exec族函数下表列出了exec族函数，它们之间的差别在于如何解释参数。 函数名 路径搜索 命令行参数 环境数组 execl() 否 列表 否 execlp() 是 列表 否 execle() 否 列表 是 execv() 否 数组 否 execvp() 是 数组 否 execve() 否 数组 是 参数说明第一个参数每个函数的第一个参数表示被执行文件的路径名。 路径名可以是绝对路径或是当前进程目录的相对路径。 此外，如果路径名中不包含“/”字符，execlp()和execvp()函数就在PATH环境变量指定的所有目录中搜索这个可执行文件。 execl(), execlp()和exec1e()中间的参数除了第一个参数，execl(), execlp()和exec1e()函数包含的其他参数个数都是可变的。 每个参数指向一个字符串，这个字符串是对新程序命令行参数的描述，正如函数名中“l”字符所隐含的一样，这些参数组织成一个列表，最后一个值为NULL。 通常情况下，第一个命令行参数复制可执行文件名。 execv(), execvp()和execve()的第二个参数相反，execv(), execvp()和execve()函数指定单个参数的命令行参数，正如函数名中的“v”字符所隐含的一样，这单个参数是指向命令行参数串的指针向量地址。 数组的最后一个元素必须存放NULL值。 最后一个参数execle()和execve()函数的最后一个参数是指向环境串的指针数组的地址：数组的最后一个元素照样必须为NULL。其他函数对新程序环境参数的访问是通过C库定义的外部全局变量environ进行的。 所有的exec函数(除execve()外)都是C库定义的封装例程，并利用了execve()系统调用，这是Linux所提供的处理程序执行的唯一系统调用。 sys_execve()服务sys_execve()服务例程接收下列参数： 可执行文件路径名的地址(在用户态地址空间)。 以NULL结束的字符串指针数组的地址(在用户态地址空间)，每个字符串表示一个命令行参数。 以NULL结束的字符串指针数组的地址(也在用户态地址空间)。每个字符串以NAME = value形式表示一个环境变量。 sys_execve()执行过程sys_execve()把可执行文件路径名拷贝到一个新分配的页框。然后调用do_execve()函数，传递给它的参数为指向这个页框的指针、指针数组的指针及把用户态寄存器内容保存到内核态堆栈的位置。 do_execve()do_execve()依次执行下列操作： 动态地分配一个linux_binprn数据结构，并用新的可执行文件的数据填充linux_binprn数据结构。 调用path_lookup(), dentry_open()和path_release()，以获得与可执行文件相关的目录项对象、文件对象和索引节点对象。如果失败，则返回相应的错误码。 检查是否可以由当前进程执行该文件，再检查索引节点的i_writecount字段，以确定可执行文件没被写入;把-1存放在这个字段以禁止进一步的写访问。 在多处理器系统中，调用sched_exec()函数来确定最小负载CPU以执行新程序，并把当前进程转移过去。 调用ini_new_context()检查当前进程是否使用自定义局部描述符表。如果是，函数为新程序分配和淮备一个新的LDT。 调用prepare_binprm()函数填充linux_binprm数据结构，这个函数又依次执行下列操作： 再一次检查文件是否可执行(至少设置一个执行访问权限)。如果不可执行，则返回错误码(因为带有CAP_DAC_OVERRIDE权能的进程总能通过检查，所以第3步中的检查还不够。 初始化linux_binprm结构的e_uid和e_gid字段，考虑可执行文件的setuid和setgid标志的值。这些字段分别表示有效的用户ID和组ID。也要检查进程的权能。 用可执行文件的前128字节填充linux_binprm结构的buf字段。这些字节包含的是适合于识别可执行文件格式的一个魔数和其他信息。 把文件路径名、命令行参数及环境串拷贝到一个或多个新分配的页框中，最终它们会被分配给用户态地址空间。 调用search_binary_handler()函数对formats链表进行扫描，并尽力应用每个元素的load_binary方法，把linux_binprm数据结构传递给这个函数。只要load_binary方法成功应答了文件的可执行格式，对formats的扫描就终止。 如果可执行文件格式不在formats链表中，就释放所分配的所有页框并返回错误码 -ENOEXEC，表示Linux不认识这个可执行文件格式。 否则，函数释放linux_binprm数据结构，返回从这个文件可执行格式的load_binary方法中所获得的代码。 load_binary方法可执行文件格式对应的load_binary方法执行下列操作(假定这个可执行文件所在的文件系统允许文件进行内存映射并需要一个或多个共享库)： 检查存放在文件前128字节中的一些魔数以确认可执行格式。如果魔数不匹配，则返回错误码 -ENOEXEC。 读可执行文件的首部。这个首部描述程序的段和所需的共享库。 从可执行文件获得动态链接程序的路径名，并用它来确定共享库的位置并把它们映射到内存。 获得动态链接程序的目录项对象，也就获得了索引节点对象和文件对象。 检查动态链接程序的执行许可权。 把动态链接程序的前128字节拷贝到缓冲区。 对动态链接程序类型执行一些一致性检查。 调用flush_old_exec()函数释放前一个计算所占用的几乎所有资源。这个函数又依次执行下列操作： 如果信号处理程序的表为其他进程所共享，那么就分配一个新表并把旧表的引用计数器减1;而且它将进程从旧的线程组脱离。这是通过调用de_ thread()函数完成的。 如果与其他进程共享，就调用unshare_files()拷贝描述进程已打开文件的files_struct结构。 调用exec_mmap()函数释放分配给进程的内存描述符、所有线性区及所有页框，并清除进程的页表。 将可执行文件路径名赋给进程描述符的comm字段。 用flush_thread()函数清除浮点寄存器的值和在TSS段保存的调试寄存器的值。 调用flush_signal_handlers()函数，用于将每个信号恢复为默认操作，从而更新信号处理程序的表。 调用flush_old_files()函数关闭所有打开的文件，这些打开的文件在进程描述符的files-&gt;close_on_exec字段设置了相应的标志。现在，已经不能返回了，如果真出了差错，这个函数再不能恢复前一个计算 清除进程描述符的PF_FORKNOEXEC标志。这个标志用于在进程创建时设置进程记账，在执行一个新程序时清除进程记账。 设立进程新的个性，即设置进程描述符的personality字段。 调用arch_pick_mmap_layout()，以选择进程线性区的布局。 调用setup_arg_pages()函数为进程的用户态堆栈分配一个新的线性区描述符，并把那个线性区插入到进程的地址空间。setup_arg_pages()还把命令行参数和环境变量串所在的页框分配给新的线性区。 调用do_map()函数创建一个新线性区来对可执行文件正文段(即代码)进行映射。这个线性区的起始线性地址依赖于可执行文件的格式，因为程序的可执行代码通常是不可重定位的。因此，这个函数假定从某一特定逻辑地址的偏移量开始装入正文段。ELF程序被装入的起始线性地址为0x080480000。 调用do_mmap()函数创建一个新线性区来对可执行文件的数据段进行映射。这个线性区的起始线性地址也依赖于可执行文件的格式，因为可执行代码希望在特定的偏移量(即特定的线性地址)处找到它自己的变量。在ELF程序中，数据段正好被装在正文段之后。 为可执行文件的其他专用段分配另外的线性区，通常是无。 调用一个装入动态链接程序的函数。如果动态链接程序是ELF可执行的，这个函数就叫做load_elf_interp()。一般情况下，这个函数执行第12-14步的操作，不过要用动态链接程序代替被执行的文件。动态链接程序的正文段和数据段在线性区的起始线性地址是由动态链接程序本身指定的，但它们处于高地址区(通常高于0x40000000)，这是为了避免与被执行文件的正文段和数据段所映射的线性区发生冲突。 把可执行格式的linux_binfmt对象的地址存放在进程描述符的binfmt字段中。 确定进程的新权能。 创建特定的动态链接程序表并把它们存放在用户态堆栈，这些表处于命令行参数和指向环境串的指针数组之间。 设置进程的内存描述符的start_code、end_code、start_data、end_data、start_brk、brk及start_stack字段。 调用do_brk()函数创建一个新的匿名线性区来映射程序的bss段(当进程写入一个变量时，就触发请求调页，进而分配一个页框)。这个线性区的大小是在可执行程序被链接时就计算出来的。因为程序的可执行代码通常是不可重新定位的，因此，必须指定这个线性区的起始线性地址。在ELF程序中，bss段正好装在数据段之后。 调用start_thread()宏修改保存在内核态堆栈但属于用户态寄存器的eip和esp的值，以使它们分别指向动态链接程序的入口点和新的用户态堆栈的栈顶。 如果进程正被跟踪，就通知调试程序execve()系统调用已完成。 返回0(成功)。 当execve()系统调用终止且调用进程重新恢复它在用户态的执行时，执行上下文被大幅度改变，调用系统调用的代码不复存在。从这个意义上看，我们可以说execve()从未成功返回。取而代之的是，要执行的新程序已被映射到进程的地址空间。但是，新程序还不能执行，因为动态链接程序还必须考虑共享库的装载。 如果可执行文件是静态链接的，即如果不需要共享库，load_binary方法只需将程序的正文段、数据段、bss段和堆栈段映射到进程线性区，然后把用户态eip寄存器的内容设置为新程序的入口点即可。 动态链接程序如何运作尽管动态链接程序运行在用户态，但我们还要在这里简要概述一下动态链接程序是如何运作的。 它的第一个工作就是从内核保存在用户态堆栈的信息(处于环境串指针数组和arg start之间)开始，为自己建立一个基本的执行上下文。 然后，动态链接程序必须检查被执行的程序，以识别哪个共享库必须装入及在每个共享库中哪个函数被有效地请求。 接下来，解释器发出几个mmap()系统调用来创建线性区，以对将存放程序实际使用的库函数(正文和数据)的页进行映射。 然后，解释器根据库的线性区的线性地址更新对共享库符号的所有引用。 最后，动态链接程序通过跳转到被执行程序的主入口点而终止它的执行。 从现在开始，进程将执行可执行文件的代码和共享库的代码。 注解魔数：就是一个标识作用的信息。 linux中魔数的作用 参考资料Linux程序的执行过程深入理解Linux内核中文版（第三版）","link":"/2020/07/05/Linux%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-exec%E5%87%BD%E6%95%B0/"},{"title":"Linux程序调试-GDB调试器","text":"我们需要知道什么？ GDB是什么？有什么作用呢？GDB的用法有哪些？ GDB的功能GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具，GDB主要可帮助工程师完成下面4个方面的功能。 启动程序，并给定初始化的环境，可以按照工程师自定义的要求运行程序。 设置断点，让被调试的程序在工程师指定的断点处停住，断点可以是条件表达式。 查询程序执行的各种数据，当程序被停住时，可以检查此时程序中所发生的事，并追踪上文。 动态地改变程序的执行环境。 不管是调试Linux内核空间的驱动还是调试用户空间的应用程序，都必须掌握GDB的用法。在调试内核和调试应用程序时使用的GDB命令是完全相同的。 用于调试的代码以下面代码表示的应用程序为例演示GDB调试器的用法。 1234567891011121314151617int add(int a, int b){ return a + b;}int main(){ int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; int i; int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90}; int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4}; for (i = 0; i &lt; 10; i++) { sum[i] = add(array1[i], array2[i]); } return 0;} 使用下面的命令编译上述程序，得到包含调试信息的二进制文件gdb_example。注意：编译程序时需要加上-g，之后才能用gdb进行调。 1gcc -g gdb_example.c -o gdb_example ps： -c和-o是gcc编译器的可选参数。 -c表示只编译源文du件但不链接，会把.c或.cc的c源程序编译成目标文件，一般是.o文件。 -o用于指定输出文件名。不用-o的话，一般会在当前文件夹下生成默认的a.out文件作为可执行程序。 -g 把调试信息加到可执行文件中，如果没有-g，将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。 执行下面的命令进入调试状态 1gdb gdb_example 然后会出现如下效果 12345678910111213141516root@ubuntu:~/cpptest# gdb gdb_example GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-gitCopyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from gdb_example...done. 调试示例： 12345678910111213141516(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3.(gdb) runStarting program: /root/cpptest/gdb_example Breakpoint 1, add (a=48, b=85) at gdb_example.c:33 return a + b;(gdb) next4 }(gdb) nextmain () at gdb_example.c:1212 for (i = 0; i &lt; 10; i++)(gdb) next14 sum[i] = add(array1[i], array2[i]);(gdb) print sum$1 = {133, 0, 0, 0, 0, 0, 0, 0, 0, 0} GDB的启动启动GDB的方法有以下几种：1、gdb programprogram也就是你的执行文件，一般在当前目录下。2、gdb program core用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。3、gdb program 1234如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。列举一些比较常用的参数： 1--symbols=SYMFILE 从指定文件中读取符号表 1--se=FILE 从指定文件中读取符号表信息，并把他用在可执行文件中。 1--core=COREFILE 调试时core dump的core文件。 1--directory=DIR 加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。 GDB相关命令list命令作用：在GDB中运行list命令可以列出代码list的具体形式如下: list&lt;linenum&gt;：用于显示程序第linenum行周围的源程序（我的测试是一共显示10行）。效果如下所示：1234567891011(gdb) list 8 //列出文件第九行附近的代码3 return a + b;4 }5 int main()6 {7 int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0};8 int i;9 int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90};10 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4};11 12 for (i = 0; i &lt; 10; i++) list&lt;function&gt;：显示函数名为function的函数对应的源程序。如下所示：1234567891011(gdb) list main1 int add(int a, int b)2 {3 return a + b;4 }5 int main()6 {7 int sum[10] ={0, 0, 0, 0, 0, 0, 0, 0, 0, 0};8 int i;9 int array1[10] ={48, 56, 77, 33, 33, 11, 226, 544, 78, 90};10 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4}; 说明: list， 显示当前行后面的源程序。 list-，显示当前行前面的源程序。 examine命令examine命令来查看内存地址中的值,在GDB中使用的时候缩写为x。examine命令格式： 1x/&lt;number/format/u&gt; &lt;addr&gt; 参数说明 表示一个内存地址。 “x/”后的n、f、u都是可选的参数。 number是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容； format表示显示的格式，和c语言中的格式缩写一样： 如果地址所指的是字符串，那么格式可以是s 如果地址是指令地址，那么格式可以是i； d:整数integer s:字符串string c:字符char u:无符号整数 unsigned integer o:八进制格式显示变量 x:十六进制格式 f: 浮点数格式float u表示从当前地址往后请求的字节数，如果不指定的话，GDB默认的是4字节。 u参数可以被一些字符代替： b表示单字节 h表示双字节 w表示四字节 g表示八字节。 当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来 number，format，u这3个参数可以一起使用,如下面示例所示。 示例： 12(gdb) x/3uh 0x54320效果：表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。 set命令set命令用于修改内存。它的命令格式是: 1set *有类型的指针=value 比如，下列程序，在用gdb运行起来后，通过Ctrl+C停住。 12345main(){void *p = malloc(16);while(1);} 我们可以在运行中用如下命令来修改p指向的内存。 12345(gdb) set *(unsigned char *)p='h' //令p是指向无符号字符的指针变量(gdb) set *(unsigned char *)(p+1)='e'(gdb) set *(unsigned char *)(p+2)='l'(gdb) set *(unsigned char *)(p+3)='l'(gdb) set *(unsigned char *)(p+4)='o' 看看结果： 12(gdb) x/s p0x804b008: \"hello\" 也可以直接使用地址常数： 123456789(gdb) p p //print命令（缩写为p）$2 = (void *) 0x804b008(gdb) set *(unsigned char *)0x804b008='w'(gdb) set *(unsigned char *)0x804b009='o'(gdb) set *(unsigned char *)0x804b00a='r'(gdb) set *(unsigned char *)0x804b00b='l'(gdb) set *(unsigned char *)0x804b00c='d'(gdb) x/s 0x804b0080x804b008: \"world\" run命令在GDB中，运行程序使用run命令。在程序运行前，我们可以设置如下4方面的工作环境。 程序运行参数set args可指定运行时参数，如1set args 10 20 30 40 50； show args命令可以查看设置好的运行参数。 运行环境path&lt;dir&gt;可设定程序的运行路径；how paths可查看程序的运行路径；set environment varname[=value]可设置环境变量，如set env USER=baohua；show environment[varname]则可查看环境变量。 工作目录cd&lt;dir&gt;相当于shell的cd命令，pwd可显示当前所在的目录。 程序的输入输出info terminal用于显示程序用到的终端的模式；在GDB中也可以使用重定向控制程序输出，如run&gt;outfile；用tty命令可以指定输入输出的终端设备，如tty /dev/ttyS1。 break命令在GDB中用break命令来设置断点，设置断点的方法如下： break&lt;function&gt;：在进入指定函数时停住。 在C++中可以使用class::function或function（type，type）格式来指定函数名。12(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3. break &lt;linenum&gt;：在指定行号停住。12(gdb) break 12Breakpoint 2 at 0x752: file gdb_example.c, line 12. break +offset/break -offset:在当前行号的前面或后面的offset行停住，offiset为自然数。 break filename：linenum ：在源文件filename的linenum行处停住。 break filename：function ：在源文件filename的function函数的入口处停住。 break *address ：在程序运行的内存地址处停住。123(gdb) break *0x0000000000000674Note: breakpoint 1 also set at pc 0x674.Breakpoint 7 at 0x674: file gdb_example.c, line 3. break：break命令没有参数时，表示在下一条指令处停住。 break … if&lt;condition&gt; …可以是上述的break、break+offset/break–offset中的参数 condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i=100，表示当i为100时停住程序。 查看断点时，可使用info命令，如info breakpoints[n]、info break[n]（n表示断点号）。 1234567891011121314(gdb) info breakNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000000674 in add at gdb_example.c:32 breakpoint keep y 0x0000000000000752 in main at gdb_example.c:123 breakpoint keep y 0x0000000000000689 in main at gdb_example.c:54 breakpoint keep y 0x0000000000000752 in main at gdb_example.c:125 breakpoint keep y 0x000000000000070c in main at gdb_example.c:106 breakpoint keep y 0x0000000000000698 in main at gdb_example.c:7(gdb) info break 5Num Type Disp Enb Address What5 breakpoint keep y 0x000000000000070c in main at gdb_example.c:10(gdb) info breakpoint 5Num Type Disp Enb Address What5 breakpoint keep y 0x000000000000070c in main at gdb_example.c:10 单步命令next命令：用于单步执行，类似于VC++中的step over。 next的单步不会进入函数的内部。step（缩写为s）命令：与next正好相对，在单步执行一个函数时，进入其内部，类似于VC++中的step into。 12345678910(gdb) break 14Breakpoint 1 at 0x75e: file gdb_example.c, line 14.(gdb) run Starting program: /root/cpptest/gdb_example Breakpoint 1, main () at gdb_example.c:1414 sum[i] = add(array1[i], array2[i]);(gdb) stepadd (a=48, b=85) at gdb_example.c:33 return a + b; 单步执行高级用法如下： step &lt;count&gt; 也就是上面的示例单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。 next &lt;count&gt; 也就是上面的示例单步跟踪，如果有函数调用，它不会进入该函数。同理，next后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。 set step-mode set step-mode on用于打开step-mode模式，这样，在进行单步跟踪（运行step指令）时，若跨越某没有调试信息的函数，程序的执行则会在该函数的第一条指令处停住，而不会跳过整个函数。这样我们可以查看该函数的机器指令。 set step-mod off用于关闭step-mode模式 finish运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址、返回值及参数值等信息。 until（缩写为u）一直在循环体内执行单步而退不出来是一件令人烦恼的事情，用until命令可以运行程序直到退出循环体。 stepi（缩写为si）和nexti（缩写为ni） （选看）stepi和nexti用于单步跟踪一条机器指令。比如，一条C程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令，相反，step和next是C语言级别的命令。另外，运行display/i$pc命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码。 continue命令当程序被停住后，可以使用continue命令（缩写为c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点。命令格式为： 123continue [ignore-count] //ignore-count表示忽略其后多少次断点。c [ignore-count]fg [ignore-count] 示例： 12345678910111213141516(gdb) break addBreakpoint 1 at 0x674: file gdb_example.c, line 3.(gdb) break 14Breakpoint 2 at 0x75e: file gdb_example.c, line 14.(gdb) break 10Breakpoint 3 at 0x70c: file gdb_example.c, line 10.(gdb) run Starting program: /root/cpptest/gdb_example Breakpoint 3, main () at gdb_example.c:1010 int array2[10] ={85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4};(gdb) continue Continuing.Breakpoint 2, main () at gdb_example.c:1414 sum[i] = add(array1[i], array2[i]); print命令查看当前程序的运行数据：当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式如下： 12print &lt;expr&gt;print /&lt;format&gt; &lt;expr&gt; &lt; expr &gt;是表达式，也是被调试的程序中的表达式&lt; format &gt;是输出的格式，比如，如果要把表达式按十六进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中: @是一个和数组有关的操作符 ::指定一个在文件或是函数中的变量 {&lt;type&gt;}&lt;addr&gt;表示一个指向内存地址的类型为type的对象 当需要查看一段连续内存空间的值时，可以使用GDB的@操作符，@的左边是第一个内存地址，@的右边则是想查看内存的长度。例如如下动态申请的内存： 1int *array = (int *) malloc (len * sizeof (int)); 在GDB调试过程中这样显示这个动态数组的值： 1p *array@len print的输出格式如下。 12345678x：按十六进制格式显示变量。d：按十进制格式显示变量。u：按十六进制格式显示无符号整型。o：按八进制格式显示变量。t：按二进制格式显示变量。a：按十六进制格式显示变量。c：按字符格式显示变量。f：按浮点数格式显示变量。 可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。 当用GDB的print查看程序运行时数据时，每一个print都会被GDB记录下来。GDB会以$ 1，$ 2，$ 3 … 这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如 $ 1。 修改变量值如果要修改变量，如x的值，可使用如下命令： 1print x=4 watch命令watch一般用来观察某个表达式（变量也是一种表达式）的值是否有了变化，如果有变化，马上停止程序运行。设置观察点有如下几种方法来。 watch &lt;expr&gt;：为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停止程序运行。 rwatch &lt;expr&gt;：当表达式（变量）expr被读时，停止程序运行。 awatch &lt;expr&gt;：当表达式（变量）的值被读或被写时，停止程序运行。 info watchpoints：列出当前所设置的所有观察点。 jump命令GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令实现。jump &lt;linespec&gt;来指定下一条语句的运行点。 &lt; linespec &gt;可以是文件的行号，可以是file：line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。 jump &lt;address&gt; 这里的&lt; address &gt; 是代码行的内存地址。 注意：jump命令不会改变当前程序栈中的内容，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能会导致意想不到的结果，因此最好只用jump在同一个函数中进行跳转。 signal命令singal命令，可以产生一个信号量给被调试的程序，如中断信号Ctrl+C。于是，可以在程序运行的任意位置处设置断点，并在该断点处用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。signal命令的语法是 1signal &lt;signal&gt; UNIX的系统信号量通常为1~15，因此的取值也在这个范围内。 return命令如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。 12returnreturn &lt;expression&gt; 上述return命令用于取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被作为函数的返回值。 call命令call命令用于强制调用某函数： 1call &lt;expr&gt; 表达式可以是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。比如在下列程序执行while（1）的时候： 12345main(){void *p = malloc(16);while(1);} 我们可以强制要求其执行strcpy()和printf()： 12345(gdb) call strcpy(p, \"hello world\")$3 = 134524936(gdb) call printf(\"%s\\n\", p)hello world$4 = 12 info命令info命令可以用来在调试时查看寄存器、断点、观察点和信号等信息。 查看寄存器的值，使用如下命令：123info registers （查看除了浮点寄存器以外的寄存器）info all-registers （查看所有寄存器，包括浮点寄存器）info registers &lt;regname ...&gt; （查看所指定的寄存器） 查看断点信息，使用如下命令：1info break 要列出当前所设置的所有观察点，可使用如下命令：1info watchpoints 查看有哪些信号正在被GDB检测，使用如下命令：12info signalsinfo handle info line命令来查看源代码在内存中的地址。 info line后面可以跟行号、函数名、文件名：行号、文件名：函数名等多种形式，例如用下面的命令会打印出所指定的源码在运行时的内存地址：1info line tst.c:func disassembledisassemble命令用于反汇编（将机器语言转换为汇编语言）。可用它来查看当前执行时的源代码的机器码，实际上只是把目前内存中的指令冲刷出来。下面的示例用于查看函数func的汇编代码： 1234567Dump of assembler code for function func:0x8048450 &lt;func&gt;: push %ebp0x8048451 &lt;func+1&gt;: mov %esp,%ebp0x8048453 &lt;func+3&gt;: sub $0x18,%esp0x8048456 &lt;func+6&gt;: movl $0x0,0xfffffffc(%ebp)...End of assembler dump. 注意事项 GDB并不具备记忆功能，每次断开重新开启，之前的断点设置等信息都会丢失的。 总结参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》GDB用法详解gdb —- x命令详解gdb学习笔记(一)用GDB调试程序（七） //包含修改变量的值","link":"/2020/07/06/Linux%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95-GDB%E8%B0%83%E8%AF%95%E5%99%A8/"},{"title":"Linux-性能分析，测试与调优工具（2）","text":"常用工具top、vmstat、iostat和sartop命令用于显示处理器的活动状况。在缺省情况下，显示占用CPU最多的任务，并且每隔5s做一次刷新；vmstat命令用于报告关于内核线程、虚拟内存、磁盘、陷阱和CPU活动的统计信息；iostat命令用于分析各个磁盘的传输闲忙状况；sar用于收集、报告或者保存系统活动信息，其中，sar用于显示数据，sar1和sar2用于收集和保存数据。 sysctlsysctl是一个接口，可用于改变正在运行中的Linux系统。用sysctl可以读取几百个以上的系统变量，例如用sysctl –a可读取所有变量。 sysctl的实现原理是： 所有的内核参数在/proc/sys中形成一个树状结构 sysctl系统调用的内核函数是：sys_sysctl，匹配项目后，最后的读写在do_sysctl_strategy中完成 比如： 1echo \"1\" &gt; /proc/sys/net/ipv4/ip_forward 就等价于： 1sysctl –w net.ipv4.ip_forward =\"1\" 高级分析手段OProfileOProfile作用 可以帮助用户识别诸如模块的占用时间、循环的展开、高速缓存的使用率低、低效的类型转换和冗余操作、错误预测转移等问题。 它收集有关处理器事件的信息，其中包括TLB的故障、停机、存储器访问以及缓存命中和未命中的指令的攫取数量。 OProfile支持两种采样方式： 基于事件的采样（Event Based）： NMI模式 OProfile只记录特定事件（比如L2缓存未命中）的发生次数，当达到用户设定的定值时Oprofile就记录一下（采一个样）。 这种方式需要CPU内部有性能计数器（Performace Counter）。 基于时间的采样（Time Based）： Timer Interrupt模式 OProfile借助OS时钟中断的机制，在每个时钟中断，OProfile都会记录一次（采一次样）。 引入它的目的在于，提供对没有性能计数器的CPU的支持，其精度相对于基于事件的采样要低，因为要借助OS时钟中断的支持，对于禁用中断的代码，OProfile不能对其进行分析。 OProfile在Linux上分两部分: 内核模块（oprofile.ko） 负责访问性能计数器或者注册基于时间采样的函数，并将采样值置于内核的缓冲区内。 用户空间的守护进程（oprofiled） 后者在后台运行，负责从内核空间收集数据，写入文件。 控制oprofile需要用到opcontrol。要打开oprofile,需要用start选项来调用opconrol,当第一次调用opcontrol时,必须告诉它想统计内核还是用户空间数据.其运行步骤如下。1）初始化opcontrol –init2）配置opcontrol –setup –event=…3）启动opcontrol –start4）运行待分析的程序xxx5）取出数据opcontrol –dumpopcontrol –stop6）分析结果 opreport -l./xxx 具体的看一下这篇文章吧，《Linux调优工具oprofile的演示分析》 gprofGNU gprof作用： 可以打印出程序运行中各个函数消耗的时间，以帮助程序员找出众多函数中耗时最多的函数； 可产生程序运行时的函数调用关系，包括调用次数，以帮助程序员分析程序的运行流程。 GNU gprof的实现原理： 在编译和链接程序的时候（使用-pg编译和链接选项） gcc在应用程序的每个函数中都加入名为mcount（_mcount或__mcount，依赖于编译器或操作系统）的函数。 也就是说应用程序里的每一个函数都会调用mcount，而mcount会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址。 这张调用图也保存了所有与函数相关的调用时间、调用次数等的所有信息。 GNU gprof的基本用法如下。1）使用-pg编译和链接应用程序。2）执行应用程序并使它生成供gprof分析的数据。3）使用gprof程序分析应用程序生成的数据。 内核跟踪LTTngLTTng（Linux Trace Toolkit-next generation， Linux 跟踪工具包下一代）是一个用于跟踪系统详细运行状态和流程的工具 它可以跟踪记录系统中的特定事件。 这些事件包括： 系统调用的进入和退出； 陷阱/中断（Trap/Irq）的进入和退出； 进程调度事件；内核定时器 文件系统相关事件——open/read/write/seek/ioctl等； 内存管理相关事件——内存分配/释放等； 其他IPC/套接字/网络等事件。 而对于这些记录，我们可以通过图形的方式经由lttv-gui查看 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》","link":"/2020/07/09/linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%882%EF%BC%89/"},{"title":"Linux内核目录文件说明","text":"前言Linux内核也是一个抢占式多任务内核。这意味该内核可以暂停一些任务来保证任何应用都有机会来使用CPU。比如： 如果一个应用正在运行但是正在等待一些数据，内核会把这个应用暂停并允许其他的程序使用新释放的CPU资源，直到数据到来。 否则的话，系统就会浪费资源给那些正在等待数据或者其他程序执行的的任务。 内核将会强制程序去等待或者停止使用CPU。没有内核的允许，应用程序不能脱离暂停或者使用CPU。Linux设计思想是“一切皆文件”： 设备作为文件显示在/dev文件夹下，如果一个用户想要访问在存储卡上的数据，他们能通过设备文件访问这些数据。已编译的Linux内核： 在引导文件夹(/boot),用户会看到诸如“vmlinux”或者“vmlinuz”的文件。这两者都是已编译的Linux内核。 以“z”结尾的是已压缩的。“vm”代表虚拟内存。 SPARC处理器的系统上，用户可以看见一个zImage文件。部分用户可以发现一个bzImage文件，这是一个已压缩的Linux内核。 这些引导文件都是不能更改的，除非用户知道他们正在做什么。否则系统会变成无法引导，启动不了。Linux内核是所有Linux系统的核心。如果有任何恶意代码控制或破害了内核的任何一部分，那么系统会严重受损，文件可能被删除或损坏，私人信息可能被盗等等。 注意事项: 绝不在内核源代码内移动文件，除非你知道你在做什么。否则，编译会由于丢失文件失败。 内核在操作系统目录下的路径一般为：/usr/src/ Linux内核源代码划分Linux内核的文件夹结构保持相对稳定。内核开发者会做一些修改，但总体来说，这些设置对整个内核版本都是一样。驱动程序文件夹的布局也基本保持一样。Linux内核源代码包括三个主要部分： 内核核心代码，各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等 其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等 编译脚本、配置文件、帮助文档、版权说明等辅助性文件 一般在每个目录下都有一个.depend文件和一个Makefile文件。这两个文件都是编译时使用的辅助文件。仔细阅读这两个文件对弄清各个文件之间的联系和依托关系很有帮助。有的目录下还有Readme文件，它是对该目录下文件的一些说明，同样有利于对内核源码的理解。 Linux内核源代码一级目录目录文件Linux内核源代码包含如下目录： arch： 包含和硬件体系结构相关的代码 每种平台占一个相应的目录，如i386、arm、arm64、powerpc、mips等。Linux内核目前已经支持30种左右的体系结构。 在arch目录下，存放的是各个平台以及各个平台的芯片对Linux内核进程调度、内存管理、中断等的支持，以及每个具体的SoC和电路板的板级支持代码。 随着时间的推移，一些新的处理器将被支持,有些会被放弃。 /arch/boot包含了系统启动的相关信息和make之后生成的启动镜像文件bzImage。 block：包含块设备驱动程序的代码。 该目录用于实现块设备的基本框架和块设备的I/O调度算法 块设备是以数据块方式接收和发送的数据的设备。数据块都是一块一块的数据而不是持续的数据流。 crypto：英文意思是加密。目录下放了一些各种常见的加密算法的C语言代码实现。 常用加密和散列算法（如AES、SHA等），还有一些压缩和CRC校验算法。 documentation：内核各部分的通用解释和注释。 drivers：设备驱动程序，每个不同的驱动占用一个子目录。 每个文件夹都以硬件的种类或者型号命名。 如char、block、net、mtd、i2c等。 键盘和鼠标驱动也在这个input文件夹中 fireware：包含了让计算机读取和理解从设备发来的信号的代码。 举例来说，一个摄像头管理它自己的硬件，但计算机必须了解摄像头给计算机发送的信号。Linux系统会使用vicam固件（firmware）来理解摄像头的通讯。 否则，没有了固件，Linux系统将不知道如何处理摄像头发来的信息。另外，固件同样有助于将Linux系统发送消息给该设备。这样Linux系统可以告诉摄像头重新调整或关闭摄像头。 fs：fs是file system，所支持的各种文件系统 如EXT、FAT、NTFS、JFFS2等。 fs文件夹内，开发者会看到一些不在文件夹中的文件。这些文件用来控制整个文件系统。例如，mount.h中会包含挂载文件系统的代码。 文件系统是以结构化的方式来存储和管理的存储设备上的文件和目录。每个文件系统都有自己的优点和缺点。这是由文件系统的设计决定的。 举例来说，NTFS文件系统支持的透明压缩（当启用时，会在用户不知道的情况下自动压缩存储文件）。大多数文件系统缺乏此功能，但如果在fs文件夹里编入相应的文件，它们也有这种能力。 include：存放内核所需、与平台无关的头文件 内核API级别头文件。 与系统相关的头文件放置在include/linux子目录下。 与平台相关的头文件已经被移动到 arch 平台的include 目录，如 ARM 的头文件目录&lt;arch/arm/include/asm/&gt; init：内核初始化代码。 包含了内核启动的处理代码(INITiation)。main.c是内核的核心文件，这是用来衔接所有的其他文件的源代码主文件。 著名的start_kernel（）就位于init/main.c文件中。 ipc：进程间通信的代码。 用于实现System V的进程间通信（Inter Process Communication，IPC）模块 . 此文件夹中的代码是作为内核与进程之间的通信层。内核控制着硬件，因此程序只能请求内核来执行任务。 假设用户有一个打开DVD托盘的程序。程序不直接打开托盘，该程序通知内核，然后，内核给硬件发送一个信号去打开托盘。 这里的代码同样管理kill信号。 举例来说，当系统管理员打开进程管理器去关闭一个已经锁死的程序，这个关闭程序的信号被称为kill信号。 内核接收到信号，然后内核会要求程序停止或直接把进程从内存和CPU中移除（取决于kill的类型）。 命令行中的管道同样用于进程间通信。 管道会告诉内核在某个内存页上写入输出数据。程序或者命令得到的数据是来自内存页上的某个给定的指针。 kernel：内核最核心的部分，包括进程调度、定时器等 和平台相关的一部分代码放在arch/*/kernel目录下。 这个文件夹中的代码控制内核本身 在该文件夹下有个”power”文件夹，这里的代码可以使计算机重新启动、关机和挂起。 lib：库文件代码。 这里的库函数和C语言的库函数不一样。在内核编程中是不能用C语言标准库函数，此处lib目录下的库函数就是用来替代那些标准库函数的。 例如在内核中要打印信息不能用printf，而要用printk，这个printk就是这个lib目录下的。 mm：（memory management）内存管理代码 和平台相关的一部分代码放在arch/*/mm目录下。 内存并不是任意存储在RAM芯片上的。相反，内核小心地将数据放在RAM芯片上。内核不会覆盖任何正在使用或保存重要数据的内存区域。 net：网络相关代码 实现各种常见的网络协议。 samples: 存放提供的一些内核编程范例，如kfifo；后者相关用户态编程范例，如hidraw 此文件夹包含了程序示例和正在编写中的模块代码。 假设一个新的模块引入了一个想要的有用功能，但没有程序员说它已经可以正常运行在内核上。那么，这些模块就会移到这里。这给了新内核程序员一个机会通过这个文件夹来获得帮助，或者选择一个他们想要协助开发的模块。 scripts：用于配置内核的脚本文件。 这些脚本文件不是linux内核工作时使用的，而是用来辅助linux内核的配置和编译。 这个目录下的脚本不需要详细的分析，只需要通过外围来重点学会配置和编译linux内核即可。 最好不要改变这个文件夹内的任何东西。否则，可能无法配置或编译内核。 security：主要是一个SELinux的模块。 sound：声卡驱动 ALSA、OSS音频设备的驱动核心代码和常用设备驱动。 tools：编译过程中一些主机必要工具，这个文件夹中包含了和内核交互的工具。 usr：早期用户空间代码（所谓的initramfs） 实现用于打包和压缩的cpio等。 对于vmlinuz和其他类似的文件，usr文件夹中的代码在内核编译完成后创建这些文件。 该目录中的代码为内核尚未完全启动时执行用户空间代码提供了支持 virt：内核虚拟机KVM 内核一般要做到drivers与arch的软件架构分离，驱动中不包含板级信息，让驱动跨平台。同时内核的通用部分（如kernel、fs、ipc、net等）则与具体的硬件（arch和drivers）剥离。与内核移植紧密的目录是arch和drivers，有点相关的是include、block、mm、net、lib等目录。 普通文件还有一些文件在源代码的根目录下： COPYING ：许可和授权信息。 Linux内核在GPLv2许可证下授权。该许可证授予任何人有权免费去使用、修改、分发和共享源代码和编译代码。然而，没有人可以出售源代码。 CREDITS ： 贡献者列表 Kbuild ： 这是一个设置一些内核设定的脚本。 Kbuild是Kernel build（内核编译）的意思，这个文件就是linux内核特有的内核编译体系需要用到的文件。 打个比方，这个脚本设定一个ARCH变量，这是开发者想要生成的内核支持的处理器类型。 Kconfig ： 这个脚本会在开发人员配置内核的时候用到，这会在以后的文章中讨论。 MAINTAINERS ： 这是一个目前维护者列表，他们的电子邮件地址，主页，和他们负责开发和维护的内核的特定部分或文件。当一个开发者在内核中发现一个问题，并希望能够报告给能够处理这个问题的维护者时，这是是很有用的。 Makefile ： linux内核的总Makefile，整个内核工程是用这个Makefile来管理的。 这个脚本是编译内核的主要文件。这个文件将编译参数和编译所需的文件和必要的信息传给编译器。 用来组织内核的各模块，记录了个模块间的相互这间的联系和依托关系 仔细阅读各子目录下的Makefile文件对弄清各个文件这间的联系和依托关系很有帮助。 README ：提供给开发者想要知道的如何编译内核的信息。 REPORTING-BUGS ：这个文档提供如何报告问题的信息。 Linux内核源代码二级目录arch目录Kconfig文件，它用于设置这个目录里的源代码编译所需的一系列设定。每个支持的处理器架构都在它相应的文件夹中，如arm64、arm32、x86、mips等。 /arch/boot ： 内核需要的特定平台代码，包含了当前平台上系统引导过程使用的部分或全部代码。这部分代码应用于对应平台，用于完成向系统内存装载内核镜像的工作。 包含了系统启动的相关信息和make之后生成的启动镜像文件bzImage /arch/boot/dts：设备树文件/arch/kernel：用于存放特定体系结构特有信号量的实现代码和对称多处理器（Symmetric MultiProccessing，简称SMP）相关模块。/lib：通用函数在特定体系结构的文件，如利用当前体系结构特性实现的strlen和memcpy内存操作函数；与通用的实现方法相比，他们的开销小、更加高效。/math-emu：模拟FPU的代码，在ARM中，使用/math-xxx代替/arch/mm：特定体系结构的内存管理文件/arch/include：特定体系的头文件 driver目录Linux内核驱动开发工程师来说，最常接触的就是driver目录驱动程序是使内核能够沟通和操作硬件或协议（规则和标准）的小程序。没有驱动程序，内核不知道如何与硬件沟通或者处理协议（内核实际上先发送指令给BIOS，然后BIOS传给硬件）。 通用驱动程序与专用驱动程序许多驱动程序是通用驱动程序，这意味着一个通用键盘驱动可以使内核可以处理几乎所有的键盘。有些驱动是专用驱动程序，像苹果和Commodore就分别为苹果电脑和Amiga系统制造了专门的硬件。Linux内核中已经包含了许多诸如智能手机、苹果、Amiga系统、PS3、Android平板，和许多其他设备的驱动程序。 注意：有些设备的驱动不在本目录中。比如，射频驱动在net和media文件夹下。 目录与文件 accessibility ：这些驱动提供支持一些辅助设备。 在Linux 3.9.4中，这个文件夹中只有一个驱动就是盲文设备驱动。 acpi ： 高级配置和电源接口（ACPI : Advanced Configuration and Power Interface）驱动用来管理电源使用。 amba ： 高级微控制器总线架构（AMBA : Advanced Microcontroller Bus Architecture）是与片上系统（SoC）的管理和互连的协议。 SoC是一块包含许多或所有必要的计算机组件的芯片。这里的AMBA驱动让内核能够运行在这上面。 ata ： 该目录包含PATA和SATA设备的驱动程序。 串行ATA（SATA）是一种连接主机总线适配器到像硬盘那样的存储器的计算机总线接口。 并行ATA（PATA）用于连接存储设备，如硬盘驱动器，软盘驱动器，光盘驱动器的标准。PATA就是我们所说的IDE。 atm : 异步通信模式(ATM : Asynchronous Transfer Mode)是一种通信标准。 这里有各种接到PCI桥的驱动(他们连接到PCI总线)和以太网控制器(控制以太网通信的集成电路芯片)。 auxdisplay - 这个文件夹提供了三个驱动。LCD 帧缓存（framebuffer）驱动、LCD控制器驱动和一个LCD驱动。 这些驱动用于管理液晶显示器。 base : 这是个重要的目录包含了固件、系统总线、虚拟化能力等基本的驱动。 bcma : 这些驱动用于使用基于AMBA协议的总线。AMBA是由博通公司开发。 block : 这些驱动提供对块设备的支持， 像软驱、SCSI磁带、TCP网络块设备等等。 bluetooth : 蓝牙是一种安全的无线个人区域网络标准(PANs)。蓝牙驱动就在这个文件夹，它允许系统使用各种蓝牙设备。 例如，一个蓝牙鼠标不用电缆，并且计算机有一个电子狗(小型USB接收器)。Linux系统必须能够知道进入电子狗的信号，否则蓝牙设备无法工作。 bus - 这个目录包含了三个驱动。 第一个转换ocp接口协议到scp协议 第二个是设备间的互联驱动 第三个是用于处理互联中的错误处理 cdrom - 这个目录包含两个驱动。 一个是cd-rom，包括DVD和CD的读写。 第二个是gd-rom(只读GB光盘)，GD光盘是1.2GB容量的光盘，这像一个更大的CD或者更小的DVD。GD通常用于世嘉游戏机中。 char - 字符设备驱动。 字符设备每次传输数据传输一个字符。 这个文件夹里的驱动包括打印机、PS3闪存驱动、东芝SMM驱动和随机数发生器驱动等。 clk - 这些驱动用于系统时钟。 clocksource - 这些驱动用于作为定时器的时钟。 connector- 这些驱动使内核知道当进程fork并使用proc连接器更改UID(用户ID)、GID(组ID)和SID(会话ID) 内核需要知道什么时候进程fork(CPU中运行多个任务)并执行。否则,内核可能会低效管理资源。 cpufreq - 这些驱动改变CPU的电源能耗。 cpuidle - 这些驱动用来管理空闲的CPU。一些系统使用多个CPU，其中一个驱动可以让这些CPU负载相当。 crypto - 这些驱动提供加密功能。 dca - 直接缓存访问（DCA ： Direct Cache Access）驱动允许内核访问CPU缓存。 CPU缓存就像CPU内置的RAM。CPU缓存的速度比RAM更快。然而,CPU缓存的容量比RAM小得多。CPU在这个缓存系统上存储了最重要的和执行的代码。 devfreq - 这个驱动程序提供了一个通用的动态电压和频率调整(DVFS ： Generic Dynamic Voltage and Frequency Scaling)框架， 可以根据需要改变CPU频率来节约能源。也就是CPU节能。 dio - 数字输入/输出（DIO ：Digital Input/Output）总线驱动允许内核可以使用DIO总线。 dma - 直接内存访问(DMA)驱动允许设备无需CPU直接访问内存。这减少了CPU的负载。 edac - 错误检测和校正（ Error Detection And Correction）驱动帮助减少和纠正错误。 eisa - 扩展工业标准结构总线（Extended Industry Standard Architecture）驱动提供内核对EISA总线的支持。 extcon - 外部连接器（EXTernal CONnectors）驱动用于检测设备插入时的变化。例如，extcon会检测用户是否插入了USB驱动器。 firewire - 这些驱动用于控制苹果制造的类似于USB的火线设备。 firmware - 这些驱动用于和像BIOS(计算机的基本输入输出系统固件)这样的设备的固件通信。 BIOS用于启动操作系统和控制硬件与设备的固件。 一些BIOS允许用户超频CPU。 gpio - 通用输入/输出(GPIO ：General Purpose Input/Output)是可由用户控制行为的芯片的管脚。 这里的驱动就是控制GPIO。 gpu - 这些驱动控制VGA、GPU和直接渲染管理(DRM ：Direct Rendering Manager )。 VGA是640*480的模拟计算机显示器或是简化的分辨率标准。DRM是一个Unix渲染系统。 hid - 这驱动用于对USB人机界面设备的支持。 hsi - 这个驱动用于内核访问像Nokia N900这样的蜂窝式调制解调器。 hv - 这个驱动用于提供Linux中的键值对(KVP ：Key Value Pair)功能。 hwmon - 硬件监控驱动用于内核读取硬件传感器上的信息。 比如，CPU上有个温度传感器。那么内核就可以追踪温度的变化并相应地调节风扇的速度。 hwspinlock - 硬件转锁驱动允许系统同时使用两个或者更多的处理器，或使用一个处理器上的两个或更多的核心。 i2c - I2C驱动可以使计算机用I2C协议处理主板上的低速外设。 系统管理总线(SMBus ：System Management Bus)驱动管理SMBus,这是一种用于轻量级通信的two-wire总线。 ide - 这些驱动用来处理像CDROM和硬盘这些PATA/IDE设备。 idle - 这个驱动用来管理Intel处理器的空闲功能。 iio - 工业I/O核心驱动程序用来处理数模转换器或模数转换器。 infiniband - Infiniband是在企业数据中心和一些超级计算机中使用的一种高性能的端口。 这个目录中的驱动用来支持Infiniband硬件。 input - 这里包含了很多驱动，这些驱动都用于输入处理， 包括游戏杆、鼠标、键盘、游戏端口（旧式的游戏杆接口）、遥控器、触控、耳麦按钮和许多其他的驱动。 如今的操纵杆使用USB端口，但是在上世纪80、90年代，操纵杆是插在游戏端口的。 iommu - 输入/输出内存管理单元(IOMMU ：Input/Output Memory Management Unit)驱动用来管理内存管理单元中的IOMMU。 IOMMU连接DMA IO总线到内存上。IOMMU是设备在没有CPU帮助下直接访问内存的桥梁。这有助于减少处理器的负载。 ipack - Ipack代表的是IndustryPack。 这个驱动是一个虚拟总线,允许在载体和夹板之间操作。 irqchip - 这些驱动程序允许硬件的中断请求(IRQ)发送到处理器，暂时挂起一个正在运行的程序而去运行一个特殊的程序（称为一个中断处理程序）。 isdn - 这些驱动用于支持综合业务数字网(ISDN)，这是用于同步数字传输语音、视频、数据和其他网络服务使用传统电话网络的电路的通信标准。 leds - 用于LED的驱动。 lguest - lguest用于管理客户机系统的中断。中断是CPU被重要任务打断的硬件或软件信号。CPU接着给硬件或软件一些处理资源。 macintosh - 苹果设备的驱动在这个文件夹里。 mailbox - 这个文件夹(pl320-pci)中的驱动用于管理邮箱系统的连接。 md- 多设备驱动用于支持磁盘阵列，一种多块硬盘间共享或复制数据的系统。 media - 媒体驱动提供了对收音机、调谐器、视频捕捉卡、DVB标准的数字电视等等的支持。 驱动还提供了对不同通过USB或火线端口插入的多媒体设备的支持。 memory - 支持内存的重要驱动。 memstick - 这个驱动用于支持Sony记忆棒。 message - 这些驱动用于运行LSI Fusion MPT(一种消息传递技术)固件的LSI PCI芯片/适配器。 LSI大规模集成，这代表每片芯片上集成了几万晶体管、 mfd - 多用途设备(MFD)驱动提供了对可以提供诸如电子邮件、传真、复印机、扫描仪、打印机功能的多用途设备的支持。 这里的驱动还给MFD设备提供了一个通用多媒体通信端口(MCP)层。 misc - 这个目录包含了不适合在其他目录的各种驱动。就像光线传感器驱动。 mmc - MMC卡驱动用于处理用于MMC标准的闪存卡。 mtd- 内存技术设备(MTD ：Memory technology devices)驱动程序用于Linux和闪存的交互，这就就像一层闪存转换层。 其他块设备和字符设备的驱动程序不会以闪存设备的操作方式来做映射。尽管USB记忆卡和SD卡是闪存设备，但它们不使用这个驱动，因为他们隐藏在系统的块设备接口后。 这个驱动用于新型闪存设备的通用闪存驱动器驱动。 net - 网络驱动提供像AppleTalk、TCP和其他的网络协议。 这些驱动也提供对调制解调器、USB 2.0的网络设备、和射频设备的支持。 nfc - 这个驱动是德州仪器的共享传输层之间的接口和NCI核心。 ntb - 不透明的桥接驱动提供了在PCIe系统的不透明桥接。PCIe是一种高速扩展总线标准。 nubus - NuBus是一种32位并行计算总线。用于支持苹果设备。 of - 此驱动程序提供设备树中创建、访问和解释程序的OF助手。设备树是一种数据结构，用于描述硬件。 oprofile - 这个驱动用于从驱动到用户空间进程(运行在用户态下的应用)评测整个系统。 这帮助开发人员找到性能问题—-性能分析机制-是用于 Linux 的若干种评测和性能监控工具中的一种 parisc - 这些驱动用于HP生产的PA-RISC架构设备。 PA-RISC是一种特殊指令集的处理器。 parport - 并口驱动提供了Linux下的并口支持。 pci - 这些驱动提供了PCI总线服务。 pcmcia - 这些是笔记本的pc卡驱动 pinctrl - 这些驱动用来处理引脚控制设备。引脚控制器可以禁用或启用I/O设备。 platform -这个文件夹包含了不同的计算机平台的驱动像Acer、Dell、Toshiba、IBM、Intel、Chrombooks等等。 pnp - 即插即用驱动允许用户在插入一个像USB的设备后可以立即使用而不必手动配置设备。 power - 电源驱动使内核可以测量电池电量，检测充电器和进行电源管理。 pps - Pulse-Per-Second驱动用来控制电流脉冲速率。这用于计时。 ps3 - 这是Sony的游戏控制台驱动- PlayStation3。 ptp - 图片传输协议(PTP)驱动支持一种从数码相机中传输图片的协议。 pwm - 脉宽调制(PWM)驱动用于控制设备的电流脉冲。主要用于控制像CPU风扇。 rapidio - RapidIO驱动用于管理RapidIO架构，它是一种高性能分组交换，用于电路板上交互芯片的交互技术，也用于互相使用底板的电路板。 regulator - 校准驱动用于校准电流、温度、或其他可能系统存在的校准硬件。—-用于控制系统中某些设备的电压电流供应 remoteproc - 这些驱动用来管理远程处理器。 rpmsg - 这个驱动用来控制支持大量驱动的远程处理器通讯总线(rpmsg)。 这些总线提供消息传递设施,促进客户端驱动程序编写自己的连接协议消息。 该基础架构允许主处理器上的 Linux 操作系统管理远程处理器上远程软件环境的生命周期和通信-用于在 AMP 环境中的操作系统之间实现 IPC 的 rpmsg 组件和 API rtc - 实时时钟(RTC)驱动使内核可以读取时钟。 s390 - 用于31/32位的大型机架构的驱动。 sbus - 用于管理基于SPARC的总线驱动。 scsi - 允许内核使用SCSI标准外围设备。例如,Linux将在与SCSI硬件传输数据时使用SCSI驱动。 sfi -简单固件接口(SFI)驱动允许固件发送信息表给操作系统。这些表的数据称为SFI表。 sh - 该驱动用于支持SuperHway总线。 sn - 该驱动用于支持IOC3串口。 spi - 这些驱动处理串行设备接口总线(SPI)，它是一个在在全双工下运行的同步串行数据链路标准。设备在主/从模式下通信(取决于设备配置)。 ssb - ssb(Sonics Silicon Backplane)驱动提供对在不同博通芯片和嵌入式设备上使用的迷你总线的支持。 staging - 该目录含有许多子目录。这里所有的驱动还需要在加入主内核前经过更多的开发工作。 target - SCSI设备驱动 tc - 这些驱动用于TURBOchannel，TURBOchannel是数字设备公司开发的32位开放总线。这主要用于DEC工作站。 thermal - thermal驱动使CPU保持较低温度。—Linux温控框架 tty - tty驱动用于管理物理终端连接。 uio - 该驱动允许用户编译运行在用户空间而不是内核空间的驱动。这使用户驱动不会导致内核崩溃。 运行在用户空间的IO技术 usb - USB设备允许内核使用USB端口。闪存驱动和记忆卡已经包含了固件和控制器,所以这些驱动程序允许内核使用USB接口和与USB设备。 uwb - Ultra-WideBand驱动用来管理短距离，高带宽通信的超低功耗的射频设备 vfio - 允许设备访问用户空间的VFIO驱动。—-用户态驱动框架 vhost - 这是用于宿主内核中的virtio服务器驱动。用于虚拟化中。 video - 这是用来管理显卡和监视器的视频驱动。 virt - 这些驱动用来虚拟化。 virtio - 这个驱动用来在虚拟PCI设备上使用virtio设备。用于虚拟化中。 vlynq - 这个驱动控制着由德州仪器开发的专有接口。这些都是宽带产品，像WLAN和调制解调器，VOIP处理器，音频和数字媒体信号处理芯片。 vme - WMEbus最初是为摩托罗拉68000系列处理器开发的总线标准 w1 - 这些驱动用来控制one-wire总线。 watchdog - 该驱动管理看门狗定时器，这是一个可以用来检测和恢复异常的定时器。 xen - 该驱动是Xen管理程序系统。这是个允许用户运行多个操作系统在一台计算机的软件或硬件。这意味着xen的代码将允许用户在同一时间的一台计算机上运行两个或更多的Linux系统。用户也可以在Linux上运行Windows、Solaris、FreeBSD、或其他操作系统。 zorro - 该驱动提供Zorro Amiga总线支持。 阅读驱动代码的说明 Linux的内核代码在驱动程序文件夹中以源代码的形式包含了许多驱动程序。驱动文件夹中的每个文件夹会在下面说明。在配置和 编译内核时，这样有助于你了解驱动程序。否则，用户可能会在编译时加入不必要的或者漏掉重要的驱动。驱动代码通常会包含一个单行注释来指出驱动的目的。比如，tc的驱动代码，有一行的注释说是用于TURBOchannel总线。由于这些文档，用户应该看驱动前几行的注释来了解它们的用途。 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》Linux内核目录结构介绍（超详细）LINUX内核目录文件说明以及配置并编译内核的方法linux内核源码目录结构","link":"/2020/07/09/LINUX%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"title":"Linux内核的编译及加载","text":"编译内核需要做什么？ 查找并且下载一份内核源代码 配置内核。 编译内核和模块。 配置启动文件。 Linux内核代码获取与解压建议直接去官方网站（ www.kernel.org ）下载Linux内核代码。编译内核时，一般将源码解压到/usr/src目录下，解压完成后会在该目录下生成一个与源码包版本号一致的目录。 12345mv linux-3.12.6.tar.xz /usr/src //将下载的内核移动到/usr/src/目录下// 切换到/usr/src/ 下载的压缩包是.tar.xz后缀，解压分为两步xz -d linux-3.12.6.tar.xztar -xvf linux-3.12.6.tar linux DOC 编译生成linux源根目录/Documentation/00-INDEX:目录索引linux源根目录/Documentation/HOWTO:指南生成linux内核帮助文档:在linux源根目录(Documentation) 执行下面的命令 12make htmldocs//ubuntu16下需要执行sudo apt-get install xmlto安装插件才可生成doc文档 在 https://www.kernel.org/doc/html/latest/index.html 也能查看到官方生成的文档 内核编译的准备工作说明一下：本文章是根据Ubuntu系统的命令格式来写的更换内核之前，先更新一下源： 1sudo apt-get update 然后安装一些必要的编译内核的工具 1apt-get install libncurses5-dev build-essential kernel-package libncurses5-dev是为了运行make menuconfig Build-essential是编译工具 kernel-package是编译内核工具 进入下载的内核主目录: 1cd linux-3.12.6 清理所有产生的文件与config配置文件（第一次编译内核时可省略） 1sudo make mrproper 配置内核在编译内核时，需要配置内核，可以使用下面命令中的一个： 123456make config #（基于文本的最为传统的配置界面，不推荐使用）make menuconfig #（基于文本菜单的配置界面）开启文本菜单选项，对窗口有限制，尽量调大窗口，否则会出错 #使用此命令需安装gcc和ncurses-develmake xconfig #（要求QT被安装）make gconfig #（要求GTK+被安装） make menuconfig最值得推荐，它不依赖于QT或GTK+，且非常直观，对/home/baohua/develop/linux中的Linux 4.0-rc1内核运行 make ARCH=arm menuconfig后的界面如下图所示。 对每一个配置选项，用户有三种选含义如下： &lt;*&gt;或[*]——编译进内核本体 [M]——编译成内核模块 [ ]——不将该功能编译进内核 Linux内核的配置系统由以下3个部分组成。 Makefile：分布在Linux内核源代码中，定义Linux内核的编译规则。 Kconfig（配置文件）：给用户提供配置选择的功能。 配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面（提供字符界面和图形界面）。这些配置工具使用的都是脚本语言，如用Tcl/TK、Perl等。 .config配置文件(隐藏文件)： 使用make config、make menuconfig等命令后，会生成一个.config配置文件存储配置信息，记录哪些部分被编译入内核、哪些部分被编译为内核模块。 如果想方便配置，可复制/boot/config文件覆盖.config文件，直接修改即可。 运行make menuconfig等时，配置工具首先分析与体系结构对应的/arch/xxx/Kconfig文件（xxx即为传入的ARCH参数） 通过source引入多层次的Kconfig文件：/arch/xxx/Kconfig文件中除本身包含一些与体系结构相关的配置项和配置菜单以外，还通过source语句引入了一系列Kconfig文件，而这些Kconfig又可能再次通过source引入下一层的Kconfig。 配置工具依据Kconfig包含的菜单和条目即可描绘出一个如图1所示的分层结构。 编译内核和模块编译 12sudo make -j4 # 以4个内核多线程方式编译内核sudo make modules -j4 安装 12sudo make modules_installsudo make install 此时，内核编译完成。安装完成后会在/boot目录下生成几个新内核的文件。剩下是修改启动程序配置，然后运行新的内核程序。 配置启动文件进入引导程序（boot loader)的配置文件看看，对于不同的引导程序(LILO和GRUB）,其配置文件所在路径不同。 对于LILO，路径为：/etc/lilo.conf 对于GRUB，路径为：/boot/grub/grub.cfg 本系统为GRUB引导，因此进入/boot/grub/grub.cfg查看grub.conf配置文件，会发现新内核的信息已经写入了 如果想开机默认显示grub菜单栏：编辑grub.conf，然后注释掉”GRUB_HIDDEN_TIMEOUT”和”GRUB_HIDDEN_TIMEOUT_QUIET” 1sudo vi /etc/default/grub 编辑完毕之后更新一下： 1sudo update-grub 重启,然后选择更改后的内核 1sudo reboot Kconfig和Makefile在Linux内核中增加程序需要完成以下3项工作: 将编写的源代码复制到Linux内核源代码的相应目录中。 修改Kconfig配置：在目录的Kconfig文件中增加关于新源代码对应项目的编译配置选项。 修改Makefile编译代码：在目录的Makefile文件中增加对新源代码的编译条目。 内核编译中的Makefile这里主要对内核源代码各级子目录中的kbuild（内核的编译系统）Makefile进行简单介绍，这部分是内核模块或设备驱动开发者最常接触到的。 Makefile的语法包括如下几个方面。 目标定义：用来定义哪些内容要作为模块编译，哪些要编译并链接进内核。（编译成模块or编译进内核） 代码示例：12345obj -y += foo.o------------------------------------------------------------------------------------obj -y 表示要由foo.c或者foo.s文件编译得到foo.o并链接进内核（无条件编译，所以不需要Kconfig配置选项）obj -m 则表示该文件要作为模块编译。obj -n 形式的目标不会被编译。 更常见的做法是根据make menuconfig后生成的config文件的CONFIG_变量来决定文件的编译方式，如：12obj -$(CONfiG_ISDN) += isdn.oobj -$(CONfiG_ISDN_PPP_BSDCOMP) += isdn_bsdcomp.o 除了具有上述obj -形式的目标以外，还有lib -y library库、hostprogs -y主机程序等目标，但是这两类基本都应用在特定的目录和场合下。 多文件模块的定义:处理一个模块由多个文件组成的情况。 最简单的Makefile仅需一行代码就够了。如果一个模块由多个文件组成，会稍微复杂一些，这时候应采用模块名加-y或-$后缀的形式来定义模块的组成文件，如下：123456789##Makefile for the linux ext2-filesystem routines.#obj -$(CONfiG_EXT2_FS) += ext2.oext2 -y := balloc.o dir.o file.o fsync.o ialloc.o inode.o ioctl.o namei.o super.o symlink.oext2 -$(CONfiG_EXT2_FS_XATTR) += xattr.o xattr_user.o xattr_trusted.oext2 -$(CONfiG_EXT2_FS_POSIX_ACL) += acl.oext2 -$(CONfiG_EXT2_FS_SECURITY) += xattr_security.oext2 -$(CONfiG_EXT2_FS_XIP) += xip.o 模块的名字为ext2 由balloc.o、dir.o、file.o等多个目标文件最终链接生成ext2.o直至ext2.ko文件， 并且是否包括xattr.o、acl.o等则取决于内核配置文件的配置情况，例如，如果CONFIG_EXT2_FS_POSIX_ACL被选择，则编译acl.c得到acl.o并最终链接进ext2。 目录层次的迭代:处理是否编译一个目录中文件进内核的情况。如下例：1obj -$(CONfiG_EXT2_FS) += ext2/ 当CONFIG_EXT2_FS的值为y或m时，kbuild将会把ext2目录列入向下迭代的目标中。 KconfigKconfig（配置文件）：在内核编译时给用户提供配置选择的功能。主要包括如下几个方面。 配置选项 大多数内核配置选项都对应Kconfig中的一个配置选项（config）： 12345config MODVERSIONS # 配置选项 bool \"Module versioning support\" #配置选项的类型 help # 帮助信息 Usually, you have to use modules compiled with your kernel. Saying Y here makes it ... “config”关键字定义新的配置选项，之后的几行代码定义了该配置选项的属性。 配置选项的属性包括: 类型、数据范围、输入提示、 依赖关系、选择关系及帮助信息、默认值等。 每个配置选项都必须指定类型，配置选项类型包括bool、tristate、string、hex和int 其中tristate和string是两种基本类型，其他类型都基于这两种基本类型。 类型定义后可以紧跟输入提示， 下面两段脚本是等价的：1bool \"Networking support\" 12boolprompt \"Networking support\" 输入提示的一般格式为：1prompt &lt;prompt&gt; [if &lt;expr&gt;] #可选的if用来表示该提示的依赖关系。 配置使用默认值并使用if的格式为：1default &lt;expr&gt; [if &lt;expr&gt;] 如果用户不设置对应的选项，配置选项的值就是默认值。//为了便于理解，可以看下面的例子； 依赖关系的格式为： 1depends on（或者requires） &lt;expr&gt; 如果定义了多重依赖关系，它们之间用“&amp;&amp;”间隔。 依赖关系也可以应用到该菜单中所有的其他选项（同样接受if表达式）内，下面两段脚本是等价的：12bool \"foo\" if BARdefault y if BAR 123depends on BARbool \"foo\"default y 选择关系（也称为反向依赖关系）:A如果选择了B，则在A被选中的情况下，B自动被选中。(我个人理解为一种包含关系)格式为： 1select &lt;symbol&gt; [if &lt;expr&gt;] 数据范围的格式为： 1range &lt;symbol&gt; &lt;symbol&gt; [if &lt;expr&gt;] int和hex类型的选项设置可以接受的输入值范围，用户只能输入大于等于第一个symbol，且小于等于第二个symbol的值。 帮助信息的格式为： 1234help（或---help---）开始…结束 帮助信息完全靠文本缩进识别结束。 “—help—”和“help”在作用上没有区别，设计“—help—”的初衷在于将文件中的配置逻辑与给开发人员的提示分开。 菜单结构配置选项在菜单树结构中的位置可由两种方法决定。 第一种方式：12345menu \"Network device support\"depends on NETconfig NETDEVICES…endmenu 所有处于“menu”和“endmenu”之间的配置选项都会成为“Network device support”的子菜单，而且，所有子菜单（config）选项都会继承父菜单（menu）的依赖关系，比如，“Network device support”对“NET”的依赖会被加到配置选项NETDEVICES的依赖列表中。 注意：menu后面跟的“Network device support”项仅仅是1个菜单，没有对应真实的配置选项，也不具备3种不同的状态。这是它和config的区别。 第二种方式：通过分析依赖关系生成菜单结构：如果菜单项在一定程度上依赖于前面的选项，它就能成为该选项的子菜单。如果父选项为“n”，子选项不可见；如果父选项可见，子选项才可见。示例如下：1234567config MODULES bool \"Enable loadable module support\"config MODVERSIONS bool \"Set version information on all module symbols\" depends on MODULEScomment \"module support disabled\"depends on !MODULES MODVERSIONS直接依赖MODULES，只有MODULES不为“n”时，该选项才可见。 除此之外，Kconfig中还可能使用“choices…endchoice”、“comment”、“if…endif”这样的语法结构。其中“choices…endchoice”的结构为：1234choice&lt;choice options&gt;&lt;choice block&gt;endchoice 它定义一个选择群，其接受的选项（choice options）可以是前面描述的任何属性，例如，LDD6410的VGA输出分辨率可以是1024×768或者800×600，在drivers/video/samsung/Kconfig中就定义了如下choice：12345678910111213choicedepends on FB_S3C_VGAprompt \"Select VGA Resolution for S3C Framebuffer\"default FB_S3C_VGA_1024_768config FB_S3C_VGA_1024_768 bool \"1024*768@60Hz\" ---help--- TBAconfig FB_S3C_VGA_640_480 bool \"640*480@60Hz\" ---help--- TBAendchoice 相关资料： 用Kconfig配置脚本和Makefile脚本编写的更详细信息，可以分别参见内核文档Documentation目录内的kbuild子目录下的Kconfig-language.txt和Makefiles.txt文件。 注解内核多次编译过，在编译开始之前可进行清理 123 make clean #清理编译的文件，但保留配置文件 make mrproper #移除所有编译生成的文件、配置文件和备份文件 make distclean #清理所有产生的文件与config配置文件与编辑过的补丁文件,也就是完全清理 如果想快速编译，可进行如下操作 1make -j * #*为cup核心数 如何只编译内核的部分代码 只编译某子目录中的相关代码： 12cd /usr/src/linuxmake path/to/dir/ 只编译部分模块： 1make M=path/to/dir 只编译一个模块： 123make path/to/dir/MOD_NAME.ko``` 将编译生成的文件保存至别处： make O=/path/to/somewhere ``` 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》linux内核编译详解Linux 内核编译Linux源码下生成并安装内核文档Linux(ubuntu)更换内核方法linux内核编程入门 hello worldMakefile教程（绝对经典，所有问题看这一篇足够了）如何系统地学习 Makefile 相关的知识（读/写）？Makefile-百度百科","link":"/2020/07/10/Linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A0%E8%BD%BD/"},{"title":"Linux内核的组成","text":"概述Linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）5个子系统组成。 如果更具体一点就是下面这幅图： 进程调度 处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。 可运行进程实际是仅等待 CPU 资源的进程，如果某个进程在等待其他资源，则该进程是不可运行进程。 在设备驱动编程中，当请求的资源不能得到满足时，驱动一般会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪状态。 进程睡眠睡眠的划分： 可中断的睡眠(浅睡眠)：在收到信号的时候会醒。其状态标志位为TASK_INTERRUPTIBLE； 不可中断的睡眠(深睡眠)：把信号传递到这种睡眠状态的进程不能改变它的状态,也就是说它不响应信号的唤醒。其状态标志位为TASK_UNINTERRUPTIBLE。 进程的描述在Linux内核中，使用task_struct结构体来描述进程，该结构体中包含描述该进程内存资源、文件系统资源、文件资源、tty资源、信号处理等的指针。 Linux线程创建Linux的线程采用轻量级进程模型来实现，在用户空间通过pthread_create()API创建线程的时候，本质上内核只是创建了一个新的task_struct，并将新task_struct的所有资源指针都指向创建它的那个task_struct的资源指针。 内核线程绝大多数进程（以及进程中的多个线程）是由用户空间的应用创建的，当它们存在底层资源和硬件访问的需求时，会通过系统调用进入内核空间。有时候，在内核编程中，如果需要几个并发执行的任务，可以启动内核线程，这些线程没有用户空间。启动内核线程的函数为： 1pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags); 内存管理内存管理的主要作用是控制多个进程安全地共享主内存区域。当CPU提供内存管理单元（MMU）时，Linux内存管理对于每个进程完成从虚拟内存到物理内存的转换。内存管理从逻辑上可以分为硬件无关的部分和硬件相关的部分。 硬件无关的部分( Architecture Independent Manager)提供了提供所有的内存管理机制,包括进程的映射（以进程为单位的memory mapping）和虚拟内存的对换（虚拟内存的Swapping）。 硬件相关的部分( Architecture Specific Managers)为内存管理硬件提供了虚拟接口 Linux进程地址空间一般而言，32位处理器的Linux的每个进程享有4GB的内存空间，0 ~ 3GB属于用户空间，3 ~ 4GB属于内核空间，内核空间对常规内存、I/O设备内存以及高端内存有不同的处理方式。当然，内核空间和用户空间的具体界限是可以调整的，在内核配置选项Kernel Features→Memory split下，可以设置界限为2GB或者3GB。 Linux内存管理的组成 Linux内核的内存管理总体比较庞大，包含底层的Buddy算法，它用于管理每个页的占用情况，内核空间的slab以及用户空间的C库的二次管理。 内核也提供了页缓存的支持，用内存来缓存磁盘 per-BDI flusher线程用于刷回脏的页缓存到磁盘。 Kswapd（交换进程）则是Linux中用于页面回收（包括file-backed的页和匿名页）的内核线程，它采用最近最少使用（LRU）算法进行内存回收。 slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。 在内核初始化完成之后, 内存管理的责任就由伙伴系统来承担. 伙伴系统是一个结合了2的方幂个分配器和空闲缓冲区合并计技术的内存分配方案, 其基本思想很简单. 内存被分成含有很多页面的大块, 每一块都是2个页面大小的方幂. 如果找不到想要的块, 一个大块会被分成两部分, 这两部分彼此就成为伙伴. 其中一半被用来分配, 而另一半则空闲. 这些块在以后分配的过程中会继续被二分直至产生一个所需大小的块. 当一个块被最终释放时, 其伙伴将被检测出来, 如果伙伴也空闲则合并两者. 虚拟文件系统Linux虚拟文件系统隐藏了各种硬件的具体细节，为所有设备提供了统一的接口。而且，它独立于各个具体的文件系统，是对各种文件系统的一个抽象。 它为上层的应用程序提供了统一的vfs_read（）、vfs_write（）等接口，并调用具体底层文件系统或者设备驱动中实现的file_operations结构体的成员函数。 网络接口网络接口提供了对各种网络标准协议的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序两部分： 网络协议部分负责实现每一种可能的网络传输协议 网络设备驱动程序负责与硬件设备进行通信，每一种可能的硬件设备都有相应的设备驱动程序。 Linux内核支持的协议栈种类较多，如Internet、UNIX、CAN、NFC、Bluetooth、WiMAX、IrDA等，上层的应用程序统一使用套接字接口。 进程间通信Linux支持进程间的多种通信机制，包含信号量、共享内存、消息队列、管道、UNIX域套接字等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。 在实际的Linux应用中，人们更多地趋向于使用UNIX域套接字，而不是System V IPC中的消息队列等机制。 Linux内核5个组成部分之间的依赖关系 处于中心位置的是进程调度，所有其他的子系统都依赖于它，因为每个子系统都需要挂起或恢复进程。 一般情况下，当一个进程等待硬件操作完成时，它被挂起；当操作真正完成时，进程被恢复执行。 例如，当一个进程通过网络发送一条消息时，网络接口需要挂起发送进程，直到硬件成功地完成消息的发送，当消息被发送出去以后，网络接口给进程返回一个代码，表示操作的成功或失败。 其他子系统（内存管理，虚拟文件系统及进程间通信）以相似的理由依赖于进程调度。 进程调度与内存管理之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。 进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有内存，还可存取共同的内存区域。 虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK 设备。 内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程（swapd）定期地由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。 除了上面图示中的资源以外，内核中的所有子系统还要依赖一些共同的资源，但在图中并没有显示出来。这些资源包括所有子系统都用到的过程，例如分配和释放内存空间的过程，打印警告或错误信息的过程，还有系统的调试例程等。 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》slab-百度百科伙伴系统之伙伴系统概述–Linux内存管理(十五) //很通俗的博客。Linux内核的整体架构 //不错的英文图示《深入分析Linux内核源代码》","link":"/2020/07/13/Linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90/"},{"title":"Linux模块（modules）","text":"前言Linux 是一个整体式的内核（Monolithic Kernel）结构，也就是说，整个内核是一个单独的、非常大的程序。 从实现机制来说，我们又把它划分为5个子系统（前一篇文章有介绍），内核的各个子系统都提供了内部接口（函数和变量），这些函数和变量可供内核所有子系统调用和使用。 Linux 的整体式结构决定了要给内核增加新的成分也是非常困难，因此Linux 提供了一种全新的机制—可装入模块（Loadable Modules，以下简称模块）： 用户可以根据自己的需要，在不需要对内核进行重新编译的条件下，模块能被动态地插入到内核或从内核中移走。 模块的特点： 模块本身可以不被编译入内核映像，从而控制了内核的大小。 模块一旦被加载，它就和内核中的其他部分完全一样。 我们需要知道什么？ 什么是模块?为什么要使用模块? 整体式内核or微内核 linux 内核是一体化内核，就是说，在内核模式下，linux内核执行在一个单独的地址空间。然而，linux也借鉴了微内核设计中一些好的思想，比如：拥有模块化设计，支持内核抢占，支持内核线程，支持动态加载内核模块到内核映像。相反，linux没有采用微内核中那些破坏性能的特性，比如：所有进程运行于内核模式且所有函数可以直接调用而不是通过消息传递的方式。仅管如此，linux内核是模块化的，多线程的且内核自身是可调度的。 可以说linux是做出了各方面的权衡，典型的实用主义。实用主义又赢得了一些胜利。 什么是模块?模块: 是内核的一部分（通常是设备驱动程序），但是并没有被编译到内核里面去。 它们被分别编译并连接成一组目标文件，这些文件能被插入到正在运行的内核，或者从正在运行的内核中移走，进行这些操作可以使用insmod（插入模块）或rmmod（移走模块）命令，或者，在必要的时候，内核本身能请求内核守护进程(kerned)装入或卸下模块。 这里列出在Linux 内核源程序中所包括的一些模块: 文件系统：minix，sysv，isofs，hpfs，smbfs，ext3，nfs，proc 等。 所有的SCSI 高级驱动程序: disk, tape, cdrom, generic。 大多数SCSI 驱动程序: aha1542, in2000等 大多数以太网驱动程序：非常多，请看./Documentation/networking/net-modules.txt 很多其他模块，例如： binfmt_elf: elf 装入程序 binfmt_java: java 装入程序 serial: 串口（tty） 为什么要使用模块?Linux内核的整体架构本就非常庞大，其包含的组件也非常多。如果把所有需要的功能都编译到Linux内核中。这会导致两个问题： 一是生成的内核会很大， 二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核。 而使用模块机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时候，其对应的代码被动态地加载到内核。按需动态装入模块是非常吸引人的，因为这样可以保证内核达到最小并且使得内核非常灵活 挂载文件系统的例子例如，当你可能偶尔使用 VFAT 文件系统，你只要安装(mount) VFAT，VFAT 文件系统就成为一个可装入模块，kerneld 通过自动装入VFAT 文件系统建立你的Linux 内核，当你卸下(unmount)VFAT 部分时，系统检测到你不再需要的FAT 系统模块，该模块自动地从内核中被移走。按需动态装入模块还意味着，你会有更多的内存给用户程序。 Linux 内核模块的优缺点利用内核模块的动态装载性具有如下优点： 将内核映像的尺寸保持在最小，并具有最大的灵活性； 便于检验新的内核代码，而不需重新编译内核并重新引导。 内核模块的引入带来的缺点： 对系统性能和内存利用有负面影响； 装入的内核模块和其他内核部分一样，具有相同的访问权限，因此，差的内核模块会导致系统崩溃； 为了使内核模块访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改这些符号表 有些模块要求利用其他模块的功能，因此，内核要维护模块之间的依赖性； 内核必须能够在卸载模块时通知模块，并且要释放分配给模块的内存和中断等资源； 内核版本和模块版本的不兼容，也可能导致系统崩溃，因此，严格的版本检查是必需的。 内核模块的Hello World这个最简单的内核模块只包含内核模块加载函数、卸载函数和对GPL v2许可权限的声明以及一些描述信息。 1234567891011121314151617181920212223242526272829/* * a simple kernel module: hello * * Copyright (C) 2014 Barry Song (baohua@kernel.org) * * Licensed under GPLv2 or later. */#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;static int __init hello_init(void) //内核模块加载函数{ printk(KERN_INFO \"Hello World enter\\n\"); return 0;}module_init(hello_init); //以“module_init（函数名）”的形式来指定模块加载函数。static void __exit hello_exit(void) //模块卸载函数{ printk(KERN_INFO \"Hello World exit\\n \");}module_exit(hello_exit); //以“module_exit（函数名）”的形式来指定模块卸载函数。//模块声明与描述MODULE_AUTHOR(\"Barry Song &lt;21cnbao@gmail.com&gt;\"); //声明模块的作者MODULE_LICENSE(\"GPL v2\"); //声明模块的许可证声明MODULE_DESCRIPTION(\"A simple Hello World Module\"); //声明模块的描述 MODULE_ALIAS(\"a simplest module\"); //声明模块的别名 编译它会产生hello.ko目标文件，通过insmod ./hello.ko命令可以加载它，通过rmmod hello命令可以卸载它，加载时输出“Hello World enter”，卸载时输出“Hello World exit”。 说明： 内核模块中用于输出的函数是内核空间的printk()而不是用户空间的printf()。printk()的用法和printf()基本相似，但前者可定义输出级别。printk（）可作为一种最基本的内核调试手段， moudle_init 和 module_exit 这几行使用了特别的内核宏来指出模块加载函数和卸载函数的角色. 内核是一个独特的环境, 它将它的要求强加于要和它接口的代码上.所以写内核代码需要遵循各种规范。 有几个文件对模块是特殊的, 必须出现在每一个可加载模块中. 因此, 几乎所有模块代码都有下面内容: 12#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt; moudle.h 包含了大量加载模块需要的函数和符号的定义. init.h 来指定初始化和清理函数 大部分模块还包含 moudleparam.h, 使得可以在模块加载时传递参数给模块. Linux内核模块程序结构一个Linux内核模块主要由如下几个部分组成: 模块加载函数 当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。 模块卸载函数 当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。 模块许可证声明 许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（Kernel Tainted）的警告。 在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“DualBSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这个在学术界和法律界都有争议）。 大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。 模块参数（可选） 模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。 模块导出符号（可选） 内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的变量或函数。 模块作者等信息声明（可选） 各种 MODULE_ 声明可以出现在你的源码文件的任何函数之外的地方. 但是惯例是把这些声明放在文件末尾。 模块加载函数Linux内核模块加载函数一般以__init标识声明,示例模板如下： 123static int _ _init initialization_function(void){ /* 初始化代码 */ }module_init(initialization_function); 模块加载函数以“module_init（函数名）”的形式被指定。它返回整型值，若初始化成功，应返回0。而在初始化失败时，应该返回错误编码。在Linux内核里，错误编码是一个接近于0的负值，在&lt;linux/errno.h&gt;中定义，包含-ENODEV、-ENOMEM之类的符号值。 总是返回相应的错误编码是种非常好的习惯，因为只有这样，用户程序才可以利用perror等方法把它们转换成有意义的错误信息字符串。 在Linux内核中，可以使用request_module（const char*fmt，…）函数加载内核模块，驱动开发人员可以通过调用下列代码灵活地加载其他内核模块： 1request_module(module_name); 模块卸载函数Linux内核模块卸载函数一般以__exit标识声明,示例模板如下： 123static void _ _exit cleanup_function(void){ /* 释放代码 */ }module_exit(cleanup_function); 模块卸载函数在模块卸载的时候执行，而不返回任何值，且必须以“module_exit（函数名）”的形式来指定。 用__exit来修饰模块卸载函数，可以告诉内核如果相关的模块被直接编译进内核（即built-in），则cleanup_function（）函数会被省略，直接不链进最后的镜像。因为如果模块被内置进内核，就不可能卸载它了，卸载函数也就没有存在的必要了。 模块参数可以用“module_param（参数名，参数类型，参数读/写权限）”为模块定义一个参数。例如下列代码定义了1个整型参数和1个字符指针参数： 1234static char *book_name = \"dissecting Linux Device Driver\";module_param(book_name, charp, S_IRUGO);static int book_num = 4000;module_param(book_num, int, S_IRUGO); 在装载内核模块时，用户可以向模块传递参数，形式为insmode（或modprobe）模块名参数名=参数值，如果不传递，参数将使用模块内定义的缺省值。 如果模块被内置，就无法insmod了，但是bootloader可以通过在bootargs里设置“模块名.参数名=值”的形式给该内置的模块传递参数 导出符号Linux的“/proc/kallsyms”文件对应着内核符号表，它记录了符号以及符号所在的内存地址。模块可以使用如下宏导出符号到内核符号表中： 12EXPORT_SYMBOL(符号名);EXPORT_SYMBOL_GPL(符号名); 导出的符号可以被其他模块使用，只需使用前声明一下即可。 EXPORT_SYMBOL_GPL（）只适用于包含GPL许可权的模块。 下面给出了一个导出整数加、减运算函数符号的内核模块的例子: 12345678910111213141516#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;int add_integar(int a, int b){return a + b;}EXPORT_SYMBOL_GPL(add_integar);int sub_integar(int a, int b){return a - b;}EXPORT_SYMBOL_GPL(sub_integar);MODULE_LICENSE(\"GPL v2\"); 从“/proc/kallsyms”文件中找出add_integar、sub_integar的相关信息： 123456789# grep integar /proc/kallsymse679402c r __ksymtab_sub_integar [export_symb]e679403c r __kstrtab_sub_integar [export_symb]e6794038 r __kcrctab_sub_integar [export_symb]e6794024 r __ksymtab_add_integar [export_symb]e6794048 r __kstrtab_add_integar [export_symb]e6794034 r __kcrctab_add_integar [export_symb]e6793000 t add_integar [export_symb]e6793010 t sub_integar [export_symb] 模块声明与描述12345MODULE_AUTHOR(author); //声明模块的作者MODULE_DESCRIPTION(description); //声明模块的描述MODULE_VERSION(version_string); //声明模块的版本MODULE_DEVICE_TABLE(table_info); //声明模块的设备表MODULE_ALIAS(alternate_name); //声明模块的别名 对于USB、PCI等设备驱动，通常会创建一个MODULE_DEVICE_TABLE，以表明该驱动模块所支持的设备： 1234567/* table of devices that work with this driver */static struct usb_device_id skel_table [] = { { USB_DEVICE(USB_SKEL_VENDOR_ID,USB_SKEL_PRODUCT_ID) }, { } /* terminating enttry */};MODULE_DEVICE_TABLE (usb, skel_table); 查询内核中已加载模块的信息lsmod命令lsmod命令格式lsmod命令可以获得系统中已加载的所有模块以及模块间的依赖关系，例如： 12345678$ lsmodModule Size Used byhello 9 472 0nls_iso8859_1 12 032 1nls_cp437 13 696 1vfat 18 816 1fat 57 376 1 vfat... Module ：表示模块的名称。 Size：表示模块的大小。 Used：表示依赖模块的个数。 by：表示依赖模块的内容。 lsmod命令原理lsmod命令实际上是读取并分析/proc/modules文件，与上述lsmod命令结果对应的“/proc/modules”文件。如下： 12345$ cat /proc/moduleshello 12393 0 - Live 0xe67a2000 (OF)nls_utf8 12493 1 - Live 0xe678e000isofs 39596 1 - Live 0xe677f000vboxsf 42561 2 - Live 0xe6767000 (OF)… /sys/module与tree -a内核中已加载模块的信息也存在于/sys/module目录下: 加载hello.ko后，内核中将包含/sys/module/hello目录，该目录下又有一个refcnt文件和一个sections目录，在/sys/module/hello目录下运行tree –a可得到如下目录树： tree命令会以树状图的方式列出指定目录下的所有文件，包括目录里的文件，显示出指定目录的文件目录结构。 123computer:/sys/module/hello# tree -a.├── coresize├── holders├── initsize├── initstate├── notes│ └── .note.gnu.build-id├── refcnt├── sections│ ├── .exit.text3 directories, 15 files modinfo命令使用modinfo&lt;模块名&gt;命令可以获得模块的信息，包括模块作者、模块的说明、模块所支持的参数以及vermagic： 1234567891011121314151617181920# modinfo floppyfilename: /lib/modules/4.15.0-96-generic/kernel/drivers/block/floppy.koalias: block-major-2-*license: GPLauthor: Alain L. Knaffsrcversion: EECA1709167BA33BEFC75FDalias: acpi*:PNP0700:*alias: pnp:dPNP0700*depends: retpoline: Yintree: Yname: floppyvermagic: 4.15.0-96-generic SMP mod_unload signat: PKCS#7signer: sig_key: sig_hashalgo: md4parm: floppy:charpparm: FLOPPY_IRQ:intparm: FLOPPY_DMA:int 加载和卸载模块modprobe命令modprobe命令: 可以加载模块和卸载模块 比insmod命令要强大，它在加载某模块时，会同时加载该模块所依赖的其他模块。 使用modprobe命令加载的模块若以“modprobe -r filename”的方式卸载，将同时卸载其依赖的模块。 modprobe可载入指定的个别模块，或是载入一组相依的模块。modprobe会根据depmod所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。 Linux modprobe命令-菜鸟教程模块之间的依赖关系存放在根文件系统的/lib/modules/&lt;kernel-version&gt;/modules.dep文件中，实际上是在整体编译内核的时候由depmod工具生成的，它的格式非常简单： 1234567kernel/lib/cpu-notifier-error-inject.ko: kernel/lib/notifier-error-inject.kokernel/lib/pm-notifier-error-inject.ko: kernel/lib/notifier-error-inject.kokernel/lib/lru_cache.ko:kernel/lib/cordic.ko:kernel/lib/rbtree_test.ko:kernel/lib/interval_tree_test.ko:updates/dkms/vboxvideo.ko: kernel/drivers/gpu/drm/drm.ko insmod命令 insmod 实用程序必须找到请求装入的内核模块，请求装入的内核模块通常保存在/lib/modules/kernel-version/目录下。 内核模块被连接成目标文件，与系统中其他程序不同的是，这种目标文件是可重定位的（它们是a.out 或ELF 格式的目标文件）。 insmods 实用程序位于／sbin 目录下 只有超级用户才能插入一个模块，其简单的命令如下： 1insmod serial.o //serial.o 为串口的驱动程序。 但是，这条命令执行以后可能会出现错误信息，诸如模块与内核版本不匹配、不认识的符号等。 查看/proc/ksyms，从中就可以发现内核移出的所有符号,插入模块时候出现不认识的符号，说明模块中的符号并未包含到内核中。这种情况通常说明模块有一些依赖的模块没有装载到内核。 怎么才能知道所依赖的模块呢？ 除了从符号名判断外，更有效的方法是使用depmod 和 modprobe 命令来代替insmod 命令。传递参数给模块通常情况下，当你插入模块时，还需要把参数传递给模块。例如，一个设备驱动程序想知道它所驱动的设备的I/O 地址和IRQ，或者一个网络驱动程序想知道你要它进行多少次的诊断跟踪。这里给出一个例子： 12insmod ne.o io=0x400 irq=10//这里装入的是NE2000 类的以太网适配器驱动程序，并告诉它以太网适配器的I/O 地址为0x400，其所产生的中断为IRQ 10。 对于可装入模块，并没有标准的参数形式，也几乎没有什么约定。每个模块的编写者可以决定insmod 可以用什么样的参数。 对于Linux 内核现已支持的模块，Linux HOWTO 文档给出了每种驱动程序的参数信息。 rmmod命令通过rmmod hello命令可以卸载hello模块 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》《深入分析Linux内核源码》","link":"/2020/07/13/Linux%E6%A8%A1%E5%9D%97%EF%BC%88modules%EF%BC%89/"},{"title":"Linux-信号","text":"前言信号是什么？ 信号(signal)是很短的消息（通常是一个数，以此来标识信号），可以被发送到一个进程或一组进程。信号可以干什么？ 信号在最早的Unix系统中即被引入，用于在用户态进程间通信。内核也用信号通知进程系统所发生的事件。 信号的作用名字前缀为SIG的一组宏用来标识信号：比如当一个进程引用无效的内存时，SIGSEGV宏产生发送给进程的信号标识符。 使用信号的两个主要目的是： 让进程知道已经发生了一个特定的事件。 强迫进程执行它自己代码中的信号处理程序。 这两个目的不是互斥的，因为进程经常通过执行一个特定的例程来对某一事件做出反应。 查看所有信号1234567891011121314$kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 信号的分类常规信号(regular signal)： 编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的) 如果一个常规信号被连续发送多次，那么，只有其中的一个发送到接收进程。 实时信号(real-time signal)： 编号为32 ~ 64的信号是后来扩充的，称做可靠信号(实时信号)。 必须排队以便发送的多个信号能被接收到。 尽管Linux内核并不使用实时信号，它还是通过几个特定的系统调用完全实现了POSIX标准。 可以从两个不同的分类角度对信号进行分类： 可靠性方面：可靠信号与不可靠信号； 不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。 与时间的关系上：实时信号与非实时信号。 Linux中的前31个信号12345678910111213141516171819202122232425262728293031323334编号 信号名称 缺省操作 解释 POSIX1 SIGHUP Terminate 挂起控制终或进程 是2 SIGINT Terminate 来自键盘的中断 是3 SIGQUIT Dump 从键盘退出 是4 SIGILL Dump 非法指令 是5 SIGTRAP Dump 跟踪的断点 否6 SIGABRT Dump 异常结束 是6 SIGIOT Dump 等价于SIGABRT 否7 SIGBUS Dump 总线错误 否8 SIGFPE Dump 浮点异常 是9 SIGKILL Terminate 强迫进程终止 是10 SIGUSR1 Terminate 对进程可用 是11 SIGSEGV Dump 无效的内存引用 是12 SIGUSR2 Terminate 对进程可用 是13 SIGPIPE Terminate 向无读者的管道写 是14 SIGALRM Terminate 实时定时器时钟 是15 SIGTERM Terminate 进程终止 是16 SIGSTKFLT Terminate 协处理器栈错误 否17 SIGCHLD Ignore 子进程停止、结束或在被跟踪时获得信号 是18 SIGCONT Continue 如果已经停止则恢复执行 是19 SIGSTOP Stop 停止进程执行 是20 SIGSTP Stop 从tty发出停止进程 是21 SIGTTIN Stop 后台进程请求输入 是22 SIGTTOU Stop 后台进程请求输出 是23 SIGURG Ignore 套接字上的紧急条件 否24 SIGXCPU Dump 超过CPU时限 否25 SIGXFSZ Dump 超过文件大小的限制 否26 SIGVTALRM Terminate 虚拟定时器时钟 否27 SIGPROF Terminate 概况定时器时钟 否28 SIGWINCH Ignore 窗口调整大小 否29 SIGIO Terminate I/O现在可能发生 否30 SIGPWR Terminate 等价于SIGIO 否31 SIGSYS Dump 坏的系统调用 否31 SIGUNUSED Dump 等价于SIGSYS 否 与信号相关的最重要的系统调用1234567891011121314kill() 向线程组发送一个信号tkill() 向进程发送一个信号tgkill() 向一个特定线程组中的进程发送信号sigaction() 改变与信号相关的操作signal() 类似于sigaction()sigpending() 检查是否有挂起信号sigprocmask() 改动堵塞信号的集合sigsuspend() 等待一个信号rt_sigaction() 改变与实时信号相关的操作rt_sigpending() 检测是否挂起实时信号rt_sigprocmask() 修改阻塞的实时信号的集合rt_sigqueueinfo() 向线程组发送一个实时信号rt_sigsuspend() 等待一个实时信号rt_sigtimedwait() 类似于rt_sigsuspend() 信号的传递信号的一个重要特点是它们可以随时被发送给状态经常不可预知的进程。 发送给非运行进程的信号必须由内核保存，直到进程恢复执行。阻塞一个信号要求信号的传递拖延，直到随后解除阻塞，这使得信号产生一段时间之后才能对其传递这一问题变得更加严重。 因此，内核区分信号传递的两个不同阶段： 信号产生：内核更新目标进程的数据结构以表示一个新信号已被发送。 信号传递：内核强迫目标进程通过以下方式对信号做出反应：或改变目标进程的执行状态，或开始执行一个特定的信号处理程序，或两者都是。 每个所产生的信号至多被传递一次。信号是可消费资源：一旦它们已传递出去，进程描述符中有关这个信号的所有信息都被取消。 一般来说，信号可以保留不可预知的挂起时间。必须考虑下列因素： 信号通常只被当前正运行的进程传递(即由current进程传递)。 给定类型的信号可以由进程选择性地阻塞(blocked)。这种情况下，在取消阻塞前进程将不接收这个信号。 当进程执行一个信号处理程序的函数时，通常“屏蔽”相应的信号，即自动阻塞这个信号直到处理程序结束。因此，所处理的信号另一次出现不能中断信号处理程序，所以，信号处理函数不必是可重入的。 挂起信号(pending signal)：已经产生但还没有传递的信号称为挂起信号。 不论什么时候，对于某个常规类型的信号，一个进程仅存在其一个挂起信号。同一进程同种类型的其它信号不被排队，仅仅被简单的丢弃。 可是，对于实时信号时不同的,其同种类型的挂起信号能够多个。 尽管信号的表示比较直观，但内核的实现相当复杂。内核必须： 记住每个进程阻塞哪些信号。 当从内核态切换到用户态时，对任何一个进程都要检查是否有一个信号已到达。这几乎在每个定时中断时都发生(大约每毫秒发生一次)。 确定是否可以忽略信号。这发生在下列所有的条件都满足时： 目标进程没有被另一个进程跟踪(进程描述符中ptrace字段的PT_PTRACED标志等于0)。 信号没有被目标进程阻塞。 信号被目标进程忽略(或者因为进程已显示地忽略了信号，或者因为进程没有改变信号的缺省操作且这个缺省操作就是“忽略”)。 处理这样的信号，即信号可能在进程运行期间的任一时刻请求把进程切换到一个信号处理函数，并在这个函数返回以后恢复原来执行的上下文。 传递信号之前所执行的操作进程应答,进程以三种方式对一个信号做出应答： 显示地忽略信号。 执行与信号相关的缺省操作。由内核预定义的缺省操作取决于信号的类型，可以是下列类型之一： Terminate：进程被终止(杀死)。 Dump：进程被终止(杀死)，并且，如果可能，创建包含进程执行上下文的核心转储文件。这个文件可以用于调试。 Ignore：信号被忽略。 Stop：进程被停止，即把进程置为TASK_STOPPED状态。 Continue：如果进程被停止(TASK_STOPPED)，就把它置为TASK_RUNNING状态。 通过调用相应的信号处理函数捕获信号。 注意，被对一个信号的阻塞和忽略是不同的：只要信号被阻塞，它就不被传递；只有在信号解除阻塞后才传递它。而一个被忽略的信号总是被传递，只是没有进一步的操作。 如果信号的传递会引起内核杀死一个进程，那么这个信号对该进程就是致命的。 SIGKILL信号总是致命的； 而且，缺省操作为Terminate的每个信号，以及不被进程捕获的信号对该进程也是致命的。 注意，如果一个被进程捕获的信号，其对应的信号处理函数终止了这个进程，那么这个信号就不是致命的，因为进程自己选择了终止，而不是被内核杀死。 POSIX信号和多线程应用POSIX 1003.1标准对多线程应用的信号处理有一些严格的要求： 信号处理程序必须在多线程应用的所有线程之间共享；不过，每个线程必须有自己的挂起信号掩码和阻塞信号掩码。 POSIX库函数kill()和sigqueue()必须向所有的多线程应用而不是某个特殊的线程发出信号。所有由内核产生的信号如此(如：SIGCHLD、SIGINT或SIGQUIT)。 每个发送给多线程应用的信号仅传递给一个线程，这个线程是由内核在从不会阻塞该信号的线程中随意选择出来的。 如果向多线程应用发送了一个致命的信号，那么内核将杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程。 线程组 如果一个挂起信号被发送给了某个特定进程，那么这个信号是私有的；如果被发送给了整个线程组，它就是共享的。 与信号相关的数据结构对系统中的每个进程来说，内核必须跟踪什么信号当前正在挂起或被屏蔽，以及每个线程组是如何处理所有信号的。为了完成这些操作，内核使用几个从处理器描述符可存取的数据结构: 信号描述符和信号处理程序描述符进程描述符的signal字段指向信号描述符(signal descriptor)——一个signal_struct类型的结构，用来跟踪共享挂起信号。 信号描述符还包括与信号处理关系并不密切的一些字段，如： 每进程的资源限制数组rlim 用于存放进程的组领头进程 会话领头进程PID的字段pgrp和session。 信号描述符被属于同一组线程组的所有进程共享: 也就是被调用clone()系统调用(CLONE_THREAD标志置位)创建的所有进程共享，因此，对属于同一线程组的每个进程而言，信号描述符中的字段必须都是相同的。 信号处理程序描述符(signad handler descriplor):每个进程还引用它，它是一个sighand_struct类型的结构，用来描述每个信号必须怎样被线程组处理。 在调用clone()系统调用时设置CLONE_SIGHAND标志，信号处理程序描述符就可以由几个进程共享。 描述符的count字段表示共享该结构的进程个数。 在一个POSIX的多线程应用中，线程组中的所有轻量级进程都引用相同的信号描述符和信号处理程序描述符。 挂起信号队列为了跟踪当前的挂起信号是什么，内核把两个挂起信号队列与每个进程相关联： 共享挂起信号队列，它位于信号描述符的shared_pending字段，存放整个线程组的挂起信号。 私有挂起信号队列，它位于进程描述符的pending字段，存放特定进程(轻量级进程)的挂起信号。 与信号处理相关的系统调用kill()系统调用:一般用kill(pid, sig)系统调用向普通进程或多线程应用发送信号，其相应的服务例程是sys_kill()函数。整数参数pid的几个含义取决于它的值： pid &gt; 0：把sig信号发送到其PID等于pid的进程所属的线程组。 pid = 0：把sig信号发送到与调用进程同组的进程的所有线程组。 pid = -1：把信号发送到所有进程，除了swapper（PID 0)、init(PID 1)和current以外。 pid &lt; -1：把信号发送到进程组-pid进程的所有线程组 kill()系统调用能发送任何信号，即使是编号在32~64之间的实时信号。然而，kill()系统调用不能确保把一个新的元素加入到目标进程的挂起信号队列，因此，挂起信号的多个实例可能被丢失。实时信号应当通过rt_sigqueueinfo()系统调用进行发送。 tkill()和tgkill()系统调用: tkill()和tgkill()系统调用向线程组中的指定进程发送信号。 所有遵循POSIX标准的pthread库的pthread_kill()函数，都是调用这两个系统调用中的任意一个向指定的轻量级进程发送信号。 改变信号的操作sigaction(sig, act, oact)系统调用允许用户为信号指定一个操作。 当然，如果没有自定义的信号操作，那么内核执行与传递的信号相关的缺省操作。 POSIX标准规定，当缺省操作是”Ignore”时，把信号操作设置成SIG_IGN或SIG_DFL将引起同类型的任一挂起信号被丢弃。 此外还要注意，对信号处理程序来说，不论请求屏蔽信号是什么，SIGKILL和SIGSTOP从不被屏蔽。 检查挂起的阻塞信号:sigpending系统调用允许进程检查挂起的阻塞信号的集合，也就是说检查信号被阻塞时已产生的那些信号。修改阻塞信号的集合:sigprocmask()系统调用允许进程修改阻塞信号的集合。这个系统调用只应用于常规信号(非实时信号)。相应的sys_sigprocmask()服务例程作用于三个参数： oset：进程地址空间的一个指针，指向存放以前位掩码的一个位数组。 set：进程地址空间的一个指针，指向包含新位掩码的位数组。 how：一个标志，可以有下列的一个值： SIG_BLOCK：*set位掩码数组，指定必须加到阻塞信号的位掩码数组中的信号。 SIG_UNBLOCK：*set位掩码数组，指定必须从阻塞信号的位掩码数组中删除的信号。 SIG_SETMASK：*set位掩码数组，指定阻塞信号新的位掩码数组。 挂起进程:sigsuspend()系统调用把进程置为TASK_INTERRUPTBLE状态，当然这是把mask参数指向的位掩码数组所指定的标准信号阻塞以后设置的。只有当一个非忽略、非阻塞的信号发送到进程以后，进程才被唤醒。 参考资料【Linux】Linux进程信号详解Linux信号（signal) 机制分析","link":"/2020/07/14/Linux-%E4%BF%A1%E5%8F%B7/"},{"title":"（阅读笔记）网络信息空间的大数据计算","text":"原文介绍网络信息空间的大数据计算 作者：胡春明、马帅、怀进鹏 ，中国计算机学会通讯我们需要知道什么？ 大数据有什么特征？怎么产生的？这些特征带来了哪些影响？大数据时代的研究方法是不是要变化一下？有了大数据，我们需要用它来做计算，那么大数据计算在不同的层次（数据-算法-系统）又会遇到什么样的挑战？ 大数据的特征通常认为大数据具有“4V”特征： Volume：规模庞大 Variety：种类繁多 Velocity：变化频繁 Value：价值巨大但价值密度低。 谐音：大多变价了 这些特征有什么影响吗？ 这些特征对发现事实、揭示规律并预测未来提出了新的挑战，并将对已有计算模式、理论和方法产生深远的影响。 传统数据到大数据时代的研究方法论变化首先，网络信息空间大数据数量庞大，数据的统计特征分布不均匀。（采样精度问题） 在传统的采样方法中，样本选取的差异在减少计算量的同时可能会引入结果的不确定性，采样的质量和精确性都会对计算结果产生影响。 但是，在大数据的计算中，对单一数据项和分析算法的精确性要求不再苛刻，通过对大量数据的分析处理能够有效弥补传统抽样方法的局限（也就是上面黑体标出的局限）。 其次，大数据种类繁多，变化频繁。（分类问题） 已有的计算模式往往通过预先确定的分类方法降低问题的难度和规模，提高预测的准确性。//传统方法通过分类来处理 而在大数据计算中，数据的持续更新可能难以形成稳定的分类，不仅要考虑可分类条件下的精确算法，还要考虑动态数据下的增量算法。//大数据难以形成稳定的分类，需要考虑更多，比如动态数据的增量算法。 最后，大数据研究不同于传统的逻辑推理研究，是对巨大的数据做统计分析和归纳。（推理与统计归纳问题） 传统的确定性问题往往通过自顶向下的还原方法，逐步分解并加以研究。//传统的是自顶向下的还原出问题 而对多源异构大数据相关问题的研究不仅需要还原方法，还需要自底向上的归纳方法，通过关联关系补充因果关系的不足，实现多源数据和多种计算方法的有效融合。//不仅需要自顶部向下的还原，还需要自底向上的归纳 大数据计算的特征文章作者自己又总结了大数据计算的特征。大数据计算具有“近似处理、增量计算、多源归纳”的计算属性，并可进一步归纳为大数据计算的“3I”特征 近似性(Inexact) 增量性(Incremental) 归纳性(Inductive) 大数据计算特征在不同层次带来的挑战三个特性分别在数据层面、算法层面和系统层面给大数据计算带来了“可表示”“可计算”和“可操作”三大问题。 近似性(Inexact)挑战传统计算复杂性理论认为的易解问题在大数据时代下已成为难解问题。由于数据本身的异构和噪声，很难按照传统精确处理的思路来进行大数据的挖掘。此外，许多应用需求旨在寻找数据间的潜在关联关系和宏观趋势特征，允许解的质量在一定区间内近似。 因此，从数据层面，需要综合考虑数据的语义特征、结构特征与质量特征，理解并量化度量数据的价值分布；从算法理论层面，需要建立大数据下的算法复杂性理论及近似算法理论，识别数据量对算法质量的关联关系；从系统层面，需要设计满足用户需求的非精确计算架构，达到用户需求与计算效能的均衡 增量性(Incremental)挑战网络信息空间大数据动态持续产生，不断更新，很难形成大数据的统一视图。此外，许多大数据处理对实时性要求越来越高，全量式的批处理和迭代处理方式在时间上难以满足需求，增量式处理成为一种解决办法。 例子： 例如，百度智能搜索涉及近万亿的网页，大量网页频繁更新，在构建搜索索引和获取用户查询结果时，很难及时对近千PB(1PB=1015B)网页数据进行全量计算；（难以从头全部计算一遍，最好是根据增量的数据来计算调整结果，有一点像控制论的思想） 再如突发事件预警需要业务用户对数据进行长期、频繁地探索，并根据不断更新的结果对数据源、分析方法和计算过程等要素进行调整，以获得更准确及时的结果。 因此，从数据层面，需要量化度量数据的动态复杂性；从算法理论层面，需要考虑数据动态性及其对解的质量的影响，并设计增量式处理算法；从系统层面，需要设计支持增量计算的存储和处理架构及相关机制。 归纳性(Inductive)挑战大数据的多源异构特征对网络信息空间数据挖掘提出新挑战并带来机遇。寻找同一实体在多源数据之间的潜在关联性，有助于进一步规避数据中的噪声干扰，并通过多源数据处理的智能归纳融合，修正非精确数据处理引入的偏差，同时获得比单一数据源更好的处理效果。 大数据下单一源头数据计算的结果可能不准确，可以依靠别的数据源的结果来进行修正 例子： 百度根据用户的搜索日志及其在“百度贴吧”和“百度知道”等不同产品线中提交的数据进行归纳融合，建立用户行为模型，可提供更为准确的个性化搜索结果。 因此，从数据层面，一方面要研究多源异构数据的表示、度量与语义理解方法，努力减少多源异构数据带来的难题，另一方面需要关注多源数据间的潜在关联性和融合方法；从算法层面，需要寻找新的多源数据处理和智能归纳融合算法，并提高算法精度及效率；从系统层面，需要研究多源数据间可迁移学习的数据挖掘新方法，探索融合机器挖掘和人群分析的多种数据处理机制。 参考文献网络信息空间的大数据计算 作者：胡春明、马帅、怀进鹏","link":"/2020/07/22/%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/"},{"title":"Linux-虚拟文件系统","text":"linux设计思想 Linux作为一个最著名的自由软件，几乎处处体现了“自由”的思想，你可以编译适合自己系统要求的内核，或者轻松添加别人开发的新的模块。只要你有实力，你还可以自己写一个新的Linux 支持的文件系统。Linux 不仅支持多种文件系统，而且还支持这些文件系统相互之间进行访问。Linux成功的关键因素之一是它具有与其他操作系统和谐共存的能力，你能够透明的安装具有其他操作系统文件格式的磁盘分区（比如Windows系统）。这一切都要归功于神奇的虚拟文件系统。 虚拟文件系统思想 虚拟文件系统所隐含的思想是把表示很多不同种类文件系统的共同信息放入内核；其中有一个字段或函数来支持linux所支持的所有文件系统所提供的任何操作。对所调用的每个读、写或其他函数，内核都能把他们替换成支持本地linux文件系统、NTFS文件系统或者文件所在的其他任何文件系统的实际函数。 我们需要知道什么？ 概括的说，本文主要讲虚拟文件系统的设计目标，结构及其实现： 虚拟文件系统是什么？为什么要使用虚拟文件系统？怎么实现虚拟文件系统的？ 虚拟文件系统的组成有哪些，在linux中处于什么样的层次，能不能画个原理图示意一下？ Linux中虚拟文件系统、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系是什么样子的？ Linux文件操作的系统调用和C库文件操作的相关介绍 sysfs文件系统与Linux设备模型是什么？ linux文件系统中关键的结构体的介绍,inode结构体与file结构体 虚拟文件系统概念虚拟文件系统又称虚拟文件系统转换（Virual Filesystem Switch ，简称VFS）: 说它虚拟，是因为它所有的数据结构都是在运行以后才建立，并在卸载时删除，而在磁盘上并没有存储这些数据结构。 如果只有VFS，系统是无法工作的，因为它的这些数据结构不能凭空而来，只有与实际的文件系统，如Ext2、Minix、MSDOS、VFAT 等相结合，才能开始工作，所以VFS 并不是一个真正的文件系统。 与VFS 相对应，我们称Ext2、Minix、MSDOS 等为具体文件系统。 是内核的一个软件层，用来处理与Unix标准文件系统相关的所有系统调用，也为各种文件系统提供一个通用的接口。 VFS 的作用概括说来，VFS 主要有以下几个作用。 对具体文件系统的数据结构进行抽象，以一种统一的数据结构进行管理。 接受用户层的系统调用，例如write、open、stat、link 等。 支持多种具体文件系统之间相互访问。 接受内核其他子系统的操作请求，特别是内存管理子系统。 VFS 提供一个统一的接口（实际上就是file_operatoin 数据结构），一个具体文件系统要想被Linux 支持，就必须按照这个接口编写自己的操作函数，而将自己的细节对内核其他子系统隐藏起来。 因而，对内核其他子系统以及运行在操作系统之上的用户程序而言，所有的文件系统都是一样的。实际上，要支持一个新的文件系统，主要任务就是编写这些接口函数。 图1. Linux虚拟文件系统与整个软硬件系统的关系 文件系统的逻辑关系VFS 称为内核的一个子系统，其他子系统只与VFS 打交道，而并不与具体文件系统发生联系。对具体文件系统来说，VFS 是一个管理者，而对内核的其他子系统来说，VFS 是它们与具体文件系统的一个接口，整个Linux 中文件系统的逻辑关系如图2所示。 图2. Linux中文件系统的逻辑关系示意图 文件系统与设备驱动之间的关系Linux中虚拟文件系统、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系。 图3. 文件系统与设备驱动之间的关系 应用程序和VFS之间的接口是系统调用，而VFS与文件系统以及设备文件之间的接口是file_operations结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数 由于字符设备的上层没有类似于磁盘的ext2等文件系统，所以字符设备的file_operations成员函数就直接由设备驱动提供了。 块设备有两种访问方法 一种方法是不通过文件系统直接访问裸设备 在Linux内核实现了统一的def_blk_fops这一file_operations，它的源代码位于fs/block_dev.c，所以当我们运行类似于“dd if=/dev/sdb1of=sdb1.img”的命令 把整个/dev/sdb1裸分区复制到sdb1.img的时候，内核走的是def_blk_fops这个file_operations； 另外一种方法是通过文件系统来访问块设备 file_operations的实现则位于文件系统内，文件系统会把针对文件的读写转换为针对块设备原始扇区的读写。 ext2、fat、Btrfs等文件系统中会实现针对VFS的file_operations成员函数，设备驱动层将看不到file_operations的存在。 图4. 应用程序、VFS与设备驱动 VFS支持的文件系统VFS支持的文件系统可以划分为三种主要类型： 磁盘文件系统 网络文件系统 特殊文件系统 这些文件系统管理在本地磁盘分区中可用的存储空间或者其他可以起到磁盘作用的设备（比如USB闪存）。 这些文件系统允许轻易的访问属于其他网络计算机的文件系统所包含的文件。 比如NFS,CIFS(用于微软Windows的通用网络系统) 这些文件系统不管理本地或者远程磁盘空间。 比如/proc、/sys、/dev等文件系统。 .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); } VFS处理的系统调用VFS 处理的系统调用涉及文件系统、常规文件、目录及符号链接，还有一些特殊的系统调用，如下所示： 涉及设备文件和管道文件的系统调用，诸如ioperm( )、ioctl( )、pipe( )和mknod( )， 套接字系统调用，诸如socket( )、connect( )、bind( )和 protocols( )。 VFS 的部分系统调用： 点击展开系统调用列表 >folded123456789101112131415161718192021mount( )/ umount( ) 安装/卸载文件系统sysfs( ) 获取文件系统信息statfs( )/ fstatfs( ) /ustat( ) 获取文件系统统计信息chroot( ) 更改根目录chdir( ) /fchdir( ) /getcwd( ) 更改当前目录mkdir( ) /rmdir( ) 创建/删除目录getdents( ) /readdir( )/ link( ) unlink( )/rename( ) 对目录项进行操作readlink( ) /symlink( ) 对软链接进行操作chown( ) /fchown( ) /lchown( ) 更改文件所有者chmod( )/ fchmod( ) /utime( ) 更改文件属性stat( ) /fstat( ) /lstat( ) access( ) 读取文件状态open( ) /close( ) /creat( ) /umask( ) 打开/关闭文件dup( ) /dup2( ) /fcntl( ) 对文件描述符进行操作select( ) /poll( ) 异步I/O 通信truncate( ) /ftruncate( ) 更改文件长度lseek( ) /_llseek( ) 更改文件指针read( )/ write( ) /readv( ) /writev( )/sendfile( ) 文件I/O 操作pread( )/ pwrite( ) 搜索并访问文件mmap( ) /munmap( ) 文件内存映射fdatasync( ) /fsync( ) /sync( )/ msync( ) 同步访问文件数据flock( ) 处理文件锁 VFS 中的数据结构虚拟文件系统模型的实现方式： 虚拟文件系统所隐含的主要思想在于引入了一个通用的文件模型，这个模型能够表示所有支持的文件系统。 该模型严格遵守传统UNIX 文件系统提供的文件模型。 你可以把通用文件模型看作是面向对象的，在这里，对象是一个软件结构，其中既定义了数据结构也定义了其上的操作方法。 出于效率的考虑，Linux 的编码并未采用面向对象的程序设计语言（比如C++）。因此通用文件模型对象作为数据结构来实现：数据结构中指向函数的域就对应于对象的方法。 通用文件模型由下列对象类型组成： 超级块（superblock）对象：存放系统中已安装文件系统的有关信息。 对于基于磁盘文件系统，这类对象通常对应于存放在磁盘上的文件系统控制块（filesystem control block），也就是说，每个文件系统都有一个超级块对象。 很多具体文件系统中都有超级块结构，超级块是这些文件系统中最重要的数据结构，它是来描述整个文件系统信息的，是一个全局的数据结构。 注意：Minix、Ext2 等有超级块，VFS 也有超级块，为了避免与后面介绍的Ext2 超级块发生混淆，这里用VFS 超级块来表示。 VFS 超级块是各种具体文件系统在安装时建立的，并在这些文件系统卸载时自动删除，可见，VFS 超级块确实只存在于内存中，同时提到VFS 超级块也应该说成是哪个具体文件系统的VFS超级块。 索引节点（inode）对象：存放关于具体文件的一般信息。 对于基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块（file control block），也就是说，每个文件都有一个索引节点对象。每个索引节点对象都有一个索引节点号，这个号唯一地标识某个文件系统中的指定文件。 强调一点，具体文件系统的索引节点是存储在磁盘上的，是一种静态结构，要使用它，必须调入内存，填写VFS 的索引节点，因此，也称VFS索引节点为动态节点。 目录项（dentry）对象：存放目录项与对应文件进行链接的信息。 每个文件除了有一个索引节点inode 数据结构外，还有一个目录项dentry（directoryenrty）数据结构。dentry 结构中有个d_inode 指针指向相应的inode 结构。 VFS 把每个目录看作一个由若干子目录和文件组成的常规文件。例如，在查找路径名/tmp/test 时，内核为根目录“/”创建一个目录项对象，为根目录下的tmp 项创建一个第2 级目录项对象，为/tmp目录下的test 项创建一个第3 级目录项对象。 每个磁盘文件系统都以自己特有的方式将该类信息存在磁盘上。 文件（file）对象：存放打开文件与进程之间进行交互的有关信息。 这类信息仅当进程访问文件期间存在于内存中。 既然inode 结构和dentry 结构都是对文件各方面属性的描述，那为什么不把这两个结构“合二为一”呢？ 这是因为二者所描述的目标不同，dentry结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，因此，目录项对象在磁盘上并没有对应的映像；而inode结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统（如Ext2），Ext2_ inode 结构在磁盘上就有对应的映像。所以说，一个索引节点对象可能对应多个目录项对象。 超级块、索引节点、目录项及文件的数据结构，它们的共同特点有两个： 充分考虑到对多种具体文件系统的兼容性； 是“虚”的，也就是说只能存在于内存。 这正体现了VFS 的特点 进程与VFS对象的交互示例下图是一个简单的示例，对进程与文件之间的交互过程进行了说明： 三个不同的进程已经打开同一个文件，其中两个进程已经使用同一个硬链接。 每个进程都使用自己的文件对象，但是因为两个进程共有硬链接的关系，我们只需要两个目录项对象，每个硬链接对应一个目录项对象。 然后这两个目录项对象指向同一个索引节点对象，该索引节点对象标识超级块对象，以及随后的普通磁盘文件。 进程与VFS对象的交互 说明： 最近最常使用的目录项对象被放在所谓目录项高速缓存的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程 磁盘高速缓存 一般说来，磁盘高速缓存属于软件机制，它允许内核将原本存在磁盘上的某些信息保存在RAM中，以便对这些数据的进一步访问能快速进行，而不必慢速访问磁盘本身。 除了目录项高速缓存，索引结点高速缓存之外，Linux还使用其他磁盘高速缓存，其中最重要的一种的页高速缓存。 磁盘高速缓存，硬件高速缓存与内存高速缓存直接之间的区别 硬件高速缓存是一个快速的静态的RAM，它加快了对慢速动态RAM的请求。内存高速缓存是一种软件机制，引入它是为了绕过内核内存分配器。与磁盘高速缓存不同，上述两者都与磁盘或其他设备无关。 参考资料《Linux设备驱动开发详解：基于最新的Linux4.0内核》《深入分析Linux内核源代码》《深入理解Linux内核》","link":"/2020/08/10/Linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"Linux-特殊文件系统","text":"前言网络和磁盘文件系统能够使用户处理存放在内核之外的信息。特殊文件系统可以为系统程序员和管理员提供一种容易的方式来操作内核的数据结构并实现操作系统的特殊特征。 Linux中常用的 特殊文件系统下表列出了最常用的特殊文件系统 名字 安装 说明 bdev none 块设备 binfmt_misc any 其他可执行格式 devpts /dev/pts 伪终端支持（开放组织的Unix98标准） eventpollfs none 由有效事件轮询机制使用 futexfs none 由futex（快速用户空间加锁）机制使用 pipefs none 管道 proc /proc 对内核数据结构的常规访问点。一个反映内核运行情况的虚的文件系统，并不实际存在于磁盘上。历史最早，最初就是用来跟内核交互的唯一方式，用来获取处理器、内存、设备驱动、进程等各种信息。 rootfs none 为启动阶段提供一个空的根目录 shm none IPC共享线性区 mqueue any 实现POSIX消息队列时使用 sockfs none 套接字 sysfs /sys 对系统数据的常规访问点（一般是些驱动）, 跟 kobject 框架紧密联系，而 kobject 是为设备驱动模型而存在的，所以 sysfs 是为设备驱动服务的。 tmpfs any 临时文件（如果不被交换出去就保持在RAM中） usbfs /proc/bus/usb USB设备 注意： 有几个特殊文件系统没有固定的安装点（也就是any）。这些文件系统可以由用户自由的安装和使用。 还有一些特殊文件系统根本没有安装点（也就是none）。它们不是用于和用户交互，但是内核可以使用它们，以便更容易地重用VFS层的某些代码； 特殊文件系统不限于物理块设备。然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0而次设备号具有任意值（每个特殊文件系统有不同的值）。 set_anon_super()函数用于初始化特殊文件系统的超级块；该函数本质上获得一个未使用的次设备号dev，然后用主设备号0和次设备号dev设置新超级块的s_dev字段。而另一个kill_anon_super()函数移走特殊文件系统的超级块。unnamed_dev_idr变量包含指向一个辅助结构（记录当前在用的次设备号）的指针。尽管有些内核设计者不喜欢虚拟块设备标识符，但是这些标识符有助于内核以统一的方式处理特殊文件系统和普通文件系统。 /proc文件系统/proc 是一个特殊的文件系统，其安装点一般都固定为/proc。这个文件系统中所有的文件都是特殊文件，其内容不存在于任何设备上。每当创建一个进程时，系统就以其pid 为文件名在这个目录下建立起一个特殊文件，使得通过这个文件就可以读／写相应进程的用户空间，而当进程退出时则将此文件删除。/proc 文件系统中的目录项结构dentry，在磁盘上没有对应结构，而以内存中的proc_dir_entry 结构来代替。 查看Linux源码可以通过在线的linux源码进行查看，非常方便的。通过tag切换还可以查看不同版本的linux。 proc_dir_entry定义的地方: Linux kernel 2.6.38.8 在#include &lt;linux/proc_fs.h&gt; Linux kernel 3.10.17 在fs/proc/internal.h:struct proc_dir_entry Linux内核提供了很多proc文件系统的API,相关API定义在kernel-3.10/fs/proc/generic.c中，并在kernel-3.10\\include\\linux\\proc_fs.h中引用 struct proc_dir_entry数据结构定义路径：kernel-3.10/fs/proc/internal.h 123456789101112131415161718192021222324252627282930313233//这还没有完全实现。这个想法是为了在这些proc_dir_entries中创建一个内存树(就像实际的/proc文件系统一样 )，//这样我们就可以动态地 向/proc添加新文件。/* * This is not completely implemented yet. The idea is to * create an in-memory tree (like the actual /proc filesystem * tree) of these proc_dir_entries, so that we can dynamically * add new files to /proc. * * The \"next\" pointer creates a linked list of one /proc directory, * while parent/subdir create the directory structure (every * /proc file has a parent, but \"subdir\" is NULL for all * non-directory entries). */struct proc_dir_entry { unsigned int low_ino; umode_t mode; nlink_t nlink; kuid_t uid; kgid_t gid; loff_t size; const struct inode_operations *proc_iops; const struct file_operations *proc_fops; struct proc_dir_entry *next, *parent, *subdir; void *data; atomic_t count; /* use count */ atomic_t in_use; /* number of callers into module in progress; */ /* negative -&gt; it's going away RSN */ struct completion *pde_unload_completion; struct list_head pde_openers; /* who did -&gt;open, but not -&gt;release */ spinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */ u8 namelen; char name[];}; 在/proc/下创建目录proc_mkdir函数定义路径：kernel-3.10/fs/proc/generic.c 123456struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent)/*proc_mkdir_data()第二个参数mode=0表示mode = S_IRUGO | S_IXUGO; */{ return proc_mkdir_data(name, 0, parent, NULL);} 参数parent表示name的父目录，一般为NULL，表示挂载在/proc/下。 参数name就是在proc/下创建的目录名。 该函数实际上调用了proc_mkdir_data函数来创建一个目录的。proc_mkdir_data函数定义路径：kernel-3.10/fs/proc/generic.c 123456789101112131415161718struct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode, struct proc_dir_entry *parent, void *data){ struct proc_dir_entry *ent; if (mode == 0) mode = S_IRUGO | S_IXUGO; ent = __proc_create(&amp;parent, name, S_IFDIR | mode, 2); if (ent) { ent-&gt;data = data; if (proc_register(parent, ent) &lt; 0) { kfree(ent); ent = NULL; } } return ent;} 当需要对创建的目录指定mode的时候，可用下面这个API： 1234struct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode, struct proc_dir_entry *parent){ return proc_mkdir_data(name, mode, parent, NULL); 移除创建的目录或文件remove_proc_entry函数定义路径：kernel-3.10/fs/proc/generic.c 1234567891011121314151617181920212223242526272829303132333435363738void remove_proc_entry(const char *name, struct proc_dir_entry *parent){ struct proc_dir_entry **p; struct proc_dir_entry *de = NULL; const char *fn = name; unsigned int len; spin_lock(&amp;proc_subdir_lock); if (__xlate_proc_name(name, &amp;parent, &amp;fn) != 0) { spin_unlock(&amp;proc_subdir_lock); return; } len = strlen(fn); for (p = &amp;parent-&gt;subdir; *p; p=&amp;(*p)-&gt;next ) { if (proc_match(len, fn, *p)) { de = *p; *p = de-&gt;next; de-&gt;next = NULL; break; } } spin_unlock(&amp;proc_subdir_lock); if (!de) { WARN(1, \"name '%s'\\n\", name); return; } proc_entry_rundown(de); if (S_ISDIR(de-&gt;mode)) parent-&gt;nlink--; de-&gt;nlink = 0; WARN(de-&gt;subdir, \"%s: removing non-empty directory \" \"'%s/%s', leaking at least '%s'\\n\", __func__, de-&gt;parent-&gt;name, de-&gt;name, de-&gt;subdir-&gt;name); pde_put(de);} 参考资料github上的linux开源代码 Linux 文件系统：procfs, sysfs, debugfs 用法简介proc文件系统详解Linux内核通信之—proc文件系统（详解）《深入分析Linux内核源代码》《深入理解Linux内核》","link":"/2020/08/11/Linux-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"Linux-VFS中的数据结构","text":"前言VFS（虚拟文件系统）四大对象：struct super_block 超级块、struct inode 索引节点、struct dentry 目录项、struct file 文件对象VFS采用的是面向对象的设计思想，使用一簇数据结构来代表通用文件对象。所以内核中的数据结构都使用C结构体实现。 超级块super_block对象，代表一个具体的已安装文件系统。 索引节点inode对象，代表一个具体文件。 目录项dentry对象，代表一个目录项，是路径的一个组成部分。 文件file对象，代表有进程打开的文件。 每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法： super_operations对象：包含内核针对特定文件系统所能调用的方法。 inode_operations对象：包含内核对特定文件所能调用的方法。 dentry_operations对象：包含内核对特定目录所能调用的方法。 file_operations对象：包含进程针对已打开文件所能调用的方法。 操作对象作为一个指针结构体被实现，此结构体中包含指向操作其父对象的函数指针。对于其中许多方法来说，可以继承使用VFS提供的通用函数，如果通用函数提供的基本功能无法满足需要，就必须使用实际文件系统的独有方法填充这些函数指针，使其指向文件系统实例。 注意，这里所说的对象指的是结构体，不是像C++和Java那样的真正的数据类型。 VFS使用了大量结构体对象，它所包括的对象远远多于上述几种对象，比如： 每个注册的文件系统都由file_system_type结构体表示，它描述了文件系统及其性能； 每一个安装点都用vfsmount结构体表示，它包含的是安装点的相关信息，如位置和安装标志等。 与进程相关的结构体是：file_struct、fs_struct、namespace和file。它们描述了文件系统以及和进程相关的文件。 本文中的代码以linux3.10内核版本的代码为准。 超级块很多具体文件系统中都有超级块结构，超级块是这些文件系统中最重要的数据结构，它是来描述整个文件系统信息的，可以说是一个全局的数据结构。超级块描述已安装文件系统。文件系统的控制信息存储在超级块中。超级块是文件系统的控制块，有整个文件系统信息，一个文件系统所有的inode都要连接到超级块上，可以说，一个超级块就代表了一个文件系统。 Minix、Ext2 等有超级块，VFS 也有超级块，为了避免与后面介绍的Ext2 超级块发生混淆，这里用VFS 超级块来表示。 VFS 超级块是各种具体文件系统在安装时建立的，并在这些文件系统卸载时自动删除 VFS 超级块确实只存在于内存中，同时提到VFS 超级块也应该说成是哪个具体文件系统的VFS超级块。 VFS 超级块在include/linux/fs.h 中定义，即数据结构super_block，该结构及其主要域的含义如下： 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091struct super_block { struct list_head s_list; /* Keep this first 指向超级块链表的指针*/ dev_t s_dev; /* search index; _not_ kdev_t 设备表示符*/ unsigned char s_blocksize_bits; /*块大小的值占用的位数，例如，如果块大小为1024 字节，则该值为10*/ unsigned long s_blocksize; /*该具体文件系统中数据块的大小，以字节为单位 */ loff_t s_maxbytes; /* Max file size 文件的最大长度 */ struct file_system_type *s_type; /*指向文件系统的file_system_type 数据结构的指针 */ const struct super_operations *s_op; /*指向某个特定的具体文件系统的用于超级块操作的函数集合 */ const struct dquot_operations *dq_op; /* 指向某个特定的具体文件系统用于限额操作的函数集合 */ const struct dquot_operations *dq_op; /* 指向某个特定的具体文件系统用于限额操作的函数集合 */ const struct quotactl_ops *s_qcop; const struct export_operations *s_export_op; unsigned long s_flags; /* 安装标志*/ unsigned long s_magic; /*魔数，即该具体文件系统区别于其他文件系统的一个标志*/ struct dentry *s_root; struct rw_semaphore s_umount; /*对超级块读写时进行同步*/ int s_count; /*对超级块的使用计数*/ atomic_t s_active;#ifdef CONFIG_SECURITY void *s_security;#endif const struct xattr_handler **s_xattr; struct list_head s_inodes; /* all inodes 把所有索引对象链接在一起，存放的是头结点*/ struct hlist_bl_head s_anon; /* anonymous dentries for (nfs) exporting */#ifdef CONFIG_SMP struct list_head __percpu *s_files;#else struct list_head s_files; //链接所有打开的文件#endif struct list_head s_mounts; /* list of mounts; _not_ for fs use */ /* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */ struct list_head s_dentry_lru; /* unused dentry lru */ int s_nr_dentry_unused; /* # of dentry on lru */ /* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */ spinlock_t s_inode_lru_lock ____cacheline_aligned_in_smp; struct list_head s_inode_lru; /* unused inode lru */ int s_nr_inodes_unused; /* # of inodes on lru */ struct block_device *s_bdev; struct backing_dev_info *s_bdi; struct mtd_info *s_mtd; struct hlist_node s_instances; struct quota_info s_dquot; /* Diskquota specific options */ struct sb_writers s_writers; char s_id[32]; /* Informational name 文本名字 */ u8 s_uuid[16]; /* UUID */ void *s_fs_info; /* Filesystem private info 文件系统特设信息*/ unsigned int s_max_links; fmode_t s_mode; /* Granularity of c/m/atime in ns. Cannot be worse than a second */ u32 s_time_gran; /* * The next field is for VFS *only*. No filesystems have any business * even looking at it. You had been warned. */ struct mutex s_vfs_rename_mutex; /* Kludge */ /* * Filesystem subtype. If non-empty the filesystem type field * in /proc/mounts will be \"type.subtype\" */ char *s_subtype; /* * Saved mount options for lazy filesystems using * generic_show_options() */ char __rcu *s_options; const struct dentry_operations *s_d_op; /* default d_op for dentries */ /* * Saved pool identifier for cleancache (-1 means none) */ int cleancache_poolid; struct shrinker s_shrink; /* per-sb shrinker handle */ /* Number of inodes with nlink == 0 but still referenced */ atomic_long_t s_remove_count; /* Being remounted read-only */ int s_readonly_remount;}; 所有超级块对象（每个已安装的文件系统都有一个超级块）以双向环形链表的形式链接在一起。链表中第一个元素和最后一个元素的地址分别存放在super_blocks 变量的s_list 域的 next 和 prev 域中。s_list 域的数据类型为struct list_head，在内核的其他很多地方都可以找到这样的数据类型；这种数据类型仅仅包括指向链表中的前一个元素和后一个元素的指针。因此，超级块对象的s_list 域包含指向链表中两个相邻超级块对象的指针。 图1 说明了list_head 元素、next 和 prev 如何嵌入到超级块对象中的。 图1. 超级块链表 s_fs_info字段指向属于具体文件系统的超级块信息。为了效率起见，由s_fs_info字段所指向的数据被复制到内存(也就是具体文件系统的超级块)。任何基于磁盘的文件系统都需要访问和更改自己的磁盘分配位图（磁盘分配位图指存在于磁盘中用来标识磁盘每个块是否空闲的一段存储空间），以便分配或释放块。VFS允许这些文件系统直接对内存超级块的s_fs_info字段进行操作，而无需访问磁盘。 与超级块关联的方法就是超级块操作，由super_operations来描述，该结构的起始地址存放在超级块的s_op字段中。super_operations结构如下，代码来自include/linux/fs.h 点击展开代码 >folded1234567891011121314151617181920212223242526272829struct super_operations { struct inode *(*alloc_inode)(struct super_block *sb); /* 为索引节点对象分配空间，包括具体文件系统的数据所需要的空间。*/ void (*destroy_inode)(struct inode *); /* 撤销索引节点对象，包括具体文件系统的数据。 */ void (*dirty_inode) (struct inode *, int flags); /* 当索引节点标记为修改（脏）时调用。*/ int (*write_inode) (struct inode *, struct writeback_control *wbc); /* 用通过传递参数指定的索引节点对象的内容更新一个文件系统的索引节点。*/ int (*drop_inode) (struct inode *); void (*evict_inode) (struct inode *); void (*put_super) (struct super_block *); /* 释放通过传递的参数指定的超级块对象（因为相应的文件系统被卸载）。*/ int (*sync_fs)(struct super_block *sb, int wait); /* 在清除文件系统来更新磁盘上的具体文件系统数据结构时调用（由日志文件系统使用）。*/ int (*freeze_fs) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); /* 将文件系统的统计信息返回，填写在buf缓冲区中。*/ int (*remount_fs) (struct super_block *, int *, char *); /* 用新的选项重新安装文件系统（当某个安装选项必须被修改时被调用）。*/ void (*umount_begin) (struct super_block *); /* 中断一个安装操作，因为相应的卸载操作已经开始（只在网络文件系统中使用）。*/ int (*show_options)(struct seq_file *, struct dentry *); /* 用来显示特定文件系统的选项。*/ int (*show_devname)(struct seq_file *, struct dentry *); int (*show_path)(struct seq_file *, struct dentry *); int (*show_stats)(struct seq_file *, struct dentry *); /* 用来显示特定文件系统的状态。*/#ifdef CONFIG_QUOTA //一般情况下用不到最后两个方法 ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);/* 限额系统使用该方法从文件中读取数据，该文件详细说明了所在文件系统的限制。*/ ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); /* 限额系统使用该方法将数据写入文件中，该文件详细说明了所在文件系统的限制。*/#endif int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t); int (*nr_cached_objects)(struct super_block *); void (*free_cached_objects)(struct super_block *, int);}; 每一个文件系统都可以定义自己的超级块操作，它可以是上面结构的一个字集，因为有些操作可能不需要，未实现的方法对应的字段置为NULL,当我们要调用其中的一个操作时，比如read_inode,这执行以下操作 1sb-&gt;s_op-&gt;read_inode(inode); 这里sb存放所涉及超级块对象的地址。super_operations表的read_inode字段存放这函数的地址，因此，这一函数被直接调用。 注意，系统没有定义get_super方法来读超级块，那么，内核如何能够调用一个对象的方法而从磁盘读出该对象？ 我们将在描述文件系统类型的另一个对象中找到等价的get_sb方法。该方法定义在具体文件系统的file_system_type结构中，在register_filesystem的时候会把该文件系统注册进去。 VFS 的索引节点索引节点:文件系统处理文件所需要的所有信息都放在称为索引节点的数据结构中索引节点（inode）,是 VFS 中最为重要的一个结构，用于描述一个文件的meta（元）信息，其包含的是诸如文件的大小、拥有者、创建时间、磁盘位置等和文件相关的信息，所有文件都有一个对应的 inode 结构。文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在。有关使用索引节点的原因将在下一章中进一步介绍.这里主要强调一点，具体文件系统的索引节点是存储在磁盘上的，是一种静态结构，要使用它，必须调入内存，填写VFS 的索引节点，因此，也称VFS 索引节点为动态节点。这里用VFS 索引节点来避免与下一章的Ext2 索引节点混淆。VFS 索引节点的数据结构inode 在include/linux/fs.h 中定义如下: 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394struct inode { umode_t i_mode; /*文件的类型与访问权限 */ unsigned short i_opflags; kuid_t i_uid; /*文件拥有者标识号*/ kgid_t i_gid; /*文件拥有者所在组的标识号*/ unsigned int i_flags; /*文件系统的安装标志*/#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; struct posix_acl *i_default_acl;#endif const struct inode_operations *i_op; /*索引节点的操作*/ struct super_block *i_sb; /*指向该文件系统超级块的指针 *//************用于分页机制的域**********************************/ struct address_space *i_mapping; ／* 把所有可交换的页面管理起来*/#ifdef CONFIG_SECURITY void *i_security;#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /*索引节点号*/ /* * Filesystems may only read i_nlink directly. They shall use the * following functions for modification: * * (set|clear|inc|drop)_nlink * inode_(inc|dec)_link_count */ union { const unsigned int i_nlink; unsigned int __i_nlink; }; dev_t i_rdev; /*实际设备标识号*/ loff_t i_size; /*文件的大小（以字节为单位）*/ struct timespec i_atime; struct timespec i_mtime; /*文件的最后修改时间*/ struct timespec i_ctime; /*节点的修改时间*/ spinlock_t i_lock; /* i_blocks, i_bytes, maybe i_size */ /*该节点是否被锁定，用于同步操作中*/ unsigned short i_bytes; unsigned int i_blkbits; blkcnt_t i_blocks; /*块大小*/#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount;#endif /* Misc */ unsigned long i_state; /*索引节点的状态标志*/ struct mutex i_mutex; unsigned long dirtied_when; /* jiffies of first dirtying */ struct hlist_node i_hash; ／*指向哈希链表的指针*/ struct list_head i_wb_list; /* backing dev IO list */ struct list_head i_lru; /* inode LRU list */ struct list_head i_sb_list; union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; u64 i_version; atomic_t i_count; /*当前使用该节点的进程数。计数为0，表明该节点可丢弃或被重新使用 */ atomic_t i_dio_count; atomic_t i_writecount; const struct file_operations *i_fop; /* former -&gt;i_op-&gt;default_file_ops */ /*指向文件操作的指针 */ struct file_lock *i_flock; /*指向文件加锁链表的指针*/ struct address_space i_data;#ifdef CONFIG_QUOTA struct dquot *i_dquot[MAXQUOTAS];#endif struct list_head i_devices; /*设备文件形成的链表*/ union { struct pipe_inode_info *i_pipe; /*指向管道文件*/ struct block_device *i_bdev; /*指向块设备文件的指针*/ struct cdev *i_cdev; /*指向字符设备文件的指针*/ }; __u32 i_generation;#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* all events this inode cares about */ struct hlist_head i_fsnotify_marks;#endif#ifdef CONFIG_IMA atomic_t i_readcount; /* struct files open RO */#endif void *i_private; /* fs or device private pointer */}; inode 中几个比较重要的成员： i_uid：文件所属的用户 i_gid：文件所属的组 i_rdev：文件所在的设备号 i_size：文件的大小 i_atime：文件的最后访问时间 i_mtime：文件的最后修改时间 i_ctime：文件的创建时间 i_op：inode相关的操作列表 i_fop：文件相关的操作列表 i_sb：文件所在文件系统的超级块 重点说明i_op 和 i_fop 这两个成员： i_op 成员定义对目录相关的操作方法列表，譬如 mkdir()系统调用会触发 inode-&gt;i_op-&gt;mkdir() 方法，而 link() 系统调用会触发 inode-&gt;i_op-&gt;link() 方法。而 i_fop 成员则定义了对打开文件后对文件的操作方法列表，譬如 read() 系统调用会触发 inode-&gt;i_fop-&gt;read() 方法，而 write() 系统调用会触发 inode-&gt;i_fop-&gt;write() 方法 进一步说明： 每个文件都有一个inode，每个inode 有一个索引节点号i_ino。在同一个文件系统中，每个索引节点号都是唯一的，内核有时根据索引节点号的哈希值查找其inode结构。 每个文件都有个文件主，其最初的文件主是创建了这个文件的用户，但以后可以改变。每个用户都有一个用户组，且属于某个用户组，因此，inode 结构中就有相应的i_uid、i_gid，以指明文件主的身份。 inode 中有两个设备号，i_dev和i_rdev。首先，除特殊文件外，每个节点都存储在某个设备上，这就是i_dev。其次，如果索引节点所代表的并不是常规文件，而是某个设备，那就还得有个设备号，这就是i_rdev。 每当一个文件被访问时，系统都要在这个文件的inode 中记下时间标记，这就是inode中与时间相关的几个域。 属于“ 正在使用” 或“ 脏” 链表的索引节点对象也同时存放在一个称为inode_hashtable 链表中。 哈希表加快了对索引节点对象的搜索，前提是系统内核要知道索引节点号及对应文件所在文件系统的超级块对象的地址。 由于散列技术可能引发冲突，所以，索引节点对象设置一个i_hash 域，其中包含向前和向后的两个指针，分别指向散列到同一地址的前一个索引节点和后一个索引节点；该域由此创建了由这些索引节点组成的一个双向链表。 与索引节点关联的方法也叫索引节点操作，由inode_operations结构来描述，该结构的地址存放在i_op 域中，该结构也包括一个指向文件操作方法的指针。 目录项对象dentry 的定义在include/linux/dcache.h 中：目录项的主要作用是方便查找文件。一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象。 如，在路径 /home/liexusong/example.c 中，目录 /, home/, liexusong/ 和文件 example.c 都对应一个目录项对象。 不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，VFS 在遍历路径名的过程中现场将它们逐个地解析成目录项对象。 请注意，目录项对象在磁盘上并没有对应的镜像，因此在dentry结构中不包含指出该对象已被修改的字段。 目录项对象存放在名为dentry_cache的slab分配器高速缓存中。因此，目录项对象的创建和删除是通过调用kmem_cache_alloc()和kmem_cache_free()实现的。 每个目录项对象可以处于以下四种状态之一： 空闲状态（free）：处于该状态的目录项对象不包括有效的信息，而且还没有被VFS使用。对应的内存区由slab分配器进行处理。 未使用状态（unused）：处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器d_count的值为0，但其d_inode字段仍然指向关联的索引节点对象。该目录项对象包含有效的信息，但是为了在必要时回收内存，它的内容可能被丢弃。 正在使用状态（in use）：处于该状态的目录项对象当前正在被内核使用。该对象的引用计数器d_count的值为正数，其d_inode字段指向关联的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。 负状态(negative)：与目录项关联的索引节点不复存在，那是因为相应的磁盘索引节点已被删除，或者因为目录项对象是通过解析一个不存在文件的路径名创建的。目录项对象的d_inode字段被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。术语“负状态”容易使人误解，因为根本不涉及任何负值。 目录项的定义如下： 点击展开代码 >folded123456789101112131415161718192021222324252627282930struct dentry { /* RCU lookup touched fields */ unsigned int d_flags; /* protected by d_lock */ seqcount_t d_seq; /* per dentry seqlock */ struct hlist_bl_node d_hash; /* lookup hash list */ struct dentry *d_parent; /* parent directory */ struct qstr d_name; struct inode *d_inode; /* Where the name belongs to - NULL is * negative */ unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */ /* Ref lookup also touches following */ unsigned int d_count; /* protected by d_lock */ spinlock_t d_lock; /* per dentry lock */ const struct dentry_operations *d_op; //注意这个指针，指向响应的目录项的操作函数 struct super_block *d_sb; /* The root of the dentry tree */ unsigned long d_time; /* used by d_revalidate */ void *d_fsdata; /* fs-specific data */ struct list_head d_lru; /* LRU list */ /* * d_child and d_rcu can share memory */ union { struct list_head d_child; /* child of parent list */ struct rcu_head d_rcu; } d_u; struct list_head d_subdirs; /* our children */ struct hlist_node d_alias; /* inode alias list */}; 与目录项对象关联的方法称为目录项操作。这些方法由dentry_operations结构加以描述，该结构的地址存放在目录项对象的d_op字段中。尽管一些文件系统定义了它们自己的目录项方法，但是这些字段通常为NULL，而VFS使用缺省函数代替这些方法： 点击展开代码 >folded12345678910111213141516struct dentry_operations { int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, const struct inode *, struct qstr *); int (*d_compare)(const struct dentry *, const struct inode *, const struct dentry *, const struct inode *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); void (*d_release)(struct dentry *); void (*d_prune)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(struct dentry *, bool);} ____cacheline_aligned; 下面对dentry 结构给出进一步的解释。 dentry与inode的关系：一个有效的dentry 结构必定有一个inode 结构，这是因为一个目录项要么代表着一个文件，要么代表着一个目录，而目录实际上也是文件。所以，只要dentry 结构是有效的，则其指针d_inode 必定指向一个inode 结构。可是，反过来则不然，一个inode 却可能对应着不止一个dentry 结构；也就是说，一个文件可以有不止一个文件名或路径名。这是因为一个已经建立的文件可以被连接（link）到其他文件名。所以在inode 结构中有一个队列i_dentry，凡是代表着同一个文件的所有目录项都通过其dentry 结构中的d_alias 域挂入相应inode结构中的i_dentry 队列。 dentry_hashtable：在内核中有一个哈希表dentry_hashtable ，是一个list_head 的指针数组。一旦在内存中建立起一个目录节点的dentry 结构，该dentry 结构就通过其d_hash 域链入哈希表中的某个队列中。 dentry_unused队列：内核中还有一个队列dentry_unused，凡是已经没有用户（count 域为0）使用的dentry结构就通过其d_lru 域挂入这个队列。 dentry 结构中除了d_alias、d_hash、d_lru 三个队列外，还有d_vfsmnt、d_child 及d_subdir 三个队列。 其中d_vfsmnt 仅在该dentry 为一个安装点时才使用。 当该目录节点有父目录时，则其dentry 结构就通过d_child 挂入其父节点的d_subdirs 队列中，同时又通过指针d_parent 指向其父目录的dentry 结构，而它自己各个子目录的dentry 结构则挂在其d_subdirs 域指向的队列中。 从上面的叙述可以看出，一个文件系统中所有目录项结构或组织为一个哈希表，或组织为一颗树，或按照某种需要组织为一个链表，这将为文件访问和文件路径搜索奠定下良好的基础。 目录项高速缓存由于从磁盘读入一个目录项并构造相应的目录项对象需要花费大量时间，所以，在完成对目录项对象的操作后，可能后面还要使用它，因此仍在内存中保留它有重要的意义。 为了最大限度地提高处理这些目录项对象的效率，Linux使用目录项高速缓存，它由两种类型的数据结构组成： 一个处于正在使用，未使用或负状态的目录项对象的集合 一个散列表，从中能快速获取与给定的文件名和目录名对应的目录项对象。同样，如果访问的对象不再目录项高速缓存中，则散列函数返回一个空值。 目录项高速缓存的作用还相当于索引节点高速缓存（inode cache）的控制器。在内核内存中，并不丢弃与未用目录项相关的索引节点，这是由于目录项高速缓存仍在使用它们。因此，这些索引节点对象保存在RAM中，并且能够借助相应的目录项快速引用他们。 为了减少VFS层遍历文件路径的时间，内核将目录项对象缓存在目录项缓存（简称dcache）中。目录项缓存包括三个主要部分： “被使用的”目录项链表。 “未被使用的”双向链表。 散列表和相应的散列函数。 每个目录项对象可以处于四种状态（空闲状态，未使用状态，正在使用状态，负状态）。被使用和未被使用的目录项都对应一个有效的索引节点，而负状态的目录项没有对应的有效索引节点。所有“未使用”目录项对象都存放在一个“最近最少使用（Least Recently used，LRU）”的双向链表中，该链表按照插入的时间排序。 换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项对象总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得最近最常用的对象得以保存。 LRU链表的首元素和尾元素的地址存放在list_head类型的dentry_unused变量的next字段和prev字段中。目录项对象的d_lru字段包括指向链表中的相邻目录项的指针。 每个“正在使用”的目录项对象都被插入一个正在使用的双向链表中 该链表由相应索引节点对象的i_dentry字段所指向(由于每个索引节点可能与若干硬链接相关联，所以需要一个链表)。 目录项对象的d_alias字段存放链表中相邻元素的地址。这两个字段的类型都是struct list_head。 当指向相应文件的最后一个硬链接被删除后，一个“正在使用”的目录项对象可能变成负状态。在这种情况下，该目录项对象被移到“未使用”目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，“负状态”目录项对象就朝着LRU链表的尾部移动，这样一来，这些对象就逐渐被释放。 散列表是由dentry_hashtable数组实现的，方便虚拟文件系统vfs快速索引dentry。。 数组中每个元素是一个指向链表的指针，这种链表就是把具有相同散列表值的目录项进行散列而形成的。 该数组的长度取决于系统已经安装的RAM的数量，缺省值是每兆字节RAM包含256个元素。 散列函数的产生的值是由目录的目录项对象及其文件名计算出来的。 还有一个链表就是表示父子结构的链表。 与进程相关的文件结构先解释一下文件描述符、打开的文件描述、系统打开文件表、用户打开文件表的概念以及它们的联系 文件对象文件描述符(fd)：在Linux 中，进程是通过文件描述符（file descriptors，简称fd）而不是文件名来访问文件的，文件描述符实际上是一个整数。Linux 中规定每个进程最多能同时使用NR_OPEN个文件描述符(进程最大打开文件数限制sysctl_nr_open)，sysctl_nr_open值在include/linux/fs.h 中定义，为1024×1024（2.0 版中仅定义为256）。文件位置：每个文件都有一个32 位的数字来表示下一个读写的字节位置，这个数字叫做文件位置。 每次打开一个文件，除非明确要求，否则文件位置都被置为0，即文件的开始处，此后的读或写操作都将从文件的开始处执行，但你可以通过执行系统调用LSEEK（随机存储）对这个文件位置进行修改。 打开的文件描述（open file description）：Linux 中专门用了一个数据结构file 来保存打开文件的文件位置，这个结构称为打开的文件描述。这个数据结构的设置是煞费苦心的，因为它与进程的联系非常紧密，可以说这是VFS 中一个比较难于理解的数据结构。 首先，为什么不把文件位置干脆存放在索引节点中，而要多此一举，设一个新的数据结构呢？ 为了避免多个进程对同一个文件的lseek操作相互影响：我们知道，Linux 中的文件是能够共享的，假如把文件位置存放在索引节点中，则如果有两个或更多个进程同时打开同一个文件时，它们将去访问同一个索引节点，于是一个进程的LSEEK 操作将影响到另一个进程的读操作，这显然是不允许也是不可想象的。 既然进程是通过文件描述符访问文件的，为什么不用一个与文件描述符数组相平行的数组来保存每个打开文件的文件位置？ 尽管设置平行的数组保存每个打开文件的文件位置可以解决多个进程对一个文件操作的问题，但是无法解决子进程继续操作文件的问题。设置平行的数组这个想法也是不能实现的，原因就在于在生成一个新进程时，子进程要共享父进程的所有信息，包括文件描述符数组。 一个文件不仅可以被不同的进程分别打开，而且也可以被同一个进程先后多次打开。一个进程如果先后多次打开同一个文件，则每一次打开都要分配一个新的文件描述符，并且指向一个新的file 结构，尽管它们都指向同一个索引节点，但是，如果一个子进程不和父进程共享同一个file 结构，而是也如上面一样，分配一个新的file 结构，会出现什么情况了？让我们来看一个例子。 假设有一个输出重定位到某文件A 的shell script（shell 脚本），我们知道，shell是作为一个进程运行的，当它生成第1 个子进程时，将以0 作为A 的文件位置开始输出，假设输出了2KB 的数据，则现在文件位置为2KB。然后，shell 继续读取脚本，生成另一个子进程，它要共享shell 的file 结构，也就是共享文件位置，所以第2 个进程的文件位置是2KB，将接着第1 个进程输出内容的后面输出。如果shell 不和子进程共享文件位置，则第2 个进程就有可能重写第1 个进程的输出了，这显然不是希望得到的结果。 上面的讨论可以看出设置file 结构的原因。 file 结构中主要保存了文件位置，此外，还把指向该文件索引节点的指针也放在其中。系统打开文件表:file 结构形成一个双链表，称为系统打开文件表，其最大长度是NR_FILE，在fs.h 中定义为8192。file 结构在include/linux/fs.h 中定义如下,具体的解释可以去看《Linux内核设计与实现》： 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct file { /* * fu_list becomes invalid after file_free is called and queued via * fu_rcuhead for RCU freeing */ union { struct list_head fu_list; //文件对象链表 struct rcu_head fu_rcuhead; //释放之后的RCU链表 } f_u; struct path f_path; //包含目录项#define f_dentry f_path.dentry struct inode *f_inode; /* cached value */ const struct file_operations *f_op; // 文件的操作列表 /* * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR. * Must not be taken from IRQ context. */ spinlock_t f_lock; //单个文件结构锁#ifdef CONFIG_SMP int f_sb_list_cpu;#endif atomic_long_t f_count; // 计数器（表示有多少个用户打开此文件） unsigned int f_flags; // 标识位 fmode_t f_mode; // 打开模式 loff_t f_pos; // 读写偏移量 struct fown_struct f_owner; // 所属者信息，通过信号进行异步I/O 数据的传送 const struct cred *f_cred; //文件的信任状 struct file_ra_state f_ra;//预读状态 u64 f_version; //版本号#ifdef CONFIG_SECURITY void *f_security; //安全模块#endif /* needed for tty driver, and maybe others */ void *private_data; /* tty 驱动程序的钩子 */#ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; //事件池链表 struct list_head f_tfile_llink;#endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; //页缓存映射#ifdef CONFIG_DEBUG_WRITECOUNT unsigned long f_mnt_write_state; //调试状态#endif}; 类似于目录项对象，文件对象实际上没有对应的磁盘数据．所以在结构体中没有代表其对象是否为脏、是否需要写回磁盘的标志。文件对象通过f_dentry指针指向相关的目录项对象．目录项会指向相关的索引节点，索引节点会记录文件是否是脏的。 每个文件对象总是包含在下列的一个双向循环链表之中。 “未使用”文件对象的链表： 该链表既可以用做文件对象的内存高速缓存，又可以当作超级用户的备用存储器，也就是说，即使系统的动态内存用完，也允许超级用户打开文件。 由于这些对象是未使用的，它们的f_count 域是NULL，该链表首元素的地址存放在变量free_list 中，内核必须确认该链表总是至少包含NR_RESERVED_FILES 个对象，通常该值设为10。 “正在使用”文件对象的链表。 该链表中的每个元素至少由一个进程使用，因此，各个元素的f_count 域不会为NULL，该链表中第一个元素的地址存放在变量anon_list 中。 如果VFS 需要分配一个新的文件对象，就调用函数get_empty_filp( )。该函数检测“未使用”文件对象链表的元素个数是否多于NR_RESERVED_FILES，如果是，可以为新打开的文件使用其中的一个元素；如果没有，则退回到正常的内存分配。 每个文件系统都有其自己的文件操作集合,执行诸如读写文件这样的操作。 当内核将一个索引节点从磁盘装入内存的时候,就会把指向这些文件操作的指针存放在file_operations结构中，而该结构的地址存放在该索引节点的i_fop字段中。 当进程打开这个文件的时候，vfs就用存放在索引节点中的这个地址初始化新文件对象的f_op字段，使得对文件操作的后续调用能够使用这些函数。 如果需要，vfs随后也可以通过在f_op字段存放一个新值而修改文件操作的集合。 file的操作集合如下，代码在include/linux/fs.h 中： 点击展开代码 >folded123456789101112131415161718192021222324252627282930struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t); ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t); int (*readdir) (struct file *, void *, filldir_t); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); int (*show_fdinfo)(struct seq_file *m, struct file *f);}; 用户打开文件表每个进程用一个files_struct 结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表， 它是进程的私有数据。 files_struct 结构在include/linux/fdtable.h 中定义如下： 点击展开代码 >folded123456789101112131415161718192021222324252627struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; struct rcu_head rcu;};/* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; //结构的使用计数 struct fdtable __rcu *fdt; //指向其他fd表的指针 struct fdtable fdtab; //基fd表 /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; int next_fd; //缓存下一个可以使用的fd unsigned long close_on_exec_init[1]; //exec()时关闭的文件描述符链表 unsigned long open_fds_init[1]; //打开的文件描述符链表 struct file __rcu * fd_array[NR_OPEN_DEFAULT]; //缺省的文件对象数组，文件对象指针的初始化数组}; fd_array数组指针指向已经打开的文件对象。因为NR_OPEN_DEFAULT等于BITS_PER_LONG，在64位机器体系结构中这个宏的值为64，所以该数组可以容纳64个文件对象。如果一个进程打开的文件对象超过64个，内核将分配一个新数组，并将fdt指针指向它。所以对适当数量的文件对象的访问会执行的很快，因为它是对静态数组的操作；如果一个进程打开的文件数量过多，那么内核就需要建立新数组。所以如果系统中有大量的进程都要打开超过64 个文件，为了优化性能，管理员可以适当增NR_OPEN_DEFAULT 的预定义值． open_fds定义在include/linux/fdtable.h中， 关于文件系统信息的fs_struct 结构进程和文件的相互作用时，内核必须维护一些数据，其中就有进程的fs_struct 结构。每个进程描述符的fs字段就指向进程的fs_struct结构。 义在include/linux/fs_struct.h 中: 12345678struct fs_struct { int users; spinlock_t lock; seqcount_t seq; int umask; //umask 域由umask()系统调用使用，用于为新创建的文件设置初始文件许可权。 int in_exec; struct path root, pwd; //个人猜测 root 代表着本进程所在的根目录，pwd 指向进程当前所在的目录}; VFS数据结构间的关系超级块：对一个文件系统的描述；索引节点：对一个文件物理属性的描述；目录项：对一个文件逻辑属性的描述。文件与进程之间的关系是由另外的数据结构来描述的： 一个进程所处的位置是由fs_struct来描述的 一个进程（或用户）打开的文件是由files_struct来描述的 整个系统所打开的文件是由file结构来描述。 如图2给出了这些数据结构之间的关系： 图2. vfs数据结构之间的关系 图2来自链接 总结参考资料《深入分析Linux内核源代码》 //书籍内核版本有些旧《Linux内核设计与实现》 //目前感觉这个版本是最准的Linux 内核编程之文件系统（一）Linux文件编程之虚拟文件系统(VFS)Linux 内核编程之文件系统（二）VFS中的目录项对象和文件对象理解linux文件系统—VFS主要数据结构及之间的关系 //这里面的配图不错VFS中的基本数据结构虚拟文件系统文件系统– 虚拟文件系统相关数据结构","link":"/2020/08/12/Linux-VFS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Linux文件系统注册、安装与卸载","text":"概述 当内核被编译时，就已经确定了可以支持哪些文件系统，这些文件系统在系统引导时，在 VFS 中进行注册。如果文件系统是作为内核可装载的模块，则在实际安装时进行注册，并在模块卸载时注销。 VFS的初始化函数用来向VFS注册，即填写文件注册表file_system_type数据结构。每一个文件系统类型在注册表中有一个登记项，记录该文件系统的类型名、文件系统特性、指向对应的VFS超级块读取函数的地址及已注册项的链指针等。 函数register_filesystem()用于注册文件系统类型，函数unregister_filesystem()用于注销一个文件系统类型。 文件系统的注册VFS以链表的形式管理已经注册的文件系统。文件系统的注册有两种途径： 第一种是编译操作系统内核的时候确定了可以支持那性文件系统，在文件系统被引导是，在VFS中进行注册。 第二种是文件系统被当作可装载模块，通过insmod/rmmod命令在装入该文件系统模块时向VFS注册。 文件系统的初始化例程：每个文件系统都有一个初始化例程，它的作用就是在VFS中进行注册，即填写一个叫 file_system_type 的数据结构。 file_system_type数据结构 file_system_type结构包含了文件系统的名称以及一个指向对应的 VFS 超级块读取例程的地址。 所有已注册的文件系统的file_system_type 结构形成一个链表，为区别后面将要说到的已安装的文件系统形成的另一个链表，我们把这个链表称为注册链表。 这个注册链表是一个临界资源，受file_systems_lock 自旋读写锁的保护。 图1所示就是内核中的 file_system_type 链表，链表头由file_systems变量指定。图1仅示意性地说明系统中已安装的3个文件系统Ext2、proc、iso9660 其file_system_type 结构所形成的链表。 图1. 已注册的文件系统形成的链表.PNG file_system_type数据结构在include/linux/fs.h中定义如下： 1234567891011121314151617181920212223242526struct file_system_type { const char *name; // 文件系统的类型名，以字符串的形式出现 int fs_flags; //指明具体文件系统的一些特性。 /* public flags for file_system_type */ #define FS_REQUIRES_DEV 1 #define FS_BINARY_MOUNTDATA 2#define FS_HAS_SUBTYPE 4#define FS_USERNS_MOUNT 8 /* Can be mounted by userns root */#define FS_USERNS_DEV_MOUNT 16 /* A userns mount does not imply MNT_NODEV */#define FS_RENAME_DOES_D_MOVE 32768 /* FS will handle d_move() during rename() internally. */ struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); //删除超级块的方法 struct module *owner; struct file_system_type * next; //把所有的file_system_type 结构链接成单项链表的链接指针 struct hlist_head fs_supers; //具有相同文件系统类型的超级块对象链表的头 struct lock_class_key s_lock_key; struct lock_class_key s_umount_key; struct lock_class_key s_vfs_rename_key; struct lock_class_key s_writers_key[SB_FREEZE_LEVELS]; struct lock_class_key i_lock_key; struct lock_class_key i_mutex_key; struct lock_class_key i_mutex_dir_key;}; 说明： fs_flags字段存放几个标志，的说明如下： FS_REQUIRES_DEV：这种类型的任何文件系统必须位于物理磁盘设备上 FS_BINARY_MOUNTDATA：文件系统使用的二进制安装数据 一般的文件系统类型要求有物理的设备作为其物质基础，其fs_flags 中的FS_REQUIRES_DEV 标志位为1，这些文件系统如Ext2、Minix、ufs 等。 next：把所有的file_system_type 结构链接成单项链表的链接指针， 变量file_systems 指向这个链表。这个链表是一个临界资源，受file_systems_lock 自旋读写锁的保护。 owner：如果file_system_type 所代表的文件系统是通过可安装模块实现的，则该指针指向代表着具体模块的module 结构。如果文件系统是静态地链接到内核，则这个域为NULL。实际上，你只需要把这个域置为THIS_MODLUE （这是个一个宏），它就能自动地完成上述工作。 fs_supers：一个双向链表。链表中的元素是超级块结构。每个文件系统都有一个超级块，但有些文件系统可能被安装在不同的设备上，而且每个具体的设备都有一个超级块，这些超级块就形成一个双向链表。链表元素的向前和向后链接存放在超级块的s_instances字段中。 kill_sb字段指向删除超级块的函数。 register_filesystem()注册函数搞清楚这个数据结构的各个域以后， 就很容易理解下面的注册函数register_filesystem()，该函数定义于fs/filesystems.c： 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132/** * register_filesystem - register a new filesystem * @fs: the file system structure * * Adds the file system passed to the list of file systems the kernel * is aware of for mount and other syscalls. Returns 0 on success, * or a negative errno code on an error. * * The &amp;struct file_system_type that is passed is linked into the kernel * structures and must not be freed until the file system has been * unregistered. */ int register_filesystem(struct file_system_type * fs){ int res = 0; struct file_system_type ** p; BUG_ON(strchr(fs-&gt;name, '.')); if (fs-&gt;next) return -EBUSY; write_lock(&amp;file_systems_lock); //对该链表的查找加了写锁write_lock p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name)); if (*p) res = -EBUSY; else *p = fs; write_unlock(&amp;file_systems_lock); return res;}EXPORT_SYMBOL(register_filesystem); find_filesystem()函数在同一个文件中定义如下： 123456789static struct file_system_type **find_filesystem(const char *name, unsigned len){ struct file_system_type **p; for (p=&amp;file_systems; *p; p=&amp;(*p)-&gt;next) if (strlen((*p)-&gt;name) == len &amp;&amp; strncmp((*p)-&gt;name, name, len) == 0) break; return p;} 注意，对注册链表的操作必须互斥地进行，因此，对该链表的查找加了写锁write_lock。 unregister_filesystem()撤销注册文件系统注册后，还可以撤消这个注册，即从注册链表中删除一个file_system_type结构，此后系统不再支持该种文件系统。fs/filesystems.c中的unregister_filesystem()函数就是起这个作用的，它在执行成功后返回0，如果注册链表中本来就没有指定的要删除的结构，则返回-1，其代码如下： 12345678910111213141516171819202122232425262728293031323334/** * unregister_filesystem - unregister a file system * @fs: filesystem to unregister * * Remove a file system that was previously successfully registered * with the kernel. An error is returned if the file system is not found. * Zero is returned on a success. * * Once this function has returned the &amp;struct file_system_type structure * may be freed or reused. */ int unregister_filesystem(struct file_system_type * fs){ struct file_system_type ** tmp; write_lock(&amp;file_systems_lock); tmp = &amp;file_systems; while (*tmp) { if (fs == *tmp) { *tmp = fs-&gt;next; fs-&gt;next = NULL; write_unlock(&amp;file_systems_lock); synchronize_rcu(); return 0; } tmp = &amp;(*tmp)-&gt;next; } write_unlock(&amp;file_systems_lock); return -EINVAL;}EXPORT_SYMBOL(unregister_filesystem); 文件系统的安装 安装一个文件系统时，内核首先要检查参数的合法性，VFS通过查找由file_systems（file_system_type的首结点）指向的注册表，寻找匹配的file_system_type，就可获得读取文件系统超级块函数的地址，接着查找作为新文件系统安装点的VFS inode,VFS安装程序必须分配一个VFS超级块，然后读入安装文件系统的超级块，并进行填充，再申请一个vfsmount数据结构（其中包含了文件系统所在的块设备的标识、安装点及指向VFS超级块的指针等），使它的指针指向所分配的VFS超级块。当文件系统安装以后，它的根inode便常驻在inode高速缓存中。总的来说，安装过程的主要工作是：创建安装点对象、将其挂接到根文件系统的指定安装点下、初始化超级块对象从而获得文件系统的基本信息和相关的操作。 要使用一个文件系统，仅仅注册是不行的，还必须安装这个文件系统。 Linux使用系统的根文件系统(system's root filesystem)，它由内核在引导阶段直接安装，并拥有系统初始化脚本以及最基本的系统程序。在安装Linux 时，硬盘上已经有一个分区安装了ext3文件系统（也可能是其他种类的系统），它是作为根文件系统的，根文件系统在启动时自动安装。其实，在系统启动后你所看到的文件系统，都是在启动时安装的。 其他文件系统要么由初始化脚本安装，要么由用户直接安装在已安装文件系统的目录上。 作为一个目录树，每个文件系统都拥有自己的根目录(root directory)。安装文件系统的这个目录称之为安装点(mount point)。已安装文件系统属于安装点目录的一个子文件系统。 例如，/proc虚拟文件系统是系统的根文件系统的孩子(且系统的根文件系统是/proc的父亲)。 已安装文件系统的根目录隐藏了父文件系统的安装点目录原来的内容，而且父文件系统的整个子树位于安装点之下。 mount命令如果需要自己（一般是超级用户）安装文件系统，则需要指定3 种信息：文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点。 1mount -t ext3 /dev/sda5 /mnt ext3 就是文件系统的名称 /dev/sda5 是包含文件系统的物理块设备， /mnt 是将要安装到的目录，即安装点。 从这个例子可以看出，安装一个文件系统实际上是安装一个物理设备。 vfsmount数据结构把一个文件系统（或设备）安装到一个目录点时要用到的主要数据结构为vfsmount和struct mount，定义于include/linux/mount.h 中： 12345struct vfsmount { struct dentry *mnt_root; /* root of the mounted tree */ struct super_block *mnt_sb; /* pointer to superblock */ int mnt_flags;}; 说明： mnt_sb 指向所安装设备的超级块结构super_block。 文件系统的安装选项，也就是vfsmount 结构中的安装标志mnt_flags在include/uapi/linux/fs.h 中，定义如下： 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334/* * These are the fs-independent mount-flags: up to 32 flags are supported */#define MS_RDONLY 1 /* Mount read-only */#define MS_NOSUID 2 /* Ignore suid and sgid bits */#define MS_NODEV 4 /* Disallow access to device special files */#define MS_NOEXEC 8 /* Disallow program execution */#define MS_SYNCHRONOUS 16 /* Writes are synced at once */#define MS_REMOUNT 32 /* Alter flags of a mounted FS */#define MS_MANDLOCK 64 /* Allow mandatory locks on an FS */#define MS_DIRSYNC 128 /* Directory modifications are synchronous */#define MS_NOATIME 1024 /* Do not update access times. */#define MS_NODIRATIME 2048 /* Do not update directory access times */#define MS_BIND 4096#define MS_MOVE 8192#define MS_REC 16384#define MS_VERBOSE 32768 /* War is peace. Verbosity is silence. MS_VERBOSE is deprecated. */#define MS_SILENT 32768#define MS_POSIXACL (1&lt;&lt;16) /* VFS does not apply the umask */#define MS_UNBINDABLE (1&lt;&lt;17) /* change to unbindable */#define MS_PRIVATE (1&lt;&lt;18) /* change to private */#define MS_SLAVE (1&lt;&lt;19) /* change to slave */#define MS_SHARED (1&lt;&lt;20) /* change to shared */#define MS_RELATIME (1&lt;&lt;21) /* Update atime relative to mtime/ctime. */#define MS_KERNMOUNT (1&lt;&lt;22) /* this is a kern_mount call */#define MS_I_VERSION (1&lt;&lt;23) /* Update inode I_version field */#define MS_STRICTATIME (1&lt;&lt;24) /* Always perform atime updates *//* These sb flags are internal to the kernel */#define MS_NOSEC (1&lt;&lt;28)#define MS_BORN (1&lt;&lt;29)#define MS_ACTIVE (1&lt;&lt;30)#define MS_NOUSER (1&lt;&lt;31) 说明： 从定义可以看出，每个标志对应32 位中的一位。 安装标志是针对整个文件系统中的所有文件的。例如，如果MS_NOSUID 标志为1，则整个文件系统中所有可执行文件的suid 标志位都不起作用了。 struct mount结构struct mount结构在linux/fs/mount.h： 点击展开代码 >folded123456789101112131415161718192021222324252627282930313233struct mount { struct list_head mnt_hash; //安装点的哈希表 struct mount *mnt_parent; //是指向上一层安装点的指针 struct dentry *mnt_mountpoint; //指向安装点dentry 结构的指针 struct vfsmount mnt;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp;#else int mnt_count; int mnt_writers;#endif struct list_head mnt_mounts; /* list of children, anchored here */ struct list_head mnt_child; /* and going through their mnt_child */ struct list_head mnt_instance; /* mount instance on sb-&gt;s_mounts */ const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */ struct list_head mnt_list; struct list_head mnt_expire; /* link in fs-specific expiry list */ struct list_head mnt_share; /* circular list of shared mounts */ struct list_head mnt_slave_list;/* list of slave mounts */ struct list_head mnt_slave; /* slave list entry */ struct mount *mnt_master; /* slave is on master-&gt;mnt_slave_list */ struct mnt_namespace *mnt_ns; /* containing namespace */ struct mountpoint *mnt_mp; /* where is it mounted */#ifdef CONFIG_FSNOTIFY struct hlist_head mnt_fsnotify_marks; __u32 mnt_fsnotify_mask;#endif int mnt_id; /* mount identifier */ int mnt_group_id; /* peer group identifier */ int mnt_expiry_mark; /* true if marked for expiry */ int mnt_pinned; int mnt_ghosts;}; 说明： mnt_hash：为了对系统中的所有安装点进行快速查找，内核把它们按哈希表来组织，mnt_hash就是形成哈希表的队列指针。 mnt_mountpoint： 是指向安装点dentry 结构的指针。而dentry 指针指向安装点所在目录树中根目录的dentry 结构。？ mnt_parent： 是指向上一层安装点的指针。如果当前的安装点没有上一层安装点（如根设备），则这个指针为NULL。 同时，vfsmount 结构中还有mnt_mounts 和mnt_child 两个队列头 只要上一层vfsmount 结构存在，就把当前vfsmount 结构中mnt_child 链入上一层vfsmount 结构的mnt_mounts 队列中。这样就形成一个设备安装的树结构，从一个vfsmount结构的mnt_mounts 队列开始，可以找到所有直接或间接安装在这个安装点上的其他设备。 mnt_list：是指向vfsmount结构所形成链表的头指针。 另外，系统还定义了vfsmntlist 变量，指向mnt_list 队列。//在Linux kernel3.10 中没有vfsmntlist 安装根文件系统 每个文件系统都有它自己的根目录，如果某个文件系统（如Ext3）的根目录是系统目录树的根目录，那么该文件系统称为根文件系统。而其他文件系统可以安装在系统的目录树上，把这些文件系统要插入的那些目录就称为安装点。 当系统启动时，就要在变量ROOT_DEV 中寻找包含根文件系统的磁盘主码。 当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为/dev 目录下的一个设备文件。 类似地，根文件系统的安装标志存放在root_mountflags 变量中。用户可以指定这些标志，这是通过对已编译的内核映像执行/sbin/rdev 外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。 根文件系统的安装函数为mount_root()。 安装一个常规文件系统一旦在系统中安装了根文件系统，就可以安装其他的文件系统。每个文件系统都可以安装在系统目录树中的一个目录上。 安装文件系统的两个系统的两种方式： 以命令方式来安装文件系统，例如mount命令。 在用户程序中要安装一个文件系统则可以调用mount()系统调用。 sys_mount()函数mount()系统调用在内核的实现函数为sys_mount()，其函数定义使用SYSCALL_DEFINE定义，其代码在fs/namespace.c 中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*sys_mount系统调用*//* dev_name为待安装设备的路径名； dir_name为安装点的路径名； type是表示文件系统类型的字符串；*/SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name, char __user *, type, unsigned long, flags, void __user *, data){ int ret; char *kernel_type; struct filename *kernel_dir; char *kernel_dev; unsigned long data_page; ret = copy_mount_string(type, &amp;kernel_type); if (ret &lt; 0) goto out_type; kernel_dir = getname(dir_name); if (IS_ERR(kernel_dir)) { ret = PTR_ERR(kernel_dir); goto out_dir; } ret = copy_mount_string(dev_name, &amp;kernel_dev); if (ret &lt; 0) goto out_dev; ret = copy_mount_options(data, &amp;data_page); if (ret &lt; 0) goto out_data; ret = do_mount(kernel_dev, kernel_dir-&gt;name, kernel_type, flags, (void *) data_page); free_page(data_page);out_data: kfree(kernel_dev);out_dev: putname(kernel_dir);out_dir: kfree(kernel_type);out_type: return ret;} 说明： dev_name为待安装文件系统所在设备的路径名，如果不需要就为空（例如，当待安装的是基于网络的文件系统时）； dir_name 则是安装点（空闲目录）的路径名； type 是文件系统的类型，必须是已注册文件系统的字符串名（如“Ext3”） flags是安装模式，如前面所述。 data 指向一个与文件系统相关的数据结构（可以为NULL）。 copy_mount_options()和getname()函数将结构形式或字符串形式的参数值从用户空间拷贝到内核空间。 这些参数值的长度均以一个页面为限，但是getname()在复制时遇到字符串结尾符“\\0”就停止，并返回指向该字符串的指针； 而copy_mount_options()则拷贝整个页面，并返回该页面的起始地址。 该函数调用的主要函数为do_mount()，do_mount()执行期间要加内核锁，不过这个锁是针对SMP，我们暂不考虑。 do_mount()的实现代码在fs/namespace.c中： 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to * be given to the mount() call (ie: read-only, no-dev, no-suid etc). * * data is a (void *) that can point to any structure up to * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent * information (or be NULL). * * Pre-0.97 versions of mount() didn't have a flags word. * When the flags word was introduced its top half was required * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9. * Therefore, if this magic number is present, it carries no information * and must be discarded. */long do_mount(const char *dev_name, const char *dir_name, const char *type_page, unsigned long flags, void *data_page){ struct path path; int retval = 0; int mnt_flags = 0; /* Discard magic */ if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; /* Basic sanity checks */ if (!dir_name || !*dir_name || !memchr(dir_name, 0, PAGE_SIZE)) return -EINVAL; if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; /* ... and get the mountpoint */ retval = kern_path(dir_name, LOOKUP_FOLLOW, &amp;path); if (retval) return retval; retval = security_sb_mount(dev_name, &amp;path, type_page, flags, data_page); if (!retval &amp;&amp; !may_mount()) retval = -EPERM; if (retval) goto dput_out; /* Default to relatime unless overriden */ if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; /* Separate the per-mountpoint flags */ if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; flags &amp;= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN | MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT | MS_STRICTATIME); if (flags &amp; MS_REMOUNT) retval = do_remount(&amp;path, flags &amp; ~MS_REMOUNT, mnt_flags, data_page); else if (flags &amp; MS_BIND) retval = do_loopback(&amp;path, dev_name, flags &amp; MS_REC); else if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) retval = do_change_type(&amp;path, flags); else if (flags &amp; MS_MOVE) retval = do_move_mount(&amp;path, dev_name); else retval = do_new_mount(&amp;path, type_page, flags, mnt_flags, dev_name, data_page);dput_out: path_put(&amp;path); return retval;} 对函数中的主要代码给予说明: 对参数dir_name 和dev_name 进行基本检查，注意“！dir_name ” 和“!*dir_name”的不同，前者指指向字符串的指针为不为空，而后者指字符串不为空。memchr()函数在指定长度的字符串中寻找指定的字符，如果字符串中没有结尾符“\\0”，也是一种错误。前面已说过，对于基于网络的文件系统dev_name 可以为空。 把安装标志为MS_NOSUID、MS_NOEXEC 和MS_NODEV 的3个标志位从flags 分离出来，放在局部安装标志变量mnt_flags 中。 如果flags 中的MS_REMOUNT 标志位为1，就表示所要求的只是改变一个原已安装设备的安装方式，例如从“只读“安装方式改为“可写”安装方式，这是通过调用do_remount()函数完成的。 如果flags 中的MS_BIND 标志位为1，就表示把一个“回接”设备捆绑到另一个对象上。 回接设备是一种特殊的设备（虚拟设备），而实际上并不是一种真正设备，而是一种机制，这种机制提供了把回接设备回接到某个可访问的常规文件或块设备的手段。通常在/dev目录中有/dev/loop0 和/dev/loop1 两个回接设备文件。调用do_loopback()来实现回接设备的安装。 如果flags 中的MS_MOVE 标志位为1，就表示把一个已安装的设备可以移到另一个安装点，这是通过调用do_move_mount()函数来实现的。 如果不是以上3 种情况，那就是一般的安装请求，于是把安装点加入到目录树中，这是通过调用do_new_mount()函数来实现的，而do_new_mount()首先调用vfs_kern_mount函数形成一个安装点。do_new_mount()函数也调用了 do_new_mount()函数的代码在fs/namespace.c 中： 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * create a new mount for userspace and request it to be added into the * namespace's tree */static int do_new_mount(struct path *path, const char *fstype, int flags, int mnt_flags, const char *name, void *data){ struct file_system_type *type; struct user_namespace *user_ns = current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns; struct vfsmount *mnt; int err; if (!fstype) return -EINVAL; type = get_fs_type(fstype); if (!type) return -ENODEV; if (user_ns != &amp;init_user_ns) { if (!(type-&gt;fs_flags &amp; FS_USERNS_MOUNT)) { put_filesystem(type); return -EPERM; } /* Only in special cases allow devices from mounts * created outside the initial user namespace. */ if (!(type-&gt;fs_flags &amp; FS_USERNS_DEV_MOUNT)) { flags |= MS_NODEV; mnt_flags |= MNT_NODEV; } } mnt = vfs_kern_mount(type, flags, name, data); if (!IS_ERR(mnt) &amp;&amp; (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &amp;&amp; !mnt-&gt;mnt_sb-&gt;s_subtype) mnt = fs_set_subtype(mnt, fstype); put_filesystem(type); if (IS_ERR(mnt)) return PTR_ERR(mnt); err = do_add_mount(real_mount(mnt), path, mnt_flags); if (err) mntput(mnt); return err;} 对函数中的主要代码给予说明: 只有系统管理员才具有安装一个设备的权力，因此首先要检查当前进程是否具有这种权限。 get_fs_type()函数根据具体文件系统的类型名在file_system_file 链表中找到相应的结构。 vfs_kern_mount()函数代码在fs/namespace.c 中： 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data){ struct mount *mnt; struct dentry *root; if (!type) return ERR_PTR(-ENODEV); mnt = alloc_vfsmnt(name); if (!mnt) return ERR_PTR(-ENOMEM); if (flags &amp; MS_KERNMOUNT) mnt-&gt;mnt.mnt_flags = MNT_INTERNAL; root = mount_fs(type, flags, name, data); if (IS_ERR(root)) { free_vfsmnt(mnt); return ERR_CAST(root); } mnt-&gt;mnt.mnt_root = root; mnt-&gt;mnt.mnt_sb = root-&gt;d_sb; mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; br_write_lock(&amp;vfsmount_lock); list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;root-&gt;d_sb-&gt;s_mounts); br_write_unlock(&amp;vfsmount_lock); return &amp;mnt-&gt;mnt;}EXPORT_SYMBOL_GPL(vfs_kern_mount); alloc_vfsmnt（）函数调用slab 分配器给类型为vfsmount 结构的局部变量mnt 分配空间，并进行相应的初始化。 do_add_mount()函数代码，fs/namespace.c 中： 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243/* * add a mount into a namespace's mount tree */static int do_add_mount(struct mount *newmnt, struct path *path, int mnt_flags){ struct mountpoint *mp; struct mount *parent; int err; mnt_flags &amp;= ~(MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL); mp = lock_mount(path); if (IS_ERR(mp)) return PTR_ERR(mp); parent = real_mount(path-&gt;mnt); err = -EINVAL; if (unlikely(!check_mnt(parent))) { /* that's acceptable only for automounts done in private ns */ if (!(mnt_flags &amp; MNT_SHRINKABLE)) goto unlock; /* ... and for those we'd better have mountpoint still alive */ if (!parent-&gt;mnt_ns) goto unlock; } /* Refuse the same filesystem on the same mount point */ err = -EBUSY; if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) goto unlock; err = -EINVAL; if (S_ISLNK(newmnt-&gt;mnt.mnt_root-&gt;d_inode-&gt;i_mode)) goto unlock; newmnt-&gt;mnt.mnt_flags = mnt_flags; err = graft_tree(newmnt, parent, mp);unlock: unlock_mount(mp); return err;} 文件系统的卸载如果文件系统中的文件当前正在使用，该文件系统是不能被卸载的。如果文件系统中的文件或目录正在使用，则 VFS 索引节点高速缓存中可能包含相应的 VFS 索引节点。根据文件系统所在设备的标识符，检查在索引节点高速缓存中是否有来自该文件系统的 VFS 索引节点，如果有且使用计数大于0，则说明该文件系统正在被使用，因此，该文件系统不能被卸载。否则，查看对应的 VFS 超级块，如果该文件系统的 VFS 超级块标志为“脏”，则必须将超级块信息写回磁盘。上述过程结束之后，对应的 VFS 超级块被释放，vfsmount 数据结构将从vfsmntlist链表中断开并被释放。具体的实现代码为fs/super.c 中的sys_umount()函数。 参考资料《深入分析Linux内核源代码》 //书籍内核版本有些旧控制文件系统的安装和卸载文件系统的注册与注销、安装与卸载文件系统怎么让Linux内核认识自己mount系统调用初探 注解uapi文件夹：（the user space API of the kernel，Then upon kernel installation, the uapi include files become the top level /usr/include/linux/ files.）Linux Kernel 中新增的这些 uapi 头文件，其实都是来自于各个模块原先的头文件，最先是由 David Howells 提出来的。uapi 只是把内核用到的头文件和用户态用到的头文件分开。Linux的系统调用都改为SYSCALL_DEFINE定义,原因参照：Linux系统调用之SYSCALL_DEFINE。","link":"/2020/08/16/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%B3%A8%E5%86%8C%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"},{"title":"Linux-块设备驱动程序","text":"概述 Linux块设备处理程序的组织是相当复杂的，在此不可能详细介绍内核块设备I/O子系统中包含的所有函数我们主要说明下面几个问题： Linux块设备I/O子系统的体系结构是什么？ 块设备I/O子系统的主要组件有哪些？有哪些作用？ 打开一个块设备文件时内核执行的步骤有哪些？ 内核如何对块设备和块设备的请求进行管理？-&gt;这部分在内核中称为块I/O层 块设备与字符设备块设备:系统中能够随机（不需要按顺序）访问固定大小数据片（chunks）的设备被称作块设备，这些数据片就称作块。 最常见的块设备是硬盘，除此以外，还有软盘驱动器、CD-ROM驱动器和闪存等等许多其他块设备。 注意，它们都是以安装文件系统的方式使用的——这也是块设备的一般访问方式。 字符设备:另一种基本的设备类型是字符设备。 字符设备按照字符流的方式被有序访问，像串口和键盘就都属于字符设备。 如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；反过来，如果一个设备是随机（无序的）访问的，那么它就属于块设备。 两种类型的设备的根本区别在于它们是否可以被随机访问——也就是能否在访问设备时随意地从一个位置跳转到另一个位置。 为什么要使用专门的内核子系统来进行块设备的管理？对块设备的优化带来什么好处？ 内核管理块设备要比管理字符设备细致得多，需要考虑的问题和完成的工作相比字符设备来说要复杂许多。这是因为字符设备仅仅需要控制一个位置—当前位置—而块设备访问的位置必须能够在介质的不同区间前后移动。所以事实上内核不必提供一个专门的子系统来管理字符设备，但是对块设备的管理却必须要有一个专门的提供服务的子系统。不仅仅是因为块设备的复杂性远远高于字符设备， 更重要的原因是块设备对执行性能的要求很高；对硬盘每多一分利用都会对整个系统的性能带来提升，其效果要远远比键盘吞吐速度成倍的提高大得多。另外，我们将会看到，块设备的复杂性会为这种优化留下很大的施展空间。 块设备的扇区/内核的块扇区扇区是什么？ 块设备中最小的可寻址单元是扇区。扇区大小一般是2的整数倍，而最常见的是512字节。 扇区的大小是设备的物理属性 扇区是所有块设备的基本单元，块设备无法对比它还小的单元进行寻址和操作，不过许多块设备能够一次就传输多个扇区。 虽然大多数块设备的扇区大小都是512字节，不过其它大小的扇区也很常见， 比如，很多CD-ROM盘的扇区都是2K大小。 在Linux中，扇区大小按惯例都设为512字节；如果一个块设备使用更大的扇区，那么相应的底层设备驱动程序将做些必要的变换。 为什么提出扇区？扇区的作用是什么？ 为了达到可接受的性能，硬盘和类似的设备快速传送几个相邻字节的数据（也就是传递多个字节的数据会提高性能）。块设备的每次数据传送操作都作用于一组称为扇区的相邻字节。 尽管磁盘的物理构造很复杂，但是硬盘控制器接收到的命令将磁盘看成一大组扇区。应该把扇区作为数据传送的基本单元，不允许传送少于一个扇区的数据，大部分磁盘设备都可以同时传送几个相邻的扇区。 对存放在块设备中的一组数据是通过他们在磁盘上的位置来标识，即其首个512字节扇区的下标以及扇区的数目。扇区的下标存放在类型为sector_t的32位或64位的变量中。 块块： 虽然各种软件的用途不同，但是它们都会用到自己的最小逻辑可寻址单元—块。 块是文件系统的一种抽象，只能基于块来访问文件系统。虽然物理磁盘寻址是按照扇区来级进行的，但是内核执行的所有磁盘操作都是按照块进行的。 由于扇区是设备的最小可寻址单元，所以块不能比扇区还小，只能数倍于扇区大小。对有扇区的硬件设备，内核还要求块大小是2的整数倍，且不能超过一个页的长度。 对块大小的要求最终如下： 必须是扇区大小的2的整数倍，并且要小于页面大小（页框大小），所以通常块大小是512字节，1KB或者4KB 在80X86体系结构中，允许块的大小为512，1024，2048，4096字节。 块设备的块大小不是唯一的，创建一个磁盘文件系统时，管理员可以选择合适的块大小。因此，同一个磁盘上的几个分区可能使用不同的块大小。 此外，对块设备文件的每次读或写操作是一种“原始”访问，因为他绕过了磁盘文件系统；内核通过使用最大的块（4096字节）执行该操作。 块缓冲区：每个块都需要自己的块缓冲区，它是内核用来存放块内容的RAM空间。 当内核从磁盘读出一个块时，就用从硬件设备中所获得的数据来填充相应的缓冲区；同样，当内核向磁盘中写入一个块时，就用相关块缓冲区的数据来更新硬件设备上相应的一组相邻字节。 块缓冲区的大小通常要与相应块的大小相匹配。 缓冲区首部是一个与每个缓冲区相关的buffer_head类型的描述符。它包含内核处理缓冲区需要了解的所有信息；因此，在对每个缓冲区进行操作之前，内核都要首先检查其缓冲区首部；因此，在对每个缓冲区进行操作之前，内核都要首先检查其缓冲区首部。 扇区与块的关系图1是扇区与块之间的关系图： 图1. 扇区与块之间的关系 扇区和块的别称： 扇区：设备的最小寻址单元，或称为“硬扇区”“设备块”。 块：文件系统的最小寻址单元，或称为“文件块”“I/O块”。 扇区和块的区别： 扇区是硬件设备传送数据的基本单位，而块是VFS和文件系统传送数据的基本单位。 例如：内核访问一个文件的内容时，它必须首先从磁盘上读文件的磁盘索引节点所在的块。该块对应磁盘上一个或多个相邻的扇区，而VFS将其看成是一个单一的数据单元。 扇区这一个概念之所以对内核重要，是因为所有设备的I/O必须以扇区为单位进行操作，内核所使用的“块”这一个高级概念就是建立在扇区之上的。 深入理解linux 块设备的处理在本节我们来说明一下Linux块设备I/O子系统的体系结构。块设备驱动程序上的每个操作都涉及很多内核组件，其中最重要的一些如图2所示： 图2. 块设备操作涉及的内核组件 例如，我们假设一个进程在某个磁盘文件上发出一个read()系统调用（write()系统调用本质上采用同样的方式）。下面是内核对进程请求给予回应的一般步骤： read()系统调用的服务例程调用一个适当的函数，将文件描述符和文件内的偏移量传递给它。虚拟文件系统位于块设备处理体系结构的上层，他提供一个通用的文件模型，Linux支持的所有文件系统均采用该模型。 VFS函数确定所请求的数据是否存在，比如文件指针的位置的合法性等，如果有必要的话，它决定如何执行read操作（但均通过具体的文件系统提供的文件操作来执行）。有时候没有必要访问磁盘上的数据，因为内核将大多数最近从块设备读出或写入其中的数据保存在RAM中，及通过磁盘高速缓存来获得数据。 我们假设内核从块设备读数据，那么它就必须确定数据的物理位置。为了做到这点，内核依赖映射层（mapping layer），主要执行下面两步： 3.1. 内核确定该文件所在文件系统的块大小，并根据文件块的大小计算所请求数据的长度。本质上，文件被看作许多数据块的集合，因此内核确定请求数据所在的块号（文件开始位置的块索引）。 3.2. 接下来，映射层调用一个具体文件系统的函数，它访问文件的磁盘索引节点，然后根据逻辑块号确定所请求数据在磁盘上的位置。事实上，磁盘也被看作数据块的数组，因此内核必须确定存放所请求数据的块对应的号（磁盘或分区开始位置的相对索引）。由于一个文件可能存储在磁盘上的不连续块中，因此存放在磁盘索引节点中的数据结构将每个文件块号映射为一个逻辑块号。 3.3. 如果是从原始设备文件进行读访问，映射层就不调用具体文件系统的方法，而是把块设备文件中的偏移量转换成在磁盘或者在对应该设备文件的磁盘分区中的位置。 现在内核可以对块设备发出读请求。内核利用通用块层（generic block layer）启动I/O操作来传送所请求的数据。一般而言，每个I/O操作只针对磁盘上一组连续的块。由于请求的数据不必位于相邻的块中，所以通用块层可能启动几次I/O操作。每次I/O操作是由一个“块I/O”（简称“bio”）结构描述，它收集底层组件需要的所有信息以满足所发出的请求。通用块层为所有的块设备提供了一个抽象视图，因而隐藏了硬件块设备间的差异性。几乎所有的块设备都是磁盘。 通用块层下面的“I/O调度程序”根据预先定义的内核策略将待处理的I/O数据传送请求归类。调度程序的作用是把物理介质上相邻的数据请求聚集在一起。 最后块设备驱动程序向磁盘控制器的硬件接口发送适当的命令，从而进行实际的数据传送。 块设备内核组件管理数据的方式块设备中的数据存储涉及到了许多内核组件，每个组件采用不同长度的块来管理磁盘数据： 硬件块设备控制器采用称为“扇区”的固定长度的块来传送数据。因此，I/O调度程序和块设备驱动程序必须管理数据扇区。 虚拟文件系统、映射层和具体文件系统将磁盘数据存放在成为“块”的逻辑单元中。一个块对应文件系统中一个最小的磁盘存储单元。 “段”: 块设备驱动程序应该能够处理数据的“段”。一个段就是一个内存页或内存页的一部分，它们包含磁盘上物理相邻的数据块。 磁盘高速缓存作用于磁盘数据的“页”上，每页正好装在一个页框中。 通用块层将所有的上层和下层的组件组合在一起，因此它了解数据的扇区、块、段以及页。即使有许多不同的数据块，它们通常也是共享相同的物理RAM单元。 管理数据方式示例例如，图3显示了一个具有4KB字节的页的构造。上层内核组件将页看成是4个1024字节组成的块缓冲区。块设备驱动程序正在传送页中的后三个块，因此这3块被插入到涵盖了后3072字节的段中。硬盘控制器将该段看成是由6个512字节的扇区组成。 图3. 包含磁盘数据的页的典型构造 段 磁盘的每个I/O操作的实质是在磁盘与一些RAM单元之间相互传送一些相邻扇区的内容。 大多数情况下，磁盘控制器直接采用DMA方式进行数据传送。 DMA方式的特点是，磁盘控制器就像一个外置CPU一样，块设备驱动程序只要向磁盘控制器发送一些适当的命令就可以触发一次数据传送；一旦完成数据的传送，控制器就会发出一个中断通知块设备驱动程序。 DMA方式传送的是磁盘上相邻扇区的数据。这是一个物理约束：磁盘控制器允许DMA传送不相邻的扇区数据，但是这种方式的传送速率很低，因为在磁盘表面上移动读/写磁头是相当慢的。 老式的磁盘控制器仅仅支持“简单的”DMA传送方式：在这种传送方式中，磁盘必须与RAM中的连续内存单元相互传送数据。但是，新的磁盘控制器，也就是我们即将讲到的SCSI磁盘控制器，支持所谓的分散-聚集（scatter-gather）DMA传送方式。此种方式中，磁盘可以与一些非连续的内存区相互传送数据。启动一次分散-聚集DMA传送，块设备驱动程序需要向磁盘控制器发送： 要传送的起始磁盘扇区号和总的扇区数（要传的数据位置） 内存区的描述符链表，其中链表的每项包含一个地址和一个长度（需要传送到的位置） 磁盘控制器则负责整个数据传送，例如： 在读操作中控制器从相邻磁盘扇区中获得数据，然后将它们存放到不同的内存区中。 为了使用分散-聚集DMA传送方式，块设备驱动程序必须能够处理称为段的数据存储元。 一个段就是一个内存页或内存页中的一部分，它们包含一些相邻磁盘扇区中的数据。 因此，一次分散-聚集DMA操作可能同时传送几个段。 注意，块设备驱动程序不需要知道块、块大小以及块缓冲区。因此，即使高层将段看成是由几个块缓冲区组成的页，块设备驱动程序也不用对此给予关注。 如果，不同的段在RAM中相应的页框正好是连续的并且在磁盘上相应的数据块也是相邻的，那么通用块层可以合并它们。通过这种合并方式产生的更大的内存区就称为物理段。然而，在多种体系结构上还允许使用另一个合并方式：通过使用一个专门的总线电路来处理总线地址与物理地址间的映射。通过这种合并方式产生的内存区称为硬件段。由于我们将注意力集中在80 x 86体系结构上，它在总线地址和物理地址之间不存在动态的映射，因此在本章剩余部分我们假定硬件段总是对应物理段。 缓冲区与缓冲区头当一个块被调入内存时（也就是，在读入后或者等待写出的时候），它要存储在一个缓冲区中。每个缓冲区和一个块对应，它相当于磁盘块在内存中的表示。一个块小于一个页，所以一页可以容纳一个或多个内存中的块。 由于内核在处理数据时需要一些相关的控制信息，每个缓冲区都有一个对应的描述符。该描述符buffer_head结构体表示，被称作缓冲区头，它包含了内核操作缓冲区所需的全部信息： buffer_head结构体buffer_head结构体在include/linux/buffer_head.h中定义： 12345678910111213141516171819202122232425/* * Historically, a buffer_head was used to map a single block * within a page, and of course as the unit of I/O through the * filesystem and block layers. Nowadays the basic I/O unit * is the bio, and buffer_heads are used for extracting block * mappings (via a get_block_t call), for tracking state within * a page (via a page_mapping) and for wrapping bio submission * for backward compatibility reasons (e.g. submit_bh). */struct buffer_head { unsigned long b_state; //缓冲区状态标志 /* buffer state bitmap (see above) */ struct buffer_head *b_this_page; //页面中的缓冲区 /* circular list of page's buffers */ struct page *b_page; //存储缓冲区的页面 /* the page this bh is mapped to */ sector_t b_blocknr; //起始块号 /* start block number */ size_t b_size; //映像的大小 /* size of mapping */ char *b_data; //页面内的数据指针 /* pointer to data within the page */ struct block_device *b_bdev; //相关联的块设备 bh_end_io_t *b_end_io;//I/O完成方法 /* I/O completion */ void *b_private; /* reserved for b_end_io */ struct list_head b_assoc_buffers; /*相关的映射链表 associated with another mapping */ struct address_space *b_assoc_map; /*相关的地址空间 mapping this buffer is associated with */ atomic_t b_count; /*缓冲区使用计数 users using this buffer_head */}; 说明： b_count域表示缓冲区的使用记数，可通过两个定义在文件include/linux/buffer_head.h中的内联函数对此域进行增减。 点击展开对b_count域进行增减的内联函数 >folded12345678910static inline void get_bh(struct buffer_head *bh){ atomic_inc(&amp;bh-&gt;b_count);}static inline void put_bh(struct buffer_head *bh){ smp_mb__before_atomic_dec(); atomic_dec(&amp;bh-&gt;b_count);} 在操作缓冲区头之前，应该先使用get_bh()函数增加缓冲区头的引用计数，确保该缓冲区头不会再被分配出去；当完成对缓冲区头的操作之后，还必须使用put_bh()函数减少引用计数。 b_blocknr域：与缓冲区对应的磁盘物理块由b_blocknr域索引，该值是b_bdev域指明的块设备中的逻辑块号。 与缓冲区对应的内存物理页由b_page域表示，另外，b_data域直接指向相应的块（它位于b_page域所指明的页面中的某个位置上），块的大小由b_size域表示，所以块在内存中的起始位置在b_data处，结束位置在(b_data + b_size)处。 b_state域表示缓冲区状态标志，可以是下表中一种或者多种标志的组合。合法的标志存放在bh_state_bits枚举中，在include/linux/buffer_head.h中定义 点击展开bh_state_bits枚举列表 >folded12345678910111213141516171819202122232425enum bh_state_bits { BH_Uptodate, /* 该缓冲区包含可用数据Contains valid data */ BH_Dirty, /* 该缓冲区是脏的，缓冲区的内容比磁盘中的块内容要新，所以缓冲区的内容必须被写回磁盘Is dirty */ BH_Lock, /* 该缓冲区正在被I/O操作访问，被锁定以防止并发访问Is locked */ BH_Req, /* 该缓冲区有I/O请求操作Has been submitted for I/O */ BH_Uptodate_Lock,/* Used by the first bh in a page, to serialise * IO completion of other buffers in the page */ BH_Mapped, /* 该缓冲区是映射磁盘块的可用缓冲区Has a disk mapping */ BH_New, /* 缓冲区是通过get_block()刚刚映射的，尚且不能访问Disk mapping was newly created by get_block */ BH_Async_Read, /*该缓冲区正通过end_buffer_async_read()被异步I/O读操作使用 Is under end_buffer_async_read I/O */ BH_Async_Write, /*该缓冲区正通过end_buffer_async_write()被异步写操作使用 Is under end_buffer_async_write I/O */ BH_Delay, /* 该缓冲区尚未与磁盘块关联Buffer is not yet allocated on disk */ BH_Boundary, /* 该缓冲区片于连续块区的边界，下一个块不再连续 Block is followed by a discontiguity */ BH_Write_EIO, /* 该缓冲区在写的时候遇到I/O错误 I/O error on write */ BH_Unwritten, /* 该缓冲区在硬盘上的空间已经被申请但是没有实际数据写出Buffer is allocated on disk but not written */ BH_Quiet, /* 该缓冲区禁止错误Buffer Error Prinks to be quiet */ BH_Meta, /* Buffer contains metadata */ BH_Prio, /* Buffer should be submitted with REQ_PRIO */ BH_PrivateStart,/* not a state bit, but the first bit available * for private allocation by other entities */}; 说明： BH_PrivateStart：bh_state_bits列表还包含了一个特殊标志——BH_PrivateStart，该标志不是可用状态标志，使用它是为了指明可被其他代码使用的起始位。块I/O层不会使用BH_PrivateStart或更高的位。那么某个驱动程序希望通过b_state域存储信息时就可以安全地使用这些位。驱动程序可以在这些位中定义自己的状态标志，只要保证自定义的状态标志不与块I/O层的专用位发生冲突就可以了。 块缓冲区头、块缓冲区以及页框的关系每个块缓冲区都对应一个块缓冲区头buffer_head，二者的关系类似于物理页框和物理页框描述符，前者用来存储数据，后者是对前者的属性以及控制信息的描述。块缓冲区头、块缓冲区以及页框的关系如下： 图4. 块缓冲区头、块缓冲区以及页框的关系 总结一下: 缓冲区:磁盘块在物理内存中的表示形式 缓冲区描述符:对缓冲区的相关信息的描述，描述了缓冲区与磁盘块的映射关系 缓冲区头的目的在于描述磁盘块和物理内存缓冲区（在特定页面上的字节序列）之间的映射关系。这个结构体在内核中只扮演一个描述符的角色，说明从缓冲区到块的映射关系。 通用块层通用块层是一个内核组件，它处理来自系统中的所有对块设备发出的请求。由于该层所提供的函数，内核可以容易的做到： 将数据缓冲区放在高端内存——仅当CPU访问其数据时，才将页框映射为内核中的线性地址空间，并在数据访问完后取消映射。 通过一些附加额手段，实现一个所谓的“零-复制”模式，将磁盘数据直接存放在用户态地址空间而不是首先复制到内核内存区； 事实上，内核为I/O数据传送使用的缓冲区所在的页框就映射在进程的用户态线性地址空间中。 管理逻辑卷，例如有LVM(逻辑卷管理)和RAID（磁盘冗余阵列）使用的逻辑卷：几个磁盘分区，即使位于不同的磁盘中，也可以被看做是一个单一的分区。 发挥大部分新磁盘控制器的高级特性，例如大主板磁盘高速缓存，增强的DMA性能，I/O传送请求的相关调度等。 深入理解linux bio结构体通用块层的核心数据结构是一个称为bio的描述符，它描述了块设备的I/O操作。目前内核中块I/O操作的基本容器由bio结构体表示。在更上层的具体的文件系统的读写操作方法中，构造bio结构，并通过通用块层来提交各块设备驱动程序来进行实际的数据传输。 它定义在文件include/linux/blk_types.h中: 该结构体代表了正在活动的以段(segment)链表形式组织的块I/O操作。一个段是一小块连续的内存缓冲区。这样,单个缓冲区就不一定要连续。所以使用段来描述缓冲区,即使一个缓冲区分散在内存的多个位置上,bio结构体也能对内核保证I/O操作的执行。这样的向量I/O称为分散-聚合I/O。 每个bio结构都包含一个磁盘存储区表示符（存储区中的起始扇区号和扇区数目）和一个或多个描述与I/O操作相关的内存区的段。 bio结构定义如下： 点击展开bio结构体 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* struct bio, bio_vec and BIO_* flags are defined in blk_types.h *//* * main unit of I/O for the block layer and lower layers (ie drivers and * stacking drivers) */struct bio { sector_t bi_sector; /* 磁盘上相关的扇区,块I/O操作的第一个扇区 device address in 512 byte sectors */ struct bio *bi_next; /* 请求链表，链接到请求队列中的下一个bio request queue link */ struct block_device *bi_bdev; //指向块设备描述符的指针 unsigned long bi_flags; /* 状态和命令标志status, command, etc */ unsigned long bi_rw; /* 读还是写,I/O操作标志 bottom bits READ/WRITE, * top bits priority */ unsigned short bi_vcnt; /* bio的biovec数组中段的数目，bio_vec的偏移个数 how many bio_vec's */ unsigned short bi_idx; /* bio的biovec数组中段的当前索引值 current index into bvl_vec */ /* Number of segments in this BIO after * physical address coalescing is performed. */ unsigned int bi_phys_segments; //合并之后的硬件段数目 unsigned int bi_size; /* I/O计数 residual I/O count */ /* * To keep track of the max segment size, we account for the * sizes of the first and last mergeable segments in this bio. */ unsigned int bi_seg_front_size; //第一个可合并段的大小，硬件段合并算法使用 unsigned int bi_seg_back_size; //最后一个可合并段的大小，硬件段合并算法使用 bio_end_io_t *bi_end_io; //bio的I/O操作结束时调用的方法 void *bi_private; //拥有者的私有方法。通用块层和块设备驱动程序的I/O完成方法所使用的指针#ifdef CONFIG_BLK_CGROUP /* * Optional ioc and css associated with this bio. Put on bio * release. Read comment on top of bio_associate_current(). */ struct io_context *bi_ioc; struct cgroup_subsys_state *bi_css;#endif#if defined(CONFIG_BLK_DEV_INTEGRITY) struct bio_integrity_payload *bi_integrity; /* data integrity */#endif /* * Everything starting with bi_max_vecs will be preserved by bio_reset() */ unsigned int bi_max_vecs; /* bio中的bio_vec数组中允许的最大段数 max bvl_vecs we can hold */ atomic_t bi_cnt; /* bio的引用计数器 pin count */ struct bio_vec *bi_io_vec; /* 指向bio中的bio_vec数组中段的指针 the actual vec list */ struct bio_set *bi_pool; /* * We can inline a number of vecs at the end of the bio, to avoid * double allocations for a small number of bio_vecs. This member * MUST obviously be kept at the very end of the bio. */ struct bio_vec bi_inline_vecs[0]; //内嵌bio向量}; 说明： bio结构体描述的都只是元数据部分，实际数据都包含在紧跟其后的 bio_vec结构体 中。bio中的每一个段是由bio_vec结构体描述的 bio结构体中的bi_io_vec字段指向bio_vec数据结构的第一个元素，bi_vcnt则存放了bio_vec数据结构数组中当前元素的个数。 bi_private域，这是一个属于拥有者（创建者）的私有域，只有创建了bio结构的拥有者可以读写该域。bio结构体中的主要成员变量都是用来管理I/O操作执行的相关信息的,其中最重要的几个成员变量是bi_io_vec、bi_vcnt和bi_idx。下图显示了bio结构体及相关结构体之间的关系： 图5. bio结构体及bio_vec, bi_vcnt和bi_idx之间的关系 说明： 在每个给定的块I/O操作中，bi_vcnt域用来描述bi_io_vec所指向的vio_vec数组中的向量数目。当块I/O操作执行完毕后,bi_idx域指向数组的当前索引。 在块I/O操作期间bio描述符的内容一直保持更新。例如，如果块设备驱动程序在一次分散-聚集DMA操作中不能完成全部的数据传送，那么bio中的bi_idx字段会不断更新来指向待传送的第一个段。为了从索引bi_idx指向的当前段开始不断遍历bio中的段，设备驱动程可以执行宏bio_for_each_segment(). 当通用块层启动一次新的I/O操作时，调用bio_alloc()函数分配一个新的bio结构。内核使用fs_bio_set结构类型来管理bio结构相关内存分配的缓冲区，这个结构由几个用于引用内存池或slab缓冲的指针组成。fs_bio_set中的一个成员bio_pool用于引用分配bio结构的内存池，而在这个缓冲区中分配的内存块的单位并不是sizeof(struct bio)，而是sizeof(struct bio) + BIO_INLINE_VECS* sizeof(struct bio_vec)个字节。在分配了bio结构之后，通常要为bio分配bio_vec结构，当bio_vec结构数小于BIO_INLINE_VECS时则可以通过bio结构的最后一个成员bi_inline_vecs来引用这些bio_vec结构。 内核同时创建了6个slab缓冲区用于分配数量不等的bio_vec结构，当所需的bio_vec结构数大于BIO_INLINE_VECS，则从这些缓冲区中分配内存。 I/O 向量bi_io_vec域指向一个bio_vec结构体数组，该结构体链表包含一个特定I/O操作所需要使用的所有片段。 每个bio_vec结构都是一个形式为&lt;page, offset, len&gt;的向量，它描述的是一个特定的片段。段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度。 整个bio_vec结构体数组表示一个完整的缓冲区。bio_vec结构定义在include/linux/blk_types.h 12345678/* * was unsigned short, but we might as well be ready for &gt; 64kB I/O pages */struct bio_vec { struct page *bv_page; //指向这个缓冲区所驻留的物理页。指向段的页框中页描述符的指针 unsigned int bv_len; //这个缓冲区以字节为单位的大小。段的字节长度 unsigned int bv_offset; //缓冲区所驻留的页以字节为单位的偏移量，页框中段数据的偏移量。}; 总而言之，每一个块IO请求都通过一个bio结构体表示。 每个请求包括一个或多个块，这些块存储在bio_vec结构体数组中。 这些结构体描述了每个片段在物理页中的实际位置，并且像向量一样被组织在一起。 IO操作的第一个片段由bio_io_vecs指针所指向，其他的片段在其后一次防止，共有bi_vcnt个片段。 当块IO层开始执行请求、需要使用各个片段时，bi_idx域会不断更新，指向当前片段。 块IO层通过bi_idx可以跟踪IO操作的完成进度。但该域更重要的作用在于分割bio结构体。 bi_cnt域记录bio结构体的使用计数，如果为0就销毁该结构体，并释放内存。通过下面的函数管理使用计数： bio_put()代码在fs/bio.c： 点击展开bio_put()代码 >folded12345678910111213141516171819/** * bio_put - release a reference to a bio * @bio: bio to release reference to * * Description: * Put a reference to a &amp;struct bio, either one you have gotten with * bio_alloc, bio_get or bio_clone. The last put of a bio will free it. **/void bio_put(struct bio *bio){ BIO_BUG_ON(!atomic_read(&amp;bio-&gt;bi_cnt)); /* * last put frees it */ if (atomic_dec_and_test(&amp;bio-&gt;bi_cnt)) bio_free(bio);}EXPORT_SYMBOL(bio_put); bio_get()代码在include/linux/bio.h： 点击展开bio_get()代码 >folded123456789101112131415/* * get a reference to a bio, so it won't disappear. the intended use is * something like: * * bio_get(bio); * submit_bio(rw, bio); * if (bio-&gt;bi_flags ...) * do_something * bio_put(bio); * * without the bio_get(), it could potentially complete I/O before submit_bio * returns. and then bio would be freed memory when if (bio-&gt;bi_flags ...) * runs */#define bio_get(bio) atomic_inc(&amp;(bio)-&gt;bi_cnt) 前者增加使用计数，后者减少使用计数（如果为0就销毁该结构体，并释放内存）在操作正在活动的bio结构体时，一定要首先增加它的使用计数，以免在操作过程中该bio结构体被释放。 缓冲区头与bio结构体方法对比缓冲区头和新的bio结构体之间存在显著差别： bio结构体代表的是I/O操作，它可以包括内存中的一个或多个页。由于bio结构体是轻量级的，它描述的块可以不需要连续的存储区，并且不需要分隔I/O操作。 buffer_head结构体代表的是一个缓冲区，它描述的仅仅是磁盘中的一个块。因为缓冲区头关联的是单独页中的单独磁盘块，所以它可能会引起不必要的分隔，将请求按块为单位划分，只能靠以后再重新组合。 利用bio代替buffer_head好处有： 不需要连续存储区，也不需要分割I/O操作 bio很容易处理高端内存，因为它处理的是物理页而不是直接指针 bio既可以代表普通页，也可以代表直接I/O bio便于执行分散——集中(矢量化)块I/O操作，操作中的数据可以来自多个物理页 bio相比缓冲区头属于轻量级结构体。因为它只需要包含块I/O操作所需的信息就行了，不用包含与缓冲区本身相关的不必要信息。 但是还是需要缓冲区头这个概念，毕竟它还负责描述磁盘块到页面的映射。bio结构体不包含任何和缓冲区相关的状态信息——它仅仅是一个矢量数组，描述一个或多个单独块I/O操作的数据片段和相关信息。在当前设置中，当bio结构体描述当前正在使用的I/O操作时，buffer_head结构体仍然需要包含缓冲区信息。内核通过这两种结构分别保存各自的信息，可以保证每种结构所含的信息量尽可能少。 请求队列块设备将它们挂起的块I/O请求保存在请求队列中，该队列由request_queue结构体表示，定义在文件linux/blkdev.h中，包含一个双向请求链表以及相关控制信息。 点击展开request_queue结构体代码 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161struct request_queue { /* * Together with queue_head for cacheline sharing */ struct list_head queue_head; struct request *last_merge; struct elevator_queue *elevator; int nr_rqs[2]; /* # allocated [a]sync rqs */ int nr_rqs_elvpriv; /* # allocated rqs w/ elvpriv */ /* * If blkcg is not used, @q-&gt;root_rl serves all requests. If blkcg * is used, root blkg allocates from @q-&gt;root_rl and all other * blkgs from their own blkg-&gt;rl. Which one to use should be * determined using bio_request_list(). */ struct request_list root_rl; request_fn_proc *request_fn; make_request_fn *make_request_fn; prep_rq_fn *prep_rq_fn; unprep_rq_fn *unprep_rq_fn; merge_bvec_fn *merge_bvec_fn; softirq_done_fn *softirq_done_fn; rq_timed_out_fn *rq_timed_out_fn; dma_drain_needed_fn *dma_drain_needed; lld_busy_fn *lld_busy_fn; /* * Dispatch queue sorting */ sector_t end_sector; struct request *boundary_rq; /* * Delayed queue handling */ struct delayed_work delay_work; struct backing_dev_info backing_dev_info; /* * The queue owner gets to use this for whatever they like. * ll_rw_blk doesn't touch it. */ void *queuedata; /* * various queue flags, see QUEUE_* below */ unsigned long queue_flags; /* * ida allocated id for this queue. Used to index queues from * ioctx. */ int id; /* * queue needs bounce pages for pages above this limit */ gfp_t bounce_gfp; /* * protects queue structures from reentrancy. -&gt;__queue_lock should * _never_ be used directly, it is queue private. always use * -&gt;queue_lock. */ spinlock_t __queue_lock; spinlock_t *queue_lock; /* * queue kobject */ struct kobject kobj;#ifdef CONFIG_PM_RUNTIME struct device *dev; int rpm_status; unsigned int nr_pending;#endif /* * queue settings */ unsigned long nr_requests; /* Max # of requests */ unsigned int nr_congestion_on; unsigned int nr_congestion_off; unsigned int nr_batching; unsigned int dma_drain_size; void *dma_drain_buffer; unsigned int dma_pad_mask; unsigned int dma_alignment; struct blk_queue_tag *queue_tags; struct list_head tag_busy_list; unsigned int nr_sorted; unsigned int in_flight[2]; /* * Number of active block driver functions for which blk_drain_queue() * must wait. Must be incremented around functions that unlock the * queue_lock internally, e.g. scsi_request_fn(). */ unsigned int request_fn_active; unsigned int rq_timeout; struct timer_list timeout; struct list_head timeout_list; struct list_head icq_list;#ifdef CONFIG_BLK_CGROUP DECLARE_BITMAP (blkcg_pols, BLKCG_MAX_POLS); struct blkcg_gq *root_blkg; struct list_head blkg_list;#endif struct queue_limits limits; /* * sg stuff */ unsigned int sg_timeout; unsigned int sg_reserved_size; int node;#ifdef CONFIG_BLK_DEV_IO_TRACE struct blk_trace *blk_trace;#endif /* * for flush operations */ unsigned int flush_flags; unsigned int flush_not_queueable:1; unsigned int flush_queue_delayed:1; unsigned int flush_pending_idx:1; unsigned int flush_running_idx:1; unsigned long flush_pending_since; struct list_head flush_queue[2]; struct list_head flush_data_in_flight; struct request flush_rq; struct mutex sysfs_lock; int bypass_depth;#if defined(CONFIG_BLK_DEV_BSG) bsg_job_fn *bsg_job_fn; int bsg_job_size; struct bsg_class_device bsg_dev;#endif#ifdef CONFIG_BLK_CGROUP struct list_head all_q_node;#endif#ifdef CONFIG_BLK_DEV_THROTTLING /* Throttle data */ struct throtl_data *td;#endif struct rcu_head rcu_head;}; 通过内核中像文件系统这样的高层的代码将请求加入到队列中。请求队列只要不为空，队列对应的块设备驱动程序就会从队列头获取请求，然后将其送入对应的块设备上去。 请求队列表中的每一项都是一个单独的请求，由request结构体表示。 队列中的请求由结构体request表示，因为一个请求可能要操作多个连续的磁盘块，所以每个请求可以由多个bio结构体组成。 注意，虽然磁盘上的块必须连续，但是在内存中这些块并不一定要连续_每个bio结构体都可以描述多个段（段是内存中的连续的小区域），而每个请求也可以包含多个bio结构体。 I/O调度程序(块I/O调度层)如果简单地以内核产生的请求的次序直接将请求发向块设备的话，性能会很差。磁盘寻址是整个计算机中最慢的操作之一，每次寻址（定位磁盘磁头到特定块上的某个位置）需要花费不少时间，所以尽量缩短寻址时间无疑提高系统性能。 为了优化寻址操作，内核既不会简单地按请求接受次序，也不会立即将其提交给磁盘。相反，它会在提交前，先执行名为合并排序的预操作，这种预操作可以极大地提高系统的整体性能。 在内核中负责提交I/O请求的子系统称为I/O调度程序: I/O调度程序将磁盘I/O资源分配给系统中所有挂起的块I/O请求。这种资源分配是通过将请求队列中挂起的请求合并和排序来完成的。 进程调度程序与I/O调度程序的共同点与区别： 二者都是将一个资源虚拟给多个对象 进程调度程序的作用是将处理器资源分配给系统中的运行进程。处理器被进程调度程序虚拟给系统中的运行进程共享。 I/O调度程序虚拟块设备给多个磁盘请求，以便降低磁盘寻址时间，确保磁盘性能地最优化。 I/O调度程序的工作I/O调度程序的工作是管理块设备的请求队列。 它决定队列中的请求排列顺序以及在什么时候派发请求到块设备。这样做有利于减少磁盘寻址时间，从而提高全局吞吐量。 I/O调度器提高的是系统整体性能，对个别请求可能不公平。 I/O调度程序通过两种方法减少磁盘寻址时间：合并与排序。 合并：指将两个或多个请求结合成一个请求。通过合并请求，I/O调度程序将多次请求的开销压缩成一次请求的开销。更重要的是，请求合并后只需要传递给磁盘一条寻址命令，就可以访问到请求合并前必须多次寻址才能访问完的磁盘区域了，因此合并请求显然能减少系统开销和磁盘寻址次数。 比如文件系统提交请求到请求队列——请求是从文件中读取一个数据区。（当然，最终所有的操作都是针对扇区和块进行的，而不是文件，还假定请求的块都是来自文件块）。如果这时队列中已经存在一个请求，它访问的磁盘扇区和当前请求访问的磁盘扇区相邻（比如，同一个文件中早些时候被读取的数据区），那么这两个请求就可以合并为一个对单个和多个相邻磁盘扇区操作的新请求。 排序：如果存在一个请求，它要操作的磁盘扇区位置与当前请求比较接近，那么是不是该让这两个请求在请求队列上也相邻呢？事实上，I/O调度程序的确是这样处理上述情况的，整个请求队列将按扇区增长方向有序排列。使所有请求按硬盘上扇区的排列顺序有序排列（尽可能的）的目的不仅是为了缩短单独一次请求的寻址时间，更重要的优化在于，通过保持磁盘头以直线方向移动，缩短了所有请求的磁盘寻址时间。该排序算法类似于电梯调度（A–&gt;B…..A—&gt;B）。 访问块设备字符设备的实现比较简单，内核例程和用户态API一一对应，这种映射关系由字符设备的file_operations维护。块设备接口则相对复杂，读写API没有直接到块设备层，而是直接到文件系统层，然后再由文件系统层发起读写请求。对于块设备来说，读写操作是以数据块为单位进行的，为了使高速的 CPU 同低速块设备能够协调工作，提高读写效率，操作系统设置了缓冲机制。当进行读写的时候，首先对缓冲区读写，只有缓冲区中没有需要读的数据或是需要写的数据没有地方写时，才真正地启动设备控制器去控制设备本身进行数据交换，而对于设备本身的数据交换同样也是同缓冲区打交道。 块设备驱动程序的注册register_blkdev()函数块设备驱动中的第1个工作通常是注册它们自己到内核，申请设备号，完成这个任务的函数是register_blkdev(),代码在/block/genhd.c 点击展开register_blkdev()函数代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * register_blkdev - register a new block device * * @major: the requested major device number [1..255]. If @major=0, try to * allocate any unused major number. * @name: the name of the new block device as a zero terminated string * * The @name must be unique within the system. * * The return value depends on the @major input parameter. * - if a major device number was requested in range [1..255] then the * function returns zero on success, or a negative error code * - if any unused major number was requested with @major=0 parameter * then the return value is the allocated major number in range * [1..255] or a negative error code otherwise */int register_blkdev(unsigned int major, const char *name){ //传入的参数是要注册的主设备号和设备名称 struct blk_major_name **n, *p; int index, ret = 0; mutex_lock(&amp;block_class_lock); /* temporary */ //检查传入的主设备号是否为0，如果为0怎么办？ //如果为0的话内核会自动去major_name这个指针数组中为你分配一个主设备号 //如果已经没有空闲的设备号的话，就会返回一个错误 if (major == 0) { for (index = ARRAY_SIZE(major_names)-1; index &gt; 0; index--) { if (major_names[index] == NULL) break; } if (index == 0) { printk(\"register_blkdev: failed to get major for %s\\n\", name); ret = -EBUSY; goto out; } major = index; ret = major; } //如果主设备号不为0 ，我们就可以申请一个struct blk_major_name的结构体，并将它初始化，主要是将设备号和设备名称存储到这个结构体中 p = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL); if (p == NULL) { ret = -ENOMEM; goto out; } p-&gt;major = major; strlcpy(p-&gt;name, name, sizeof(p-&gt;name)); p-&gt;next = NULL; index = major_to_index(major); //这个函数是做模运算用来得到一个索引值(0-255)，也许你要问了，如果我的主设备号大于255，是不是会将major_names指针数组中的元素覆盖掉？ //看看下面的for循环就明白了。假定主设备号是288，那么index = 288%255，就是33 //内核首先拿到索引值为33的元素，用*n判断此元素是否为空，如果为空，直接跳出for循环，将上面开辟的结构体赋值给*n好了，这样就将设备的信息注册到了全局数组中去了 //如果此元素不为空，也就是已经有一个设备注册到这了，怎么办?那内核就会去比较已经注册的主设备号与我们将要注册的主设备号是否一致，如果一致，内核就会提示我们该设备号已经被占用了。 //如果不一致呢？有一个next指针，这个指针是指向下一个设备的结构体，直到找到一个空的结构体，并将前面申请的结构体进行赋值。 for (n = &amp;major_names[index]; *n; n = &amp;(*n)-&gt;next) { if ((*n)-&gt;major == major) break; } if (!*n) *n = p; else ret = -EBUSY; if (ret &lt; 0) { printk(\"register_blkdev: cannot get major %d for %s\\n\", major, name); kfree(p); }out: mutex_unlock(&amp;block_class_lock); return ret;}EXPORT_SYMBOL(register_blkdev); 参数说明： major参数是块设备要使用的主设备号，name为设备名，它会显示在/proc/devices中。如果major为0，内核会自动分配一个新的主设备号，register_blkdev()函数的返回值就是这个主设备号。 如果register_blkdev()返回一个负值，表明发生了一个错误。 /proc/devices是一个文件，这个文件列出字符和块设备的主设备号，以及分配到这些设备号的设备名称。示例如下： 点击展开/proc/devices示例 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[root@master ~]# cat /proc/devices Character devices: 1 mem 4 /dev/vc/0 4 tty 4 ttyS 5 /dev/tty 5 /dev/console 5 /dev/ptmx 7 vcs 10 misc 13 input 21 sg 29 fb128 ptm136 pts162 raw180 usb188 ttyUSB189 usb_device202 cpu/msr203 cpu/cpuid226 drm231 infiniband_mad231 infiniband_verbs231 infiniband_cm235 infiniband_cm236 infiniband_mad237 mlx5_fpga_tools238 mei239 ipmidev240 infiniband_verbs241 aux242 nvme243 megaraid_sas_ioctl244 ptp245 pps246 hidraw247 usbmon248 bsg249 hmm_device250 watchdog251 iio252 rtc253 dax254 tpmBlock devices:259 blkext 8 sd 9 md 11 sr 65 sd 66 sd 67 sd 68 sd 69 sd 70 sd 71 sd128 sd129 sd130 sd131 sd132 sd133 sd134 sd135 sd254 mdp major_names数组代码在block/genhd.c 12345static struct blk_major_name { struct blk_major_name *next; int major; char name[16];} *major_names[BLKDEV_MAJOR_HASH_SIZE]; 说明： BLKDEV_MAJOR_HASH_SIZE = 255 这是一个指针数组，其中的每一个元素都指向了一个struct blk_major_name的结构体 struct blk_major_name结构体就是用来存放设备的主设备号和设备名称的 更加详细的解释看参考文献。 unregister_blkdev()函数unregister_blkdev()代码在/block/genhd.c 点击展开unregister_blkdev()函数代码 >folded123456789101112131415161718192021void unregister_blkdev(unsigned int major, const char *name){ struct blk_major_name **n; struct blk_major_name *p = NULL; int index = major_to_index(major); mutex_lock(&amp;block_class_lock); for (n = &amp;major_names[index]; *n; n = &amp;(*n)-&gt;next) if ((*n)-&gt;major == major) break; if (!*n || strcmp((*n)-&gt;name, name)) { WARN_ON(1); } else { p = *n; *n = p-&gt;next; } mutex_unlock(&amp;block_class_lock); kfree(p);}EXPORT_SYMBOL(unregister_blkdev); 说明：传递给register_blkdev()的参数必须与传递给unregister_blkdev()的参数匹配，否则这个函数返回-EINVAL。 两个函数的声明代码在include/linux/fs.h 12extern int register_blkdev(unsigned int, const char *);extern void unregister_blkdev(unsigned int, const char *); 每种具体的块设备都有一套具体的操作，因而各自有一个类似于file_operations 那样的数据结构，称为block_device_operations 结构。它是对块设备操作的集合，其定义为,代码在include/linux/blkdev.h： 1234567891011121314151617181920212223242526272829303132struct block_device_operations { //打开和释放 int (*open) (struct block_device *, fmode_t); void (*release) (struct gendisk *, fmode_t); //I/O控制 int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long); int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long); int (*direct_access) (struct block_device *, sector_t, void **, unsigned long *); //介质改变 unsigned int (*check_events) (struct gendisk *disk, unsigned int clearing); /* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */ int (*media_changed) (struct gendisk *); void (*unlock_native_capacity) (struct gendisk *); //使介质有效 int (*revalidate_disk) (struct gendisk *); //获得驱动器信息 int (*getgeo)(struct block_device *, struct hd_geometry *); /* this callback is with swap_lock and sometimes page table lock held */ void (*swap_slot_free_notify) (struct block_device *, unsigned long);、 //模块指针，一个指向拥有这个结构体的模块的指针，它通常被初始化为THIS_MODULE struct module *owner;}; 如果说file_operation 结构是连接虚拟的VFS 文件的操作与具体文件系统的文件操作之间的枢纽，那么block_device_operations就是连接抽象的块设备操作与具体块设备操作之间的枢纽。 具体的块设备是由主设备号唯一确定的，因此，主设备号唯一地确定了一个具体的block_device_operations 数据结构。 那么，块设备注册到系统以后，怎样与文件系统联系起来呢，也就是说，文件系统怎么调用已注册的块设备，这还得从file_operations 结构说起。 先来看一下块设备的file_operations 结构的定义，变量名为def_blk_fops，其位于fs/block_dev.c中： 1234567891011121314151617const struct file_operations def_blk_fops = { .open = blkdev_open, .release = blkdev_close, .llseek = block_llseek, .read = do_sync_read, .write = do_sync_write, .aio_read = blkdev_aio_read, .aio_write = blkdev_aio_write, .mmap = generic_file_mmap, .fsync = blkdev_fsync, .unlocked_ioctl = block_ioctl,#ifdef CONFIG_COMPAT .compat_ioctl = compat_blkdev_ioctl,#endif .splice_read = generic_file_splice_read, .splice_write = generic_file_splice_write,}; 以open()系统调用为例，说明用户进程中的一个系统调用如何最终与物理块设备的操作联系起来。在此，我们仅仅给出几个open()函数的调用关系，如图所示。 图6.几个open函数的调用关系 当调用open()系统调用时，其最终会调用到def_blk_fops的blkdev_open() 函数。 blkdev_open()函数的任务：根据主设备号找到对应的block_device_operations结构，然后再调用block_device_operations结构中的函数指针open所指向的函数，如果open 所指向的函数非空，就调用该函数打开最终的物理块设备。 这就简单地说明了块设备注册以后，从最上层的系统调用到具体地打开一个设备的过程。 块驱动程序的体系结构块设备驱动程序通常分为两部分，即高级驱动程序和低级驱动程序，前者处理VFS 层，后者处理硬件设备 图7.块设备驱动程序的体系结构 假设进程对一个设备文件发出read()或write()系统调用。VFS 执行对应文件对象的read 或write方法，由此就调用高级块设备处理程序中的一个过程。这个过程执行的所有操作都与对这个硬件设备的具体读写请求有关。内核提供两个名为generic_file_read()和generic_file_write()通用函数来留意所有事件的发生。因此，在大部分情况下，高级硬件设备驱动程序不必做什么，而设备文件的read和write方法分别指向generic_file_read()和generic_file_write()方法。但是，有些块设备的处理程序需要自己专用的高级设备驱动程序。 即使高级设备驱动程序有自己的read 和write 方法，但是这两个方法通常最终还会调用generic_file_read ( )和generic_file_write ( )函数。这些函数把对I/O 设备文件的访问请求转换成对相应硬件设备的块请求。 所请求的块可能已在主存， 因此generic_file_read ( )和generic_file_write ( )函数调用getblk()函数来检查缓冲区中是否已经预取了块，还是从上次访问以来缓冲区一直都没有改变。 如果块不在缓冲区中，getblk()就必须调用ll_rw_block()继续从磁盘中读取这个块，后面这个函数激活操纵设备控制器的低级驱动程序，以执行对块设备所请求的操作。 在VFS 直接访问某一块设备上的特定块时，也会触发缓冲区I/O 操作。 例如，如果内核必须从磁盘文件系统中读取一个索引节点，那么它必须从相应磁盘分区的块中传送数据 。 对于特定块的直接访问是由bread()和breada()函数来执行的，这两个函数又会调用前面提到过的getblk()和ll_rw_block()函数。 由于块设备速度很慢，因此缓冲区I/O 数据传送通常都是异步处理的： 低级设备驱动程序对DMAC和磁盘控制器进行编程来控制其操作，然后结束。当数据传送完成时，就会产生一个中断，从而第2次激活这个低级设备驱动程序来清除这次I/O 操作所涉及的数据结构。 块设备基于缓冲区的数据交换对于块设备来说，读写操作是以数据块为单位进行的，为了使高速的 CPU 同低速块设备能够协调工作，提高读写效率，操作系统设置了缓冲机制。块设备读和写当进行读写的时候，首先对缓冲区读写，只有缓冲区中没有需要读的数据或是需要写的数据没有地方写时，才真正地启动设备控制器去控制设备本身进行数据交换，而对于设备本身的数据交换同样也是同缓冲区打交道。 在PC 体系结构中，允许块的大小为512、1024、2048 和4096 字节。同一个块设备驱动程序可以作用于多个块大小，因为它必须处理共享**同一主设备号的一组设备文件，而每个块设备文件都有自己预定义的块大小。 例如，一个块设备驱动程序可能会处理有两个分区的硬盘，一个分区包含Ext2 文件系统，另一个分区包含交换分区。内核在一个名为blksize_size的表中存放块的大小；表中每个元素的索引就是相应块设备文件的主设备号和从设备号。如果blksize_size[M]为NULL，那么共享主设备号M的所有块设备都使用标准的块大小，即1024 字节。 每个块都需要自己的缓冲区，它是内核用来存放块内容的RAM内存区。当设备驱动程序从磁盘读出一个块时，就用从硬件设备中所获得的值来填充相应的缓冲区；同样，当设备驱动程序向磁盘中写入一个块时，就用相关缓冲区的实际值来更新硬件设备上相应的一组相邻字节。缓冲区的大小一定要与块的大小相匹配。 块设备请求虽然块设备驱动程序可以一次传送一个单独的数据块，但是内核并不会为磁盘上每个被访问的数据块都单独执行一次I/O 操作,取而代之的是，只要可能，内核就试图把几个块合并在一起，并作为一个整体来处理，这样就减少了磁头的平均移动时间。 当进程、VFS 层或者任何其他的内核部分要读写一个磁盘块时，就真正引起一个块设备请求。 从本质上说，这个请求描述的是所请求的块以及要对它执行的操作类型（读还是写）。 然而，并不是请求一发出，内核就满足它，实际上，块请求发出时I/O 操作仅仅被调度，稍后才会被执行(先调度，后执行)。这种人为的延迟有悖于提高块设备性能的关键机制。 当请求传送一个新的数据块时，内核检查能否通过稍微扩大前一个一直处于等待状态的请求而满足这个新请求，也就是说，能否不用进一步的搜索操作就能满足新请求。由于磁盘的访问大都是顺序的，因此这种简单机制就非常高效。 延迟请求复杂化了块设备的处理。 例如，假设某个进程打开了一个普通文件，然后，文件系统的驱动程序就要从磁盘读取相应的索引节点。高级块设备驱动程序把这个请求加入一个等待队列，并把这个进程挂起，直到存放索引节点的块被传送为止。因为块设备驱动程序是中断驱动的，因此，只要高级驱动程序一发出块请求，它就可以终止执行。 在稍后的时间低级驱动程序才被激活，它会调用一个所谓的策略程序从一个队列中取得这个请求，并向磁盘控制器发出适当的命令来满足这个请求。当I/O 操作完成时，磁盘控制器就产生一个中断，如果需要，相应的处理程序会再次调用这个策略程序来处理队列中进程的下一个请求。 每个块设备驱动程序都维护自己的请求队列；每个物理块设备都应该有一个请求队列，以提高磁盘性能的方式对请求进行排序。因此策略程序就可以顺序扫描这种队列，并以最少地移动磁头而为所有的请求提供服务。 块设备驱动程序的几个函数Linux中硬盘驱动程序的实现重要文件由于块设备驱动程序的绝大部分都与设备无关的，故内核开发者通过把大部分相同的代码放在一个头文件block/blk.h中来简化驱动程序的代码。从而每个块设备驱动程序都必须 包含这个头文件。 参考资料《深入分析Linux内核源代码》 //书籍内核版本有些旧《Linux内核设计与实现》 //目前感觉这个版本是最准的Linux 通用块层 bio 详解块设备注册 register_blkdev | 学步园","link":"/2020/08/17/Linux-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"},{"title":"C++精度控制","text":"C++的格式控制语法ostream 类是从ios派生而来的,而ios则是从ios_base派生来的。 ios_base类封装了C++标准中的流输入输出中不依赖于读写的数据的类型的基本信息，如格式化信息、异常状态、事件回调函数等，所以很多的格式控制都需要。 C++程序设计时，一般不会直接调用std::ios_base的成员函数，但是会经常用到该类中定义的各种流的数据格式的枚举值常量。如ios_base::hex、ios_base::skipws等等。 C++中通过cout来实现格式输出，就类似于C语言中通过printf()来实现格式输出。 cout.setf()的作用是通过设置格式标志来控制输出形式 保留有效位数setprecision(n)：控制浮点数显示的有效数字个数，这个有效数字是囊括了小数点之前的整数部分的，比如12.345是五位有效数字。特性： 四舍五入进行保留； 如果有效位数不够，不会自动补0（3.15，setprecision（4）；3.15） 如果小数点前的位数多余要保留的位数，则使用科学计数法 代码实例： 12345678910111213#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main(){ double num=12.3456789;//小数点后有7位，一共是9个有效数字 cout&lt;&lt;setprecision(1)&lt;&lt;\"setprecision(1): \"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;setprecision(4)&lt;&lt;\"setprecision(4): \"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;setprecision(6)&lt;&lt;\"setprecision(6): \"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;setprecision(8)&lt;&lt;\"setprecision(8): \"&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;setprecision(10)&lt;&lt;\"setprecision(10): \"&lt;&lt;num&lt;&lt;endl; return 0;} 说明：使用cout&lt;&lt;setprecision(n)时#include &lt;iomanip&gt;在这里必须要带上，否则会出现如下错误。 1234main.cpp: In function ‘int main()’:main.cpp:6:8: error: ‘setprecision’ was not declared in this scope 6 | cout&lt;&lt;setprecision(1)&lt;&lt;\"setprecision(1): \"&lt;&lt;num&lt;&lt;endl; | ^~~~~~~~~~~~ 运行结果： 12345setprecision(1): 1e+01 //小数点前的位数多余要保留的位数，使用科学计数法setprecision(4): 12.35setprecision(6): 12.3457setprecision(8): 12.345679 //可以看到这里是四舍五入保留有效数字的setprecision(10): 12.3456789 //有效位数不够，不会自动补0 当然也可以用cout.precision(n);这样的写法，这个写法不用加#include &lt;iomanip&gt;头文件。 12345678910#include &lt;iostream&gt;using namespace std;int main(){ double num=12.3456789;//小数点后有7位，一共是9个有效数字 cout.precision(1); cout&lt;&lt;\"setprecision(1): \"&lt;&lt;num&lt;&lt;endl; //输出的结果是setprecision(1): 1e+01 return 0;} 保留小数点后n位fixed和setprecision(n)结合可以实现保留小数点后几位，且会补0。//fixed指定点,即小数点后有n个有效数字特性： 保留小数点之后的几位有效数字，不包括整数部分。 四舍五入进行保留 如果小数点之后有效位数不够，自动补0 写法一般有三种： 12345678/*写法1*/cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(n); /*写法2*/cout&lt;&lt;fixed&lt;&lt;setprecision(n);/*写法3*/cout.flags(cout.fixed) //定点,即小数点后有n个有效数字cout.unsetf(cout.fixed) //取消定点法,即变成输出n个有效数字 1234567891011#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main(){ double a = 12.3456789; cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(8)&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;a&lt;&lt;endl; return 0;} 结果： 12312.345712.3456789012.3456789000 在计算过程中保留有效位数。 要对 sum 保留6位有效数字，需要在计算过程中就直接转换成 double（一般不用float） 12sum += (double)(1.0/i);cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; sum &lt;&lt; endl; 使用数学公式来实现四舍五入1234567891011#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std;int main(){ double a = 13.456789; double b; b = floor(a * 10000.000f + 0.5) / 10000.000f; /*保留小数点后四位*/cout&lt;&lt;b; //输出13.4568return 0;} 设置浮点数的显示精度 这个各种在线编程题中经常会考到的，尽量记住啊！也就是显示几位有效数字。 std::ios_base::precision是显示有效位的成员函数原型如下: 123streamsize precision() const; (1)streamsize precision( streamsize new_precision ); (2)` 上述函数管理 std::num_put::do_put 所进行的浮点输出精度（即生成多少数位）。(1) 返回当前精度。(2) 设置精度为给定值。 std::basic_ios::init 所建立的默认精度为 6想要恢复只有通过调用精度控制 cout.precision(6); 其中new_precision可以是const也可以是#define宏定义过的。 测试代码如下: 1234567891011#include &lt;iostream&gt;using namespace std;int main(){ float price1=10.45,price2=1.5+5.0/6.0; cout&lt;&lt;\"price1 = \"&lt;&lt;price1&lt;&lt;endl; //正常格式 cout&lt;&lt;\"price2 = \"&lt;&lt;price2&lt;&lt;endl; //正常格式,默认6位有效 cout.precision(4); //显示4位精度 cout&lt;&lt;\"price1 = \"&lt;&lt;price1&lt;&lt;endl; //只有4位有效,出现0会自动省略 cout&lt;&lt;\"price2 = \"&lt;&lt;price2&lt;&lt;endl; //只有4位,不会四舍五入} 结果： 1234price1 = 10.45price2 = 2.33333 price1 = 10.45price2 = 2.333 打印末尾的0和小数点ios_base提供了setf函数(用于set标记),能够控制多种格式化特性,此外ios_base函数提供了多个常量,可做setf函数的参数个数如下面一行代码使cout显示末尾小数点,当然,也会显示末尾位0的 1cout.setf(ios_base::showpoint); 测试代码如下: 1234567891011#include &lt;iostream&gt;using namespace std;int main(){ float price1=10.40,price2=1.5+5.0/6.0; cout&lt;&lt;\"pricel = \"&lt;&lt;price1&lt;&lt;endl; //正常格式 cout&lt;&lt;\"price2 = \"&lt;&lt;price2&lt;&lt;endl; //正常格式 cout.setf(ios_base::showpoint); //显示小数点和后面的0 cout&lt;&lt;\"pricel = \"&lt;&lt;price1&lt;&lt;endl; //不会忽略0 cout&lt;&lt;\"price2 = \"&lt;&lt;price2&lt;&lt;endl; } 结果： 1234pricel = 10.4price2 = 2.33333pricel = 10.4000price2 = 2.33333 setf其他方法setf有两种原型: 12fmtflags setf(fmtlags); (1)fmtflags setf(fmtflags,fmtflags); (2) 先来讲第一种:fmtflags是bitmask类型的typedef名,用于存储格式标记, 该名称还是在ios_base类中定义的 bitmask类型是一种用来存储各个位置的类型,可以是整型,枚举,甚至可以说是STL bitset容器 下表是fmtflag setf(fmtlags)的一些常量控制和格式控制 常量 含义 ios_base::boolapha 输出和输入bol值 ios_base::showpoint 显示末尾小数点 ios_base::uppercase 大写字母输出16进制 ios_base:showbase 输出C++基数前缀 ios_base::showpos 正数前面加上’+’号 测试其中几个函数,代码如下: 123456789101112#include &lt;iostream&gt;using namespace std;int main(){ int s=20; cout.setf(ios_base::showpos); cout&lt;&lt;\"s = \"&lt;&lt;s&lt;&lt;endl; //已经填充'+'号 cout&lt;&lt;hex&lt;&lt;\"s = \"&lt;&lt;s&lt;&lt;endl; //16进制输出 cout.setf(ios_base::uppercase); cout.setf(ios_base::showbase); cout&lt;&lt;\"s = \"&lt;&lt;s&lt;&lt;endl; //以16进制输出,并输出前缀Ox } 结果 123s = +20s = 14s = 0X14 下面介绍第二种: 1fmtlags setf(fmtflags,fmtflas); 和第一种不同的是,这种格式会返回以前的设置,第二种第一个参数指出要设置哪些位，第二个参数指出要清除哪些位。下面函数调用和16进制控制符作用相同 1cout.setf(ios_base::hex,ios_base::basefield); 第一参数 第二参数 含义 ios_base::dec ios_base::basefield 使用十进制基数 ios_base::oct ios_base::basefield 使用八进制基数 ios_base::hex ios_base::basefield 使用16进制基数 第一参数 第二参数 含义 ios_base::fixed ios_base::floatfield 定点计数法 ios_base::scientifc ios_base::floatfield 使用科学计数法 ios_base::left ios_base::adjustfield 使用左对齐 ios_base::right ios_base::adjustfield 使用右对齐 ios_base::internal ios_base::adjustfield 符号或者基数前缀左对齐,值右对齐 标准控制符表可以通过使用下面的操作符，不直接操作标志。例如：当我们设置dec标志时, 我们可以使用下面的命令: 1cout &lt;&lt; dec; //设置dec表示 设置endl标志时，可以使用下面命令： 1cout &lt;&lt; endl; //输出换行标示，并清空缓冲区 iostream中定义的操作符 操作符 描述 输入 输出 boolalpha 启用boolalpha标志 √ √ dec 启用dec标志 √ √ endl 输出换行标示，并清空缓冲区 √ ends 输出空字符 √ fixed 启用fixed标志 √ flush 清空流 √ hex 启用 hex 标志 √ √ internal 启用 internal标志 √ left 启用 left标志 √ noboolalpha 关闭boolalpha 标志 √ √ noshowbase 关闭showbase 标志 √ noshowpoint 关闭showpoint 标志 √ noshowpos 关闭showpos 标志 √ noskipws 关闭skipws 标志 √ nounitbuf 关闭unitbuf 标志 √ nouppercase 关闭uppercase 标志 √ oct 启用 oct 标志 √ √ right 启用 right 标志 √ scientific 启用 scientific 标志 √ showbase 启用 showbase 标志 √ showpoint 启用 showpoint 标志 √ showpos 启用 showpos 标志 √ skipws 启用 skipws 标志 √ unitbuf 启用 unitbuf 标志 √ uppercase 启用 uppercase 标志 √ ws 跳过所有前导空白字符 √ iomanip中定义的操作符 操作符 描述 输入 输出 resetiosflags(long f) 关闭被指定为f的标志 √ √ setbase(int base) 设置数值的基本数为base √ setfill(int ch) 设置填充字符为ch √ setiosflags(long f) 启用指定为f的标志 √ √ setprecision(int p) 设置数值的精度(四舍五入) √ setw(int w) 设置域宽度为w √ 如果系统支持则可以使用,否则继续使用setf(); 进制转换1.将进制进行转换ios_base类作为引导例如,控制整数以十进制,十六进制,八进制显示, 可以使用dec,hex,oct控制符,如下: 1234567891011#include &lt;iostream&gt;using namespace std;int main(){ int a=10; cout&lt;&lt;\"original:\"&lt;&lt;a&lt;&lt;endl; //原型输出 cout&lt;&lt;\"dec:\"&lt;&lt;dec&lt;&lt;a&lt;&lt;endl; //十进制输出a cout&lt;&lt;\"hex:\"&lt;&lt;hex&lt;&lt;a&lt;&lt;endl; //十六进制输出a cout&lt;&lt;\"oct:\"&lt;&lt;oct&lt;&lt;a&lt;&lt;endl; //八进制输出a} 输出结果如下 1234original:10dec:10hex:aoct:12 注意：使用dec，hex，oct进行格式控制的时候。一旦进行了格式控制，其格式控制的时间会在接下来程序执行的时间内持续。 12345678910#include &lt;iostream&gt;using namespace std;int main(){ int b=100,a=10; cout&lt;&lt;hex&lt;&lt;\"a= \"&lt;&lt;a&lt;&lt;endl; //十六进制输出a cout&lt;&lt;\"b = \"&lt;&lt;b&lt;&lt;endl; return 0;} 输出的结果是 12a= ab = 64 修改字符宽度-width()函数width()可以修改字符的宽度 12int width();int width(int i); width(i)中,i是宽度,当然width只能影响下一个项目,然后字符宽度将自动恢复为默认值。例子如下代码: 123cout&lt;&lt;'#'; cout.width(10); cout&lt;&lt;10&lt;&lt;'#'&lt;&lt;50&lt;&lt;\"#\\n\"; 结果 1# 10#50# widt(i),i的参数可以是const 类型,也可以是#define类型 填充字符-fill()函数fill()成员函数可以用来改变填充字符,例如:cout.fill(’@’) 代码如下: 123456789cout.fill('@'); //填充@字符 char *str[3]={\"这里识别不出来\",\"有几个\",\"号\"}; int num[3]={500,600,700}; for(int i=0;i&lt;=2;i++) //3次循环 { cout&lt;&lt;str[i]&lt;&lt;\" :$\"; //输出str的每个元素 cout.width(5); cout&lt;&lt;num[i]&lt;&lt;endl; //输出num的每个元素 } 运行结果如下: 123这里识别不出来 :$@@500有几个 :$@@600号 :$@@700 取消c++ setprecision 设置的精度C++11需要： 1std::cout &lt;&lt; std::defaultfloat; C++11之前需要： 1std::cout.unsetf(std::ios_base::floatfield); 两种方法都可以把浮点输出格式还原为默认状态。 参考资料C++精度控制说明(详细)C++ 中的 cout.setf() 函数C++保留任意小数点位数&amp;格式化输出","link":"/2020/09/25/C-%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6/"},{"title":"Linux内存管理","text":"进程的用户空间划分 我们以x86架构的 32 位 Linux系统为例子表述：栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。此外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 堆（heap）：用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） BSS 段（bss segment）：是指用来存放程序中未初始化的或者初始化为 0 的全局变量和静态变量的一块内存区域。BSS段属于静态内存分配。 数据段（data segment）：是指用来存放程序中已初始化的全局变量的一块内存区域。换句话说就是存放程序静态分配的变量和全局变量。数据段属于静态内存分配。 代码段（code segment/text segment）：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 说明： 包含data段和bss段的整个区段此时通常称为数据区。 数据段、BSS 段、堆通常是被连续存储在内存中，在位置上是连续的，而代码段和栈往往会被独立存放。堆和栈两个区域在 i386 体系结构中栈向下扩展、堆向上扩展，相对而生。就像下面这张图这样子： 图1. Linux进程用户空间分区 使用size命令查看size命令说明size 作用：显示一个目标文件或者链接库文件中的目标文件的各个段的大小(可执行文件段的大小,默认为a.out)，是 GNU 二进制工具集 GNU Binutils 的一员。支持的目标： elf32-i386 a.out-i386-linux efi-app-ia32 elf32-little elf32-big srec symbolsrec tekhex binary ihex trad-core。 1234# root @ LAPTOP in /usr/bin $ size sort text data bss dec hex filename 104372 3136 1960 109468 1ab9c sort text表示正文段 data表示包含静态变量和已经初始化的全局变量的数据段大小（可执行文件包含了初始化的值） bss由可执行文件中不含其初始化值的全局变量组成。 C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。 size命令安装1$ apt-get install binutils //注意安装的时候不要写成Binutils，这样是找不到安装包的 安装成功后，查看size命令的版本 123456$ size -vGNU size (GNU Binutils for Ubuntu) 2.30Copyright (C) 2018 Free Software Foundation, Inc.This program is free software; you may redistribute it under the terms ofthe GNU General Public License version 3 or (at your option) any later version.This program has absolutely no warranty. 参考资料(深入理解计算机系统) bss段，data段、text段、堆(heap)和栈(stack)别再说你不懂Linux内存管理了，10张图给你安排的明明白白","link":"/2020/10/05/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"软件设计模式","text":"序言 为什么我们需要模式？直截了当的答案是我们不想重新发明轮子！ 设计模式基本概念什么是模式： 概念：在技术生活中经常发生的问题通常具有定义明确的解决方案，这些解决方案灵活，模块化且更易于理解。这些从战术细节上抽象出来的解决方案就成为了模式。 应用场景：假如你针对一个问题设计解决方案时遇到了似曾相识的感觉，换句话说，这个解决方案与之前你遇到的某个问题的解决方案极为相似，那么尽管问题在不同的领域，你可能在不知不觉中就使用了一种模式。 为什么要使用设计模式？ 为了重用代码 让代码更容易被他人理解 保证代码可靠性。 GOF（Gang of Four）1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用下面是一个示例，让我们更深刻地了解什么是设计模式以及如何应用它们。 接下来的文章中我们来做一下有意思的大工程吧，运用代码来创建一架飞机！ 首先我们要创建飞机的类，名字为 Aircraft，然后要创建相应的构造函数。类构造函数是面向对象语言中的基本概念之一。构造函数帮助创建类的对象，并可以接受参数。 1234567891011class Aircraft { private: string type; public: Aircraft(string type) { this-&gt;type = type; }} 在上面的示例中，我们为该类提供了默认构造函数，该构造函数接受飞机的单个参数type 。结果过了几天后，你意识到你还要向Aircraf类添加其他属性。我们就假设你要添加的新属性是飞机的颜色，但是你之前已经发布了一个版本的库，并且无法在库中修改原始构造函数。因为库已经发布给用户了，很多用户说不定都已经用上了，所以不能够改已经发布的库的函数接口。那么该怎么办呢？ 解决方案是添加另一个具有两个参数的构造函数（也就是我们新加入一个拥有不同接口的构造函数），如下所示： 123456789101112131415161718class Aircraft { private: string type; string color; public: Aircraft(string type) { this-&gt;type = type; } Aircraft(string type, string color) { this-&gt;type = type; this-&gt;color = color; }} 假如又过了几天，你又有新的属性要添加到飞机这个类中。如果继续上面这种方式，你将最终得到一堆构造函数，其中的函数参数越来越像折叠望远镜，我们就把这种办法称作为折叠构造函数模式（telescoping constructor pattern ）吧： 1234Aircraft(string type)Aircraft(string type, string color)Aircraft(string type, string color, string prop3)Aircraft(string type, string color, string prop3, string prop4) The telescoping pattern is called an anti-pattern: how NOT to do things! //伸缩模式称为反模式：也就是如何对发布的库不做修改！ 很明显，使用折叠构造函数模式来处理这种属性变量越来越多的类是极为不便的，那么，我们该采取何种方法呢？ 实际上处理变量越来越多的类的方法是使用建造者模式（Builder Pattern），我们将在接下来的文章中深入讨论。 设计模式概要 经验丰富的开发人员应精通设计模式，应用这些模式可使代码在将来可重用和可维护。 设计模式不仅限于面向对象的语言，还存在于计算机科学的其他领域，例如分布式系统，大数据系统或用户界面。 急于要接受即将面试的课程的人们，建议您遍历所有的创建型模式，装饰器，代理，迭代器，观察者和访客模式。 设计模式的分类： 创建型模式：新创建的对象听起来可能很琐碎，但在创建对象实例时随便乱扔代码绝对会让你日后头痛。创新的设计模式提供了有关如何最好地将对象创建过程封装到程序中的有力建议。、 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 结构型模式：与类的组成有关，即类的构成或构造方式。 行为设计模式：规定了类和对象之间的交互以及责任的委派。 特别关注对象之间的通信 面向对象设计的建议 Separate out parts of code that vary or change from those that remain the same. //将保持不变的部分和经常变化的部分分开。 Always code to an interface and not against a concrete implementation. //针对接口编码，不要针对具体实现编码。 Encapsulate behaviors as much as possible. //尽可能对行为进行封装 Favor composition over inheritance. Inheritance can result in explosion of classes and also sometimes the base class is fitted with new functionality that isn’t applicable to some of its derived classes.//优先考虑组成而不是继承。继承会导致类的爆炸式增长，并且有时基类还配备了不适用于其某些派生类的新功能。 Interacting components within a system should be as loosely coupled as possible. //系统内的交互组件应尽可能松散地耦合。 Ideally, class design should inhibit modification and encourage extension. //理想情况下，类应该禁止修改并鼓励扩展。 Using patterns in your day to day work, allows exchanging entire implementation concepts with other developers via shared pattern vocabulary.//通过运用设计模式词汇和其他人交换设计思路 接下来我们说明的大多数设计模式，都是围绕着构建我们的飞机来的，不得不说是个大工程啊（从零开始造飞机！），开始我们的设计模式之旅吧！ 参考资料设计模式总结Software Design Patterns: Best Practices for Software Developers /github educative","link":"/2020/10/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"建造者模式","text":"建造者模式是什么 ？顾名思义，建造者模式用于构建对象。 有时，我们创建的对象可能很复杂，可能由多个子对象组成，或者需要复杂的构建过程。通过使用建造者模式，可以简化创建复杂类型的过程。 建造者模式通常用来构建复合或者聚合的对象 严谨地说，构建器模式封装或隐藏了构建复杂对象的过程，并将对象的表示和构建进行了分离。这种分离使我们可以使用相同的构建过程来构建不同的表示形式。 建造者模式是一个非常实用而常见的创建类型的模式（creational design pattern) 应用场景： 当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。 建造者模式类图类图由以下实体组成 Builder：其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法Product getProduct()。 Concrete Builder：具体的建造者 Director ：决定如何构建最终产品的算法. 其会包含一个负责组装的方法void Construct(Builder builder)， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品。 Product：最终要生成的对象 使用建造者模式造不同的飞机接下来的示例讨论了如何将表示和构造复杂的对象两个操作耦合在一起。 示例：以制造飞机为例，假设飞机的制造过程分三个步骤进行： 驾驶舱的制作 引擎 机翼 在我们的假设中，每架飞机至少需要上述三个步骤。但是，如果飞机是客机的话，我们就需要增加在飞机上建造浴室的步骤。这些步骤代表了构建过程。我们建造的产品可以是不同的形式。文中的例子是飞机，但可以有不同的表示形式的飞机，例如战斗机或客机。但是使用相同的建造过程，我们应该能够同时生产战斗机和客机。 现在看一些代码。首先，我们将从AircraftBuilder类的抽象接口开始。 The builder contains a method for each component that can be part of the final product. These methods are selectively overridden by concrete builders depending on if the builders will be including that part in the final product variant that they are responsible for building. 抽象类Builder会包含最终产品每个部分的构建方法。 这些方法会被具体的构建者（concrete builders）有选择地覆盖，这取决于具体的构建者负责的最终产品中是否包括该部分，如果包含，就覆盖对应的方法。 12345678910111213141516171819class AircraftBuilder {public: virtual void buildEngine() { //引擎 } virtual void buildWings() { //机翼 } virtual void buildCockpit() { //驾驶舱 } virtual void buildBathrooms() { //洗手间 } virtual IAircraft&amp; getResult() = 0; //返回最终产品的方法} 现在，我们将实施两个具体的建造者，一个用于F-16，另一个用于波音747。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Boeing747Builder：public AircraftBuilder { Boeing747 boeing747;public: virtual void buildCockpit() override //选择覆盖驾驶舱建造方法 { } virtual void buildEngine() override //选择覆盖引擎建造方法 { } virtual void buildBathrooms() override //选择覆盖洗手间建造方法 { } virtual void buildWings() override //选择覆盖机翼建造方法 { } virtual IAircraft&amp; getResult() override //返回最终产品的方法 { return boeing747; }} class F16Builder extends AircraftBuilder { F16 f16;public: virtual void buildEngine() override //选择覆盖引擎建造方法 { // get F-16 an engine // f16.engine = new F16Engine(); } virtual void buildWings() override //选择覆盖机翼建造方法 { // get F-16 wings // f16.wings = new F16Wings(); } virtual void buildCockpit() override //选择覆盖驾驶舱建造方法 { f16 = new F16(); // get F-16 a cockpit // f16.cockpit = new F16Cockpit(); } virtual IAircraft&amp; getResult() override //返回最终产品的方法 { return f16; }} 为简便起见，我们提供了建造器的框架，并跳过了每种方法的单独实现。 请注意，F16Builder它不会覆盖该buildBathrooms方法，因为F-16座舱中没有浴室。由于波音747拥有供乘客使用的浴室，因此波音的制造商确实重写了浴室的方法。 建造飞机所需的过程或算法（在我们的案例中是创建不同零件的特定顺序）被称为的另一个类Director捕获。 Director类在某种意义上指导着飞机的建造。最终产品仍由建造者（Builders）返回（return）。这里的意思是说Director类知识用来配置建造过程中的参数，最中的产品仍然在建造者那里，所以需要建造者（Builders）返回（return）产品。 12345678910111213141516171819class Director { AircraftBuilder aircraftBuilder; //捕获Builder，也就是Builder是Director的一份子public: Director(AircraftBuilder aircraftBuilder) //构造函数 { this-&gt;aircraftBuilder = aircraftBuilder; } void construct(bool isPassenger) //构建过程（可以有各种参数，来配置构建过程） { aircraftBuilder.buildCockpit(); aircraftBuilder.buildEngine(); aircraftBuilder.buildWings(); if (isPassenger) aircraftBuilder.buildBathrooms(); }} 请注意，我们如何通过我们选择的制造商，并将飞机产品（表示形式）更改为F-16或Boeing-747。 在我们的方案中，建造者返回相同的超类，但是如果构建器返回的产品不太相似，则情况可能并非如此。 客户端将使用以下模式： 12345678910class Client {public: void Clientmain() { F16Builder f16Builder = F16Builder(); //先初始化一个建造者 Director director = Director(f16Builder); //然后交给指导者来配参数 director.construct(false); //指导建造过程 IAircraft f16 = f16Builder.getResult(); //建造者接受指导后返回最终的产品 }} The AircraftBuilder interface hides how a given aircraft gets built. The client is unaware of the classes F16Engine, F16Cockpit and similar classes for Boeing-747. 假如没有指导者如果在没有Director的情况下使用了构建器模式。客户端可以直接实例化Builder并调用所需的方法以获取自身的产品。而且也是一个应对“（伸缩构建）telescoping constructors”的解法： 假设一个类具有很多的属性，但是有些属性是可选的。在这种情况下，可以调用Builder仅设置必需的属性并创建产品。 其他例子另一个假设的示例可能是创建pdf或html类型的文档。请考虑以下代码段： 12345678910111213IDocument construct(DocumentBuilder documentBuilder) { documentBuilder.addTitle(\"Why use design patterns\"); documentBuilder.addBody(\"blah blah blah... more blah blah blah\"); documentBuilder.addAuthor(\"C. H. Afzal\"); documentBuilder.addConclusion(\"Happy Coding!\"); // Return the document and depending on the concrete // implementation of the DocumentBuilder, we could return // either a pdf or html document. return documentBuilder.buildDocument(); } 上面的方法可以出现在控制器代码或客户端代码中，并且可以通过更改传递给该方法的DocumentBuilder的具体类型来构建不同的文档类型。我们可以从抽象类中得到一个HtmlDocumentBuilder和一个PdfDocumentBuilder派生类DocumentBuilder。 抽象工厂模式与建造者模式 建造者模式可能看起来类似于抽象工厂模式，但是二者还是略有不同。其中一个不同之处在于，建造者模式是逐步创建对象的，而抽象工厂模式则一步就返回了对象。 建造者模式的比喻假设我们有一座工厂吧，工厂得有基础核心部门（Builder），这个部门拥有所有的基础生产资料模板，然后我们需要几个分别生产不同产品的车间（Concrete Builder）吧，这些车间需要自己从基础核心部门挑选合适的模板然后自己填充定制，用于生产自己的产品。 工厂的生产不能太随意，得需要指挥部（Director）指导，指挥部在基础核心部门（Builder）等着其他车间（Concrete Builder）来接受指导，给出相应的指挥命令（也就是参数），最终车间（Concrete Builder）生产出合适的产品。 参考资料设计模式总结Software Design Patterns: Best Practices for Software Developers /github educative","link":"/2020/10/14/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"C++虚函数","text":"虚函数与纯虚函数定义虚函数的目的：为了允许用基类的指针来调用子类的这个函数。定义纯虚函数的目的：为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 注意： 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义一个函数为纯虚函数，才代表函数没有被实现。 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数（虚函数）是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。 虚函数虚函数定义：被virtual关键字修饰的成员函数。 使用规则： 为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。 除了构造函数之外，任意非 static 成员函数都可以是虚函数。 virtual 保留字只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。 虚函数声明基类和子类要一致：在派生类中重新定义时,其函数原型,包括返回类型,函数名,参数个数,参数类型及参数的先后顺序,都必须与基类中的原型完全相同. 虚函数在派生类中重新定义时候，如果返回的是对基类型的引用或是指针，那么派生类的虚函数可以返回基类函数返回类型的派生类引用或指针，而不是一定要求一样的，primer上看到的。 虚函数符号子类可以不加virtual：c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数； 如果派生类没有覆盖基类中的某个成员函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。 作用： 启用动态绑定，实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。 如果成员默认为非虚函数，对非虚函数的调用在编译时确定。 虚函数是重载的一种表现形式,是一种动态的重载方式。 虚函数是基类希望派生类继承函数的缺省实现和重载的成员函数。当基类的指针或者引用指向派生类的对象的时候，这时候，如果使用基类指针或引用调用一个虚函数，实际上调用的是继承类的版本； 注意： 当我们使用指针或引用对虚函数的调用将被动态绑定，即根据所绑定的对象不同，所执行的函数不同，有可能是基类的，也有可能是派生类的。 相对的，非虚函数总是在编译时根据调用该函数的对象、引用或指针的类型而确定。 在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。//也就是说虚函数部分，是不被作为基类部分在派生类中继承的，而是被重新定义的，画一画继承的图可能会更清晰地理解这一点。 纯虚函数纯虚函数（pure virtual）没有实现，被初始化为0；规定：在函数形参表后面写上 = 0 以指定纯虚函数。 1virtual void fun(void) = 0; 声明一个纯虚函数（pure virtual）的目的: 是为了让派生类只继承函数接口，也就是上面说的接口继承。这个类（包含纯虚函数的类）的存在只是为了让其他类继承。 为了令继承类继承函数接口以及做一份强制性实现。 声明非纯虚函数（impure virtual）的目的: 是让继承类继承该函数的接口和缺省实现。 非虚函数一般成员函数，无virtual关键字修饰。非虚函数总是在编译时根据调用该函数的对象、引用或指针的类型而确定，而不是像 override关键字C++11新标准允许派生类显式注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在形参列表或const限定符或引用限定符后面添加一个关键字override。 规定： 基类函数必须有 virtual 关键字，不能有 static 。 不在同一个作用域（分别位于派生类与基类），函数名字相同，参数相同。 优点： 如果我们使用了override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将会报错。 123456789101112131415class A{pulic: virtual void func() const;};class B: A{pulic: virtual void func() const override final; //OK};class C: B{pulic: virtual void func()const; //error, B::func is final}; final关键字禁用继承在C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final。如果继承该类会导致编译错误。 1234class A final{ /*...*/}; 禁用重写在C++中，如果把某个函数指定为final，使之后任何尝试覆盖该函数的操作都引发错误。final关键字至于方法参数列表后面。 123456class A{ public: A(); virtual void Method() final;}; C++抽象类抽象类：包含有（或继承）一个或多个纯虚函数的类是抽象类。在C#，Java中用abstract定义抽象类，而在C++中有抽象类的概念，但没有这个关键字。 规定: 抽象类只能用作其他类的基类，不能建立抽象类对象。 抽象类不能用作参数类型、函数返回类型或显式转换的类型。 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。 特点： 由于抽象类包含了没有定义的纯虚函数,所以不能定义抽象类的对象，也就是说抽象类无法实例化。 C++接口C++接口满足以下条件： 类中没有定义任何的成员变量 所有的成员函数都是纯虚函数 所有的成员函数都是公有的 接口是一种特殊的抽象类 实现继承和接口继承实现继承：派生类同时继承基类的接口和实现。接口继承：派生类不继承基类的实现，只会继承基类的接口。 包含虚函数的类和包含纯虚函数的类有什么别称吗？如果类中包含有纯虚函数，则这个类是抽象类，而且由于抽象类包含了没有定义的纯虚函数,所以不能定义抽象类的对象。 如果有虚函数和正常函数就是普通的类。 总结纯虚函数：要求继承类必须含有某个接口，并对接口函数实现。虚函数：继承类必须含有某个接口，可以自己实现。也可以不实现，而采用基类定义的缺省实现。非虚函数：继承类必须含有某个接口，必须使用基类的实现。 参考资料C++ primer 第四版C++接口继承与实现继承C++虚函数C++开发者眼中的Java关键字abstract 多态 任何可以在基类对象上执行的操作也可以通过派生类对象使用。 可以使用基类类型的指针或引用来引用派生类型对象，所以，使用基类类型的引用或指针时，不知道指针或引用所绑定的对象的类型：基类类型的引用或指针可以引用基类类型对象，也可以引用派生类型对象。无论实际对象具有哪种类型，编译器都将它当作基类类型对象。将派生类对象当作基类对象是安全的，因为每个派生类对象都拥有基类子对象。而且，派生类继承基类的操作。","link":"/2020/10/15/C-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"title":"工厂方法模式","text":"如何赋予派生类创建适当对象的责任。(how derived classes can be given the responsibility of creating appropriate objects.) 基本概念工厂方法模式（Factory Method Pattern）： 工厂模式是创建型模式的一种。 工厂生产商品，软件工厂则生产对象。 应用场景： 工厂方法模式在计算机的很多领域得到应用，它的应用遍布各种工具箱（toolkit）和框架（framework）。 当我们不能实现知道类是什么样子和我们需要实例化哪些子类对象时候，就可以使用工厂方法模式。 比如，C++常常采用下面的方式创建对象： 12SomeClass someClassObject_1 = SomeClass(); //栈中分配 SomeClass * someClassObject_2 = new SomeClass(); //堆中分配 上述方法的问题在于，使用SomeClass的对象的代码现在突然变得依赖于SomeClass的具体实现。使用new创建对象没有什么错，但是它带有将我们的创建对象的代码和具体实现的代码紧密耦合起来了。这违反了原则“对接口而不是针对实现编程”。（code to an interface and not to an implementation.）这句话也就是说尽量在有需求来的时候，我们类中实现的代码尽量不要变化，而是通过各种接口的组合来解决新需求。 举个例子，如果创建对象需要一系列复杂的初始化操作，比如需要关联其他成员，查配置文件，查数据库表，这时候该怎么办？如果都写到构造函数里面，那构造函数就会很长很长，代码可读性也不好。那么比较好的方式是什么呢？计算机里面解决问题的方法就是加一个层。我们就加一个专门的层——工厂类，来专门负责对象的创建工作。 形式上，工厂方法被定义为以下形式： 提供一个用于对象创建的接口，但将对象的实例化委托给子类。 类图 Class DiagramThe class diagram consists of the following entities: Product：抽象产品角色。 Concrete Product：具体产品角色，工厂方法模式所创建的任何对象都是这个角色的实例。 Creator：工厂类角色，工厂方法模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象。 Concrete Creator：具体工厂类角色。 实例让我们继续制造飞机的过程吧！假设我们正在尝试为F-16战斗机建模。client代码需要为喷气式战斗机构造引擎并进行试飞。该类的简单实现将如下所示： 123456789101112131415161718192021222324252627class F16 { F16Engine engine; //引擎 F16Cockpit cockpit; //驾驶舱protected: void makeF16() //造飞机 { engine = F16Engine(); //造引擎 cockpit = F16Cockpit(); //造驾驶舱 }public: void fly() //试飞 { makeF16(); cout&lt;&lt;\"F16 with bad design flying\"; }} class Client {public: void Clientmain() { // We instantiate from a concrete class, thus tying // ourselves to it F16 f16 = F16(); f16.fly(); }} 在上面的代码中，我们建造飞机时候使用F16类的具体实现。这时候突然飞机的版本要更新了，我们也要建造它，肯定需要在程序中对新版本的飞机进行表达，这时候该怎么办呢？ 如果采用上面的程序的话，我们只能在新建F16实例的地方更换client代码，比如之前创建的是F16，我们后来想要创建F16B，就得在client代码里面改。 另一种解决方法是将对象的创建封装在另一个对象中，该对象仅负责更新和新建所要求的F-16变体，到时候想。 我们来说说第二种方法。首先，假设我们要表示F16的A变体和B变体，那么代码看起来像： 1234567891011121314class F16SimpleFactory {public: F16 makeF16(string variant) { switch (variant) { case \"A\": return F16A(); case \"B\": return F16B(); default: return F16(); } }} 上面是简单工厂模式的示例，但是上面这种代码还不是模式，而应该算作常见的编程习惯。 您也可以将make方法标记为static，以跳过工厂对象创建步骤(意思是直接通过类名加静态方法来进行调用，而不是在对象中进行封装)。 但是，由于静态方法不能在子类中覆盖，因为它们是类的唯一方法，因此我们将不能对静态工厂进行子类化。 但是，如果我们希望将F16对象部分的创建保持在同一类中，并且仍然能够引入新的F16变体，则可以对F16进行子类化，并将正确的F16变体对象的创建委托给子类处理。 那么这个新方法正是工厂方法模式！ 这里的方法是makeF16()，我们将使其表现得像产生适当F16变体的工厂。 让我们继续前进，我们引入了两个这样的子类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class F16 { IEngine engine; ICockpit cockpit; protected: virtual F16* makeF16() //这里是制造部分 { engine = F16Engine(); cockpit = F16Cockpit(); return this; } public: void taxi() { cout&lt;&lt;\"F16 is taxing on the runway !\"&lt;&lt;endl; } void fly() { // Note here carefully, the superclass F16 doesn't know // what type of F-16 variant it was returned. F16 f16 = makeF16(); f16.taxi(); cout&lt;&lt;\"F16 is in the air !\"&lt;&lt;endl; }} class F16A:public F16 {public: virtual F16* makeF16() override //这里是制造部分 { super.makeF16(); engine = F16AEngine(); return this; }} class F16B:public F16 override { public: virtual F16* makeF16() { super.makeF16(); engine = F16BEngine(); return this; }} 看上面的代码，我们使用子类继承，然后在子类中实现特殊化的引擎对象。 工厂方法可以提供也可以不提供默认或通用的实现，但是可以通过覆盖create / make方法来使子类专门化或修改产品。 在我们的示例中，变体模型仅具有不同的发动机，但座舱相同。 客户端代码现在可以使用更新的模型，如下所示： 1234567891011121314class Client { public void main() { vector&lt;F16 *&gt; myAirForce; F16 * f16A =new F16A(); F16 * f16B =new F16B(); myAirForce.push_back(f16A); myAirForce.push_back(f16B); for (F16 *f16 : myAirForce) { f16-&gt;fly(); } }} 请注意，工厂模式是借助抽象类和多态来实现的， 在我们的情况下，父类F16不知道它是从makeF16()方法返回的F16的哪个变体。 一般设置是超类具有除创建方法之外的所有方法的实现。 create方法可以是抽象方法，也可以带有默认实现，然后由超类的其他方法调用。 正确的对象的创建是子类的责任。 简单工厂模式和静态工厂模式的区别 简单工厂无法像工厂方法模式那样通过继承来生产变化的产品。 注意 该模式可能会导致很多差别很小的子类。 如果子类扩展了功能，那么超类将无法使用它，除非它将其转换为具体类型，然而向下转换可能在运行时失败。 参考资料设计模式之 “工厂模式”设计模式总结Software Design Patterns: Best Practices for Software Developers /github educative","link":"/2020/10/16/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"《科学哲学》读书笔记","text":"第一章 何为科学什么是科学？普通人的回答可能是科学包含数理化生等学科，而不包含艺术音乐之类的学科哲学家所追寻的回答而不是上述这种罗列式的回答，而是回去探寻这些学科的共同特征，也就是使科学得以成为科学的东西是什么？ 科学的特征？下面是一些人的解释 试图理解，解释和预言我们生活在其中的世界。 科学家探索世界的特殊方法，似乎有道理，因为许多科学的确使用了在其他非科学的领域所找不到的方法。一个明显的例子，就是是实验方法的运用，它是现代科学发展史上的转折点。 科学理论的建构，科学家们并不是仅仅在记录本上记下他们实验和观察的结果——他们希望用一个一般的理论来解释这些结果。虽然这并不容易做到，但已经获得一些重大的成果。 科学哲学的一个关键问题：弄明白实验，观察，理论架构等方法是如何帮助科学家揭开这么多自然之谜的。 现代科学之起源现代科学起源于1500年到1750年之间发生在欧洲的科学告诉发展时期。也就是我们现在所称的科学革命时期。 哥白尼革命 开普勒三定律 伽利略 实验验证假说 笛卡尔 机械哲学论 牛顿 动力学和机械论理论 相对论和量子力学 达尔文进化论 分子生物学 计算机科学，神经科学 何为科学哲学？科学哲学的主要任务是去分析各门科学所采用的研究方法。也许我们会困惑，为啥这项任务不交给科学家来做呢？部分答案是：从一个哲学化的视野去观察科学可以使我们进行更深入的探索———去揭示科学实践中暗含的但是不被科学家们明确讨论的假设。 下面是一个例子：假设一个科学家做了一个实验并且获得了一个特定的结果。他反复多次做一个实验，一直得出相同的结果。然后他可能会确信如果他继续在完全相同的条件下做这一个实验，得到的结果完全相同。这一假设看起来很显然，但是作为哲学家，就会产生质疑。有什么理由让我们假设将来的重复实验会得到相同的结果？我们怎么知道这是真的呢？科学家当然没时间去厘清这些略显古怪的问题。 科学与伪科学什么是科学？卡尔·波普尔 科学理论的基本特征是它应该具有可证伪性，称一个理论是可证伪性的并不是说它是错的。而是说它意味着该理论能够做出一些可以用经验进行检验的特定预测。如果这些预测被发现是错误的，这一个理论就会被证伪了，或者说是否证了。 波普尔的划分一定是合理的吗？如果一个科学理论与观测不符们是不是就应该立刻抛弃它？然而现在科学家的通常做法是。他们会寻找能解决矛盾的方法而非放弃理论。 第二章 科学推理演绎和归纳逻辑学家在演绎和归纳这两种推理形式之间做了重要的区分。归纳推理的经典例子(法国人喝葡萄酒) 所有的法国人都喜欢红葡萄酒皮埃尔是一个法国人 因此，皮埃尔喜欢红葡萄酒 演绎推理通常可以表达为，推理的前提必然导致结论。前提和结论之间存在一种关系，也就是说前提为真的话，结论也必定为真。当然前提实际上是否为真是另外一回事，它并不影响推论的演绎性质。 归纳推理的例子（臭鸡蛋）盒子里的前五个鸡蛋发臭了所有鸡蛋上标明的保质日期相同 因此，第六个鸡蛋也是发臭的 这看起来是一个合理的推理，但是不是演绎推理，前提并 不会必然导致结论。可能会出现前提为真，结论为假的情况。但是归纳推理对科学家也是必不可少的，比如唐氏综合症的例子，所有已经发现的唐氏综合症患者都有一条多余的染色体，也就是47条（23对+1条），科学家就据此归纳地推出一条结论：所有唐氏综合症患者，包括尚未检验的，都有一条多余的染色体。 休谟的问题虽然归纳推理在逻辑上并非是无懈可击的，但是它似乎是形成关于世界之信念的一种非常合理的方法 自然的齐一性假设:我们通常假设我们未检验的物体将在某些相关的方面与我们已经检验过的同类物体类似。 休谟归纳问题： 最佳说明的推理另一种普通非演绎性推论：食品柜里的干奶酪不见了，仅仅留下一些干奶酪碎屑昨天晚上听到了来自食品柜的刮擦声音 所以，干奶酪是被老鼠吃了 这一推论是非演绎性的，前提并不必然导致结论。 但是总体来说这个假说相当合理，它是对已经有的事实最好的解释。这类推理被称为最佳说明推理（IBE，inference to the best explanation） 概率与归纳第三章 科学中的解释在提供解释这一目的上，现代科学常常能够成功。但是科学解释确切的说是什么呢？说一个现象能够被科学进行解释究竟是什么意思？ 亨普尔的覆盖律解释模型亨普尔认为，科学解释的典型逻辑和论证结构是一样的，由一系列的前提得出一个结论。 亨普尔的解释模型：普适定律特定事实经过演绎推理=&gt;待解释的现象 模型的三个要素说明： 论证必须是演绎推理 前提必须都为真 前提至少包含一个普适定律（有时候也称为自然律） 为什么亨普尔的模型被称为覆盖解释模型？ 因为按照这一模型，解释的本质就是表明待解释的对象的现象就是被某个自然普适定律所覆盖的。 当然亨普尔的模型也会有一些不足，我们可以举出一些反例。反例主要有两类 一类是科学解释，但是不符合该模型 一类不是科学解释，但是符合该模型 对称问题我们主要聚焦在第二类问题上。一个很典型的例子是旗杆和影子的长度问题以及这个问题的对称问题。 其中的原因是亨普尔的模型没有考虑因果性的问题。 解释和因果性科学能够解释一切吗？解释和还原第四章 实在论和反实在论第五章 科学变迁和科学革命科学观念随着时间不断变化，是否存在一种清晰的变迁方式呢？当科学家放弃现有理论而支持一种新的理论时，我们作何解释？最新的科学理论在客观性上是否就比先前的更好？客观性的概念是否就有意义呢？ 逻辑实证主义的科学哲学科学革命的结构不可通约性和观察数据的理论负荷库恩和科学的合理性库恩的遗产第六章 物理学，生物学和心理学中的哲学问题 第七章 科学和科学批评者 参考资料科学哲学 牛津通俗本","link":"/2020/10/26/%E7%A7%91%E5%AD%A6%E5%93%B2%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"演讲","slug":"演讲","link":"/tags/%E6%BC%94%E8%AE%B2/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"名著","slug":"名著","link":"/tags/%E5%90%8D%E8%91%97/"},{"name":"生产力","slug":"生产力","link":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"学术论文","slug":"学术论文","link":"/tags/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"基本结构","slug":"基本结构","link":"/tags/%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"},{"name":"心态","slug":"心态","link":"/tags/%E5%BF%83%E6%80%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"性能分析","slug":"性能分析","link":"/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"目录结构","slug":"目录结构","link":"/tags/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"费曼","slug":"费曼","link":"/tags/%E8%B4%B9%E6%9B%BC/"},{"name":"诺贝尔奖","slug":"诺贝尔奖","link":"/tags/%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96/"},{"name":"传记","slug":"传记","link":"/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux概述","slug":"Linux概述","link":"/tags/Linux%E6%A6%82%E8%BF%B0/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"简述","slug":"简述","link":"/tags/%E7%AE%80%E8%BF%B0/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"文档和注释","slug":"文档和注释","link":"/tags/%E6%96%87%E6%A1%A3%E5%92%8C%E6%B3%A8%E9%87%8A/"},{"name":"软连接","slug":"软连接","link":"/tags/%E8%BD%AF%E8%BF%9E%E6%8E%A5/"},{"name":"硬连接","slug":"硬连接","link":"/tags/%E7%A1%AC%E8%BF%9E%E6%8E%A5/"},{"name":"文件与目录","slug":"文件与目录","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"内存分配","slug":"内存分配","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"内存分区","slug":"内存分区","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"静态多态","slug":"静态多态","link":"/tags/%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"动态多态","slug":"动态多态","link":"/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"容器类","slug":"容器类","link":"/tags/%E5%AE%B9%E5%99%A8%E7%B1%BB/"},{"name":"关联容器","slug":"关联容器","link":"/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"},{"name":"顺序容器","slug":"顺序容器","link":"/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"},{"name":"C++标准库","slug":"C-标准库","link":"/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"桶排序","slug":"桶排序","link":"/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"priority_queue","slug":"priority-queue","link":"/tags/priority-queue/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"pair","slug":"pair","link":"/tags/pair/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"运算符","slug":"运算符","link":"/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"重载","slug":"重载","link":"/tags/%E9%87%8D%E8%BD%BD/"},{"name":"初始化","slug":"初始化","link":"/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"音标","slug":"音标","link":"/tags/%E9%9F%B3%E6%A0%87/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"信号量","slug":"信号量","link":"/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"互斥锁","slug":"互斥锁","link":"/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"deque","slug":"deque","link":"/tags/deque/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"B-树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"B+树","slug":"B-树","link":"/tags/B-%E6%A0%91/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层","slug":"传输层","link":"/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"设计方法","slug":"设计方法","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"应用层","slug":"应用层","link":"/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"套接字","slug":"套接字","link":"/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"内核","slug":"内核","link":"/tags/%E5%86%85%E6%A0%B8/"},{"name":"驱动程序","slug":"驱动程序","link":"/tags/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"},{"name":"概述","slug":"概述","link":"/tags/%E6%A6%82%E8%BF%B0/"},{"name":"程序执行","slug":"程序执行","link":"/tags/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/"},{"name":"调试器","slug":"调试器","link":"/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"},{"name":"说明","slug":"说明","link":"/tags/%E8%AF%B4%E6%98%8E/"},{"name":"编译加载","slug":"编译加载","link":"/tags/%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD/"},{"name":"模块","slug":"模块","link":"/tags/%E6%A8%A1%E5%9D%97/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"挑战","slug":"挑战","link":"/tags/%E6%8C%91%E6%88%98/"},{"name":"大数据计算","slug":"大数据计算","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/"},{"name":"研究方法论","slug":"研究方法论","link":"/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"虚拟文件系统","slug":"虚拟文件系统","link":"/tags/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"VFS","slug":"VFS","link":"/tags/VFS/"},{"name":"特殊文件系统","slug":"特殊文件系统","link":"/tags/%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"块设备","slug":"块设备","link":"/tags/%E5%9D%97%E8%AE%BE%E5%A4%87/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"建造者模式","slug":"建造者模式","link":"/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"博客维护","slug":"博客维护","link":"/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"},{"name":"醒世通言","slug":"醒世通言","link":"/categories/%E9%86%92%E4%B8%96%E9%80%9A%E8%A8%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"效率工具","slug":"效率工具","link":"/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"学术论文","slug":"学术论文","link":"/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"软件工程","slug":"软件工程","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"英语学习","slug":"英语学习","link":"/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"课外学术阅读","slug":"课外学术阅读","link":"/categories/%E8%AF%BE%E5%A4%96%E5%AD%A6%E6%9C%AF%E9%98%85%E8%AF%BB/"}]}